<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Servlet堆栈上的Web</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="spring-web" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>Servlet堆栈上的Web</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#mvc">1。Spring Web MVC</a>
<ul class="sectlevel2">
<li><a href="#mvc-servlet">1.1。DispatcherServlet的</a>
<ul class="sectlevel3">
<li><a href="#mvc-servlet-context-hierarchy">1.1.1。上下文层次结构</a></li>
<li><a href="#mvc-servlet-special-bean-types">1.1.2。特殊豆类</a></li>
<li><a href="#mvc-servlet-config">1.1.3。Web MVC配置</a></li>
<li><a href="#mvc-container-config">1.1.4。Servlet配置</a></li>
<li><a href="#mvc-servlet-sequence">1.1.5。处理</a></li>
<li><a href="#mvc-handlermapping-interceptor">1.1.6。截击</a></li>
<li><a href="#mvc-exceptionhandlers">1.1.7。例外</a>
<ul class="sectlevel4">
<li><a href="#mvc-excetionhandlers-handling">左轮手枪链</a></li>
<li><a href="#mvc-ann-customer-servlet-container-error-page">容器错误页面</a></li>
</ul>
</li>
<li><a href="#mvc-viewresolver">1.1.8。查看分辨率</a>
<ul class="sectlevel4">
<li><a href="#mvc-viewresolver-handling">处理</a></li>
<li><a href="#mvc-redirecting-redirect-prefix">重定向</a></li>
<li><a href="#mvc-redirecting-forward-prefix">转发</a></li>
<li><a href="#mvc-multiple-representations">内容谈判</a></li>
</ul>
</li>
<li><a href="#mvc-localeresolver">1.1.9。语言环境</a>
<ul class="sectlevel4">
<li><a href="#mvc-timezone">时区</a></li>
<li><a href="#mvc-localeresolver-acceptheader">标题解析器</a></li>
<li><a href="#mvc-localeresolver-cookie">Cookie解析器</a></li>
<li><a href="#mvc-localeresolver-session">会话解析器</a></li>
<li><a href="#mvc-localeresolver-interceptor">Locale拦截器</a></li>
</ul>
</li>
<li><a href="#mvc-themeresolver">1.1.10。主题</a>
<ul class="sectlevel4">
<li><a href="#mvc-themeresolver-defining">定义主题</a></li>
<li><a href="#mvc-themeresolver-resolving">解决主题</a></li>
</ul>
</li>
<li><a href="#mvc-multipart">1.1.11。多部分解析器</a>
<ul class="sectlevel4">
<li><a href="#mvc-multipart-resolver-commons">Apache <code>FileUpload</code></a></li>
<li><a href="#mvc-multipart-resolver-standard">Servlet 3.0</a></li>
</ul>
</li>
<li><a href="#mvc-logging">1.1.12。记录</a>
<ul class="sectlevel4">
<li><a href="#mvc-logging-sensitive-data">敏感数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#filters">1.2。过滤器</a>
<ul class="sectlevel3">
<li><a href="#filters-http-put">1.2.1。表格数据</a></li>
<li><a href="#filters-forwarded-headers">1.2.2。转发标题</a></li>
<li><a href="#filters-shallow-etag">1.2.3。浅ETag</a></li>
<li><a href="#filters-cors">1.2.4。CORS</a></li>
</ul>
</li>
<li><a href="#mvc-controller">1.3。带注释的控制器</a>
<ul class="sectlevel3">
<li><a href="#mvc-ann-controller">1.3.1。宣言</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-requestmapping-proxying">AOP代理</a></li>
</ul>
</li>
<li><a href="#mvc-ann-requestmapping">1.3.2。请求映射</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-requestmapping-uri-templates">URI模式</a></li>
<li><a href="#mvc-ann-requestmapping-pattern-comparison">模式比较</a></li>
<li><a href="#mvc-ann-requestmapping-suffix-pattern-match">后缀匹配</a></li>
<li><a href="#mvc-ann-requestmapping-rfd">后缀匹配和RFD</a></li>
<li><a href="#mvc-ann-requestmapping-consumes">耗材类型</a></li>
<li><a href="#mvc-ann-requestmapping-produces">可生产的媒体类型</a></li>
<li><a href="#mvc-ann-requestmapping-params-and-headers">参数，标题</a></li>
<li><a href="#mvc-ann-requestmapping-head-options">HTTP HEAD，OPTIONS</a></li>
<li><a href="#mvc-ann-requestmapping-composed">自定义注释</a></li>
<li><a href="#mvc-ann-requestmapping-registration">明确的注册</a></li>
</ul>
</li>
<li><a href="#mvc-ann-methods">1.3.3。处理程序方法</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-arguments">方法参数</a></li>
<li><a href="#mvc-ann-return-types">返回值</a></li>
<li><a href="#mvc-ann-typeconversion">类型转换</a></li>
<li><a href="#mvc-ann-matrix-variables">矩阵变量</a></li>
<li><a href="#mvc-ann-requestparam">使用<code>@RequestParam</code></a></li>
<li><a href="#mvc-ann-requestheader">使用<code>@RequestHeader</code></a></li>
<li><a href="#mvc-ann-cookievalue">使用<code>@CookieValue</code></a></li>
<li><a href="#mvc-ann-modelattrib-method-args">使用<code>@ModelAttribute</code></a></li>
<li><a href="#mvc-ann-sessionattributes">使用<code>@SessionAttributes</code></a></li>
<li><a href="#mvc-ann-sessionattribute">使用<code>@SessionAttribute</code></a></li>
<li><a href="#mvc-ann-requestattrib">使用<code>@RequestAttribute</code></a></li>
<li><a href="#mvc-redirecting-passing-data">重定向属性</a></li>
<li><a href="#mvc-flash-attributes">Flash属性</a></li>
<li><a href="#mvc-multipart-forms">多</a></li>
<li><a href="#mvc-ann-requestbody">使用<code>@RequestBody</code></a></li>
<li><a href="#mvc-ann-httpentity">HttpEntity</a></li>
<li><a href="#mvc-ann-responsebody">使用<code>@ResponseBody</code></a></li>
<li><a href="#mvc-ann-responseentity">ResponseEntity</a></li>
<li><a href="#mvc-ann-jackson">杰克逊JSON</a></li>
</ul>
</li>
<li><a href="#mvc-ann-modelattrib-methods">1.3.4。模型</a></li>
<li><a href="#mvc-ann-initbinder">1.3.5。使用<code>DataBinder</code></a></li>
<li><a href="#mvc-ann-exceptionhandler">1.3.6。例外</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-exceptionhandler-args">方法参数</a></li>
<li><a href="#mvc-ann-exceptionhandler-return-values">返回值</a></li>
<li><a href="#mvc-ann-rest-exceptions">REST API例外</a></li>
</ul>
</li>
<li><a href="#mvc-ann-controller-advice">1.3.7。控制器建议</a></li>
</ul>
</li>
<li><a href="#mvc-uri-building">1.4。URI链接</a>
<ul class="sectlevel3">
<li><a href="#web-uricomponents">1.4.1。UriComponents</a></li>
<li><a href="#web-uribuilder">1.4.2。UriBuilder</a></li>
<li><a href="#web-uri-encoding">1.4.3。URI编码</a></li>
<li><a href="#mvc-servleturicomponentsbuilder">1.4.4。相对Servlet请求</a></li>
<li><a href="#mvc-links-to-controllers">1.4.5。控制器的链接</a></li>
<li><a href="#mvc-links-to-controllers-from-views">1.4.6。视图中的链接</a></li>
</ul>
</li>
<li><a href="#mvc-ann-async">1.5。异步请求</a>
<ul class="sectlevel3">
<li><a href="#mvc-ann-async-deferredresult">1.5.1。使用<code>DeferredResult</code></a></li>
<li><a href="#mvc-ann-async-callable">1.5.2。使用<code>Callable</code></a></li>
<li><a href="#mvc-ann-async-processing">1.5.3。处理</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-async-exceptions">异常处理</a></li>
<li><a href="#mvc-ann-async-interception">截击</a></li>
<li><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></li>
</ul>
</li>
<li><a href="#mvc-ann-async-http-streaming">1.5.4。HTTP流媒体</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-async-objects">对象</a></li>
<li><a href="#mvc-ann-async-sse">SSE</a></li>
<li><a href="#mvc-ann-async-output-stream">原始数据</a></li>
</ul>
</li>
<li><a href="#mvc-ann-async-reactive-types">1.5.5。反应类型</a></li>
<li><a href="#mvc-ann-async-disconnects">1.5.6。断开</a></li>
<li><a href="#mvc-ann-async-configuration">1.5.7。组态</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-async-configuration-servlet3">Servlet容器</a></li>
<li><a href="#mvc-ann-async-configuration-spring-mvc">Spring MVC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mvc-cors">1.6。CORS</a>
<ul class="sectlevel3">
<li><a href="#mvc-cors-intro">1.6.1。介绍</a></li>
<li><a href="#mvc-cors-processing">1.6.2。处理</a></li>
<li><a href="#mvc-cors-controller">1.6.3。使用<code>@CrossOrigin</code></a></li>
<li><a href="#mvc-cors-global">1.6.4。全局配置</a>
<ul class="sectlevel4">
<li><a href="#mvc-cors-global-java">Java配置</a></li>
<li><a href="#mvc-cors-global-xml">XML配置</a></li>
</ul>
</li>
<li><a href="#mvc-cors-filter">1.6.5。CORS过滤器</a></li>
</ul>
</li>
<li><a href="#mvc-web-security">1.7。网络安全</a></li>
<li><a href="#mvc-caching">1.8。HTTP缓存</a>
<ul class="sectlevel3">
<li><a href="#mvc-caching-cachecontrol">1.8.1。使用<code>CacheControl</code></a></li>
<li><a href="#mvc-caching-etag-lastmodified">1.8.2。控制器</a></li>
<li><a href="#mvc-caching-static-resources">1.8.3。静态资源</a></li>
<li><a href="#mvc-httpcaching-shallowetag">1.8.4。<code>ETag</code>过滤器</a></li>
</ul>
</li>
<li><a href="#mvc-view">1.9。查看技术</a>
<ul class="sectlevel3">
<li><a href="#mvc-view-thymeleaf">1.9.1。Thymeleaf</a></li>
<li><a href="#mvc-view-freemarker">1.9.2。FreeMarker的</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-freemarker-contextconfig">查看配置</a></li>
<li><a href="#mvc-views-freemarker">FreeMarker配置</a></li>
<li><a href="#mvc-view-freemarker-forms">表格处理</a></li>
</ul>
</li>
<li><a href="#mvc-view-groovymarkup">1.9.3。Groovy Markup</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-groovymarkup-configuration">组态</a></li>
<li><a href="#mvc-view-groovymarkup-example">例</a></li>
</ul>
</li>
<li><a href="#mvc-view-script">1.9.4。脚本视图</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-script-dependencies">要求</a></li>
<li><a href="#mvc-view-script-integrate">脚本模板</a></li>
</ul>
</li>
<li><a href="#mvc-view-jsp">1.9.5。JSP和JSTL</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-jsp-resolver">查看解析器</a></li>
<li><a href="#mvc-view-jsp-jstl">JSP与JSTL</a></li>
<li><a href="#mvc-view-jsp-tags">Spring的JSP标记库</a></li>
<li><a href="#mvc-view-jsp-formtaglib">Spring的表单标签库</a></li>
</ul>
</li>
<li><a href="#mvc-view-tiles">1.9.6。瓷砖</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-tiles-dependencies">依赖</a></li>
<li><a href="#mvc-view-tiles-integrate">组态</a></li>
</ul>
</li>
<li><a href="#mvc-view-feeds">1.9.7。RSS和Atom</a></li>
<li><a href="#mvc-view-document">1.9.8。PDF和Excel</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-document-intro">文档视图简介</a></li>
<li><a href="#mvc-view-document-pdf">PDF视图</a></li>
<li><a href="#mvc-view-document-pdf">Excel视图</a></li>
</ul>
</li>
<li><a href="#mvc-view-jackson">1.9.9。杰克逊</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-json-mapping">基于杰克逊的JSON视图</a></li>
<li><a href="#mvc-view-xml-mapping">基于Jackson的XML视图</a></li>
</ul>
</li>
<li><a href="#mvc-view-xml-marshalling">1.9.10。XML编组</a></li>
<li><a href="#mvc-view-xslt">1.9.11。XSLT视图</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-xslt-beandefs">豆</a></li>
<li><a href="#mvc-view-xslt-controllercode">调节器</a></li>
<li><a href="#mvc-view-xslt-transforming">转型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mvc-config">1.10。MVC配置</a>
<ul class="sectlevel3">
<li><a href="#mvc-config-enable">1.10.1。启用MVC配置</a></li>
<li><a href="#mvc-config-customize">1.10.2。MVC配置API</a></li>
<li><a href="#mvc-config-conversion">1.10.3。类型转换</a></li>
<li><a href="#mvc-config-validation">1.10.4。验证</a></li>
<li><a href="#mvc-config-interceptors">1.10.5。拦截器</a></li>
<li><a href="#mvc-config-content-negotiation">1.10.6。内容类型</a></li>
<li><a href="#mvc-config-message-converters">1.10.7。消息转换器</a></li>
<li><a href="#mvc-config-view-controller">1.10.8。查看控制器</a></li>
<li><a href="#mvc-config-view-resolvers">1.10.9。查看解析器</a></li>
<li><a href="#mvc-config-static-resources">1.10.10。静态资源</a></li>
<li><a href="#mvc-default-servlet-handler">1.10.11。默认Servlet</a></li>
<li><a href="#mvc-config-path-matching">1.10.12。路径匹配</a></li>
<li><a href="#mvc-config-advanced-java">1.10.13。高级Java配置</a></li>
<li><a href="#mvc-config-advanced-xml">1.10.14。高级XML配置</a></li>
</ul>
</li>
<li><a href="#mvc-http2">1.11。HTTP / 2</a></li>
</ul>
</li>
<li><a href="#webmvc-client">2。REST客户端</a>
<ul class="sectlevel2">
<li><a href="#webmvc-resttemplate">2.1。使用<code>RestTemplate</code></a></li>
<li><a href="#webmvc-webclient">2.2。使用<code>WebClient</code></a></li>
</ul>
</li>
<li><a href="#testing">3。测试</a></li>
<li><a href="#websocket">4。的WebSockets</a>
<ul class="sectlevel2">
<li><a href="#websocket-intro">4.1。WebSocket简介</a>
<ul class="sectlevel3">
<li><a href="#websocket-intro-architecture">4.1.1。HTTP与WebSocket</a></li>
<li><a href="#websocket-intro-when-to-use">4.1.2。何时使用WebSockets</a></li>
</ul>
</li>
<li><a href="#websocket-server">4.2。WebSocket API</a>
<ul class="sectlevel3">
<li><a href="#websocket-server-handler">4.2.1。使用<code>WebSocketHandler</code></a></li>
<li><a href="#websocket-server-handshake">4.2.2。WebSocket握手</a></li>
<li><a href="#websocket-server-deployment">4.2.3。部署</a></li>
<li><a href="#websocket-server-runtime-configuration">4.2.4。服务器配置</a></li>
<li><a href="#websocket-server-allowed-origins">4.2.5。允许起源</a></li>
</ul>
</li>
<li><a href="#websocket-fallback">4.3。SockJS后备</a>
<ul class="sectlevel3">
<li><a href="#websocket-fallback-sockjs-overview">4.3.1。概观</a></li>
<li><a href="#websocket-fallback-sockjs-enable">4.3.2。启用S​​ockJS</a></li>
<li><a href="#websocket-fallback-xhr-vs-iframe">4.3.3。IE 8和9</a></li>
<li><a href="#websocket-fallback-sockjs-heartbeat">4.3.4。心跳</a></li>
<li><a href="#websocket-fallback-sockjs-servlet3-async">4.3.5。客户端断开连接</a></li>
<li><a href="#websocket-fallback-cors">4.3.6。SockJS和CORS</a></li>
<li><a href="#websocket-fallback-sockjs-client">4.3.7。使用<code>SockJsClient</code></a></li>
</ul>
</li>
<li><a href="#websocket-stomp">4.4。STOMP</a>
<ul class="sectlevel3">
<li><a href="#websocket-stomp-overview">4.4.1。概观</a></li>
<li><a href="#websocket-stomp-benefits">4.4.2。优点</a></li>
<li><a href="#websocket-stomp-enable">4.4.3。启用S​​TOMP</a></li>
<li><a href="#websocket-stomp-message-flow">4.4.4。消息流</a></li>
<li><a href="#websocket-stomp-handle-annotations">4.4.5。带注释的控制器</a>
<ul class="sectlevel4">
<li><a href="#websocket-stomp-message-mapping">使用<code>@MessageMapping</code></a></li>
<li><a href="#websocket-stomp-subscribe-mapping">使用<code>@SubscribeMapping</code></a></li>
<li><a href="#websocket-stomp-exception-handler">使用<code>@MessageExceptionHandler</code></a></li>
</ul>
</li>
<li><a href="#websocket-stomp-handle-send">4.4.6。发送消息</a></li>
<li><a href="#websocket-stomp-handle-simple-broker">4.4.7。简单的经纪人</a></li>
<li><a href="#websocket-stomp-handle-broker-relay">4.4.8。外部经纪人</a></li>
<li><a href="#websocket-stomp-handle-broker-relay-configure">4.4.9。连接到经纪人</a></li>
<li><a href="#websocket-stomp-destination-separator">4.4.10。点作为分隔符</a></li>
<li><a href="#websocket-stomp-authentication">4.4.11。认证</a></li>
<li><a href="#websocket-stomp-authentication-token-based">4.4.12。令牌认证</a></li>
<li><a href="#websocket-stomp-user-destination">4.4.13。用户目的地</a></li>
<li><a href="#websocket-stomp-ordered-messages">4.4.14。消息顺序</a></li>
<li><a href="#websocket-stomp-appplication-context-events">4.4.15。活动</a></li>
<li><a href="#websocket-stomp-interceptors">4.4.16。截击</a></li>
<li><a href="#websocket-stomp-client">4.4.17。STOMP客户端</a></li>
<li><a href="#websocket-stomp-websocket-scope">4.4.18。WebSocket范围</a></li>
<li><a href="#websocket-stomp-configuration-performance">4.4.19。性能</a></li>
<li><a href="#websocket-stomp-stats">4.4.20。监控</a></li>
<li><a href="#websocket-stomp-testing">4.4.21。测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#web-integration">5。其他Web框架</a>
<ul class="sectlevel2">
<li><a href="#web-integration-common">5.1。通用配置</a></li>
<li><a href="#jsf">5.2。JSF</a>
<ul class="sectlevel3">
<li><a href="#jsf-springbeanfaceselresolver">5.2.1。春豆解析器</a></li>
<li><a href="#jsf-facescontextutils">5.2.2。使用<code>FacesContextUtils</code></a></li>
</ul>
</li>
<li><a href="#struts">5.3。Apache Struts 2.x</a></li>
<li><a href="#tapestry">5.4。Tapestry 5.x</a></li>
<li><a href="#web-integration-resources">5.5。更多资源</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>这部分文档包括对基于Servlet API构建并部署到Servlet容器的Servlet-stack Web应用程序的支持。各个章节包括<a href="#mvc">Spring MVC</a> ， <a href="#mvc-view">View Technologies</a> ， <a href="#mvc-cors">CORS支持</a>和<a href="#websocket">WebSocket支持</a> 。对于反应堆栈Web应用程序，请参阅<a href="web-reactive.html#spring-web-reactive">Web on Reactive Stack</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc"><a class="anchor" href="#mvc"></a> 1。Spring Web MVC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Web MVC是构建在Servlet API上的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块（ <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc"><code>spring-webmvc</code></a> ）的名称，但它通常被称为“Spring MVC”。</p>
</div>
<div class="paragraph">
<p>与Spring Web MVC并行，Spring Framework 5.0引入了一个反应堆栈Web框架，其名称“Spring WebFlux”也基于其源模块（ <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux"><code>spring-webflux</code></a> ）。本节介绍Spring Web MVC。 <a href="web-reactive.html#spring-web-reactive">下一节将</a>介绍Spring WebFlux。</p>
</div>
<div class="paragraph">
<p>有关基本信息以及与Servlet容器和Java EE版本范围的兼容性，请参阅Spring Framework <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a> 。</p>
</div>
<div class="sect2">
<h3 id="mvc-servlet"><a class="anchor" href="#mvc-servlet"></a> 1.1。DispatcherServlet的</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-dispatcher-handler">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>与许多其他Web框架一样，Spring MVC围绕前端控制器模式设计，其中中央<code>Servlet</code> <code>DispatcherServlet</code>为请求处理提供共享算法，而实际工作由可配置委托组件执行。该模型非常灵活，支持多种工作流程。</p>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>与任何<code>Servlet</code> ，需要使用Java配置或<code>web.xml</code>根据Servlet规范进行声明和映射。反过来， <code>DispatcherServlet</code>使用Spring配置文件来发现它需要请求映射，视图解析，异常处理，委托组件<a href="#mvc-servlet-special-bean-types">和更多</a> 。</p>
</div>
<div class="paragraph">
<p>下面的Java配置示例注册并初始化<code>DispatcherServlet</code> ，它由Servlet容器自动检测（请参阅<a href="#mvc-container-config">Servlet配置</a> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebApplicationInitializer</span> <span class="directive">实现</span> WebApplicationInitializer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> onStartup（ServletContext的<span class="comment">servletCxt）{//加载弹簧的web应用程序的配置</span> AnnotationConfigWebApplicationContext AC = <span class="keyword">新</span> AnnotationConfigWebApplicationContext（）; ac.register（AppConfig.class）; ac.refresh（）; <span class="comment">//创建并注册DispatcherServlet</span> DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet（ac）; ServletRegistration。动态注册= servletCxt.addServlet（ <span class="string"><span class="delimiter">“</span> <span class="content">app</span> <span class="delimiter">”</span></span> ，servlet）; registration.setLoadOnStartup（ <span class="integer">1</span> ）; registration.addMapping（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app / *</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">除了直接使用ServletContext API之外，您还可以扩展<code>AbstractAnnotationConfigDispatcherServletInitializer</code>并覆盖特定方法（请参阅<a href="#mvc-servlet-context-hierarchy">Context Hierarchy</a>下的示例）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下<code>web.xml</code>配置示例注册并初始化<code>DispatcherServlet</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span> <span class="tag">&lt;listener&gt;</span> <span class="tag">&lt;listener-class&gt;</span> org.springframework.web.context。ContextLoaderListener <span class="tag">&lt;/ listener-class&gt;</span> <span class="tag">&lt;/ listener&gt;</span> <span class="tag">&lt;context-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> /WEB-INF/app-context.xml <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt; / context-param&gt;</span> <span class="tag">&lt;servlet&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> app <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;servlet-class&gt;</span> org.springframework.web.servlet。DispatcherServlet <span class="tag">&lt;/ servlet-class&gt;</span> <span class="tag">&lt;init-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ init-param&gt;</span> <span class="tag">&lt;load-on-startup&gt;</span> 1 <span class="tag">&lt; / load-on-startup&gt;</span> <span class="tag">&lt;/ servlet&gt;</span> <span class="tag">&lt;servlet-mapping&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> app <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> / app / * <span class="tag">&lt;/ url-pattern&gt;</span> <span class="tag">&lt;/ servlet-mapping&gt;</span> <span class="tag">&lt; / web的应用&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot遵循不同的初始化顺序。Spring Boot使用Spring配置来引导自身和嵌入式Servlet容器，而不是挂钩到Servlet容器的生命周期。在Spring配置中检测<code>Filter</code>和<code>Servlet</code>声明，并在Servlet容器中注册。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container">Spring Boot文档</a> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="mvc-servlet-context-hierarchy"><a class="anchor" href="#mvc-servlet-context-hierarchy"></a> 1.1.1。上下文层次结构</h4>
<div class="paragraph">
<p><code>DispatcherServlet</code>需要一个<code>WebApplicationContext</code> （普通<code>ApplicationContext</code>的扩展）来进行自己的配置。<code>WebApplicationContext</code>有一个指向<code>ServletContext</code>的链接以及与之关联的<code>Servlet</code> 。它还绑定到<code>ServletContext</code> ，以便应用程序可以使用<code>RequestContextUtils</code>上的静态方法来查找<code>WebApplicationContext</code>如果它们需要访问它的话。</p>
</div>
<div class="paragraph">
<p>对于许多应用程序，拥有单个<code>WebApplicationContext</code>很简单且足够。也可以有一个上下文层次结构，其中一个根<code>WebApplicationContext</code>在多个<code>DispatcherServlet</code> （或其他<code>Servlet</code> ）实例之间共享，每个实例都有自己的子<code>WebApplicationContext</code>配置。有关上下文层次结构功能的更多信息，请参阅<a href="core.html#context-introduction"><code>ApplicationContext</code></a>的其他功能。</p>
</div>
<div class="paragraph">
<p>根<code>WebApplicationContext</code>通常包含基础结构bean，例如需要跨多个<code>Servlet</code>实例共享的数据存储库和业务服务。这些bean是有效继承的，可以在特定于Servlet的子<code>WebApplicationContext</code>重写（即重新声明），它通常包含给定<code>Servlet</code>本地的bean。下图显示了这种关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mvc-context-hierarchy.png" alt="mvc上下文层次结构">
</div>
</div>
<div class="paragraph">
<p>以下示例配置<code>WebApplicationContext</code>层次结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebAppInitializer</span> <span class="directive">扩展</span> AbstractAnnotationConfigDispatcherServletInitializer { <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> getRootConfigClasses（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> {RootConfig.class}; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> getServletConfigClasses（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> {App1Config.class}; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">String</span> <span class="type">[]</span> getServletMappings（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">/ app1 / *</span> <span class="delimiter">”</span></span> }; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果不需要应用程序上下文层次结构，则应用程序可以通过<code>getRootConfigClasses()</code>返回所有配置，并从<code>getServletConfigClasses()</code>返回<code>null</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示了<code>web.xml</code>等效项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span> <span class="tag">&lt;listener&gt;</span> <span class="tag">&lt;listener-class&gt;</span> org.springframework.web.context。ContextLoaderListener <span class="tag">&lt;/ listener-class&gt;</span> <span class="tag">&lt;/ listener&gt;</span> <span class="tag">&lt;context-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> /WEB-INF/root-context.xml <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt; / context-param&gt;</span> <span class="tag">&lt;servlet&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> app1 <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;servlet-class&gt;</span> org.springframework.web.servlet。DispatcherServlet <span class="tag">&lt;/ servlet-class&gt;</span> <span class="tag">&lt;init-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> /WEB-INF/app1-context.xml <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ init-param &gt;</span> <span class="tag">&lt;load-on-startup&gt;</span> 1 <span class="tag">&lt;/ load-on-startup&gt;</span> <span class="tag">&lt;/ servlet&gt;</span> <span class="tag">&lt;servlet-mapping&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> app1 <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> / app1 / * <span class="tag">&lt;/ url -pattern&gt;</span> <span class="tag">&lt;/ servlet-mapping&gt;</span> <span class="tag">&lt;/ web-app&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果不需要应用程序上下文层次结构，则应用程序可以仅配置“根”上下文，并将<code>contextConfigLocation</code> Servlet参数保留为空。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-servlet-special-bean-types"><a class="anchor" href="#mvc-servlet-special-bean-types"></a> 1.1.2。特殊豆类</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-special-bean-types">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>委托特殊bean处理请求并呈现适当的响应。“特殊bean”是指实现WebFlux框架契约的Spring管理的<code>Object</code>实例。这些通常带有内置合同，但您可以自定义其属性并扩展或替换它们。</p>
</div>
<div class="paragraph">
<p>下表列出了<code>DispatcherHandler</code>检测到的特殊bean：</p>
</div>
<table id="mvc-webappctx-special-beans-tbl" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">豆类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-handlermapping"><code>的HandlerMapping</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将请求映射到处理程序以及用于预处理和后处理的<a href="#mvc-handlermapping-interceptor">拦截器</a>列表。映射基于某些标准，其细节因<code>HandlerMapping</code>实现而异。
</p><p class="tableblock">两个主要的<code>HandlerMapping</code>实现是<code>RequestMappingHandlerMapping</code> （它支持<code>@RequestMapping</code>注释的方法）和<code>SimpleUrlHandlerMapping</code> （它维护对处理程序的URI路径模式的显式注册）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无论实际调用处理程序如何，都可以帮助<code>DispatcherServlet</code>调用映射到请求的处理程序。例如，调用带注释的控制器需要解析注释。<code>HandlerAdapter</code>的主要目的是保护<code>DispatcherServlet</code>不受此类细节的影响。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决异常的策略，可能将它们映射到处理程序，HTML错误视图或其他目标。请参阅<a href="#mvc-exceptionhandlers">例外</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-viewresolver"><code>视图解析器</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将从处理程序返回的逻辑基于<code>String</code>的视图名称解析为用于呈现给响应的实际<code>View</code> 。请参阅<a href="#mvc-viewresolver">查看分辨率</a>和<a href="#mvc-view">查看技术</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-localeresolver"><code>LocaleResolver</code></a> ， <a href="#mvc-timezone">LocaleContextResolver</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解析客户端正在使用的<code>Locale</code>以及可能的时区，以便能够提供国际化视图。请参阅<a href="#mvc-localeresolver">区域设置</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-themeresolver"><code>ThemeResolver的</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决Web应用程序可以使用的主题 - 例如，提供个性化布局。见<a href="#mvc-themeresolver">主题</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-multipart"><code>MultipartResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在一些多部分解析库的帮助下，解析多部分请求（例如，浏览器表单文件上载）的抽象。请参阅<a href="#mvc-multipart">Multipart Resolver</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-flash-attributes"><code>FlashMapManager</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储和检索“输入”和“输出” <code>FlashMap</code> ，可用于将属性从一个请求传递到另一个请求，通常是通过重定向。请参阅<a href="#mvc-flash-attributes">Flash属性</a> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-servlet-config"><a class="anchor" href="#mvc-servlet-config"></a> 1.1.3。Web MVC配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-framework-config">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>应用程序可以声明处理请求所需的<a href="#mvc-servlet-special-bean-types">特殊Bean类型</a>中列出的基础结构bean。<code>DispatcherServlet</code>检查每个特殊bean的<code>WebApplicationContext</code> 。如果没有匹配的bean类型，它将回退到<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties"><code>DispatcherServlet.properties</code></a>列出的默认类型。</p>
</div>
<div class="paragraph">
<p>在大多数情况下， <a href="#mvc-config">MVC Config</a>是最佳起点。它以Java或XML声明所需的bean，并提供更高级别的配置回调API来自定义它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot依赖于MVC Java配置来配置Spring MVC并提供许多额外的便捷选项。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-container-config"><a class="anchor" href="#mvc-container-config"></a> 1.1.4。Servlet配置</h4>
<div class="paragraph">
<p>在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为替代方法，也可以与<code>web.xml</code>文件结合使用。以下示例注册<code>DispatcherServlet</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web。WebApplicationInitializer</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebApplicationInitializer</span> <span class="directive">实现</span> WebApplicationInitializer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> onStartup（ServletContext的容器）{XmlWebApplicationContext appContext = <span class="keyword">新</span> XmlWebApplicationContext（）; appContext.setConfigLocation（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/WEB-INF/spring/dispatcher-config.xml”）;</span></span></span></span> ServletRegistration。动态注册= container.addServlet（ <span class="string"><span class="delimiter">“</span> <span class="content">dispatcher</span> <span class="delimiter">”</span></span> ， <span class="keyword">新的</span> DispatcherServlet（appContext））; registration.setLoadOnStartup（ <span class="integer">1</span> ）; registration.addMapping（ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>WebApplicationInitializer</code>是Spring MVC提供的一个接口，可确保检测到您的实现并自动用于初始化任何Servlet 3容器。的抽象基类实现<code>WebApplicationInitializer</code>命名<code>AbstractDispatcherServletInitializer</code>使得它更容易注册<code>DispatcherServlet</code>通过重载方法来指定servlet映射和位置<code>DispatcherServlet</code>配置。</p>
</div>
<div class="paragraph">
<p>对于使用基于Java的Spring配置的应用程序，建议使用此方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebAppInitializer</span> <span class="directive">扩展</span> AbstractAnnotationConfigDispatcherServletInitializer { <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> getRootConfigClasses（）{ <span class="keyword">return</span> <span class="predefined-constant">null</span> ; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> getServletConfigClasses（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> {MyWebConfig.class}; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">String</span> <span class="type">[]</span> getServletMappings（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> }; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用基于XML的Spring配置，则应直接从<code>AbstractDispatcherServletInitializer</code>扩展，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebAppInitializer</span> <span class="directive">扩展</span> AbstractDispatcherServletInitializer { <span class="annotation">@Override</span> <span class="directive">protected</span> WebApplicationContext createRootApplicationContext（）{ <span class="keyword">return</span> <span class="predefined-constant">null</span> ; } <span class="annotation">@Override</span> <span class="directive">protected</span> WebApplicationContext createServletApplicationContext（）{XmlWebApplicationContext cxt = <span class="keyword">new</span> XmlWebApplicationContext（）; cxt.setConfigLocation（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/WEB-INF/spring/dispatcher-config.xml”）;</span></span></span></span> <span class="keyword">return</span> cxt; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">String</span> <span class="type">[]</span> getServletMappings（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> }; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>AbstractDispatcherServletInitializer</code>还提供了一种方便的方法来添加<code>Filter</code>实例并将它们自动映射到<code>DispatcherServlet</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebAppInitializer</span> <span class="directive">扩展</span> AbstractDispatcherServletInitializer { <span class="comment">// ...</span>

    <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Filter</span> <span class="type">[]</span> getServletFilters（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Filter</span> <span class="type">[]</span> { <span class="keyword">new</span> HiddenHttpMethodFilter（）， <span class="keyword">new</span> CharacterEncodingFilter（）}; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每个过滤器都根据其具体类型添加默认名称，并自动映射到<code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p><code>AbstractDispatcherServletInitializer</code>的<code>isAsyncSupported</code>受保护方法提供了一个单独的位置来启用<code>DispatcherServlet</code>上的异步支持以及映射到它的所有过滤器。默认情况下，此标志设置为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>最后，如果您需要进一步自定义<code>DispatcherServlet</code>本身，则可以覆盖<code>createDispatcherServlet</code>方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-servlet-sequence"><a class="anchor" href="#mvc-servlet-sequence"></a> 1.1.5。处理</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-dispatcher-handler-sequence">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>按如下方式处理请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将<code>WebApplicationContext</code>作为控制器和进程中的其他元素可以使用的属性在请求中进行搜索和绑定。它默认绑定在<code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>键。</p>
</li>
<li>
<p>语言环境解析器绑定到请求，以允许进程中的元素解析处理请求时使用的语言环境（呈现视图，准备数据等）。如果您不需要区域设置解析，则不需要区域设置解析器。</p>
</li>
<li>
<p>主题解析器绑定到请求，以允许视图等元素确定要使用的主题。如果您不使用主题，则可以忽略它。</p>
</li>
<li>
<p>如果指定多部分文件解析程序，则会检查请求的多部分。如果找到多部分，请求将包装在<code>MultipartHttpServletRequest</code>以供进程中的其他元素进一步处理。有关<a href="#mvc-multipart">多</a>部分处理的更多信息，请参见<a href="#mvc-multipart">Multipart Resolver</a> 。</p>
</li>
<li>
<p>搜索适当的处理程序。如果找到处理程序，则执行与处理程序（预处理程序，后处理程序和控制器）关联的执行链以准备模型或呈现。或者，对于带注释的控制器，可以呈现响应（在<code>HandlerAdapter</code> ）而不是返回视图。</p>
</li>
<li>
<p>如果返回模型，则呈现视图。如果没有返回模型（可能是由于预处理器或后处理器拦截请求，可能是出于安全原因），则不会呈现任何视图，因为该请求可能已经完成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>WebApplicationContext</code>中声明的<code>HandlerExceptionResolver</code> bean用于解决在请求处理期间抛出的异常。这些异常解析器允许自定义逻辑以解决异常。有关详细信息，请参阅<a href="#mvc-exceptionhandlers">例外</a> 。</p>
</div>
<div class="paragraph">
<p>Spring <code>DispatcherServlet</code>还支持返回<code>last-modification-date</code> ，如Servlet API所指定。确定特定请求的最后修改日期的过程很简单： <code>DispatcherServlet</code>查找适当的处理程序映射并测试找到的处理程序是否实现<code>LastModified</code>接口。如果是这样， <code>LastModified</code>接口的<code>long getLastModified(request)</code>方法的值将返回给客户端。</p>
</div>
<div class="paragraph">
<p>您可以通过将Servlet初始化参数（ <code>init-param</code>元素）添加到<code>web.xml</code>文件中的Servlet声明来自定义各个<code>DispatcherServlet</code>实例。下表列出了支持的参数：</p>
</div>
<table id="mvc-disp-servlet-init-params-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。DispatcherServlet初始化参数</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实现<code>WebApplicationContext</code>类，它实例化此Servlet使用的上下文。默认情况下，使用<code>XmlWebApplicationContext</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextConfigLocation的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传递给上下文实例（由<code>contextClass</code>指定）的字符串，用于指示可以在何处找到上下文。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。对于具有两次定义的bean的多个上下文位置，最新位置优先。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>命名空间</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebApplicationContext</code>命名空间。默认为<code>[servlet-name]-servlet</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>throwExceptionIfNoHandlerFound</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在没有找到请求的处理程序时是否抛出<code>NoHandlerFoundException</code> 。然后可以使用<code>HandlerExceptionResolver</code>捕获异常（例如，通过使用<code>@ExceptionHandler</code>控制器方法）并像处理其他任何方法一样处理<code>@ExceptionHandler</code> 。
</p><p class="tableblock">默认情况下，此参数设置为<code>false</code> ，在这种情况下， <code>DispatcherServlet</code>将响应状态设置为404（NOT_FOUND），而不会引发异常。
</p><p class="tableblock">请注意，如果还配置了<a href="#mvc-default-servlet-handler">缺省servlet处理</a> ，则始终将未解析的请求转发到缺省servlet，并且永远不会引发404。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-handlermapping-interceptor"><a class="anchor" href="#mvc-handlermapping-interceptor"></a> 1.1.6。截击</h4>
<div class="paragraph">
<p>所有<code>HandlerMapping</code>实现都支持处理程序拦截器，当您要对特定请求应用特定功能时，这些拦截器非常有用 - 例如，检查主体。拦截器必须使用<code>org.springframework.web.servlet</code>包中的<code>HandlerInterceptor</code> <code>org.springframework.web.servlet</code>三种方法，这些方法应该提供足够的灵活性来执行各种预处理和后处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>preHandle(..)</code> ：在执行实际处理程序之前</p>
</li>
<li>
<p><code>postHandle(..)</code> ：处理程序执行后</p>
</li>
<li>
<p><code>afterCompletion(..)</code> ：完成请求完成后</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>preHandle(..)</code>方法返回一个布尔值。您可以使用此方法来中断或继续执行链的处理。当此方法返回<code>true</code> ，处理程序执行链继续。当它返回false时， <code>DispatcherServlet</code>假定拦截器本身已处理请求（例如，呈现适当的视图）并且不继续执行执行链中的其他拦截器和实际处理程序。</p>
</div>
<div class="paragraph">
<p>见<a href="#mvc-config-interceptors">拦截</a>在MVC配置一节的如何配置拦截器的实例。您还可以使用各个<code>HandlerMapping</code>实现上的setter直接注册它们。</p>
</div>
<div class="paragraph">
<p>请注意， <code>postHandle</code>对于<code>@ResponseBody</code>和<code>ResponseEntity</code>方法不太有用，对于这些方法，在<code>HandlerAdapter</code>和<code>postHandle</code>之前编写和提交响应。这意味着对响应进行任何更改都为时已晚，例如添加额外的标头。对于此类方案，您可以实现<code>ResponseBodyAdvice</code>并将其声明为<a href="#mvc-ann-controller-advice">Controller Advice</a> bean或直接在<code>RequestMappingHandlerAdapter</code>上进行配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-exceptionhandlers"><a class="anchor" href="#mvc-exceptionhandlers"></a> 1.1.7。例外</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-dispatcher-exceptions">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>如果在请求映射期间发生异常或从请求处理程序（例如<code>@Controller</code> ）抛出异常，则<code>DispatcherServlet</code>委托给<code>HandlerExceptionResolver</code> bean链以解决异常并提供替代处理，这通常是错误响应。</p>
</div>
<div class="paragraph">
<p>下表列出了可用的<code>HandlerExceptionResolver</code>实现：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表2。HandlerExceptionResolver实现</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>HandlerExceptionResolver</code></th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的SimpleMappingExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异常类名称和错误视图名称之间的映射。用于在浏览器应用程序中呈现错误页面。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决Spring MVC引发的异常并将它们映射到HTTP状态代码。另请参阅备用<code>ResponseEntityExceptionHandler</code>和<a href="#mvc-ann-rest-exceptions">REST API异常</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用<code>@ResponseStatus</code>注释解析异常，并<code>@ResponseStatus</code>注释中的值将它们映射到HTTP状态代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionHandlerExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过在<code>@Controller</code>或<code>@ControllerAdvice</code>类中调用<code>@ExceptionHandler</code>方法来解决异常。请参阅<a href="#mvc-ann-exceptionhandler">@ExceptionHandler方法</a> 。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="mvc-excetionhandlers-handling"><a class="anchor" href="#mvc-excetionhandlers-handling"></a>左轮手枪链</h5>
<div class="paragraph">
<p>您可以通过在Spring配置中声明多个<code>HandlerExceptionResolver</code> bean并根据需要设置其<code>order</code>属性来形成异常解析程序链。order属性越高，异常解析器定位的越晚。</p>
</div>
<div class="paragraph">
<p><code>HandlerExceptionResolver</code>的合约指定它可以返回：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个指向错误视图的<code>ModelAndView</code> 。</p>
</li>
<li>
<p>如果在解析程序中处理异常，则为空的<code>ModelAndView</code> 。</p>
</li>
<li>
<p>如果异常仍未解析，则为<code>null</code> ，以供后续解析器尝试，如果异常保留在最后，则允许冒泡到Servlet容器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#mvc-config">MVC Config</a>自动声明内置的解析器，用于默认的Spring MVC异常， <code>@ResponseStatus</code>注释的异常，以及对<code>@ExceptionHandler</code>方法的支持。您可以自定义该列表或替换它。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-customer-servlet-container-error-page"><a class="anchor" href="#mvc-ann-customer-servlet-container-error-page"></a>容器错误页面</h5>
<div class="paragraph">
<p>如果任何<code>HandlerExceptionResolver</code>仍未解析异常，并且因此将其传播或者如果响应状态设置为错误状态（即4xx，5xx），则Servlet容器可以在HTML中呈现默认错误页面。要自定义容器的默认错误页面，可以在<code>web.xml</code>声明错误页面映射。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;error-page&gt;</span> <span class="tag">&lt;location&gt;</span> / error <span class="tag">&lt;/ location&gt;</span> <span class="tag">&lt;/ error-page&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>根据前面的示例，当异常冒泡或响应具有错误状态时，Servlet容器会在容器内对配置的URL进行ERROR调度（例如， <code>/error</code> ）。然后由<code>DispatcherServlet</code>处理，可能将其映射到<code>@Controller</code> ，可以实现该<code>@Controller</code>以返回带有模型的错误视图名称或呈现JSON响应，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ErrorController</span> { <span class="annotation">@RequestMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ error</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; handle（HttpServletRequest request）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（）; map.put（ <span class="string"><span class="delimiter">“</span> <span class="content">status</span> <span class="delimiter">”</span></span> ，request.getAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">javax.servlet.error.status_code</span> <span class="delimiter">”</span></span> ））; map.put（ <span class="string"><span class="delimiter">“</span> <span class="content">reason</span> <span class="delimiter">”</span></span> ，request.getAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">javax.servlet.error.message</span> <span class="delimiter">”</span></span> ））; <span class="keyword">返回</span>地图; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Servlet API没有提供在Java中创建错误页面映射的方法。但是，您可以同时使用<code>WebApplicationInitializer</code>和最小的<code>web.xml</code> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-viewresolver"><a class="anchor" href="#mvc-viewresolver"></a> 1.1.8。查看分辨率</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-viewresolution">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC定义了<code>ViewResolver</code>和<code>View</code>接口，使您可以在浏览器中呈现模型，而无需将您与特定的视图技术联系起来。<code>ViewResolver</code>提供视图名称和实际视图之间的映射。<code>View</code>在移交给特定视图技术之前处理数据准备。</p>
</div>
<div class="paragraph">
<p>下表提供了有关<code>ViewResolver</code>层次结构的更多详细信息：</p>
</div>
<table id="mvc-view-resolvers-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表3。ViewResolver实现</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">视图解析器</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractCachingViewResolver的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractCachingViewResolver</code>子类缓存它们解析的视图实例。缓存可提高某些视图技术的性能。您可以通过将<code>cache</code>属性设置为<code>false</code>来关闭缓存。此外，如果必须在运行时刷新某个视图（例如，修改FreeMarker模板时），则可以使用<code>removeFromCache(String viewName, Locale loc)</code>方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>XmlViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实现<code>ViewResolver</code> ，它接受使用与Spring的XML bean工厂相同的DTD以XML编写的配置文件。默认配置文件是<code>/WEB-INF/views.xml</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>一个ResourceBundleViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolver</code>实现，它使用由bundle base name指定的<code>ResourceBundle</code> bean定义。对于它应该解析的每个视图，它使用属性<code>[viewname].(class)</code>的值作为视图类，并使用属性<code>[viewname].url</code>作为视图URL。您可以在<a href="#mvc-view">View Technologies</a>一章中找到示例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>作为UrlBasedViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolver</code>接口的简单实现，它影响逻辑视图名称直接解析为URL而没有显式映射定义。如果您的逻辑名称以直接的方式与视图资源的名称匹配，则这是合适的，而不需要任意映射。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>使用InternalResourceViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UrlBasedViewResolver</code>便捷子类，支持<code>InternalResourceView</code> （实际上是Servlet和JSP）和子类，如<code>JstlView</code>和<code>TilesView</code> 。您可以使用<code>setViewClass(..)</code>为此解析程序生成的所有视图指定视图类。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/UrlBasedViewResolver.html"><code>UrlBasedViewResolver</code> Javadoc</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FreeMarkerViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UrlBasedViewResolver</code>便捷子类，支持<code>FreeMarkerView</code>及其自定义子类。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContentNegotiatingViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实现<code>ViewResolver</code>接口，该接口根据请求文件名或<code>Accept</code>标头解析视图。请参阅<a href="#mvc-multiple-representations">内容协商</a> 。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="mvc-viewresolver-handling"><a class="anchor" href="#mvc-viewresolver-handling"></a>处理</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-viewresolution-handling">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过声明多个解析程序bean链接视图解析程序，并在必要时通过设置<code>order</code>属性来指定排序。请记住，order属性越高，视图解析器在链中的位置越晚。</p>
</div>
<div class="paragraph">
<p><code>ViewResolver</code>的约定指定它可以返回null以指示无法找到该视图。但是，对于JSP和<code>InternalResourceViewResolver</code> ，确定JSP是否存在的唯一方法是通过<code>RequestDispatcher</code>执行调度。因此，您必须始终将<code>InternalResourceViewResolver</code>配置为视图解析器的整体顺序中的最后一个。</p>
</div>
<div class="paragraph">
<p>配置视图解析就像将<code>ViewResolver</code> bean添加到Spring配置一样简单。<a href="#mvc-config">MVC Config</a>为<a href="#mvc-config-view-resolvers">View Resolvers</a>提供专用配置API，并添加无逻辑<a href="#mvc-config-view-controller">视图控制器</a> ，这些<a href="#mvc-config-view-controller">控制器</a>对于没有控制器逻辑的HTML模板渲染非常有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-redirecting-redirect-prefix"><a class="anchor" href="#mvc-redirecting-redirect-prefix"></a>重定向</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-redirecting-redirect-prefix">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>视图名称中的特殊<code>redirect:</code>前缀允许您执行重定向。<code>UrlBasedViewResolver</code> （及其子类）将此识别为需要重定向的指令。视图名称的其余部分是重定向URL。</p>
</div>
<div class="paragraph">
<p>净效果与控制器返回<code>RedirectView</code>效果相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名称（例如<code>redirect:/myapp/some/resource</code> ）相对于当前Servlet上下文<code>redirect:http://myhost.com/some/arbitrary/path</code> ，而名称如<code>redirect:http://myhost.com/some/arbitrary/path</code>重定向到绝对URL。</p>
</div>
<div class="paragraph">
<p>请注意，如果使用<code>@ResponseStatus</code>注释控制器方法，则注释值优先于<code>RedirectView</code>设置的响应状态。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-redirecting-forward-prefix"><a class="anchor" href="#mvc-redirecting-forward-prefix"></a>转发</h5>
<div class="paragraph">
<p>您还可以为最终由<code>UrlBasedViewResolver</code>和子类解析的视图名称使用特殊的<code>forward:</code>前缀。这将创建一个<code>InternalResourceView</code> ，它执行<code>RequestDispatcher.forward()</code> 。因此，此前缀对于<code>InternalResourceViewResolver</code>和<code>InternalResourceView</code> （对于JSP）没有用，但如果您使用其他视图技术但仍希望强制Servlet / JSP引擎处理资源的转发，则它可能会有所帮助。请注意，您也可以链接多个视图解析器。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-multiple-representations"><a class="anchor" href="#mvc-multiple-representations"></a>内容谈判</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-multiple-representations">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html"><code>ContentNegotiatingViewResolver</code></a>本身不解析视图，而是委托给其他视图解析器，并选择类似于客户端请求的表示的视图。可以从<code>Accept</code>标头或查询参数（例如， <code>"/path?确定表示<code>"/path?format=pdf"</code> ）。</p>
</div>
<div class="paragraph">
<p><code>ContentNegotiatingViewResolver</code>通过将请求媒体类型与与其每个<code>ViewResolvers</code>关联的<code>View</code>支持的媒体类型（也称为<code>Content-Type</code> ）进行比较，选择适当的<code>View</code>来处理请求。列表中具有兼容<code>Content-Type</code>的第一个<code>View</code>将表示返回给客户端。如果<code>ViewResolver</code>链无法提供兼容视图，则会查询通过<code>DefaultViews</code>属性指定的视图列表。后一个选项适用于单个<code>Views</code> ，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。<code>Accept</code>标头可以包含通配符（例如<code>text/*</code> ），在这种情况下， <code>Content-Type</code>为<code>text/xml</code>的<code>View</code>是兼容匹配。</p>
</div>
<div class="paragraph">
<p>有关配置详细信息，请参阅<a href="#mvc-config">MVC配置</a>下的<a href="#mvc-config-view-resolvers">视图解析器</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-localeresolver"><a class="anchor" href="#mvc-localeresolver"></a> 1.1.9。语言环境</h4>
<div class="paragraph">
<p>正如Spring Web MVC框架所做的那样，Spring架构的大多数部分都支持国际化。<code>DispatcherServlet</code>允许您使用客户端的语言环境自动解析消息。这是通过<code>LocaleResolver</code>对象完成的。</p>
</div>
<div class="paragraph">
<p>当请求进入时， <code>DispatcherServlet</code>查找语言环境解析器，如果找到，则会尝试使用它来设置语言环境。通过使用<code>RequestContext.getLocale()</code>方法，您始终可以检索由区域设置解析程序解析的区域设置。</p>
</div>
<div class="paragraph">
<p>除了自动语言环境解析之外，您还可以将拦截器附加到处理程序映射（有关处理程序映射拦截<a href="#mvc-handlermapping-interceptor">器</a>的更多信息，请参阅拦截）以在特定情况下更改语言环境（例如，基于请求中的参数）。</p>
</div>
<div class="paragraph">
<p>区域设置解析器和拦截器在<code>org.springframework.web.servlet.i18n</code>包中定义，并以正常方式在应用程序上下文中进行配置。Spring中包含以下选择的语言环境解析器。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-timezone">时区</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-acceptheader">标题解析器</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-cookie">Cookie解析器</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-session">会话解析器</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-interceptor">Locale拦截器</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="mvc-timezone"><a class="anchor" href="#mvc-timezone"></a>时区</h5>
<div class="paragraph">
<p>除了获取客户端的区域设置外，了解其时区通常也很有用。该<code>LocaleContextResolver</code>接口提供了一个扩展<code>LocaleResolver</code> ，让解析器提供了更丰富的<code>LocaleContext</code> ，其中可能包括时区信息。</p>
</div>
<div class="paragraph">
<p>可用时，可以使用<code>RequestContext.getTimeZone()</code>方法获取用户的<code>TimeZone</code> 。时区信息由Spring的<code>ConversionService</code>注册的任何Date / Time <code>Converter</code>和<code>Formatter</code>对象自动使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-acceptheader"><a class="anchor" href="#mvc-localeresolver-acceptheader"></a>标题解析器</h5>
<div class="paragraph">
<p>此区域设置解析程序检查客户端（例如，Web浏览器）发送的请求中的<code>accept-language</code>标头。通常，此标头字段包含客户端操作系统的区域设置。请注意，此解析程序不支持时区信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-cookie"><a class="anchor" href="#mvc-localeresolver-cookie"></a> Cookie解析器</h5>
<div class="paragraph">
<p>此区域设置解析程序检查客户端上可能存在的<code>Cookie</code> ，以查看是否指定了<code>Locale</code>或<code>TimeZone</code> 。如果是，则使用指定的详细信息。通过使用此区域设置解析程序的属性，您可以指定cookie的名称以及最大年龄。以下示例定义<code>CookieLocaleResolver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">localeResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.i18n。CookieLocaleResolver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cookieName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">clientlanguage</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 以秒为单位。如果设置为-1，则cookie不会</span> <span class="string"><span class="content">保留</span></span> （在浏览器关闭时删除） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cookieMaxAge</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">100000</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下表描述了<code>CookieLocaleResolver</code>的属性：</p>
</div>
<table id="mvc-cookie-locale-resolver-props-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表4。CookieLocaleResolver属性</caption>
<colgroup>
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:66.6668%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookieName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">classname + LOCALE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cookie的名称</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>名cookieMaxAge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet容器默认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cookie在客户端上持续存在的最长时间。如果指定<code>-1</code> ，则不会保留cookie。它仅在客户端关闭浏览器之前可用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookiePath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">限制cookie对您网站某个部分的可见性。指定<code>cookiePath</code> ，cookie仅对该路径及其下方的路径可见。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-session"><a class="anchor" href="#mvc-localeresolver-session"></a>会话解析器</h5>
<div class="paragraph">
<p><code>SessionLocaleResolver</code>允许您从可能与用户请求关联的会话中检索<code>Locale</code>和<code>TimeZone</code> 。与<code>CookieLocaleResolver</code> ，此策略将本地选择的区域设置存储在Servlet容器的<code>HttpSession</code> 。因此，这些设置对于每个会话都是临时的，因此在每个会话终止时丢失。</p>
</div>
<div class="paragraph">
<p>请注意，与外部会话管理机制没有直接关系，例如Spring Session项目。此<code>SessionLocaleResolver</code>根据当前的<code>HttpServletRequest</code>评估和修改相应的<code>HttpSession</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-interceptor"><a class="anchor" href="#mvc-localeresolver-interceptor"></a> Locale拦截器</h5>
<div class="paragraph">
<p>您可以通过将<code>LocaleChangeInterceptor</code>添加到其中一个处理程序映射来启用语言环境的更改（请参阅<a href="#mvc-handlermapping">[mvc-handlermapping]</a> ）。它检测请求中的参数并更改区域设置。它在<code>LocaleResolver</code>上调用<code>setLocale()</code> ，它也存在于上下文中。下一个示例显示，对包含名为<code>siteLanguage</code>的参数的所有<code>*.view</code>资源的调用现在更改了区域设置。因此，例如，对URL的请求<code><a href="http://www.sf.net/home.view?siteLanguage=nl" class="bare">http://www.sf.net/home.view?siteLanguage=nl</a></code>将网站语言更改为荷兰语。以下示例显示如何拦截区域设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">localeChangeInterceptor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.i18n。LocaleChangeInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">paramName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">siteLanguage</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">localeResolver</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.web.servlet.i18n。CookieLocaleResolver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">urlMapping</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.web.servlet.handler。SimpleUrlHandlerMapping</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptors</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">localeChangeInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappings</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> /**/*.view= someController <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-themeresolver"><a class="anchor" href="#mvc-themeresolver"></a> 1.1.10。主题</h4>
<div class="paragraph">
<p>您可以应用Spring Web MVC框架主题来设置应用程序的整体外观，从而增强用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉样式。</p>
</div>
<div class="sect4">
<h5 id="mvc-themeresolver-defining"><a class="anchor" href="#mvc-themeresolver-defining"></a>定义主题</h5>
<div class="paragraph">
<p>要在Web应用程序中使用主题，必须设置<code>org.springframework.ui.context.ThemeSource</code>界面。<code>WebApplicationContext</code>接口扩展了<code>ThemeSource</code>但将其职责委托给专用实现。默认情况下，委托是<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>实现，它从类路径的根目录加载属性文件。要使用自定义<code>ThemeSource</code>实现或配置<code>ResourceBundleThemeSource</code>的基本名称前缀，可以在应用程序上下文中使用保留名称<code>themeSource</code>注册bean。Web应用程序上下文自动检测具有该名称的bean并使用它。</p>
</div>
<div class="paragraph">
<p>使用<code>ResourceBundleThemeSource</code> ，主题在简单属性文件中定义。属性文件列出构成主题的资源，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>styleSheet = / themes / cool / style.css background = / themes / cool / img / coolBg.jpg</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>属性的键是从视图代码引用主题元素的名称。对于JSP，通常使用<code>spring:theme</code>自定义标记执行此操作，该标记与<code>spring:message</code>标记非常相似。以下JSP片段使用上一示例中定义的主题来自定义外观：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="error">&lt;</span> ％@ taglib prefix =“spring”uri =“http://www.springframework.org/tags”％ <span class="error">&gt;</span> <span class="tag">&lt;html&gt;</span> <span class="tag">&lt;head&gt;</span> <span class="tag">&lt;link</span> <span class="attribute-name">rel</span> = <span class="string"><span class="delimiter">“</span> <span class="content">stylesheet</span> <span class="delimiter">”</span></span> <span class="attribute-name">href</span> = <span class="string"><span class="delimiter">“</span> <span class="content">&lt;spring：theme code ='styleSheet '/</span></span> <span class="error">&gt;</span> “type =”text / css“/ <span class="error">&gt;</span> <span class="tag">&lt;/ head&gt;</span> <span class="tag">&lt;body</span> <span class="attribute-name">style</span> = <span class="string"><span class="delimiter">”</span> <span class="key">background</span> = <span class="error">&lt;</span> <span class="key">spring</span> ： <span class="value">theme</span> <span class="value">code</span> = <span class="string"><span class="delimiter">'</span> <span class="content">background</span> <span class="delimiter">'</span></span> /&gt; <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...
    <span class="tag">&lt;/ body&gt;</span> <span class="tag">&lt;/ html&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>ResourceBundleThemeSource</code>使用空的基本名称前缀。因此，属性文件从类路径的根加载。因此，您可以将<code>cool.properties</code>主题定义放在类路径根目录的目录中（例如，在<code>/WEB-INF/classes</code> ）。<code>ResourceBundleThemeSource</code>使用标准的Java资源包加载机制，允许主题的完全国际化。例如，我们可以有一个<code>/WEB-INF/classes/cool_nl.properties</code> ，它引用一个带有荷兰文本的特殊背景图像。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-themeresolver-resolving"><a class="anchor" href="#mvc-themeresolver-resolving"></a>解决主题</h5>
<div class="paragraph">
<p>定义主题后，如上<a href="#mvc-themeresolver-defining">一节所述</a> ，您可以决定使用哪个主题。<code>DispatcherServlet</code>查找名为<code>themeResolver</code>的bean，以找出要使用的<code>ThemeResolver</code>实现。主题解析器的工作方式与<code>LocaleResolver</code>工作方式大致相同。它检测用于特定请求的主题，还可以更改请求的主题。下表描述了Spring提供的主题解析器：</p>
</div>
<table id="mvc-theme-resolver-impls-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表5。ThemeResolver实现</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FixedThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择使用<code>defaultThemeName</code>属性设置的固定主题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主题在用户的HTTP会话中维护。它只需要为每个会话设置一次，但不会在会话之间保留。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CookieThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所选主题存储在客户端的cookie中。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring还提供了一个<code>ThemeChangeInterceptor</code> ，它允许使用简单的请求参数对每个请求进行主题更改。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-multipart"><a class="anchor" href="#mvc-multipart"></a> 1.1.11。多部分解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-multipart">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>org.springframework.web.multipart</code>包中的<code>MultipartResolver</code>是一种用于解析包括文件上载在内的多部分请求的策略。有一个基于<a href="http://jakarta.apache.org/commons/fileupload">Commons FileUpload的实现</a> ，另一个基于Servlet 3.0多部分请求解析。</p>
</div>
<div class="paragraph">
<p>要启用多部分处理，需要在<code>DispatcherServlet</code> Spring配置中使用<code>multipartResolver</code>的名称声明<code>MultipartResolver</code> bean。<code>DispatcherServlet</code>检测到它并将其应用于传入请求。当收到内容类型为<code>multipart/form-data</code>的POST时，解析器会解析内容并将当前的<code>HttpServletRequest</code>包装为<code>MultipartHttpServletRequest</code>以提供对已解析部分的访问，同时将它们公开为请求参数。</p>
</div>
<div class="sect4">
<h5 id="mvc-multipart-resolver-commons"><a class="anchor" href="#mvc-multipart-resolver-commons"></a> Apache <code>FileUpload</code></h5>
<div class="paragraph">
<p>要使用Apache Commons <code>FileUpload</code> ，您可以配置名为<code>multipartResolver</code> <code>CommonsMultipartResolver</code>类型的bean。您还需要将<code>commons-fileupload</code>作为类路径的依赖项。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-multipart-resolver-standard"><a class="anchor" href="#mvc-multipart-resolver-standard"></a> Servlet 3.0</h5>
<div class="paragraph">
<p>需要通过Servlet容器配置启用Servlet 3.0多部分解析。为此：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在Java中，在Servlet注册上设置<code>MultipartConfigElement</code> 。</p>
</li>
<li>
<p>在<code>web.xml</code> ，将<code>"&lt;multipart-config&gt;"</code>部分添加到servlet声明中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示如何在Servlet注册上设置<code>MultipartConfigElement</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">AppInitializer</span> <span class="directive">扩展</span> AbstractAnnotationConfigDispatcherServletInitializer { <span class="comment">// ...</span>

    <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> customizeRegistration（ServletRegistration。动态注册）{ <span class="comment">//还可以选择设置maxFileSize，maxRequestSize，fileSizeThreshold</span> registration.setMultipartConfig（ <span class="keyword">new</span> MultipartConfigElement（ <span class="string"><span class="delimiter">“</span> <span class="content">/ tmp</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦Servlet 3.0配置到位，您就可以添加名为<code>multipartResolver</code> <code>StandardServletMultipartResolver</code>类型的bean。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-logging"><a class="anchor" href="#mvc-logging"></a> 1.1.12。记录</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-logging">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC中的DEBUG级别日志记录旨在实现紧凑，简约和人性化。它侧重于高价值的信息，这些信息一次又一次地有用，而只有在调试特定问题时才有用。</p>
</div>
<div class="paragraph">
<p>TRACE级日志记录通常遵循与DEBUG相同的原则（例如，也不应该是消防软管），但可以用于调试任何问题。此外，一些日志消息可能在TRACE与DEBUG中显示不同的详细程度。</p>
</div>
<div class="paragraph">
<p>良好的日志记录来自使用日志的经验。如果您发现任何不符合既定目标的事件，请告知我们。</p>
</div>
<div class="sect4">
<h5 id="mvc-logging-sensitive-data"><a class="anchor" href="#mvc-logging-sensitive-data"></a>敏感数据</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-logging-sensitive-data">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>DEBUG和TRACE日志记录可能会记录敏感信息。这就是默认情况下屏蔽请求参数和标头的原因，并且必须通过<code>DispatcherServlet</code>上的<code>enableLoggingRequestDetails</code>属性显式启用它们的完整日志记录。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何使用Java配置执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyInitializer</span> <span class="directive">延伸</span> AbstractAnnotationConfigDispatcherServletInitializer <span class="annotation">{@覆盖</span> <span class="directive">保护</span> <span class="predefined-type">类</span> &lt;？&gt; <span class="type">[]</span> getRootConfigClasses（）{ <span class="keyword">return</span> ...; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> getServletConfigClasses（）{ <span class="keyword">return</span> ...; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">String</span> <span class="type">[]</span> getServletMappings（）{ <span class="keyword">return</span> ...; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> customizeRegistration（动态注册）{registration.setInitParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">enableLoggingRequestDetails</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="filters"><a class="anchor" href="#filters"></a> 1.2。过滤器</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-filters">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>spring-web</code>模块提供了一些有用的过滤器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#filters-http-put">表格数据</a></p>
</li>
<li>
<p><a href="#filters-forwarded-headers">转发标题</a></p>
</li>
<li>
<p><a href="#filters-shallow-etag">浅ETag</a></p>
</li>
<li>
<p><a href="#filters-cors">CORS</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="filters-http-put"><a class="anchor" href="#filters-http-put"></a> 1.2.1。表格数据</h4>
<div class="paragraph">
<p>浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户端也可以使用HTTP PUT，PATCH和DELETE。 Servlet API要求<code>ServletRequest.getParameter*()</code>方法仅支持HTTP POST的表单字段访问。</p>
</div>
<div class="paragraph">
<p><code>spring-web</code>模块提供<code>FormContentFilter</code>来拦截HTTP PUT，PATCH和DELETE请求，内容类型为<code>application/x-www-form-urlencoded</code> ，从请求正文中读取表单数据，并包装<code>ServletRequest</code>以使通过<code>ServletRequest.getParameter*()</code>系列方法提供表单数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="filters-forwarded-headers"><a class="anchor" href="#filters-forwarded-headers"></a> 1.2.2。转发标题</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-forwarded-headers">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>当请求通过代理（例如负载平衡器）时，主机，端口和方案可能会发生变化，这使得从客户端角度创建指向正确主机，端口和方案的链接成为一项挑战。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可以用来提供有关原始请求的信息的<code>Forwarded</code> HTTP头。还有其他非标准头文件，包括<code>X-Forwarded-Host</code> ， <code>X-Forwarded-Port</code> ， <code>X-Forwarded-Proto</code> ， <code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code> 。</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderFilter</code>是一个Servlet过滤器，它根据<code>Forwarded</code>标头修改请求的主机，端口和方案，然后删除这些标头。</p>
</div>
<div class="paragraph">
<p>转发标头存在安全注意事项，因为应用程序无法知道标头是由代理按预期添加还是由恶意客户端添加。这就是为什么应该将信任边界的代理配置为删除来自外部的不受信任的<code>Forwarded</code>标头。您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderFilter</code> ，在这种情况下，它会删除但不使用标头。</p>
</div>
</div>
<div class="sect3">
<h4 id="filters-shallow-etag"><a class="anchor" href="#filters-shallow-etag"></a> 1.2.3。浅ETag</h4>
<div class="paragraph">
<p><code>ShallowEtagHeaderFilter</code>过滤器通过缓存写入响应的内容并从中计算MD5哈希来创建“浅”ETag。客户端下次发送时，它会执行相同操作，但它也会将计算值与<code>If-None-Match</code>请求标头进行比较，如果两者相等，则返回304（NOT_MODIFIED）。</p>
</div>
<div class="paragraph">
<p>此策略可以节省网络带宽，但不能节省CPU，因为必须为每个请求计算完整响应。前面描述的控制器级别的其他策略可以避免计算。请参阅<a href="#mvc-caching">HTTP缓存</a> 。</p>
</div>
<div class="paragraph">
<p>此过滤器具有<code>writeWeakETag</code>参数，该参数将过滤器配置为写入弱ETag，类似于以下内容： <code>W/"02a2d595e6ed9a0b24f027f2b63b134d6"</code> （如<a href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232第2.3节中</a>所定义）。</p>
</div>
</div>
<div class="sect3">
<h4 id="filters-cors"><a class="anchor" href="#filters-cors"></a> 1.2.4。CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-filters-cors">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC通过控制器上的注释为CORS配置提供细粒度的支持。但是，当与Spring Security一起使用时，我们建议依赖于必须在Spring Security的过滤器链之前订购的内置<code>CorsFilter</code> 。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#mvc-cors">CORS</a>和<a href="#mvc-cors-filter">CORS过滤器</a>部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-controller"><a class="anchor" href="#mvc-controller"></a> 1.3。带注释的控制器</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-controller">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC提供了一个基于注释的编程模型，其中<code>@Controller</code> <code>@RestController</code>和<code>@RestController</code>组件使用注释来表达请求映射，请求输入，异常处理等。带注释的控制器具有灵活的方法签名，不必扩展基类，也不必实现特定的接口。以下示例显示了由注释定义的控制器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">HelloController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ hello</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（Model model）{model.addAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">message</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Hello World！</span><span class="delimiter">“</span></span> ）; <span class="keyword">返回</span> <span class="string"><span class="delimiter">”</span> <span class="content">index</span> <span class="delimiter">“</span></span> ;}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，该方法接受<code>Model</code>并将视图名称作为<code>String</code>返回，但是存在许多其他选项，本章稍后将对其进行说明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关<a href="https://spring.io/guides">spring.io的</a>指南和教程，请使用本节中介绍的基于注释的编程模型。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="mvc-ann-controller"><a class="anchor" href="#mvc-ann-controller"></a> 1.3.1。宣言</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-controller">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用Servlet的<code>WebApplicationContext</code>中的标准Spring bean定义来定义控制器bean。<code>@Controller</code>型允许自动检测，与Spring一致支持，以检测<code>@Component</code>路径中的<code>@Component</code>类，并为它们自动注册bean定义。它还充当带注释类的构造型，表明它作为Web组件的角色。</p>
</div>
<div class="paragraph">
<p>要启用此类<code>@Controller</code> bean的自动检测，您可以将组件扫描添加到Java配置中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">org.example.web</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：p</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/p</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：上下文</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example.web</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@RestController</code>是一个<a href="core.html#beans-meta-annotations">组合注释</a> ，它本身使用<code>@Controller</code>和<code>@ResponseBody</code>进行元注释，以指示一个控制器，其每个方法都继承了类型级<code>@ResponseBody</code>注释，因此，直接写入响应主体与视图分辨率和渲染HTML模板。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-proxying"><a class="anchor" href="#mvc-ann-requestmapping-proxying"></a> AOP代理</h5>
<div class="paragraph">
<p>在某些情况下，您需要在运行时使用AOP代理装饰控制器。例如，如果您选择在控制器上直接使用<code>@Transactional</code>注释。在这种情况下，对于控制器而言，我们建议使用基于类的代理。这通常是控制器的默认选择。但是，如果控制器必须实现不是Spring Context回调的接口（例如<code>InitializingBean</code> ， <code>*Aware</code>等），则可能需要显式配置基于类的代理。例如，使用<code>&lt;tx:annotation-driven/&gt;</code> ，您可以更改为<code>&lt;tx:annotation-driven proxy-target-class="true"/&gt;</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping"><a class="anchor" href="#mvc-ann-requestmapping"></a> 1.3.2。请求映射</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestMapping</code>批注将请求映射到控制器方法。它具有各种属性，可通过URL，HTTP方法，请求参数，标头和媒体类型进行匹配。您可以在类级别使用它来表示共享映射，或者在方法级别使用它来缩小到特定的端点映射。</p>
</div>
<div class="paragraph">
<p>还有<code>@RequestMapping</code> HTTP方法特定快捷方式变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>快捷方式是提供的<a href="#mvc-ann-requestmapping-composed">自定义注释</a> ，因为可以说，大多数控制器方法应该映射到特定的HTTP方法而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。同样，在类级别仍然需要<code>@RequestMapping</code>来表示共享映射。</p>
</div>
<div class="paragraph">
<p>以下示例具有类型和方法级别映射：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ） <span class="type">class</span> <span class="class">PersonController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Person getPerson（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@PostMapping</span> <span class="annotation">@ResponseStatus</span> （ <span class="annotation">HttpStatus</span> 。创建） <span class="directive">public</span> <span class="type">void</span> add（ <span class="annotation">@RequestBody</span> Person person）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-uri-templates"><a class="anchor" href="#mvc-ann-requestmapping-uri-templates"></a> URI模式</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-uri-templates">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用以下glob模式和通配符映射请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>？</code> 匹配一个字符</p>
</li>
<li>
<p><code>*</code>匹配路径段中的零个或多个字符</p>
</li>
<li>
<p><code>**</code>匹配零个或多个路径段</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以使用<code>@PathVariable</code>声明URI变量并访问它们的值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Pet findPet（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> ownerId， <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在类和方法级别声明URI变量，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">OwnerController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Pet findPet（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> ownerId， <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> petId）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>URI变量自动转换为适当的类型，或<code>TypeMismatchException</code> 。默认情况下支持简单类型（ <code>int</code> ， <code>long</code> ， <code>Date</code>等），您可以注册对任何其他数据类型的支持。请参见<a href="#mvc-ann-typeconversion">类型转换</a>和<a href="#mvc-ann-initbinder">使用<code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>您可以显式命名URI变量（例如， <code>@PathVariable("customId")</code> ），但是如果名称相同并且您的代码是使用调试信息或使用Java 8上的<code>-parameters</code>编译器标志编译的，则可以保留该详细信息。 。</p>
</div>
<div class="paragraph">
<p>语法<code>{varName:regex}</code>声明一个URI变量，其正则表达式的语法为<code>{varName:regex}</code> 。例如，给定URL <code>"/spring-web-3.0.5 .jar"</code> ，以下方法提取名称，版本和文件扩展名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {name：[az  - ] +}  -  {version：</span> <span class="char">\\</span> <span class="content">d</span> <span class="char">\\</span> <span class="content">。</span> <span class="char">\\</span> <span class="content">d</span> <span class="char">\\</span> <span class="content">。</span> <span class="char">\\</span> <span class="content">d} {ext：</span> <span class="char">\\</span> <span class="content">。[az] +}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle （ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> version， <span class="annotation">@ PathVariable</span> <span class="predefined-type">String</span> ext）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>URI路径模式还可以嵌入<code>${…​}</code>占位符，这些占位符在启动时通过对本地，系统，环境和其他属性源使用<code>PropertyPlaceHolderConfigurer</code>来解析。例如，您可以使用它来根据某些外部配置参数化基本URL。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring MVC使用<code>PathMatcher</code>契约和<code>spring-core</code>的<code>AntPathMatcher</code>实现进行URI路径匹配。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-pattern-comparison"><a class="anchor" href="#mvc-ann-requestmapping-pattern-comparison"></a>模式比较</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-pattern-comparison">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>当多个模式与URL匹配时，必须对它们进行比较以找到最佳匹配。这是通过使用<code>AntPathMatcher.getPatternComparator(String path)</code> ，它会查找更具体的模式。</p>
</div>
<div class="paragraph">
<p>如果URI变量数较少且单个通配符计为1且双通配符计为2，则模式不太具体。给定相等的分数，选择较长的模式。给定相同的分数和长度，选择具有比通配符更多的URI变量的模式。</p>
</div>
<div class="paragraph">
<p>默认映射模式（ <code>/**</code> ）从评分中排除，并始终排在最后。此外，前缀模式（例如<code>/public/**</code> ）被认为不具有不具有双通配符的其他模式的特定性。</p>
</div>
<div class="paragraph">
<p>有关完整的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html"><code>AntPatternComparator</code></a>中的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html"><code>AntPathMatcher</code></a>并记住您可以自定义<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html"><code>PathMatcher</code></a>实现。请参阅配置部分中的<a href="#mvc-config-path-matching">路径匹配</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-suffix-pattern-match"><a class="anchor" href="#mvc-ann-requestmapping-suffix-pattern-match"></a>后缀匹配</h5>
<div class="paragraph">
<p>默认情况下，Spring MVC执行<code>.*</code>后缀模式匹配，以便映射到<code>/person</code>的控制器也隐式映射到<code>/person.*</code> 。然后使用文件扩展名来解释用于响应的请求内容类型（即，而不是<code>Accept</code>标头） - 例如，/ <code>/person.pdf</code> ，/ <code>/person.xml</code>等。</p>
</div>
<div class="paragraph">
<p>当浏览器用于发送难以一致解释的<code>Accept</code>标头时，必须以这种方式使用文件扩展名。目前，这不再是必需品，使用<code>Accept</code>标头应该是首选。</p>
</div>
<div class="paragraph">
<p>随着时间的推移，文件扩展名的使用已经证明有多种方式存在问题。当使用URI变量，路径参数和URI编码进行覆盖时，它可能会导致歧义。有关基于URL的授权和安全性的推理（有关更多详细信息，请参阅下一节）也变得更加困难。</p>
</div>
<div class="paragraph">
<p>要完全禁用文件扩展名，必须同时设置以下两项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>useSuffixPatternMatching(false)</code> ，请参阅<a href="#mvc-config-path-matching">PathMatchConfigurer</a></p>
</li>
<li>
<p><code>favorPathExtension(false)</code> ，请参阅<a href="#mvc-config-content-negotiation">ContentNeogiationConfigurer</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>基于URL的内容协商仍然有用（例如，在浏览器中键入URL时）。为此，我们建议使用基于查询参数的策略来避免文件扩展名带来的大多数问题。另外，如果必须使用的文件扩展名，应考虑限制它们通过明确登记的扩展名列表<code>mediaTypes</code>财产<a href="#mvc-config-content-negotiation">ContentNeogiationConfigurer</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-rfd"><a class="anchor" href="#mvc-ann-requestmapping-rfd"></a>后缀匹配和RFD</h5>
<div class="paragraph">
<p>反射文件下载（RFD）攻击类似于XSS，因为它依赖于响应中反映的请求输入（例如，查询参数和URI变量）。但是，RFD攻击不依赖于将JavaScript插入HTML，而是依赖浏览器切换来执行下载，并在以后双击时将响应视为可执行脚本。</p>
</div>
<div class="paragraph">
<p>在Spring MVC中， <code>@ResponseBody</code> <code>ResponseEntity</code>和<code>ResponseEntity</code>方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展来请求。禁用后缀模式匹配并使用路径扩展进行内容协商可降低风险，但不足以防止RFD攻击。</p>
</div>
<div class="paragraph">
<p>为了防止RFD攻击，在呈现响应主体之前，Spring MVC添加了一个<code>Content-Disposition:inline;filename=f.txt</code>标头来建议一个固定且安全的下载文件。仅当URL路径包含既未列入白名单也未明确注册用于内容协商的文件扩展名时，才会执行此操作。但是，当直接在浏览器中输入URL时，它可能会产生副作用。</p>
</div>
<div class="paragraph">
<p>默认情况下，许多常见路径扩展名都列入白名单。具有自定义<code>HttpMessageConverter</code>实现的应用程序可以显式注册文件扩展名以进行内容协商，以避免为这些扩展添加<code>Content-Disposition</code>标头。请参阅<a href="#mvc-config-content-negotiation">内容类型</a> 。</p>
</div>
<div class="paragraph">
<p>有关RFD的其他建议，请参阅<a href="http://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-consumes"><a class="anchor" href="#mvc-ann-requestmapping-consumes"></a>耗材类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-consumes">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据请求的<code>Content-Type</code>缩小请求映射范围，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets</span> <span class="delimiter">”</span></span> ， <span class="annotation">consume</span> = <span class="string"><span class="delimiter">“</span> <span class="content">application / json</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> addPet（ <span class="annotation">@RequestBody</span> Pet pet）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>consumes</code>属性来缩小内容类型的映射。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>consumes</code>属性还支持否定表达式 - 例如， <code>!text/plain</code>表示<code>text/plain</code>以外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>你可以声明一个共享的<code>consumes</code>类级别属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>consumes</code>属性覆盖而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>为常用媒体类型提供常量，例如<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-produces"><a class="anchor" href="#mvc-ann-requestmapping-produces"></a>可生产的媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-produces">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="content">produce</span></span> = <span class="string"><span class="delimiter">“</span> <span class="content">application / json; charset = UTF-8</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@ResponseBody</span> <span class="directive">public</span> Pet getPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>produces</code>属性来缩小内容类型的映射。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>媒体类型可以指定字符集。支持否定表达式 - 例如， <code>!text/plain</code>表示“text / plain”以外的任何内容类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于JSON内容类型，即使<a href="https://tools.ietf.org/html/rfc7159#section-11">RFC7159</a>明确声明“没有为此注册定义charset参数”，也应指定UTF-8字符集，因为某些浏览器要求它正确解释UTF-8特殊字符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以在类级别声明共享的<code>produces</code>属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>produces</code>属性覆盖，而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>为常用媒体类型提供常量，例如<code>APPLICATION_JSON_UTF8_VALUE</code>和<code>APPLICATION_XML_VALUE</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-params-and-headers"><a class="anchor" href="#mvc-ann-requestmapping-params-and-headers"></a>参数，标题</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-params-and-headers">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据请求参数条件缩小请求映射。您可以测试是否存在请求参数（ <code>myParam</code> ），因为缺少一个请求参数（ <code>!myParam</code> ），或特定值（ <code>myParam=myValue</code> ）。以下示例显示如何测试特定值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ，params = <span class="string"><span class="delimiter">“</span> <span class="content">myParam = myValue</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>测试<code>myParam</code>是否等于<code>myValue</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以将其与请求标头条件一起使用，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets</span> <span class="delimiter">”</span></span> ，headers = <span class="string"><span class="delimiter">“</span> <span class="content">myHeader = myValue</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>测试<code>myHeader</code>是否等于<code>myValue</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以将<code>Content-Type</code>和<code>Accept</code>与headers条件匹配，但最好使用<a href="#mvc-ann-requestmapping-consumes">consume</a>并<a href="#mvc-ann-requestmapping-produces">生成</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-head-options"><a class="anchor" href="#mvc-ann-requestmapping-head-options"></a> HTTP HEAD，OPTIONS</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-head-options">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> （和<code>@RequestMapping(method=HttpMethod.GET)</code> ）透明地支持HTTP HEAD以进行请求映射。控制器方法无需更改。响应包装器，应用于<code>javax.servlet.http.HttpServlet</code>确保将<code>Content-Length</code>头设置为写入的字节数（不实际写入响应）。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> （和<code>@RequestMapping(method=HttpMethod.GET)</code> ）被隐式映射到并支持HTTP HEAD。处理HTTP HEAD请求就像它是HTTP GET一样，除了编写字节数而不是写入主体，并设置<code>Content-Length</code>头。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过将<code>Allow</code>响应头设置为所有具有匹配URL模式的<code>@RequestMapping</code>方法中列出的HTTP方法列表来处理HTTP OPTIONS。</p>
</div>
<div class="paragraph">
<p>对于没有HTTP方法声明的@ <code>@RequestMapping</code> ， <code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code> 。控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体： <code>@GetMapping</code> ， <code>@PostMapping</code>等）。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@RequestMapping</code>方法显式映射到HTTP HEAD和HTTP OPTIONS，但在常见情况下这不是必需的。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-composed"><a class="anchor" href="#mvc-ann-requestmapping-composed"></a>自定义注释</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#mvc-ann-requestmapping-head-options">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC支持使用<a href="core.html#beans-meta-annotations">组合注释</a>进行请求映射。这些注释本身是使用<code>@RequestMapping</code>元注释的，并且用于重新声明具有更窄，更具体目的的<code>@RequestMapping</code>属性的子集（或全部）。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> ， <code>@PostMapping</code> ， <code>@PutMapping</code> ， <code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。提供它们是因为，可以说，大多数控制器方法应该映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。如果您需要组合注释的示例，请查看如何声明这些注释。</p>
</div>
<div class="paragraph">
<p>Spring MVC还支持使用自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要<code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并返回自己的<code>RequestCondition</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-registration"><a class="anchor" href="#mvc-ann-requestmapping-registration"></a>明确的注册</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-registration">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同URL下的同一处理程序的不同实例。以下示例注册处理程序方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfig</span> { <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setHandlerMapping（RequestMappingHandlerMapping mapping，UserHandler handler） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">抛出</span> <span class="exception">NoSuchMethodException</span> {RequestMappingInfo info = RequestMappingInfo .paths（ <span class="string"><span class="delimiter">“</span> <span class="content">/ user / {id}</span> <span class="delimiter">”</span></span> ）。method（RequestMethod。GET）.build（）; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="predefined-type">方法</span>方法= UserHandler.class.getMethod（ <span class="string"><span class="delimiter">“</span> <span class="content">getUser</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Long</span> .class）; <i class="conum" data-value="3"></i> <b>（3）</b> mapping.registerMapping（info，handler，method）; <i class="conum" data-value="4"></i> <b>（4）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>为控制器注入目标处理程序和处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>准备映射元数据的请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加注册。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-methods"><a class="anchor" href="#mvc-ann-methods"></a> 1.3.3。处理程序方法</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-methods">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从一系列受支持的控制器方法参数和返回值中进行选择。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-arguments"><a class="anchor" href="#mvc-ann-arguments"></a>方法参数</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-arguments">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>下表描述了支持的控制器方法参数。任何参数都不支持反应类型。</p>
</div>
<div class="paragraph">
<p>JDK 8的<code>java.util.Optional</code>支持作为方法参数与具有<code>required</code>属性的注释（例如，@ <code>@RequestParam</code> ，@ <code>@RequestHeader</code>等）相结合，并且等效于<code>required=false</code> 。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebRequest</code> ， <code>NativeWebRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无需直接使用Servlet API即可访问请求参数以及请求和会话属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的javax.servlet。ServletRequest</code> ， <code>javax.servlet.ServletResponse的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择任何特定的请求或响应类型 - 例如， <code>ServletRequest</code> ， <code>HttpServletRequest</code>或Spring的<code>MultipartRequest</code> ， <code>MultipartHttpServletRequest</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http包。HttpSession中</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制进行会话。因此，这样的论证永远不会是<code>null</code> 。请注意，会话访问不是线程安全的。如果允许多个请求同时访问会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为<code>true</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http包。PushBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于编程HTTP / 2资源推送的Servlet 4.0推送构建器API。请注意，根据Servlet规范，如果客户端不支持该HTTP / 2功能，则注入的<code>PushBuilder</code>实例可以为null。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security。主要</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code>实现类。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>列举HTTPMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。语言环境</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前请求区域设置，由最可用的<code>LocaleResolver</code> （实际上是已配置的<code>LocaleResolver</code>或<code>LocaleContextResolver</code> ）确定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。TimeZone</code> + <code>java.time.了zoneid</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.InputStream</code> ， <code>java.io.读者</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet API公开的原始请求主体。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.OutputStream</code> ， <code>java.io.作家</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet API公开的原始响应主体。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI模板变量。请参阅<a href="#mvc-ann-requestmapping-uri-templates">URI模式</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI路径段中的名称 - 值对。请参见<a href="#mvc-ann-matrix-variables">矩阵变量</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet请求参数。参数值将转换为声明的方法参数类型。请参阅<a href="#mvc-ann-requestparam">使用<code>@RequestParam</code></a> 。
</p><p class="tableblock">请注意，使用<code>@RequestParam</code>是可选的（例如，设置其属性）。请参阅本表末尾的“任何其他参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头。标头值将转换为声明的方法参数类型。请参阅<a href="#mvc-ann-requestheader">使用<code>@RequestHeader</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问cookie。Cookie值将转换为声明的方法参数类型。请参阅<a href="#mvc-ann-cookievalue">使用<code>@CookieValue</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTTP请求正文。通过使用<code>HttpMessageConverter</code>实现将<code>HttpMessageConverter</code>内容转换为声明的方法参数类型。请参阅<a href="#mvc-ann-requestbody">使用<code>@RequestBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity &lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头和正文。使用<code>HttpMessageConverter</code>实现转换<code>HttpMessageConverter</code> 。见<a href="#mvc-ann-httpentity">HttpEntity</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问<code>multipart/form-data</code>请求中的部件。见<a href="#mvc-multipart-forms">Multipart</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。Map</code> ， <code>org.springframework.ui.Model</code> ， <code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTML控制器中使用的模型，并将其作为视图呈现的一部分暴露给模板。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedirectAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定在重定向（即，要附加到查询字符串）时使用的属性，以及临时存储的flash属性，直到重定向后的请求为止。请参阅<a href="#mvc-redirecting-passing-data">重定向属性</a>和<a href="#mvc-flash-attributes">Flash属性</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问模型中的现有属性（如果不存在则实例化），并应用数据绑定和验证。请参阅<a href="#mvc-ann-modelattrib-method-args">使用<code>@ModelAttribute</code></a>以及<a href="#mvc-ann-modelattrib-methods">模型</a>和<a href="#mvc-ann-initbinder">使用<code>DataBinder</code></a> 。
</p><p class="tableblock">请注意，使用<code>@ModelAttribute</code>是可选的（例如，设置其属性）。请参阅本表末尾的“任何其他参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code> ， <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问来自命令对象的验证和数据绑定的错误（即<code>@ModelAttribute</code>参数）或来自验证<code>@RequestBody</code>或<code>@RequestPart</code>参数的错误。您必须在经过验证的方法参数后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> +类级别<code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于标记表单处理完成，它触发通过类级别<code>@SessionAttributes</code>注释声明的会话属性的清除。有关更多详细信息，请参阅<a href="#mvc-ann-sessionattributes">使用<code>@SessionAttributes</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于准备相对于当前请求的主机，端口，方案，上下文路径和servlet映射的文字部分的URL。请参阅<a href="#mvc-uri-building">URI链接</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问任何会话属性，与由于类级别<code>@SessionAttributes</code>声明而存储在会话中的模型属性相反。有关更多详细信息，请参阅<a href="#mvc-ann-sessionattribute">使用<code>@SessionAttribute</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求属性。有关更多详细信息，请参阅<a href="#mvc-ann-requestattrib">使用<code>@RequestAttribute</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他论点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果方法参数与此表中的任何早期值不匹配，并且它是一个简单类型（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定，则它被解析为<code>@RequestParam</code> 。否则，它将被解析为<code>@ModelAttribute</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-return-types"><a class="anchor" href="#mvc-ann-return-types"></a>返回值</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-return-types">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>下表描述了支持的控制器方法返回值。所有返回值都支持反应类型。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法返回值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值通过<code>HttpMessageConverter</code>实现转换并写入响应。请参阅<a href="#mvc-ann-responsebody">使用<code>@ResponseBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code> ， <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定完整响应（包括HTTP头和主体）的返回值将通过<code>HttpMessageConverter</code>实现转换并写入响应。请参阅<a href="#mvc-ann-responseentity">ResponseEntity</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于返回带标题且没有正文的响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>串</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用<code>ViewResolver</code>实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数以编程方式丰富模型（请参阅<a href="#mvc-ann-requestmapping-registration">显式注册</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>视图</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数以编程方式丰富模型（请参阅<a href="#mvc-ann-requestmapping-registration">显式注册</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。Map</code> ， <code>org.springframework.ui.模型</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到隐式模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。
</p><p class="tableblock">请注意，@ <code>@ModelAttribute</code>是可选的。请参阅本表末尾的“任何其他返回值”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ModelAndView</code>对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的视图和模型属性，以及（可选）响应状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>空虚</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果具有<code>void</code>返回类型（或返回值为<code>null</code> ）的方法，如果它还具有<code>ServletResponse</code> ， <code>OutputStream</code>参数或<code>@ResponseStatus</code>批注，则认为已完全处理该响应。如果控制器已进行正<code>ETag</code>或<code>lastModified</code>时间戳检查，则也是如此（有关详细信息，请参阅<a href="#mvc-caching-etag-lastmodified">控制器</a> ）。
</p><p class="tableblock">如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DeferredResult &lt;V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从任何线程异步生成任何前面的返回值 - 例如，由于某些事件或回调。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-deferredresult">使用<code>DeferredResult</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>可赎回&lt;V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Spring MVC管理的线程中异步生成上述任何返回值。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-callable">使用<code>Callable</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListenableFuture&lt;V&gt;</code> ， <code>java.util.concurrent.CompletionStage&lt;V&gt;</code> ， <code>java.util.concurrent.CompletableFuture &lt;V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为方便的替代<code>DeferredResult</code> （例如，当底层服务返回其中一个时）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyEmitter</code> ， <code>SseEmitter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用<code>HttpMessageConverter</code>实现以异步方式发送对象流以写入响应。还支持<code>ResponseEntity</code>的主体。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-http-streaming">HTTP流</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamingResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异步写入响应<code>OutputStream</code> 。还支持<code>ResponseEntity</code>的主体。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-http-streaming">HTTP流</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">反应类型 -  Reactor，RxJava或其他通过<code>ReactiveAdapterRegistry</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">替代<code>DeferredResult</code> ，将多值流（例如， <code>Flux</code> ， <code>Observable</code> ）收集到<code>List</code> 。
</p><p class="tableblock">对于流方案（例如， <code>text/event-stream</code> ， <code>application/json+stream</code> ），使用<code>SseEmitter</code>和<code>ResponseBodyEmitter</code> ，其中<code>ServletOutputStream</code>阻塞I / O在Spring MVC管理的线程上执行，并且反压力被应用于完成每次写。
</p><p class="tableblock">请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-reactive-types">反应类型</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何与此表中任何早期值不匹配且返回值为<code>String</code>或<code>void</code>返回值都被视为视图名称（通过<code>RequestToViewNameTranslator</code>应用默认视图名称选择），前提是它不是简单类型，由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils</a>确定<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">#isSimpleProperty</a> 。简单类型的值仍未解决。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-typeconversion"><a class="anchor" href="#mvc-ann-typeconversion"></a>类型转换</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-typeconversion">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>表示一些注解的控制器方法的参数<code>String</code>基于请求输入（如<code>@RequestParam</code> ， <code>@RequestHeader</code> ， <code>@PathVariable</code> ， <code>@MatrixVariable</code>和<code>@CookieValue</code> ）可能需要类型转换如果参数被声明为比其它东西<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>对于此类情况，将根据配置的转换器自动应用类型转换。默认情况下，支持简单类型（ <code>int</code> ， <code>long</code> ， <code>Date</code>和其他）。您可以通过<code>WebDataBinder</code>自定义类型转换（请参阅<a href="#mvc-ann-initbinder">使用<code>DataBinder</code></a> ）或使用<code>FormattingConversionService</code>注册<code>Formatters</code> 。请参见<a href="core.html#format">Spring Field Formatting</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-matrix-variables"><a class="anchor" href="#mvc-ann-matrix-variables"></a>矩阵变量</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-matrix-variables">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a>讨论了路径段中的名称 - 值对。在Spring MVC中，我们将那些基于Tim Berners-Lee的<a href="http://www.w3.org/DesignIssues/MatrixURIs.html">“旧帖子”</a>称为“矩阵变量”，但它们也可以称为URI路径参数。</p>
</div>
<div class="paragraph">
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔（例如， <code>/cars;color=red,green;year=2012</code> ）。也可以通过重复的变量名称指定多个值（例如， <code>color=red;color=green;color=blue</code> ）。</p>
</div>
<div class="paragraph">
<p>如果URL预计包含矩阵变量，则控制器方法的请求映射必须使用URI变量来屏蔽该变量内容，并确保请求可以成功匹配，而与矩阵变量顺序和存在无关。以下示例使用矩阵变量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / pets / 42; q = 11; r = 22</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">String</span> petId， <span class="annotation">@ MatrixVariable</span> <span class="type">int</span> q）{ <span class="comment">// petId == 42</span> <span class="comment">// q == 11</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>鉴于所有路径段都可能包含矩阵变量，您有时可能需要消除矩阵变量预期所在的路径变量的歧义。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / owners / 42; q = 11 / pets / 21; q = 22</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@MatrixVariable</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， pathVar = <span class="string"><span class="delimiter">“</span> <span class="content">ownerId</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> q1， <span class="annotation">@ MatrixVariable</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ，pathVar = <span class="string"><span class="delimiter">“</span> <span class="content">petId</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> q2）{ <span class="comment">// q1 == 11</span> <span class="comment">// q2 == 22</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>矩阵变量可以定义为可选，并指定默认值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / pets / 42</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@MatrixVariable</span> （required = <span class="predefined-constant">false</span> ，defaultValue = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> q）{ <span class="comment">// q == 1</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要获取所有矩阵变量，可以使用<code>MultiValueMap</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / owners / 42; q = 11; r = 12 / pets / 21; q = 22; s = 23</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@ MatrixVariable</span> MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; matrixVars， <span class="annotation">@ MatrixVariable</span> （pathVar = <span class="string"><span class="delimiter">“</span> <span class="content">petId</span> <span class="delimiter">”</span></span> ）MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; petMatrixVars）{ <span class="comment">// matrixVars：[“q”：[11,22]，“r”：12，“s “：23]</span> <span class="comment">// petMatrixVars：[”q“：22，”s“：23]</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您需要启用矩阵变量的使用。在MVC Java配置中，您需要通过<a href="#mvc-config-path-matching">路径匹配将</a> <code>removeSemicolonContent=false</code>设置为<code>UrlPathHelper</code> 。在MVC XML命名空间中，您可以设置<code>&lt;mvc:annotation-driven enable-matrix-variables="true"/&gt;</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestparam"><a class="anchor" href="#mvc-ann-requestparam"></a>使用<code>@RequestParam</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestparam">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestParam</code>批注将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">EditPetForm</span> { <span class="comment">// ...</span>

    <span class="annotation">@GetMapping</span> <span class="directive">public</span> <span class="predefined-type">String</span> setupForm（ <strong><span class="annotation">@RequestParam</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">petId</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> petId</strong> ，Model model）{ <i class="conum" data-value="1"></i> <b>（1）</b> Pet pet = <span class="local-variable">this</span> .clinic.loadPet（petId）; model.addAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ，pet）; <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">petForm</span> <span class="delimiter">”</span></span> ; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestParam</code>绑定<code>petId</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，需要使用此批注的方法参数，但您可以通过将<code>@RequestParam</code>批注的<code>required</code>标志设置为<code>false</code>或通过使用<code>java.util.声明参数来指定方法参数是可选的<code>java.util.Optional</code>包装。</p>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是<code>String</code>则会自动应用类型转换。请参阅<a href="#mvc-ann-typeconversion">类型转换</a> 。</p>
</div>
<div class="paragraph">
<p>当<code>@RequestParam</code>注释声明为<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>参数时，将使用所有请求参数填充映射。</p>
</div>
<div class="paragraph">
<p>请注意，使用<code>@RequestParam</code>是可选的（例如，设置其属性）。默认情况下，任何一个简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）并且不被任何其他参数解析器解析，都被视为使用<code>@RequestParam</code>进行注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestheader"><a class="anchor" href="#mvc-ann-requestheader"></a>使用<code>@RequestHeader</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestheader">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestHeader</code>批注将请求标头绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>考虑以下请求，标题为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>主机localhost：8080接受text / html，application / xhtml + xml，application / xml; q = 0.9 Accept-Language fr，en-gb; q = 0.7，en; q = 0.3 Accept-Encoding gzip，deflate Accept-Charset ISO -8859-1，utf-8; q = 0.7，*; q = 0.7 Keep-Alive 300</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code>标头的值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ demo</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@RequestHeader</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Accept-Encoding</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">字符串</span>编码， <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@RequestHeader</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Keep-Alive</span> <span class="delimiter">”</span></span> ） <span class="type">long</span> keepAlive）{ <i class="conum" data-value="2"></i> <b>（2）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>获取<code>Accept-Encoding</code>标头的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获取<code>Keep-Alive</code>标头的值。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是<code>String</code> ，则会自动应用类型转换。请参阅<a href="#mvc-ann-typeconversion">类型转换</a> 。</p>
</div>
<div class="paragraph">
<p>在<code>Map&lt;String, String&gt;</code> ， <code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用<code>@RequestHeader</code>注释时，将使用所有标头值填充映射。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型。例如，使用<code>@RequestHeader("Accept")</code>注释的方法参数可以是<code>String</code>类型，也可以是<code>String[]</code>或<code>List&lt;String&gt;</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-cookievalue"><a class="anchor" href="#mvc-ann-cookievalue"></a>使用<code>@CookieValue</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-cookievalue">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@CookieValue</code>批注将HTTP cookie的值绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>考虑使用以下cookie的请求：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>JSESSIONID = 415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何获取cookie值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ demo</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@CookieValue</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">JSESSIONID</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> cookie）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>获取<code>JSESSIONID</code> cookie的值。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是<code>String</code> ，则自动应用类型转换。请参阅<a href="#mvc-ann-typeconversion">类型转换</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-modelattrib-method-args"><a class="anchor" href="#mvc-ann-modelattrib-method-args"></a>使用<code>@ModelAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-modelattrib-method-args">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以在方法参数上使用<code>@ModelAttribute</code>批注来从模型访问属性，或者如果不存在则将其实例化。model属性还覆盖了名称与字段名称匹配的HTTP Servlet请求参数的值。这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> processSubmit（ <span class="annotation">@ModelAttribute</span> Pet pet）{} <i class="conum" data-value="1"></i> <b>（1）</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>绑定一个<code>Pet</code>的实例。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的<code>Pet</code>实例解析如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果已经使用<a href="#mvc-ann-modelattrib-methods">Model</a>添加了<a href="#mvc-ann-modelattrib-methods">模型</a> 。</p>
</li>
<li>
<p><a href="#mvc-ann-sessionattributes">使用<code>@SessionAttributes</code></a>从HTTP会话。</p>
</li>
<li>
<p>从通过<code>Converter</code>的URI路径变量（参见下一个示例）。</p>
</li>
<li>
<p>从默认构造函数的调用。</p>
</li>
<li>
<p>从调用具有与Servlet请求参数匹配的参数的“主构造函数”。参数名称通过JavaBeans <code>@ConstructorProperties</code>或字节码中的运行时保留参数名称确定。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然通常使用<a href="#mvc-ann-modelattrib-methods">Model</a>来使用属性填充模型，但另一种替代方法是依赖于<code>Converter&lt;String, T&gt;</code>和URI路径变量约定。在下面的例子中，模型的属性的名称， <code>account</code> ，匹配URI的路径变量， <code>account</code>和<code>Account</code>通过使加载<code>String</code>帐号通过注册<code>Converter&lt;String, Account&gt;</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PutMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts / {account}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> save（ <span class="annotation">@ModelAttribute</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">account</span> <span class="delimiter">”</span></span> ）Account account）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>获取模型属性实例后，将应用数据绑定。<code>WebDataBinder</code>类将Servlet请求参数名称（查询参数和表单字段）与目标<code>Object</code>上的字段名称进行匹配。必要时，在应用类型转换后填充匹配字段。有关数据绑定（和验证）的更多信息，请参阅<a href="core.html#validation">验证</a> 。有关自定义数据绑定的更多信息，请参阅<a href="#mvc-ann-initbinder">使用<code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>数据绑定可能导致错误。默认情况下，会引发<code>BindException</code> 。但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加一个<code>BindingResult</code>参数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> processSubmit（ <span class="annotation">@ModelAttribute</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ）Pet pet，BindingResult result）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="keyword">if</span> （result.hasErrors（））{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">petForm</span> <span class="delimiter">”</span></span> ; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在<code>@ModelAttribute</code>旁边添加<code>BindingResult</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望在没有数据绑定的情况下访问模型属性。对于这种情况，您可以将<code>Model</code>注入控制器并直接访问它，或者设置<code>@ModelAttribute(binding=false)</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span> <span class="directive">public</span> AccountForm setUpForm（）{ <span class="keyword">return</span> <span class="keyword">new</span> AccountForm（）; } <span class="annotation">@ModelAttribute</span> <span class="directive">public</span> Account findAccount（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> accountId）{ <span class="keyword">return</span> accountRepository.findOne（accountId）; } <span class="annotation">@PostMapping（</span> <span class="string"><span class="delimiter">“</span> <span class="content">更新</span> <span class="delimiter">”）</span></span> <span class="directive">公共</span> <span class="predefined-type">字符串</span>更新<span class="annotation">（@Valid</span> AccountUpdateForm形式，BindingResult结果<span class="annotation">，@ModelAttribute（</span>绑定= <span class="predefined-constant">假</span> ）的帐户的帐户）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>设置<code>@ModelAttribute(binding=false)</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过添加<code>javax.validation.在数据绑定后自动应用验证<code>javax.validation.Valid</code>注释或Spring的<code>@Validated</code>注释（ee <a href="core.html#validation-beanvalidation">Bean验证</a>和<a href="core.html#validation">Spring验证</a> ）。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> processSubmit（ <span class="annotation">@Valid</span> <span class="annotation">@ModelAttribute</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ）Pet pet，BindingResult result）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="keyword">if</span> （result.hasErrors（））{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">petForm</span> <span class="delimiter">”</span></span> ; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>验证<code>Pet</code>实例。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，使用<code>@ModelAttribute</code>是可选的（例如，设置其属性）。默认情况下，任何不是简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）并且未被任何其他参数解析器解析的参数都被视为使用<code>@ModelAttribute</code>进行注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-sessionattributes"><a class="anchor" href="#mvc-ann-sessionattributes"></a>使用<code>@SessionAttributes</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-sessionattributes">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code>用于在请求之间的HTTP Servlet会话中存储模型属性。它是一个类型级别的注释，用于声明特定控制器使用的会话属性。这通常列出模型属性的名称或模型属性的类型，这些属性应该透明地存储在会话中以供后续访问请求使用。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@SessionAttributes</code>注释：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@SessionAttributes</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">EditPetForm</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@SessionAttributes</code>注释。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在第一个请求中，当名称为<code>pet</code>的模型属性添加到模型中时，它会自动提升并保存在HTTP Servlet会话中。它保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@SessionAttributes</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">EditPetForm</span> { <span class="comment">// ...</span>

    <span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（Pet pet，BindingResult errors，SessionStatus status）{ <span class="keyword">if</span> （errors.hasErrors）{ <span class="comment">// ...</span>} status.setComplete（）; <span class="comment">// ...</span>}}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从存储中清除<code>Pet</code>值。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-sessionattribute"><a class="anchor" href="#mvc-ann-sessionattribute"></a>使用<code>@SessionAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-sessionattribute">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>如果您需要访问全局管理的预先存在的会话属性（即，在控制器外部 - 例如，通过过滤器）并且可能存在或不存在，则可以对方法参数使用<code>@SessionAttribute</code>批注，如以下示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@SessionAttribute</span> User user）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@SessionAttribute</code>批注。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>对于需要添加或删除会话属性的用例，请考虑注入<code>org.springframework.web.context.request.WebRequest</code>或<code>javax.servlet.http.HttpSession</code>进入控制器方法。</p>
</div>
<div class="paragraph">
<p>为模型的临时存储在会话作为控制器工作流的一部分的属性，可以考虑使用<code>@SessionAttributes</code>如描述<a href="#mvc-ann-sessionattributes">使用<code>@SessionAttributes</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestattrib"><a class="anchor" href="#mvc-ann-requestattrib"></a>使用<code>@RequestAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestattrib">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>与<code>@SessionAttribute</code>类似，您可以使用<code>@RequestAttribute</code>批注来访问先前创建的预先存在的请求属性（例如，通过Servlet <code>Filter</code>或<code>HandlerInterceptor</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@RequestAttribute</span> Client client）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestAttribute</code>批注。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-redirecting-passing-data"><a class="anchor" href="#mvc-redirecting-passing-data"></a>重定向属性</h5>
<div class="paragraph">
<p>默认情况下，所有模型属性都被视为在重定向URL中公开为URI模板变量。在其余属性中，原始类型或集合或基本类型数组的属性会自动附加为查询参数。</p>
</div>
<div class="paragraph">
<p>如果专门为重定向准备了模型实例，则将原始类型属性作为查询参数附加可以是期望的结果。但是，在带注释的控制器中，模型可以包含为渲染目的而添加的其他属性（例如，下拉字段值）。为了避免在URL中出现此类属性的可能性，@ <code>@RequestMapping</code>方法可以声明<code>RedirectAttributes</code>类型的参数，并使用它来指定可供<code>RedirectView</code>使用的确切属性。如果方法重定向，则使用<code>RedirectAttributes</code>的内容。否则，使用模型的内容。</p>
</div>
<div class="paragraph">
<p><code>RequestMappingHandlerAdapter</code>提供了一个名为<code>ignoreDefaultModelOnRedirect</code>的标志，您可以使用该标志指示如果控制器方法重定向，则永远不应使用默认<code>Model</code>的内容。相反，控制器方法应声明<code>RedirectAttributes</code>类型的属性，如果不这样做，则不应将任何属性传递给<code>RedirectView</code> 。MVC命名空间和MVC Java配置都将此标志设置为<code>false</code> ，以保持向后兼容性。但是，对于新应用程序，我们建议将其设置为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，在展开重定向URL时，当前请求中的URI模板变量会自动可用，您需要通过<code>Model</code>或<code>RedirectAttributes</code>显式添加它们。以下示例显示如何定义重定向：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ files / {path}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> upload（...）{ <span class="comment">// ......</span>
    <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">redirect：files / {path}</span> <span class="delimiter">”</span></span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将数据传递到重定向目标的另一种方法是使用flash属性。与其他重定向属性不同，Flash属性保存在HTTP会话中（因此，不会出现在URL中）。有关更多信息，请参阅<a href="#mvc-flash-attributes">Flash属性</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-flash-attributes"><a class="anchor" href="#mvc-flash-attributes"></a> Flash属性</h5>
<div class="paragraph">
<p>Flash属性为一个请求提供了一种存储打算在另一个请求中使用的属性的方法。重定向时最常需要这种方法 - 例如，Post-Redirect-Get模式。Flash重定向（通常在会话中）之前临时保存Flash属性，以便在重定向后使请求可用，并立即删除。</p>
</div>
<div class="paragraph">
<p>Spring MVC有两个主要的抽象支持flash属性。<code>FlashMap</code>用于保存Flash属性，而<code>FlashMapManager</code>用于存储，检索和管理<code>FlashMap</code>实例。</p>
</div>
<div class="paragraph">
<p>Flash属性支持始终处于“打开”状态，无需显式启用。但是，如果不使用，它永远不会导致HTTP会话创建。在每个请求中，都有一个“输入” <code>FlashMap</code>其中包含从先前请求（如果有）传递的属性，以及一个“输出” <code>FlashMap</code>其中包含要为后续请求保存的属性。这两个<code>FlashMap</code>实例是通过静态方法从Spring MVC中的任何地方访问<code>RequestContextUtils</code> 。</p>
</div>
<div class="paragraph">
<p>带注释的控制器通常不需要直接使用<code>FlashMap</code> 。相反，@ <code>@RequestMapping</code>方法可以接受<code>RedirectAttributes</code>类型的参数，并使用它为重定向方案添加flash属性。通过<code>RedirectAttributes</code>添加的Flash属性会自动传播到“输出”FlashMap。同样，在重定向之后，“输入” <code>FlashMap</code>中的属性会自动添加到为目标URL提供服务的控制器的<code>Model</code>中。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">匹配闪存属性的请求</div>
<div class="paragraph">
<p>Flash属性的概念存在于许多其他Web框架中，并且已经证明有时会暴露于并发问题。这是因为，根据定义，闪存属性将被存储直到下一个请求。但是，非常“下一个”请求可能不是预期的接收者而是另一个异步请求（例如，轮询或资源请求），在这种情况下，过早删除flash属性。</p>
</div>
<div class="paragraph">
<p>为了减少此类问题的可能性， <code>RedirectView</code>使用目标重定向URL的路径和查询参数自动“标记” <code>FlashMap</code>实例。反过来，默认的<code>FlashMapManager</code>在查找“输入” <code>FlashMap</code>时将该信息与传入请求进行匹配。</p>
</div>
<div class="paragraph">
<p>这并不能完全消除并发问题的可能性，但会使用重定向URL中已有的信息大大减少并发问题。因此，我们建议您主要使用Flash属性进行重定向方案。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-multipart-forms"><a class="anchor" href="#mvc-multipart-forms"></a>多</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-multipart-forms">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="#mvc-multipart">启用</a> <code>MultipartResolver</code>后，将解析具有<code>multipart/form-data</code>的POST请求的内容，并将其作为常规请求参数进行访问。以下示例访问一个常规表单字段和一个上载文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">FileUploadController</span> { <span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ form</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handleFormUpload（ <span class="annotation">@RequestParam</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> name，@ <span class="annotation">RequestParam</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">file</span> <span class="delimiter">”</span></span> ）MultipartFile file）{ <span class="keyword">if</span> （！file.isEmpty（））{ <span class="type">byte</span> <span class="type">[]</span> bytes = file.getBytes（）; <span class="comment">//将字节存储在某处</span> <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">redirect：uploadSuccess</span> <span class="delimiter">”</span></span> ; } <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">redirect：uploadFailure</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用Servlet 3.0多部分解析时，也可以使用<code>javax.servlet.http.Part</code> ，而不是Spring的<code>MultipartFile</code> ，作为方法参数</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以将多部分内容用作绑定到<a href="#mvc-ann-modelattrib-method-args">命令对象</a>的数据的一部分。例如，前面示例中的表单字段和文件可以是表单对象上的字段，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyForm</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私有的</span> MultipartFile文件; <span class="comment">// ...</span>} <span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">FileUploadController</span> { <span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ form</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handleFormUpload（MyForm form，BindingResult errors）{ <span class="keyword">if</span> （！）form.getFile（）。isEmpty（））{ <span class="type">byte</span> <span class="type">[]</span> bytes = form.getFile（）。getBytes（）; <span class="comment">//将字节存储在某处</span> <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">redirect：uploadSuccess</span> <span class="delimiter">”</span></span> ; } <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">redirect：uploadFailure</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还可以在RESTful服务方案中从非浏览器客户端提交多部分请求。以下示例显示了带有JSON的文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>POST / someUrl Content-Type：multipart / mixed --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition：form-data; name =“meta-data”Content-Type：application / json; charset = UTF-8 Content-Transfer-Encoding：8bit {“name”：“value”} --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition：form-data; NAME =“文件的数据”; filename =“file.properties”Content-Type：text / xml Content-Transfer-Encoding：8bit ...档案数据......</pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestParam</code>作为<code>String</code>访问“元数据”部分，但您可能希望它从JSON反序列化（类似于<code>@RequestBody</code> ）。在使用<a href="integration.html#rest-message-conversion">HttpMessageConverter</a>转换后，使用<code>@RequestPart</code>批注访问多部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <strong><span class="annotation">@RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">meta-data</span> <span class="delimiter">”</span></span> ）MetaData元数据，@ <span class="annotation">RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">file-data</span> <span class="delimiter">”</span></span> ）MultipartFile文件</strong> ）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以将<code>@RequestPart</code>与<code>javax.validation.结合使用<code>javax.validation.Valid</code>或使用Spring的<code>@Validated</code>注释，这两种注释都会导致应用标准Bean验证。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code> ，并将其转换为400（BAD_REQUEST）响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <strong><span class="annotation">@Valid</span></strong> <span class="annotation">@RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">meta-data</span> <span class="delimiter">”</span></span> ）MetaData元数据， <strong>BindingResult结果</strong> ）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestbody"><a class="anchor" href="#mvc-ann-requestbody"></a>使用<code>@RequestBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestbody">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestBody</code>批注通过<a href="integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>将请求主体读取并反序列化为<code>Object</code> 。以下示例使用<code>@RequestBody</code>参数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@RequestBody</span> Account account）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<a href="#mvc-config">MVC配置</a>的“ <a href="#mvc-config-message-converters">消息转换器”</a>选项来配置或自定义消息转换。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@RequestBody</code>与<code>javax.validation.结合使用<code>javax.validation.Valid</code>或Spring的<code>@Validated</code>注释，这两个注释都会导致应用标准Bean验证。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code> ，并将其转换为400（BAD_REQUEST）响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@Valid</span> <span class="annotation">@RequestBody</span> Account account，BindingResult result）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-httpentity"><a class="anchor" href="#mvc-ann-httpentity"></a> HttpEntity</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-httpentity">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code>与<a href="#mvc-ann-requestbody">使用<code>@RequestBody</code></a>或多或少相同，但基于公开请求标头和正文的容器对象。以下清单显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（HttpEntity &lt;Account&gt; entity）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-responsebody"><a class="anchor" href="#mvc-ann-responsebody"></a>使用<code>@ResponseBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-responsebody">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以在方法上使用<code>@ResponseBody</code>批注，以通过<a href="integration.html#rest-message-conversion">HttpMessageConverter</a>将返回序列化到响应主体。以下清单显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts / {id}</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ResponseBody</span> <span class="directive">公共</span>帐户句柄（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类级别也支持<code>@ResponseBody</code> ，在这种情况下，它由所有控制器方法继承。这是<code>@RestController</code>的效果，它只不过是一个用<code>@Controller</code>和<code>@ResponseBody</code>标记的元注释。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@ResponseBody</code>与反应类型一起使用。有关更多详细信息， <a href="#mvc-ann-async">请</a>参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-reactive-types">活动类型</a> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="#mvc-config">MVC配置</a>的“ <a href="#mvc-config-message-converters">消息转换器”</a>选项来配置或自定义消息转换。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@ResponseBody</code>方法与JSON序列化视图结合使用。有关详细信息，请参阅<a href="#mvc-ann-jackson">Jackson JSON</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-responseentity"><a class="anchor" href="#mvc-ann-responseentity"></a> ResponseEntity</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-responseentity">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code>与<a href="#mvc-ann-responsebody">使用<code>@ResponseBody</code></a>或多或少相同，但基于指定请求标头和正文的容器对象。以下清单显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ something</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">String</span> &gt; handle（）{ <span class="comment">// ...</span>
    <span class="predefined-type">URI</span>位置= ...; <span class="keyword">return</span> ResponseEntity.created（location）.build（）; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-jackson"><a class="anchor" href="#mvc-ann-jackson"></a>杰克逊JSON</h5>
<div class="paragraph">
<p>Spring为Jackson JSON库提供支持。</p>
</div>
<div class="sect5">
<h6 id="mvc-ann-jsonview"><a class="anchor" href="#mvc-ann-jsonview"></a>杰克逊序列化观点</h6>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-jsonview">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC为<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson的序列化视图</a>提供内置支持，允许仅渲染<code>Object</code>中所有字段的子集。要将其与<code>@ResponseBody</code>或<code>ResponseEntity</code>控制器方法一起使用，您可以使用Jackson的<code>@JsonView</code>批注来激活序列化视图类，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">UserController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ user</span> <span class="delimiter">”</span></span> ） <span class="annotation">@JsonView</span> （User。WithoutPasswordView.class） <span class="directive">public</span> User getUser（）{ <span class="keyword">return</span> <span class="keyword">new</span> User（ <span class="string"><span class="delimiter">“</span> <span class="content">eric</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">7！jd＃h23</span> <span class="delimiter">“</span></span> ）;}} <span class="directive">public</span> <span class="type">class</span> <span class="class">User</span> { <span class="directive">public</span> <span class="type">interface</span> <span class="class">WithoutPasswordView</span> {}; <span class="directive">public</span> <span class="type">interface</span> <span class="class">WithPasswordView</span> <span class="directive">extends</span> WithoutPasswordView {}; <span class="directive">private</span> <span class="predefined-type">String</span> username; <span class="directive">private</span> <span class="predefined-type">String</span> password; <span class="directive">public</span> User（）{} <span class="directive">public</span> User（ <span class="predefined-type">String</span> username， <span class="predefined-type">String</span> password）{ <span class="local-variable">this</span> .username = username; <span class="local-variable">this</span> .password = password;} <span class="annotation">@JsonView</span> （WithoutPasswordView.class） <span class="directive">public</span> <span class="predefined-type">String</span> getUsername（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .username;} <span class="annotation">@JsonView</span> （WithPasswordView.class） <span class="directive">public</span> <span class="predefined-type">String</span> getPassword（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .password; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@JsonView</code>允许一组视图类，但每个控制器方法只能指定一个。如果需要激活多个视图，可以使用复合接口。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于依赖于视图分辨率的控制器，可以将序列化视图类添加到模型中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">UserController</span> <span class="directive">扩展</span> AbstractController { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ user</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> getUser（Model model）{model.addAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> User（ <span class="string"><span class="delimiter">“</span> <span class="content">eric</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">7！jd＃h23</span> <span class="delimiter">“</span></span> ））; model.addAttribute（JsonView.class.getName（），User。WithoutPasswordView.class）; <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">userView</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-modelattrib-methods"><a class="anchor" href="#mvc-ann-modelattrib-methods"></a> 1.3.4。模型</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-modelattrib-methods">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ModelAttribute</code>注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在<code>@RequestMapping</code>方法中的<a href="#mvc-ann-modelattrib-method-args">方法参数</a> ，用于从模型创建或访问<code>Object</code>并通过<code>WebDataBinder</code>将其绑定到请求。</p>
</li>
<li>
<p>作为<code>@Controller</code>或<code>@ControllerAdvice</code>类中的方法级注释，有助于在任何<code>@RequestMapping</code>方法调用之前初始化模型。</p>
</li>
<li>
<p>在<code>@RequestMapping</code>方法上标记其返回值是一个模型属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节讨论<code>@ModelAttribute</code>方法 - 前面列表中的第二项。控制器可以包含任意数量的<code>@ModelAttribute</code>方法。在同一控制器中的<code>@RequestMapping</code>方法之前调用所有这些方法。<code>@ModelAttribute</code>方法也可以通过<code>@ControllerAdvice</code>在控制器之间共享。有关更多详细信息，请参阅<a href="#mvc-ann-controller-advice">控制器建议</a>部分。</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。它们支持许多与<code>@RequestMapping</code>方法相同的参数，但<code>@ModelAttribute</code>本身或与请求体相关的任何内容除外。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@ModelAttribute</code>方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span> <span class="directive">public</span> <span class="type">void</span> populateModel（ <span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number，Model model）{model.addAttribute（accountRepository.findAccount（number））; <span class="comment">//添加更多......</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例仅添加一个属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span> <span class="directive">public</span> account addAccount（ <span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number）{ <span class="keyword">return</span> accountRepository.findAccount（number）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未明确指定名称，则会根据<code>Object</code>类型选择默认名称，如Javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a> 。您始终可以使用重载的<code>addAttribute</code>方法或<code>@ModelAttribute</code>上的<code>name</code>属性（返回值）来指定显式名称。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以使用<code>@ModelAttribute</code>作为一个方法级别注解<code>@RequestMapping</code>方法，在这种情况下的返回值<code>@RequestMapping</code>方法被解释为一个模型属性。这通常不是必需的，因为它是HTML控制器中的默认行为，除非返回值是否则将被解释为视图名称的<code>String</code> （另请参见<a href="#mvc-coc-r2vnt">[mvc-coc-r2vnt]</a> ）。<code>@ModelAttribute</code>还可以帮助自定义模型属性名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping（</span> <span class="string"><span class="content"><span class="delimiter">“/</span>帐号/（编号<span class="delimiter"><span class="annotation">）”）@ModelAttribute（</span></span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">我的帐户</span> <span class="delimiter">”）</span></span> <span class="directive">公共</span>账户手柄<span class="comment">（）{// ...</span>
    <span class="keyword">退货</span>帐户; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-initbinder"><a class="anchor" href="#mvc-ann-initbinder"></a> 1.3.5。使用<code>DataBinder</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-initbinder">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>或<code>@ControllerAdvice</code>类可以使用<code>@InitBinder</code>方法初始化<code>WebDataBinder</code>实例，而这些方法又可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将请求参数（即表单或查询数据）绑定到模型对象。</p>
</li>
<li>
<p>将基于字符串的请求值（例如请求参数，路径变量，标题，cookie等）转换为目标类型的控制器方法参数。</p>
</li>
<li>
<p>在呈现HTML表单时将模型对象值格式化为<code>String</code>值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法可以注册特定于控制器的<code>java.bean.PropertyEditor</code>或Spring <code>Converter</code>和<code>Formatter</code>组件。此外，您可以使用<a href="#mvc-config-conversion">MVC配置</a>在全局共享的<code>FormattingConversionService</code>注册<code>Converter</code>和<code>Formatter</code>类型。</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法支持许多与<code>@RequestMapping</code>方法相同的参数，但<code>@ModelAttribute</code> （命令对象）参数除外。通常，它们使用<code>WebDataBinder</code>参数（用于注册）和<code>void</code>返回值声明。以下清单显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">FormController</span> { <span class="annotation">@InitBinder</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> initBinder（WebDataBinder binder）{ <span class="predefined-type">SimpleDateFormat</span> dateFormat = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd</span> <span class="delimiter">”</span></span> ）; dateFormat.setLenient（ <span class="predefined-constant">false</span> ）; binder.registerCustomEditor（ <span class="predefined-type">Date</span> .class， <span class="keyword">new</span> CustomDateEditor（dateFormat， <span class="predefined-constant">false</span> ））; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>定义<code>@InitBinder</code>方法。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，当您通过共享的<code>FormattingConversionService</code>使用基于<code>Formatter</code>的设置时，您可以重复使用相同的方法并注册特定于控制器的<code>Formatter</code>实现，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">FormController</span> { <span class="annotation">@InitBinder</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">protected</span> <span class="type">void</span> initBinder（WebDataBinder binder）{binder.addCustomFormatter（ <span class="keyword">new</span> <span class="predefined-type">DateFormatter</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd</span> <span class="delimiter">”</span></span> ））; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在自定义格式化程序上定义<code>@InitBinder</code>方法。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-exceptionhandler"><a class="anchor" href="#mvc-ann-exceptionhandler"></a> 1.3.6。例外</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-controller-exceptions">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>和<a href="#mvc-ann-controller-advice">@ControllerAdvice</a>类可以使用<code>@ExceptionHandler</code>方法来处理来自控制器方法的异常，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleController</span> { <span class="comment">// ...</span>

    <span class="annotation">@ExceptionHandler</span> <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">String</span> &gt; handle（ <span class="exception">IOException</span> ex）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该异常可能与传播的顶级异常（即抛出直接<code>IOException</code> ）或顶级包装器异常中的直接原因（例如，包含在<code>IllegalStateException</code>内的<code>IOException</code> ）相<code>IllegalStateException</code> 。</p>
</div>
<div class="paragraph">
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常优先于原因异常匹配。更具体地说， <code>ExceptionDepthComparator</code>用于根据抛出的异常类型的深度对异常进行排序。</p>
</div>
<div class="paragraph">
<p>或者，注释声明可以缩小要匹配的异常类型，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExceptionHandler</span> （{FileSystemException.class， <span class="exception">RemoteException</span> .class}） <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">String</span> &gt; handle（ <span class="exception">IOException</span> ex）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您甚至可以使用具有非常通用参数签名的特定异常类型列表，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExceptionHandler</span> （{FileSystemException.class， <span class="exception">RemoteException</span> .class}） <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">String</span> &gt; handle（ <span class="exception">Exception</span> ex）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根和原因异常匹配之间的区别可能是令人惊讶的。</p>
</div>
<div class="paragraph">
<p>在前面显示的<code>IOException</code>变体中，通常使用实际的<code>FileSystemException</code>或<code>RemoteException</code>实例作为参数调用该方法，因为它们都是从<code>IOException</code>扩展的。但是，如果任何此类匹配异常在包装器异常内传播，而该异常本身就是<code>IOException</code> ，则传入的异常实例就是包装器异常。</p>
</div>
<div class="paragraph">
<p>在<code>handle(Exception)</code>变体中，行为更简单。这总是在包装场景中使用包装器异常调用，在这种情况下可以通过<code>ex.getCause()</code>找到实际匹配的异常。传入的异常仅在实际的<code>FileSystemException</code>或<code>RemoteException</code>实例被抛出为顶级异常时才会发生。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们通常建议您在参数签名中尽可能具体，减少root和cause异常类型之间不匹配的可能性。考虑将多匹配方法分解为单独的<code>@ExceptionHandler</code>方法，每个方法通过其签名匹配单个特定异常类型。</p>
</div>
<div class="paragraph">
<p>在多<code>@ControllerAdvice</code>安排，我们建议在声明你的主要根异常映射<code>@ControllerAdvice</code>有一个相应的订单优先。虽然根异常匹配优先于某个原因，但这是在给定控制器或<code>@ControllerAdvice</code>类的方法中定义的。这意味着优先级较高的<code>@ControllerAdvice</code> bean上的原因匹配优先于较低优先级的<code>@ControllerAdvice</code> bean上的任何匹配（例如，root）。</p>
</div>
<div class="paragraph">
<p>最后但同样重要的是， <code>@ExceptionHandler</code>方法实现可以选择通过以原始形式重新抛出它来退出处理给定的异常实例。这在您仅对根级别匹配或在特定上下文中无法静态确定的匹配中感兴趣的情况下非常有用。重新抛出的异常通过剩余的解析链传播，就好像给定的<code>@ExceptionHandler</code>方法首先不匹配一样。</p>
</div>
<div class="paragraph">
<p>Spring MVC中对<code>@ExceptionHandler</code>方法的支持是基于<code>DispatcherServlet</code>级别的<a href="#mvc-exceptionhandlers">HandlerExceptionResolver</a>机制<a href="#mvc-exceptionhandlers">构建的</a> 。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-exceptionhandler-args"><a class="anchor" href="#mvc-ann-exceptionhandler-args"></a>方法参数</h5>
<div class="paragraph">
<p><code>@ExceptionHandler</code>方法支持以下参数：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">例外类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问引发的异常。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问引发异常的控制器方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebRequest</code> ， <code>NativeWebRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无需直接使用Servlet API即可访问请求参数以及请求和会话属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的javax.servlet。ServletRequest</code> ， <code>javax.servlet.ServletResponse的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择任何特定的请求或响应类型（例如， <code>ServletRequest</code>或<code>HttpServletRequest</code>或Spring的<code>MultipartRequest</code>或<code>MultipartHttpServletRequest</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http包。HttpSession中</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制进行会话。因此，这样的论证永远不会是<code>null</code> 。<br>请注意，会话访问不是线程安全的。如果允许多个请求同时访问会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为<code>true</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security。主要</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code>实现类。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>列举HTTPMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。语言环境</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前请求区域设置，由最具体的<code>LocaleResolver</code>确定 - 实际上是已配置的<code>LocaleResolver</code>或<code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。TimeZone</code> ， <code>java.time.了zoneid</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.OutputStream</code> ， <code>java.io.作家</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问原始响应主体，由Servlet API公开。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。Map</code> ， <code>org.springframework.ui.Model</code> ， <code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问模型以获取错误响应。总是空着</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedirectAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定在重定向的情况下使用的属性 - （将附加到查询字符串）和临时存储的flash属性，直到重定向后的请求为止。请参阅<a href="#mvc-redirecting-passing-data">重定向属性</a>和<a href="#mvc-flash-attributes">Flash属性</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问任何会话属性，与由于类级别<code>@SessionAttributes</code>声明而存储在会话中的模型属性相反。有关更多详细信息，请参阅<a href="#mvc-ann-sessionattribute">使用<code>@SessionAttribute</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求属性。有关更多详细信息，请参阅<a href="#mvc-ann-requestattrib">使用<code>@RequestAttribute</code></a> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-exceptionhandler-return-values"><a class="anchor" href="#mvc-ann-exceptionhandler-return-values"></a>返回值</h5>
<div class="paragraph">
<p><code>@ExceptionHandler</code>方法支持以下返回值：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值通过<code>HttpMessageConverter</code>实例转换并写入响应。请参阅<a href="#mvc-ann-responsebody">使用<code>@ResponseBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code> ， <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值指定通过<code>HttpMessageConverter</code>实例转换完整响应（包括HTTP标头和正文）并写入响应。请参阅<a href="#mvc-ann-responseentity">ResponseEntity</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>串</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用<code>ViewResolver</code>实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数（如前所述）以编程方式丰富模型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>视图</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数（先前描述）以编程方式丰富模型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。Map</code> ， <code>org.springframework.ui.模型</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要通过<code>RequestToViewNameTranslator</code>隐式确定的视图名称要添加到隐式模型的属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要通过<code>RequestToViewNameTranslator</code>隐式确定的视图名称要添加到模型的属性。
</p><p class="tableblock">请注意，@ <code>@ModelAttribute</code>是可选的。请参阅本表末尾的“任何其他返回值”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ModelAndView</code>对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的视图和模型属性，以及（可选）响应状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>空虚</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有<code>void</code>返回类型（或<code>null</code>返回值）的方法被认为已完全处理响应，如果它还具有<code>ServletResponse</code> ， <code>OutputStream</code>参数或<code>@ResponseStatus</code>注释。如果控制器已进行正<code>ETag</code>或<code>lastModified</code>时间戳检查，则也是如此（有关详细信息，请参阅<a href="#mvc-caching-etag-lastmodified">控制器</a> ）。
</p><p class="tableblock">如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果返回值与上述任何一个不匹配且不是简单类型（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定），则默认情况下，它被视为要添加到模型的模型属性。如果它是一个简单的类型，它仍然没有得到解决。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-rest-exceptions"><a class="anchor" href="#mvc-ann-rest-exceptions"></a> REST API例外</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-rest-exceptions">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>REST服务的一个常见要求是在响应正文中包含错误详细信息。Spring Framework不会自动执行此操作，因为响应正文中的错误详细信息的表示是特定于应用程序的。但是， <code>@RestController</code>可以使用带有<code>ResponseEntity</code>返回值的<code>@ExceptionHandler</code>方法来设置<code>ResponseEntity</code>的状态和正文。这些方法也可以在<code>@ControllerAdvice</code>类中声明，以全局应用它们。</p>
</div>
<div class="paragraph">
<p>在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html"><code>ResponseEntityExceptionHandler</code></a> ，它提供对Spring MVC引发的异常的处理，并提供钩子来定制响应主体。要使用它，请创建<code>ResponseEntityExceptionHandler</code>的子类，使用<code>@ControllerAdvice</code>注释它，覆盖必要的方法，并将其声明为Spring bean。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-controller-advice"><a class="anchor" href="#mvc-ann-controller-advice"></a> 1.3.7。控制器建议</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-controller-advice">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>通常， <code>@InitBinder</code> <code>@ExceptionHandler</code> ， <code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于声明它们的<code>@Controller</code>类（或类层次结构）。如果您希望此类方法更全局地应用（跨控制器），则可以在标有<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>的类中声明它们。</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code>用<code>@Component</code>标记，这意味着可以通过<a href="core.html#beans-java-instantiating-container-scan">组件扫描</a>将这些类注册为Spring bean。
<code>@RestControllerAdvice</code>也是一个用<code>@ControllerAdvice</code>和<code>@ResponseBody</code>标记的元注释，这实际上意味着<code>@ExceptionHandler</code>方法通过消息转换（与视图分辨率或模板渲染相对）呈现给响应主体。</p>
</div>
<div class="paragraph">
<p>在启动时，该基础设施类<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法检测类型的Spring bean的<code>@ControllerAdvice</code> ，然后在运行时应用它们的方法。全球<code>@ExceptionHandler</code>方法（从<code>@ControllerAdvice</code> ）是本地的（从<em>后</em>应用<code>@Controller</code> ）。相比之下，全局<code>@ModelAttribute</code>和<code>@InitBinder</code>方法<em>在</em>本地方法<em>之前</em>应用。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>@ControllerAdvice</code>方法适用于每个请求（即所有控制器），但您可以通过使用注释上的属性将其缩小到控制器的子集，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//使用@RestController注释所有控制器</span> <span class="annotation">@ControllerAdvice</span> （annotations = RestController.class） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice1</span> {} <span class="comment">//定位特定包中的所有控制器</span> <span class="annotation">@ControllerAdvice</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">org.example.controllers</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice2</span> {} <span class="comment">// Target所有可分配给特定类的控制器</span> <span class="annotation">@ControllerAdvice</span> （assignableTypes = {ControllerInterface.class，AbstractController.class}） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice3</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a> Javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-uri-building"><a class="anchor" href="#mvc-uri-building"></a> 1.4。URI链接</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-uri-building">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>本节介绍Spring Framework中可用于处理URI的各种选项。</p>
</div>
<div class="sect3">
<h4 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a> 1.4.1。UriComponents</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>有助于使用变量从URI模板构建URI，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UriComponents uriComponents = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="2"></i> <b>（2）</b> .encode（） <i class="conum" data-value="3"></i> <b>（3）</b> .build（）; <i class="conum" data-value="4"></i> <b>（4）</b> <span class="predefined-type">URI</span> uri = uriComponents.expand（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）。toUri（）; <i class="conum" data-value="5"></i> <b>（5）</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>请求编码URI模板和URI变量。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>建立一个<code>UriComponents</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>展开变量并获取<code>URI</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例可以合并到一个链中，并使用<code>buildAndExpand</code>缩短，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。encode（）。buildAndExpand（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）.toUri（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。build（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您使用完整的URI模板进一步缩短它，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}？q = {q}</span> <span class="delimiter">“</span></span> ）。build（ <span class="string"><span class="delimiter">”</span> <span class="content">威斯汀</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">123</span> <span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a> 1.4.2。UriBuilder</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a>实现了<code>UriBuilder</code> 。您可以使用<code>UriBuilder</code>创建一个<code>UriBuilderFactory</code> 。<code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p>
</div>
<div class="paragraph">
<p>您可以配置<code>RestTemplate</code>和<code>WebClient</code>与<code>UriBuilderFactory</code>自定义的URI的准备。 <code>DefaultUriBuilderFactory</code>是一个缺省的实现的<code>UriBuilderFactory</code>使用<code>UriComponentsBuilder</code>内部和暴露共享配置选项。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何配置<code>RestTemplate</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// import org.springframework.web.util。DefaultUriBuilderFactory。EncodingMode;</span> <span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.org</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）; factory.setEncodingMode（EncodingMode。TEMPLATE_AND_VARIABLES）; RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate（）; restTemplate.setUriTemplateHandler（工厂）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例配置<code>WebClient</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// import org.springframework.web.util。DefaultUriBuilderFactory。EncodingMode;</span> <span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.org</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）; factory.setEncodingMode（EncodingMode。TEMPLATE_AND_VARIABLES）; WebClient客户端= WebClient.builder（）。uriBuilderFactory（工厂）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，您还可以直接使用<code>DefaultUriBuilderFactory</code> 。它类似于使用<code>UriComponentsBuilder</code>但它不是静态工厂方法，而是一个包含配置和首选项的实际实例，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory uriBuilderFactory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）; <span class="predefined-type">URI</span> uri = uriBuilderFactory.uriString（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotels / {hotel}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。build（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a> 1.4.3。URI编码</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder #coding（）</a> ：首先对URI模板进行预编码，然后在扩展时严格编码URI变量。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents #coding（）</a> ：扩展URI变量<em>后</em> <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">对</a> URI组件<em>进行</em>编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个选项都使用转义的八位字节替换非ASCII和非法字符。但是，第一个选项还会替换出现在URI变量中的保留含义的字符。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">考虑“;”，这在路径中是合法的但具有保留意义。第一个选项取代“;”在URI变量中使用“％3B”但在URI模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于大多数情况，第一个选项可能会给出预期结果，因为它将URI变量视为完全编码的不透明数据，而选项2仅在URI变量故意包含保留字符时才有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用第一个选项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotel list / {city}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。encode（）。buildAndExpand（ <span class="string"><span class="delimiter">“</span> <span class="content">New York</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">foo + bar</span> <span class="delimiter">”</span></span> ）.toUri （）; <span class="comment">//结果是“/ hotel％20list / New％20York？Q = FOO％2Bbar”</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotel list / {city}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。build（ <span class="string"><span class="delimiter">“</span> <span class="content">New York</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">foo + bar</span> <span class="delimiter">”</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotel list / {city}？q = {q}</span> <span class="delimiter">“</span></span> ）。build（ <span class="string"><span class="delimiter">”</span> <span class="content">纽约</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">foo + bar</span> <span class="delimiter">“</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>WebClient</code>和<code>RestTemplate</code>通过<code>UriBuilderFactory</code>策略在内部扩展和编码URI模板。两者都可以配置自定义策略。如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）factory.setEncodingMode（EncodingMode。TEMPLATE_AND_VALUES）; <span class="comment">//自定义RestTemplate ..</span>RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate（）; restTemplate.setUriTemplateHandler（工厂）; <span class="comment">//自定义WebClient ..</span>WebClient客户端= WebClient.builder（）。uriBuilderFactory（工厂）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DefaultUriBuilderFactory</code>实现<code>UriComponentsBuilder</code>内部使用<code>UriComponentsBuilder</code>来扩展和编码URI模板。作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code> ：使用<code>UriComponentsBuilder#encode()</code> （对应于前面列表中的第一个选项）对URI模板进行预编码，并在扩展时严格编码URI变量。</p>
</li>
<li>
<p><code>VALUES_ONLY</code> ：不对URI模板进行编码，而是在将URI变量扩展到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对URI变量应用严格编码。</p>
</li>
<li>
<p><code>URI_COMPONENTS</code> ：使用<code>UriComponents#encode()</code> （对应于前面列表中的第二个选项<code>UriComponents#encode()</code> ， <em>在</em> URI变量展开<em>后</em>对URI组件值进行编码。</p>
</li>
<li>
<p><code>NONE</code> ：未应用编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>RestTemplate</code>设置为<code>EncodingMode.URI_COMPONENTS</code>用于历史原因和向后兼容性。<code>WebClient</code>依赖于<code>DefaultUriBuilderFactory</code>的默认值，该值已从<code>EncodingMode.更改<code>EncodingMode.5.0.x中的URI_COMPONENTS</code>到<code>EncodingMode.5.1中的TEMPLATE_AND_VALUES</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-servleturicomponentsbuilder"><a class="anchor" href="#mvc-servleturicomponentsbuilder"></a> 1.4.4。相对Servlet请求</h4>
<div class="paragraph">
<p>您可以使用<code>ServletUriComponentsBuilder</code>创建相对于当前请求的URI，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpServletRequest请求= ...

<span class="comment">//重新使用主机，方案，端口，路径和查询字符串......</span>ServletUriComponentsBuilder UCB = ServletUriComponentsBuilder.fromRequest（请求）.replaceQueryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">帐户<span class="delimiter">ID”，</span></span></span> <span class="string"><span class="content"><span class="delimiter">“（</span>编号<span class="delimiter">）”）.build（）.expand（</span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“123”）.encode（）;</span></span></span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以创建相对于上下文路径的URI，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//重新使用主机，端口和上下文路径......</span>ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath（request）.path（ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ）。build（）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以创建相对于Servlet的URI（例如， <code>/main/*</code> ），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//重用主机，端口，上下文路径和Servlet前缀......</span>ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping（request）.path（ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ）。build（）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.1开始， <code>ServletUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code>标头的信息，这些标头指定了客户端发起的地址。考虑使用<a href="#filters-forwarded-headers"><code>ForwardedHeaderFilter</code></a>来提取和使用或丢弃此类标头。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-links-to-controllers"><a class="anchor" href="#mvc-links-to-controllers"></a> 1.4.5。控制器的链接</h4>
<div class="paragraph">
<p>Spring MVC提供了一种准备控制器方法链接的机制。例如，以下MVC控制器允许创建链接：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotels / {hotel}</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">BookingController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ bookings / {booking}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> ModelAndView getBooking（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> booking）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过按名称引用方法来准备链接，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UriComponents uriComponents = MvcUriComponentsBuilder .fromMethodName（BookingController.class， <span class="string"><span class="delimiter">“</span> <span class="content">getBooking</span> <span class="delimiter">”</span></span> ， <span class="integer">21</span> ）.buildAndExpand（ <span class="integer">42</span> ）; <span class="predefined-type">URI</span> uri = uriComponents.encode（）。toUri（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们提供了实际的方法参数值（在本例中，long值： <code>21</code> ），用作路径变量并插入到URL中。此外，我们提供值<code>42</code>来填充任何剩余的URI变量，例如从类型级请求映射继承的<code>hotel</code>变量。如果方法有更多参数，我们可以为URL不需要的参数提供null。通常，只有<code>@PathVariable</code>和<code>@RequestParam</code>参数与构造URL相关。</p>
</div>
<div class="paragraph">
<p>还有其他方法可以使用<code>MvcUriComponentsBuilder</code> 。例如，您可以使用类似于通过代理进行模拟测试的技术，以避免按名称引用控制器方法，如以下示例所示（该示例假定静态导入<code>MvcUriComponentsBuilder.on</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UriComponents uriComponents = MvcUriComponentsBuilder。fromMethodCall（on（BookingController.class）.getBooking（ <span class="integer">21</span> ））。buildAndExpand（ <span class="integer">42</span> ）; <span class="predefined-type">URI</span> uri = uriComponents.encode（）。toUri（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当控制器方法签名可用于与<code>fromMethodCall</code>创建链接时，它们的设计受到限制。除了需要适当的参数签名之外，返回类型还存在技术限制（即，为链接构建器调用生成运行时代理），因此返回类型不能是<code>final</code> 。特别是，视图名称的常见<code>String</code>返回类型在此处不起作用。您应该使用<code>ModelAndView</code>甚至是普通的<code>Object</code> （带有<code>String</code>返回值）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>前面的示例在<code>MvcUriComponentsBuilder</code>使用静态方法。在内部，它们依赖<code>ServletUriComponentsBuilder</code>从当前请求的方案，主机，端口，上下文路径和servlet路径准备基本URL。这在大多数情况下效果很好。但是，有时，它可能是不够的。例如，您可能位于请求的上下文之外（例如准备链接的批处理过程），或者您可能需要插入路径前缀（例如从请求路径中删除的区域设置前缀，并且需要重新生成插入链接）。</p>
</div>
<div class="paragraph">
<p>对于这种情况，您可以使用接受<code>UriComponentsBuilder</code>的静态<code>fromXxx</code>重载方法来使用基本URL。或者，您可以使用基本URL创建<code>MvcUriComponentsBuilder</code>的实例，然后使用基于实例的<code>withXxx</code>方法。例如，以下列表使用<code>withMethodCall</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath（）。path（ <span class="string"><span class="delimiter">“</span> <span class="content">/ en</span> <span class="delimiter">”</span></span> ）; MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo（base）; builder.withMethodCall（on（BookingController.class）.getBooking（ <span class="integer">21</span> ））。buildAndExpand（ <span class="integer">42</span> ）; <span class="predefined-type">URI</span> uri = uriComponents.encode（）。toUri（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.1开始， <code>MvcUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code>标头的信息，这些标头指定了客户端发起的地址。考虑使用<a href="#filters-forwarded-headers">ForwardedHeaderFilter</a>来提取和使用或丢弃此类标头。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-links-to-controllers-from-views"><a class="anchor" href="#mvc-links-to-controllers-from-views"></a> 1.4.6。视图中的链接</h4>
<div class="paragraph">
<p>在Thymeleaf，FreeMarker或JSP等视图中，您可以通过引用每个请求映射的隐式或显式指定名称来构建指向带注释控制器的链接。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ people / {id} / addresses</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">PersonAddressController</span> { <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {country}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> HttpEntity getAddress（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> country）{...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>给定前面的控制器，您可以从JSP准备链接，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">&lt;％@ taglib uri =“http://www.springframework.org/tags”prefix =“s”％&gt; ...&lt;a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}"&gt;获取地址&lt;/a&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例依赖于Spring标记库中声明的<code>mvcUrl</code>函数（即META-INF / spring.tld），但很容易定义自己的函数或为其他模板技术准备类似的函数。</p>
</div>
<div class="paragraph">
<p>这是如何工作的。在启动时，每一个<code>@RequestMapping</code>的使命是通过默认名称<code>HandlerMethodMappingNamingStrategy</code> ，其默认实现使用类的大写字母和方法的名称（例如， <code>getThing</code>的方法<code>ThingController</code>成为“TC＃getThing”）。如果存在名称冲突，则可以使用<code>@RequestMapping(name="..")</code>分配显式名称或实现自己的<code>HandlerMethodMappingNamingStrategy</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async"><a class="anchor" href="#mvc-ann-async"></a> 1.5。异步请求</h3>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC与Servlet 3.0异步请求<a href="#mvc-ann-async-processing">处理</a>有广泛的集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>和<a href="#mvc-ann-async-callable"><code>Callable</code></a>在控制器方法中返回值，并为单个异步返回值提供基本支持。</p>
</li>
<li>
<p>控制器可以<a href="#mvc-ann-async-http-streaming">流式传输</a>多个值，包括<a href="#mvc-ann-async-sse">SSE</a>和<a href="#mvc-ann-async-output-stream">原始数据</a> 。</p>
</li>
<li>
<p>控制器可以使用被动客户端并返回<a href="#mvc-ann-async-reactive-types">响应类型</a>以进行响应处理。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-deferredresult"><a class="anchor" href="#mvc-ann-async-deferredresult"></a> 1.5.1。使用<code>DeferredResult</code></h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>一旦在Servlet容器中<a href="#mvc-ann-async-configuration">启用</a>了异步请求处理功能，控制器方法就可以使用<code>DeferredResult</code>包装任何支持的控制器方法返回值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ quotes</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ResponseBody</span> <span class="directive">public</span> DeferredResult &lt; <span class="predefined-type">String</span> &gt; quotes（）{DeferredResult &lt; <span class="predefined-type">String</span> &gt; deferredResult = <span class="keyword">new</span> DeferredResult &lt; <span class="predefined-type">String</span> &gt;（）; <span class="comment">//在某处保存deferredResult ..</span>
    <span class="keyword">return</span> deferredResult; } <span class="comment">//来自其他一些帖子......</span>deferredResult.setResult（数据）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>控制器可以从不同的线程异步生成返回值 - 例如，响应外部事件（JMS消息），计划任务或其他事件。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-callable"><a class="anchor" href="#mvc-ann-async-callable"></a> 1.5.2。使用<code>Callable</code></h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以使用<code>java.util.concurrent.包装任何支持的返回值<code>java.util.concurrent.Callable</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> <span class="directive">public</span> <span class="predefined-type">Callable</span> &lt; <span class="predefined-type">String</span> &gt; processUpload（ <span class="directive">final</span> MultipartFile file）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Callable</span> &lt; <span class="predefined-type">String</span> &gt;（）{ <span class="directive">public</span> <span class="predefined-type">String</span> call（） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="comment">// ...</span>
            <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">someView</span> <span class="delimiter">”</span></span> ; }}; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后可以通过<a href="#mvc-ann-async-configuration-spring-mvc">配置的</a> <code>TaskExecutor</code>运行给定任务来获取返回值。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-processing"><a class="anchor" href="#mvc-ann-async-processing"></a> 1.5.3。处理</h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>以下是Servlet异步请求处理的简要概述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以通过调用<code>request.startAsync()</code>将<code>ServletRequest</code>置于异步模式。这样做的主要作用是Servlet（以及任何过滤器）可以退出，但响应保持打开状态，以便稍后处理完成。</p>
</li>
<li>
<p>对<code>request.startAsync()</code>的调用返回<code>AsyncContext</code> ，您可以使用它来进一步控制异步处理。例如，它提供了<code>dispatch</code>方法，类似于Servlet API中的forward，除了它允许应用程序在Servlet容器线程上恢复请求处理。</p>
</li>
<li>
<p><code>ServletRequest</code>提供对当前<code>DispatcherType</code>访问，您可以使用它来区分处理初始请求，异步调度，转发和其他调度程序类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DeferredResult</code>处理的工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>控制器返回<code>DeferredResult</code>并将其保存在可以访问它的某个内存中队列或列表中。</p>
</li>
<li>
<p>Spring MVC调用<code>request.startAsync()</code> 。</p>
</li>
<li>
<p>同时， <code>DispatcherServlet</code>和所有已配置的过滤器退出请求处理线程，但响应仍保持打开状态。</p>
</li>
<li>
<p>应用程序从某个线程设置<code>DeferredResult</code> ，Spring MVC将请求调度回Servlet容器。</p>
</li>
<li>
<p>再次调用<code>DispatcherServlet</code> ，并使用异步生成的返回值继续处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Callable</code>处理的工作原理如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>控制器返回<code>Callable</code> 。</p>
</li>
<li>
<p>Spring MVC调用<code>request.startAsync()</code>并将<code>Callable</code>提交给<code>TaskExecutor</code>以便在单独的线程中进行处理。</p>
</li>
<li>
<p>同时， <code>DispatcherServlet</code>和所有过滤器退出Servlet容器线程，但响应仍保持打开状态。</p>
</li>
<li>
<p>最终<code>Callable</code>产生一个结果，Spring MVC将请求发送回Servlet容器以完成处理。</p>
</li>
<li>
<p>再次调用<code>DispatcherServlet</code> ，并使用来自<code>Callable</code>的异步生成的返回值继续处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多背景和上下文，您还可以阅读在Spring MVC 3.2中引入异步请求处理支持<a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">的博客文章</a> 。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-exceptions"><a class="anchor" href="#mvc-ann-async-exceptions"></a>异常处理</h5>
<div class="paragraph">
<p>使用<code>DeferredResult</code> ，可以选择是否使用异常调用<code>setResult</code>或<code>setErrorResult</code> 。在这两种情况下，Spring MVC都会将请求发送回Servlet容器以完成处理。然后将其视为控制器方法返回给定值，或者就像它产生给定的异常一样。然后异常通过常规异常处理机制（例如，调用<code>@ExceptionHandler</code>方法）。</p>
</div>
<div class="paragraph">
<p>当您使用<code>Callable</code> ，会出现类似的处理逻辑，主要区别在于从<code>Callable</code>返回结果，或者由它引发异常。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-interception"><a class="anchor" href="#mvc-ann-async-interception"></a>截击</h5>
<div class="paragraph">
<p><code>HandlerInterceptor</code>实例可以是<code>AsyncHandlerInterceptor</code>类型，用于接收启动异步处理（而不是<code>postHandle</code>和<code>afterCompletion</code> ）的初始请求的<code>afterConcurrentHandlingStarted</code>回调。</p>
</div>
<div class="paragraph">
<p><code>HandlerInterceptor</code>实现还可以注册<code>CallableProcessingInterceptor</code>或<code>DeferredResultProcessingInterceptor</code> ，以更深入地集成异步请求的生命周期（例如，处理超时事件）。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html"><code>AsyncHandlerInterceptor</code></a> 。</p>
</div>
<div class="paragraph">
<p><code>DeferredResult</code>提供<code>onTimeout(Runnable)</code>和<code>onCompletion(Runnable)</code>回调。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html"><code>DeferredResult</code></a>的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">Javadoc</a> 。<code>Callable</code>可以替代<code>WebAsyncTask</code> ，它公开了超时和完成回调的其他方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-vs-webflux"><a class="anchor" href="#mvc-ann-async-vs-webflux"></a>与WebFlux相比</h5>
<div class="paragraph">
<p>Servlet API最初是为了通过Filter-Servlet链进行单次传递而构建的。在Servlet 3.0中添加的异步请求处理允许应用程序退出Filter-Servlet链，但保持响应打开以进行进一步处理。Spring MVC异步支持是围绕该机制构建的。当控制器返回<code>DeferredResult</code> ，将退出Filter-Servlet链，并释放Servlet容器线程。稍后，当设置<code>DeferredResult</code>时，会进行<code>ASYNC</code>分派（到同一个URL），在此期间再次映射控制器，但不使用它，而是使用<code>DeferredResult</code>值（就像控制器返回它一样）以恢复处理。</p>
</div>
<div class="paragraph">
<p>相比之下，Spring WebFlux既不是基于Servlet API构建的，也不需要这样的异步请求处理功能，因为它是异步设计的。异步处理内置于所有框架合同中，并通过请求处理的所有阶段进行内在支持。</p>
</div>
<div class="paragraph">
<p>从编程模型的角度来看，Spring MVC和Spring WebFlux都支持异步和<a href="#mvc-ann-async-reactive-types">反应类型</a>作为控制器方法中的返回值。Spring MVC甚至支持流媒体，包括反应性背压。但是，对响应的单独写入仍然是阻塞的（并且在单独的线程上执行），这与WebFlux不同，后者依赖于非阻塞I / O，并且每次写入都不需要额外的线程。</p>
</div>
<div class="paragraph">
<p>另一个根本区别是Spring MVC不支持控制器方法参数中的异步或反应类型（例如，@ <code>@RequestBody</code> ，@ <code>@RequestPart</code>等），也没有任何显式支持异步和反应类型作为模型属性。Spring WebFlux确实支持所有这些。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-http-streaming"><a class="anchor" href="#mvc-ann-async-http-streaming"></a> 1.5.4。HTTP流媒体</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs-streaming">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以将<code>DeferredResult</code>和<code>Callable</code>用于单个异步返回值。如果要生成多个异步值并将其写入响应，该怎么办？本节介绍如何执行此操作。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-objects"><a class="anchor" href="#mvc-ann-async-objects"></a>对象</h5>
<div class="paragraph">
<p>您可以使用<code>ResponseBodyEmitter</code>返回值来生成对象流，其中每个对象都使用<a href="integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>序列化并写入响应，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ events</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> ResponseBodyEmitter handle（）{ResponseBodyEmitter emitter = <span class="keyword">new</span> ResponseBodyEmitter（）; <span class="comment">//将发射器保存在某个地方..</span>
    <span class="keyword">返回</span>发射器; } <span class="comment">//在其他一些线程</span> emitter.send（ <span class="string"><span class="delimiter">“</span> <span class="content">你好一次</span> <span class="delimiter">”</span></span> ）; <span class="comment">//稍后再次</span>发出emitter.send（ <span class="string"><span class="delimiter">“</span> <span class="content">你好再来一次</span> <span class="delimiter">”</span></span> ）; <span class="comment">//并在某些时候完成</span> emitter.complete（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>ResponseBodyEmitter</code>作为<code>ResponseBodyEmitter</code>中的正文，以便自定义<code>ResponseEntity</code>的状态和标头。</p>
</div>
<div class="paragraph">
<p>当<code>emitter</code>抛出<code>IOException</code> （例如，如果远程客户端消失），应用程序不负责清理连接，不应调用<code>emitter.complete</code>或<code>emitter.completeWithError</code> 。相反，servlet容器会自动启动<code>AsyncListener</code>错误通知，其中Spring MVC进行<code>completeWithError</code>调用。反过来，此调用会对应用程序执行一次最终<code>ASYNC</code>调度，在此期间，Spring MVC将调用已配置的异常解析程序并完成请求。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-sse"><a class="anchor" href="#mvc-ann-async-sse"></a> SSE</h5>
<div class="paragraph">
<p><code>SseEmitter</code> （ <code>ResponseBodyEmitter</code>的子类）为<a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a>提供支持，其中从服务器<a href="http://www.w3.org/TR/eventsource/">发送的事件</a>根据W3C SSE规范进行格式化。要从控制器生成SSE流，请返回<code>SseEmitter</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ events</span> <span class="delimiter">”</span></span> ， <span class="annotation">produce</span> = MediaType。TEXT_EVENT_STREAM_VALUE） <span class="directive">public</span> SseEmitter handle（）{SseEmitter emitter = <span class="keyword">new</span> SseEmitter（）; <span class="comment">//将发射器保存在某个地方..</span>
    <span class="keyword">返回</span>发射器; } <span class="comment">//在其他一些线程</span> emitter.send（ <span class="string"><span class="delimiter">“</span> <span class="content">你好一次</span> <span class="delimiter">”</span></span> ）; <span class="comment">//稍后再次</span>发出emitter.send（ <span class="string"><span class="delimiter">“</span> <span class="content">你好再来一次</span> <span class="delimiter">”</span></span> ）; <span class="comment">//并在某些时候完成</span> emitter.complete（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>虽然SSE是流式传输到浏览器的主要选项，但请注意Internet Explorer不支持服务器发送事件。考虑将Spring的<a href="#websocket">WebSocket消息传递</a>与针对各种浏览器的<a href="#websocket-fallback">SockJS后备</a>传输（包括SSE）一起使用。</p>
</div>
<div class="paragraph">
<p>有关异常处理的说明，另请参见<a href="#mvc-ann-async-objects">上一节</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-output-stream"><a class="anchor" href="#mvc-ann-async-output-stream"></a>原始数据</h5>
<div class="paragraph">
<p>有时，绕过消息转换并直接流到响应<code>OutputStream</code> （例如，用于文件下载）是有用的。您可以使用<code>StreamingResponseBody</code>返回值类型来执行此操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ download</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> StreamingResponseBody handle（）{ <span class="keyword">return</span> <span class="keyword">new</span> StreamingResponseBody（）{ <span class="annotation">@</span> Override <span class="directive">public</span> <span class="type">void</span> writeTo（ <span class="predefined-type">OutputStream</span> outputStream） <span class="directive">throws</span> <span class="exception">IOException</span> { <span class="comment">// write ...</span>}}; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>StreamingResponseBody</code>作为<code>ResponseEntity</code>的主体来自定义<code>ResponseEntity</code>的状态和标头。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-reactive-types"><a class="anchor" href="#mvc-ann-async-reactive-types"></a> 1.5.5。反应类型</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs-streaming">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC支持在控制器中使用反应式客户端库。这包括来自<code>spring-webflux</code>的<code>WebClient</code>和其他，例如Spring Data反应数据存储库。在这种情况下，能够从控制器方法返回反应类型是方便的。</p>
</div>
<div class="paragraph">
<p>反应返回值的处理方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单值承诺适用于，类似于使用<code>DeferredResult</code> 。例子包括<code>Mono</code> （Reactor）或<code>Single</code> （RxJava）。</p>
</li>
<li>
<p>具有流媒体类型（例如<code>application/stream+json</code>或<code>text/event-stream</code> ）的多值流适用于类似于使用<code>ResponseBodyEmitter</code>或<code>SseEmitter</code> 。例子包括<code>Flux</code> （Reactor）或<code>Observable</code> （RxJava）。应用程序还可以返回<code>Flux&lt;ServerSentEvent&gt;</code>或<code>Observable&lt;ServerSentEvent&gt;</code> 。</p>
</li>
<li>
<p>具有任何其他媒体类型（例如<code>application/json</code> ）的多值流适用于，类似于使用<code>DeferredResult&lt;List&lt;?&gt;&gt;</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring MVC通过<code>spring-core</code>的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a>支持Reactor和RxJava，它允许它适应多个反应库。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于流式传输到响应，支持反应式反压，但是对响应的写入仍然是阻塞的，并且通过<a href="#mvc-ann-async-configuration-spring-mvc">配置的</a> <code>TaskExecutor</code>在单独的线程上执行，以避免阻塞上游源（例如从<code>WebClient</code>返回的<code>Flux</code> ）。默认情况下， <code>SimpleAsyncTaskExecutor</code>用于阻塞写入，但在加载时不适用。如果计划使用响应类型进行流式处理，则应使用<a href="#mvc-ann-async-configuration-spring-mvc">MVC配置</a>来配置任务执行程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-disconnects"><a class="anchor" href="#mvc-ann-async-disconnects"></a> 1.5.6。断开</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs-streaming">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>当远程客户端消失时，Servlet API不提供任何通知。因此，在流式传输到响应时，无论是通过<a href="#mvc-ann-async-sse">SseEmitter</a>还是&lt;&lt; mvc-ann-async-reactive-types，reactive types&gt;，定期发送数据都很重要，因为如果客户端断开连接，写入将失败。发送可以采用空（仅限注释）SSE事件或另一方必须解释为心跳并忽略的任何其他数据的形式。</p>
</div>
<div class="paragraph">
<p>或者，考虑使用具有内置心跳机制的Web消息传递解决方案（例如基于<a href="#websocket-stomp">WebSocket的STOMP</a>或具有<a href="#websocket-fallback">SockJS的</a> WebSocket）。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-configuration"><a class="anchor" href="#mvc-ann-async-configuration"></a> 1.5.7。组态</h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>必须在Servlet容器级别启用异步请求处理功能。MVC配置还公开了异步请求的几个选项。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-configuration-servlet3"><a class="anchor" href="#mvc-ann-async-configuration-servlet3"></a> Servlet容器</h5>
<div class="paragraph">
<p>Filter和Servlet声明具有<code>asyncSupported</code>标志，需要将其设置为<code>true</code>以启用异步请求处理。此外，应声明Filter映射以处理<code>ASYNC</code> <code>javax.servlet.DispatchType</code> 。</p>
</div>
<div class="paragraph">
<p>在Java配置中，当您使用<code>AbstractAnnotationConfigDispatcherServletInitializer</code>初始化Servlet容器时，这将自动完成。</p>
</div>
<div class="paragraph">
<p>在<code>web.xml</code>配置中，您可以将<code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code>到<code>DispatcherServlet</code>和<code>Filter</code>声明，并添加<code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code>来过滤映射。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-configuration-spring-mvc"><a class="anchor" href="#mvc-ann-async-configuration-spring-mvc"></a> Spring MVC</h5>
<div class="paragraph">
<p>MVC配置公开以下与异步请求处理相关的选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java配置：在<code>WebMvcConfigurer</code>上使用<code>configureAsyncSupport</code>回调。</p>
</li>
<li>
<p>XML命名空间：使用<code>&lt;mvc:annotation-driven&gt;</code>下的<code>&lt;async-support&gt;</code>元素。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以配置以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>异步请求的默认超时值，如果未设置，则取决于底层Servlet容器（例如，Tomcat上的10秒）。</p>
</li>
<li>
<p><code>AsyncTaskExecutor</code>用于在使用<a href="#mvc-ann-async-reactive-types">Reactive Types</a>进行流式处理时阻止写入，以及用于执行从控制器方法返回的<code>Callable</code>实例。如果您使用反应类型进行流式传输或者具有返回<code>Callable</code>控制器方法，我们强烈建议您配置此属性，因为默认情况下，它是<code>SimpleAsyncTaskExecutor</code> 。</p>
</li>
<li>
<p><code>DeferredResultProcessingInterceptor</code>实现和<code>CallableProcessingInterceptor</code>实现。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，您还可以在<code>DeferredResult</code> ， <code>ResponseBodyEmitter</code>和<code>SseEmitter</code>上设置默认超时值。对于<code>Callable</code> ，您可以使用<code>WebAsyncTask</code>来提供超时值。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-cors"><a class="anchor" href="#mvc-cors"></a> 1.6。CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC允许您处理CORS（跨源资源共享）。本节介绍如何执行此操作。</p>
</div>
<div class="sect3">
<h4 id="mvc-cors-intro"><a class="anchor" href="#mvc-cors-intro"></a> 1.6.1。介绍</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-intro">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>出于安全原因，浏览器禁止对当前源外的资源进行AJAX调用。例如，您可以将您的银行帐户放在一个标签页中，将evil.com放在另一个标签页中。来自evil.com的脚本不应该使用您的凭据向您的银行API发出AJAX请求 - 例如从您的帐户中提取资金！</p>
</div>
<div class="paragraph">
<p>跨源资源共享（CORS）是<a href="http://caniuse.com/#feat=cors">大多数浏览器</a>实现的<a href="http://www.w3.org/TR/cors/">W3C规范</a> ，允许您指定授权的跨域请求类型，而不是使用基于IFRAME或JSONP的安全性较低且功能较弱的变通方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-processing"><a class="anchor" href="#mvc-cors-processing"></a> 1.6.2。处理</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-processing">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>CORS规范区分了预检，简单和实际请求。要了解CORS的工作原理，您可以阅读<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>以及其他许多内容，或者查看规范以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>Spring MVC <code>HandlerMapping</code>实现为CORS提供内置支持。成功将请求映射到处理程序后， <code>HandlerMapping</code>实现检查给定请求和处理程序的CORS配置并采取进一步操作。直接处理预检请求，同时拦截，验证简单和实际的CORS请求，并设置所需的CORS响应头。</p>
</div>
<div class="paragraph">
<p>为了启用跨源请求（即，存在<code>Origin</code>头并且与请求的主机不同），您需要具有一些显式声明的CORS配置。如果未找到匹配的CORS配置，则拒绝预检请求。没有CORS头添加到简单和实际CORS请求的响应中，因此浏览器拒绝它们。</p>
</div>
<div class="paragraph">
<p>可以使用基于URL模式的<code>CorsConfiguration</code>映射单独<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a>每个<code>HandlerMapping</code> 。在大多数情况下，应用程序使用MVC Java配置或XML命名空间来声明此类映射，这会导致将单个全局映射传递给所有<code>HandlerMappping</code>实例。</p>
</div>
<div class="paragraph">
<p>您可以将<code>HandlerMapping</code>级别的全局CORS配置与更细粒度的处理程序级CORS配置相结合。例如，带注释的控制器可以使用类或方法级别的<code>@CrossOrigin</code>注释（其他处理程序可以实现<code>CorsConfigurationSource</code> ）。</p>
</div>
<div class="paragraph">
<p>组合全局和本地配置的规则通常是附加的 - 例如，所有全局和所有本地源。对于只能接受单个值的属性（例如<code>allowCredentials</code>和<code>maxAge</code> ），本地会覆盖全局值。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要从源中了解更多信息或进行高级自定义，请查看后面的代码：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code> ， <code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>是AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-controller"><a class="anchor" href="#mvc-cors-controller"></a> 1.6.3。使用<code>@CrossOrigin</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-controller">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>注释在带注释的控制器方法上启用跨源请求，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountController</span> { <span class="annotation">@CrossOrigin</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span>帐户检索（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@DeleteMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> remove（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>@CrossOrigin</code>允许：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p>控制器方法映射到的所有HTTP方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下不启用<code>allowedCredentials</code> ，因为它建立了一个信任级别，该信任级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code>在类级别也受支持，并且由所有方法继承，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span> （ <span class="annotation">origin</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://domain2.com</span> <span class="delimiter">”</span></span> ，maxAge = <span class="integer">3600</span> ） <span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span>帐户检索（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@DeleteMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> remove（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在类级别和方法级别使用<code>@CrossOrigin</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span> （maxAge = <span class="integer">3600</span> ） <span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountController</span> { <span class="annotation">@CrossOrigin</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">http://domain2.com</span> <span class="delimiter">”</span></span> ） <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span>帐户检索（ <span class="annotation">@PathVariable</span> <span class="predefined-type">长</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@DeleteMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> remove（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-global"><a class="anchor" href="#mvc-cors-global"></a> 1.6.4。全局配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-global">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>除了细粒度的控制器方法级别配置之外，您可能还希望定义一些全局CORS配置。您可以在任何<code>HandlerMapping</code>上单独设置基于URL的<code>CorsConfiguration</code>映射。但是，大多数应用程序使用MVC Java配置或MVC XNM命名空间来执行此操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，全局配置启用以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p><code>GET</code> ， <code>HEAD</code>和<code>POST</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下不启用<code>allowedCredentials</code> ，因为它建立了一个信任级别，该信任级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="sect4">
<h5 id="mvc-cors-global-java"><a class="anchor" href="#mvc-cors-global-java"></a> Java配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-global">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>要在MVC Java配置中启用CORS，可以使用<code>CorsRegistry</code>回调，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addCorsMappings（CorsRegistry注册表）{registry.addMapping（ <span class="string"><span class="content"><span class="delimiter">“/</span> API / <span class="delimiter">**”）.allowedOrigins（</span></span></span> <span class="string"><span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="delimiter"><span class="content">“http://domain2.com”）.allowedMethods（“PUT</span></span></span></span></span></span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">DELETE</span> <span class="delimiter">“</span></span> ）。allowedHeaders（ <span class="string"><span class="delimiter">”</span> <span class="content">header1</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">header2</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">header3</span> <span class="delimiter">“</span></span> ）。expposedHeaders（ <span class="string"><span class="delimiter">”</span> <span class="content">header1</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">header2</span> <span class="delimiter">“</span></span> ）。allowCredentials（ <span class="predefined-constant">true</span> ）.maxAge（ <span class="integer">3600</span> ）; <span class="comment">//添加更多映射...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-cors-global-xml"><a class="anchor" href="#mvc-cors-global-xml"></a> XML配置</h5>
<div class="paragraph">
<p>要在XML命名空间中启用CORS，可以使用<code>&lt;mvc:cors&gt;</code>元素，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;MVC：CORS&gt;</span> <span class="tag">&lt;MVC：映射</span> <span class="attribute-name">路径</span> = <span class="string"><span class="content"><span class="delimiter">“/</span> API / <span class="delimiter">**”</span></span></span> <span class="attribute-name">允许-起源</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“http://domain1.com，http://domain2.com”</span></span></span></span> <span class="attribute-name">允许的方法</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“GET，PUT”</span></span></span></span> <span class="attribute-name">准予headers</span> = <span class="string"><span class="delimiter">“</span> <span class="content">header1，header2，header3</span> <span class="delimiter">”</span></span> <span class="attribute-name">exposed-headers</span> = <span class="string"><span class="delimiter">“</span> <span class="content">header1，header2</span> <span class="delimiter">”</span></span> <span class="attribute-name">allow-credentials</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">max-age</span> = <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ resources / **</span> <span class="delimiter">”</span></span> <span class="attribute-name">allowed-origin</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://domain1.com</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：cors&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-filter"><a class="anchor" href="#mvc-cors-filter"></a> 1.6.5。CORS过滤器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-webfilter">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过内置的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/filter/CorsFilter.html"><code>CorsFilter</code></a>应用CORS支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您尝试将<code>CorsFilter</code>与Spring Security一起使用，请记住Spring Security <a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">内置了</a>对CORS的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">支持</a> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要配置过滤器， <code>CorsConfigurationSource</code>传递给其构造函数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration（）; <span class="comment">//可能......</span>
<span class="comment">// config.applyPermitDefaultValues（）</span> config.setAllowCredentials（ <span class="predefined-constant">true</span> ）; config.addAllowedOrigin（ <span class="string"><span class="delimiter">“</span> <span class="content">http://domain1.com</span> <span class="delimiter">”</span></span> ）; config.addAllowedHeader（ <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> ）; config.addAllowedMethod（ <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> ）; UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource（）; source.registerCorsConfiguration（ <span class="string"><span class="delimiter">“</span> <span class="content">/ **</span> <span class="delimiter">”</span></span> ，config）; CorsFilter filter = <span class="keyword">new</span> CorsFilter（source）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-web-security"><a class="anchor" href="#mvc-web-security"></a> 1.7。网络安全</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-web-security">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://projects.spring.io/spring-security/">Spring Security</a>项目为保护Web应用程序免受恶意攻击提供支持。请参阅Spring Security参考文档，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">Spring MVC Security</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">Spring MVC测试支持</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF保护</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">安全响应标头</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="http://hdiv.org/">HDIV</a>是另一个与Spring MVC集成的Web安全框架。</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-caching"><a class="anchor" href="#mvc-caching"></a> 1.8。HTTP缓存</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕<code>Cache-Control</code>响应头，随后是条件请求头（例如<code>Last-Modified</code>和<code>ETag</code> ）。<code>Cache-Control</code>建议私有（例如，浏览器）和公共（例如，代理）缓存如何缓存和重用响应。如果内容未更改，则<code>ETag</code>标头用于生成条件请求，该条件请求可能导致304（NOT_MODIFIED）没有正文。<code>ETag</code>可以被视为<code>Last-Modified</code>标头的更复杂的后继者。</p>
</div>
<div class="paragraph">
<p>本节介绍Spring Web MVC中可用的与HTTP缓存相关的选项。</p>
</div>
<div class="sect3">
<h4 id="mvc-caching-cachecontrol"><a class="anchor" href="#mvc-caching-cachecontrol"></a> 1.8.1。使用<code>CacheControl</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching-cachecontrol">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>支持配置与<code>Cache-Control</code>标头相关的设置，并在许多地方被接受为参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/WebContentInterceptor.html"><code>WebContentInterceptor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/support/WebContentGenerator.html"><code>WebContentGenerator</code></a></p>
</li>
<li>
<p><a href="#mvc-caching-etag-lastmodified">控制器</a></p>
</li>
<li>
<p><a href="#mvc-caching-static-resources">静态资源</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然<a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用面向用例的方法，该方法侧重于常见场景：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//缓存一小时 - “Cache-Control：max-age = 3600”</span> CacheControl ccCacheOneHour = CacheControl.maxAge（ <span class="integer">1</span> ， <span class="predefined-type">TimeUnit</span> 。小时）; <span class="comment">//防止缓存 - “Cache-Control：no-store”</span> CacheControl ccNoStore = CacheControl.noStore（）; <span class="comment">//在公共和私有缓存中缓存十天，</span> <span class="comment">//公共缓存不应该转换响应</span> <span class="comment">//“Cache-Control：max-age = 864000，public，no-transform”</span> CacheControl ccCustom = CacheControl.maxAge（ <span class="integer">10</span> ， <span class="predefined-type">TimeUnit</span> 。DAYS）.noTransform（）cachePublic（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>WebContentGenerator</code>还接受一个更简单的<code>cachePeriod</code>属性（以秒为单位定义），其工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-1</code>值不会生成<code>Cache-Control</code>响应头。</p>
</li>
<li>
<p><code>0</code>值可通过使用<code>'Cache-Control: no-store'</code>指令来防止缓存。</p>
</li>
<li>
<p><code>n &gt; 0</code>值通过使用<code>'Cache-Control: max-age=n'</code>指令将给定响应缓存<code>n</code>秒。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="mvc-caching-etag-lastmodified"><a class="anchor" href="#mvc-caching-etag-lastmodified"></a> 1.8.2。控制器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching-etag-lastmodified">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以添加对HTTP缓存的显式支持。我们建议这样做，因为资源的<code>lastModified</code>或<code>ETag</code>值需要先计算才能与条件请求标头进行比较。控制器可以向<code>ResponseEntity</code>添加<code>ETag</code>标头和<code>Cache-Control</code>设置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ book / {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">Book</span> &gt; showBook（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="predefined-type">Book</span> book = findBook（id）; <span class="predefined-type">String</span> version = book.getVersion（）; <span class="keyword">返回</span> ResponseEntity .ok（）。cacheControl（CacheControl.maxAge（ <span class="integer">30</span> ， <span class="predefined-type">TimeUnit</span> 。DAYS））。eTag（版本） <span class="comment">// lastModified也可用</span> .body（book）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果与条件请求标头的比较表明内容未更改，则前面的示例发送带有空主体的304（NOT_MODIFIED）响应。否则， <code>ETag</code>和<code>Cache-Control</code>标头将添加到响应中。</p>
</div>
<div class="paragraph">
<p>您还可以对控制器中的条件请求标头进行检查，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestMapping</span> <span class="directive">public</span> <span class="predefined-type">String</span> myHandleMethod（WebRequest webRequest，Model model）{ <span class="type">long</span> eTag = ...<i class="conum" data-value="1"></i> <b>（1）</b> if（request.checkNotModified（eTag））{ <span class="keyword">return</span> <span class="predefined-constant">null</span> ; <i class="conum" data-value="2"></i> <b>（2）</b> } model.addAttribute（...）; <i class="conum" data-value="3"></i> <b>（3）</b> <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">myViewName</span> <span class="delimiter">”</span></span> ; }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>特定于应用的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED） - 无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>继续请求处理。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有三种变体可用于检查针对<code>eTag</code>值， <code>lastModified</code>值或两者的条件请求。对于条件<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为304（NOT_MODIFIED）。对于条件<code>POST</code> ， <code>PUT</code>和<code>DELETE</code> ，您可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-caching-static-resources"><a class="anchor" href="#mvc-caching-static-resources"></a> 1.8.3。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching-static-resources">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您应该使用<code>Cache-Control</code>和条件响应头来提供静态资源，以获得最佳性能。请参阅有关配置<a href="#mvc-config-static-resources">静态资源</a>的部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-httpcaching-shallowetag"><a class="anchor" href="#mvc-httpcaching-shallowetag"></a> 1.8.4。<code>ETag</code>过滤器</h4>
<div class="paragraph">
<p>您可以使用<code>ShallowEtagHeaderFilter</code>添加从响应内容计算的“浅” <code>eTag</code>值，从而节省带宽但不节省CPU时间。见<a href="#filters-shallow-etag">浅ETag</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view"><a class="anchor" href="#mvc-view"></a> 1.9。查看技术</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>无论您决定使用Thymeleaf，Groovy标记模板，JSP还是其他技术，Spring MVC中视图技术的使用都是可插拔的，主要是配置更改的问题。本章介绍了与Spring MVC集成的视图技术。我们假设您已经熟悉<a href="#mvc-viewresolver">View Resolution</a> 。</p>
</div>
<div class="sect3">
<h4 id="mvc-view-thymeleaf"><a class="anchor" href="#mvc-view-thymeleaf"></a> 1.9.1。Thymeleaf</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-thymeleaf">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf是一个现代服务器端Java模板引擎，强调自然HTML模板，可以通过双击在浏览器中预览，这对于UI模板的独立工作（例如，由设计师）非常有用，而无需运行服务器。如果您想要替换JSP，Thymeleaf提供了一组最广泛的功能，使这种过渡更容易。Thymeleaf积极开发和维护。有关更完整的介绍，请参阅<a href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
</div>
<div class="paragraph">
<p>Thymeleaf与Spring MVC的集成由Thymeleaf项目管理。配置涉及一些bean声明，例如<code>ServletContextTemplateResolver</code> ， <code>SpringTemplateEngine</code>和<code>ThymeleafViewResolver</code> 。有关详细信息，请参阅<a href="http://www.thymeleaf.org/documentation.html">Thymeleaf + Spring</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-freemarker"><a class="anchor" href="#mvc-view-freemarker"></a> 1.9.2。FreeMarker的</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-freemarker">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://www.freemarker.org">Apache FreeMarker</a>是一个模板引擎，用于生成从HTML到电子邮件和其他人的任何类型的文本输出。Spring Framework有一个内置的集成，可以将Spring MVC与FreeMarker模板结合使用。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-freemarker-contextconfig"><a class="anchor" href="#mvc-view-freemarker-contextconfig"></a>查看配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-freemarker-contextconfig">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何将FreeMarker配置为视图技术：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.freemarker（）; } <span class="comment">//配置FreeMarker ......</span>

    <span class="annotation">@Bean</span> <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer（）{FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer（）; configurer.setTemplateLoaderPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ WEB-INF / freemarker</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中配置相同的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：freemarker</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：view-resolvers&gt;</span> <span class="comment">&lt;！ -  Configure FreeMarker ...  - &gt;</span> <span class="tag">&lt;mvc：freemarker-configurer&gt;</span> <span class="tag">&lt;mvc ：template-loader-path</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ WEB-INF / freemarker</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：freemarker-configurer&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您也可以声明<code>FreeMarkerConfigurer</code> bean以完全控制所有属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">freemarkerConfig</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.freemarker。FreeMarkerConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">templateLoaderPath</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ WEB-INF / freemarker /</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您的模板需要存储在前面示例中所示的<code>FreeMarkerConfigurer</code>指定的目录中。根据前面的配置，如果您的控制器返回<code>welcome</code>视图名称，解析器将查找<code>/WEB-INF/freemarker/welcome.ftl</code>模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-views-freemarker"><a class="anchor" href="#mvc-views-freemarker"></a> FreeMarker配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-views-freemarker">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过在<code>FreeMarkerConfigurer</code> bean上设置适当的bean属性，将<code>FreeMarkerConfigurer</code> '和'SharedVariables'直接传递给FreeMarker <code>Configuration</code>对象（由Spring管理）。<code>freemarkerSettings</code>属性需要<code>java.util.Properties</code>对象和<code>freemarkerVariables</code>属性需要<code>java.util.Map</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">freemarkerConfig</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.freemarker。FreeMarkerConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">templateLoaderPath</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ WEB-INF / freemarker /</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">freemarkerVariables</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xml_escape</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fmXmlEscape</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fmXmlEscape</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">freemarker.template.utility。XmlEscape</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关适用于<code>Configuration</code>对象的设置和变量的详细信息，请参阅FreeMarker文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-freemarker-forms"><a class="anchor" href="#mvc-view-freemarker-forms"></a>表格处理</h5>
<div class="paragraph">
<p>Spring提供了一个用于JSP的标记库，其中包含一个<code>&lt;spring:bind/&gt;</code>元素。此元素主要使表单显示来自表单支持对象的值，并显示来自Web或业务层中的<code>Validator</code>失败的结果。Spring还支持FreeMarker中的相同功能，还有用于生成表单输入元素的额外便利宏。</p>
</div>
<div class="sect5">
<h6 id="mvc-view-bind-macros"><a class="anchor" href="#mvc-view-bind-macros"></a>绑定宏</h6>
<div class="paragraph">
<p>在<code>spring-webmvc.jar</code>文件中为两种语言维护一组标准宏，因此它们始终可用于适当配置的应用程序。</p>
</div>
<div class="paragraph">
<p>Spring库中定义的一些宏被认为是内部的（私有的），但宏定义中不存在这样的范围，使得所有宏对调用代码和用户模板都可见。以下部分仅关注您需要在模板中直接调用的宏。如果您希望直接查看宏代码，该文件名为<code>spring.ftl</code> ，位于<code>org.springframework.web.servlet.view.freemarker</code>包中。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-simple-binding"><a class="anchor" href="#mvc-view-simple-binding"></a>简单的绑定</h6>
<div class="paragraph">
<p>在作为Spring MVC控制器的表单视图的HTML表单（vm或ftl模板）中，您可以使用与下一个示例类似的代码绑定到字段值，并以与JSP类似的方式显示每个输入字段的错误消息当量。以下示例显示了之前配置的<code>personForm</code>视图：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  freemarker宏必须导入命名空间。我们强烈建议坚持使用'spring' - &gt;</span> <span class="error">&lt;</span> #import“/spring.ftl”作为sp​​ring / <span class="error">&gt;</span> <span class="tag">&lt;html&gt;</span> ...
    <span class="tag">&lt;form</span> <span class="attribute-name">action</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">POST</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>名称： <span class="error">&lt;</span> @ spring.bind“myModelObject.name”/ <span class="error">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {spring.status.expression}</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ { spring.status.value？html}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;br&gt;</span> <span class="error">&lt;</span> ＃list spring.status.errorMessages as error <span class="error">&gt;</span> <span class="tag">&lt;b&gt;</span> $ {error} <span class="tag">&lt;/ b&gt;</span> <span class="tag">&lt;br&gt;</span> <span class="tag">&lt;/</span> ＃list <span class="error">&gt;</span> <span class="tag">&lt;br&gt;</span> ...
        <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ form&gt;</span> ...
<span class="tag">&lt;/ HTML&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>&lt;@spring.bind&gt;</code>需要一个'path'参数，它包含命令对象的名称（它是'command'，除非你在<code>FormController</code>属性中更改它），后跟一个句点和字段的名称。要绑定的命令对象。您还可以使用嵌套字段，例如<code>command.address.street</code> 。<code>bind</code>宏假定由<code>web.xml</code>的ServletContext参数<code>defaultHtmlEscape</code>指定的默认HTML转义行为。</p>
</div>
<div class="paragraph">
<p>名为<code>&lt;@spring.bindEscaped&gt;</code>的宏的可选形式接受第二个参数，并显式指定是否应在状态错误消息或值中使用HTML转义。您可以根据需要将其设置为<code>true</code>或<code>false</code> 。其他表单处理宏简化了HTML转义的使用，您应该尽可能使用这些宏。它们将在下一节中介绍。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-views-form-macros"><a class="anchor" href="#mvc-views-form-macros"></a>输入宏</h6>
<div class="paragraph">
<p>两种语言的附加便利宏简化了绑定和表单生成（包括验证错误显示）。永远不必使用这些宏来生成表单输入字段，您可以将它们与简单的HTML混合或匹配，或直接调用我们之前突出显示的spring绑定宏。</p>
</div>
<div class="paragraph">
<p>下表中的可用宏显示了FTL定义和每个参数列表：</p>
</div>
<table id="views-macros-defs-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表6。宏定义表</caption>
<colgroup>
<col style="width:75%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">宏</th>
<th class="tableblock halign-left valign-top">FTL定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message</code> （根据代码参数从资源包中输出字符串）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.message code /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>messageText</code> （根据代码参数从资源包中输出一个字符串，回退到默认参数的值）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.messageText代码，text /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code> （使用应用程序的上下文根作为相对URL的前缀）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.url relativeUrl /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formInput</code> （用于收集用户输入的标准输入字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formInput path，attributes，fieldType /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formHiddenInput</code> （用于提交非用户输入的隐藏输入字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formHiddenInput path，attributes /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formPasswordInput</code> （用于收集密码的标准输入字段。请注意，此类型的字段中不会填充任何值。）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formPasswordInput path，attributes /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formTextarea</code> （用于收集长，自由格式文本输入的大文本字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formTextarea path，attributes /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formSingleSelect</code> （允许选择单个所需值的下拉框选项）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formSingleSelect path，options，attributes /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formMultiSelect</code> （允许用户选择0或更多值的选项列表框）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formMultiSelect路径，选项，属性/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formRadioButtons</code> （一组单选按钮，允许从可用选项中进行单个选择）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formRadioButtons路径，选项分隔符，属性/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formCheckboxes</code> （一组允许选择0或更多值的复选框）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formCheckboxes路径，选项，分隔符，属性/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formCheckbox</code> （单个复选框）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.formCheckbox路径，属性/&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>showErrors</code> （简化绑定字段的验证错误显示）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;@ spring.showErrors separator，classOrStyle /&gt;</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>在FTL（FreeMarker）中，实际上不需要<code>formHiddenInput</code>和<code>formPasswordInput</code> ，因为您可以使用普通的<code>formInput</code>宏，指定<code>hidden</code>或<code>password</code>作为<code>fieldType</code>参数的值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>任何上述宏的参数都具有一致的含义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path</code> ：要绑定的字段的名称（即“command.name”）</p>
</li>
<li>
<p><code>options</code> ：可在输入字段中选择的所有可用值的<code>Map</code> 。映射的键表示从表单返回并绑定到命令对象的值。针对键存储的地图对象是表单上显示给用户的标签，可能与表单发回的相应值不同。通常，控制器提供这样的映射作为参考数据。您可以使用任何<code>Map</code>实现，具体取决于所需的行为。对于严格排序的映射，您可以将<code>SortedMap</code> （例如<code>TreeMap</code> ）与合适的<code>Comparator</code>一起使用，对于应按插入顺序返回值的任意Maps，请使用来自<code>commons-collections</code>的<code>LinkedHashMap</code>或<code>LinkedMap</code> 。</p>
</li>
<li>
<p><code>separator</code> ：多个选项可用作谨慎元素（单选按钮或复选框），用于分隔列表中每个元素的字符序列（例如<code>&lt;br&gt;</code> ）。</p>
</li>
<li>
<p><code>attributes</code> ：HTML标记本身中包含的附加字符串，包含任意标记或文本。该字符串由宏按字面回显。例如，在<code>textarea</code>字段中，您可以提供属性（例如'rows =“5”cols =“60”'），或者您可以传递样式信息，例如'style =“border：1px solid silver”'。</p>
</li>
<li>
<p><code>classOrStyle</code> ：对于<code>showErrors</code>宏，包含每个错误的<code>span</code>元素使用的CSS类的名称。如果未提供任何信息（或值为空），则错误将包含在<code>&lt;b&gt;&lt;/b&gt;</code>标记中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下部分概述了宏的示例（一些在FTL中，一些在VTL中）。如果两种语言之间存在使用差异，则会在说明中对其进行说明。</p>
</div>
<div class="sect6">
<h7 id="mvc-views-form-macros-input"><a class="anchor" href="#mvc-views-form-macros-input"></a>输入字段</h7>
<div class="paragraph">
<p><code>formInput</code>宏采用<code>path</code>参数（ <code>command.name</code> ）和附加<code>attributes</code>参数（ <code>command.name</code>一个示例中为空）。宏以及所有其他表单生成宏在path参数上执行隐式Spring绑定。绑定在发生新绑定之前保持有效，因此<code>showErrors</code>宏不需要再次传递path参数 - 它在最后创建绑定的字段上运行。</p>
</div>
<div class="paragraph">
<p><code>showErrors</code>宏采用分隔符参数（用于分隔给定字段上的多个错误的字符），并且还接受第二个参数 - 这次是类名称或样式属性。请注意，FreeMarker可以为attributes参数指定默认值。以下示例显示如何使用<code>formInput</code>和<code>showWErrors</code>宏：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="error">&lt;</span> @ spring.formInput“command.name”/ <span class="error">&gt;</span> <span class="error">&lt;</span> @ spring.showErrors“ <span class="tag">&lt;</span> / <span class="error">&gt;</span> ”/ <span class="error">&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一个示例显示表单片段的输出，生成名称字段并在提交表单后在字段中没有值时显示验证错误。验证通过Spring的验证框架进行。</p>
</div>
<div class="paragraph">
<p>生成的HTML类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">名称：&lt;input type =“text”name =“name”value =“”&gt; &lt;br&gt; &lt;b&gt;必需&lt;/ b&gt; &lt;br&gt; &lt;br&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>formTextarea</code>宏的工作方式与<code>formInput</code>宏的工作方式相同，并接受相同的参数列表。通常，第二个参数（attributes）用于传递<code>textarea</code>样式信息或<code>rows</code>和<code>cols</code>属性。</p>
</div>
</div>
<div class="sect6">
<h7 id="mvc-views-form-macros-select"><a class="anchor" href="#mvc-views-form-macros-select"></a>选择字段</h7>
<div class="paragraph">
<p>您可以使用四个选择字段宏在HTML表单中生成常用UI值选择输入：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>formSingleSelect</code></p>
</li>
<li>
<p><code>formMultiSelect</code></p>
</li>
<li>
<p><code>formRadioButtons</code></p>
</li>
<li>
<p><code>formCheckboxes</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>四个宏中的每一个都接受一个选项<code>Map</code> ，其中包含表单字段的值和与该值对应的标签。值和标签可以相同。</p>
</div>
<div class="paragraph">
<p>下一个例子是FTL中的单选按钮。表单支持对象为此字段指定默认值“伦敦”，因此无需进行验证。渲染表单时，可以选择的整个城市列表作为参考数据在名为“cityMap”的模型中提供。以下清单显示了该示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">...镇：&lt;@ spring.formRadioButtons“command.address.town”，cityMap，“”/&gt; &lt;br&gt; &lt;br&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的列表呈现一行单选按钮，一个用于<code>cityMap</code>每个值，并使用分隔符<code>""</code> 。没有提供其他属性（缺少宏的最后一个参数）。<code>cityMap</code>对地图中的每个键值对使用相同的<code>String</code> 。映射的键是表单实际提交为POSTed请求参数的键。地图值是用户看到的标签。在前面的示例中，给定一个包含三个众所周知的城市的列表以及表单支持对象中的默认值，HTML类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">Town：&lt;input type =“radio”name =“address.town”value =“London”&gt; London &lt;/ input&gt; &lt;input type =“radio”name =“address.town”value =“Paris”checked =“checked “&gt;巴黎&lt;/ input&gt; &lt;input type =”radio“name =”address.town“value =”纽约“&gt;纽约&lt;/ input&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您的应用程序希望通过内部代码（例如）处理城市，则可以使用合适的密钥创建代码映射，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">protected</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; referenceData（HttpServletRequest request） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; cityMap = <span class="keyword">new</span> <span class="predefined-type">LinkedHashMap</span> &lt;&gt;（）; cityMap.put（ <span class="string"><span class="delimiter">“</span> <span class="content">LDN</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">伦敦</span> <span class="delimiter">”</span></span> ）; cityMap.put（ <span class="string"><span class="delimiter">“</span> <span class="content">PRS</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">巴黎</span> <span class="delimiter">”</span></span> ）; cityMap.put（ <span class="string"><span class="delimiter">“</span> <span class="content">纽约</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">纽约</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; model = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt;&gt;（）; model.put（ <span class="string"><span class="delimiter">“</span> <span class="content">cityMap</span> <span class="delimiter">”</span></span> ，cityMap）; <span class="keyword">回归</span>模型; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>代码现在生成输出，其中无线电值是相关代码，但用户仍然可以看到更加用户友好的城市名称，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">Town：&lt;input type =“radio”name =“address.town”value =“LDN”&gt; London &lt;/ input&gt; &lt;input type =“radio”name =“address.town”value =“PRS”checked =“checked “&gt;巴黎&lt;/ input&gt; &lt;input type =”radio“name =”address.town“value =”NYC“&gt;纽约&lt;/ input&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-views-form-macros-html-escaping"><a class="anchor" href="#mvc-views-form-macros-html-escaping"></a> HTML转义</h6>
<div class="paragraph">
<p>前面描述的表单宏的默认用法导致符合HTML 4.01的HTML元素，并且使用在<code>web.xml</code>文件中定义的HTML转义的默认值，如Spring的绑定支持所使用的那样。要使元素符合XHTML或覆盖默认的HTML转义值，您可以在模板中指定两个变量（或在模型中指定模板可见的变量）。在模板中指定它们的优点是，它们可以在模板处理中稍后更改为不同的值，以便为表单中的不同字段提供不同的行为。</p>
</div>
<div class="paragraph">
<p>要切换为标记的XHTML合规性，请为名为<code>xhtmlCompliant</code>的模型或上下文变量指定值<code>true</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">&lt;＃ -  for FreeMarker  - &gt; &lt;#assign xhtmlCompliant = true&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>处理完该指令后，Spring宏生成的任何元素现在都符合XHTML标准。</p>
</div>
<div class="paragraph">
<p>以类似的方式，您可以指定每个字段的HTML转义，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="jsp">&lt;＃ - 在此之前，使用默认的HTML转义 - &gt; &lt;#assign htmlEscape = true&gt; &lt;＃ -  next字段将使用HTML转义 - &gt; &lt;@ spring.formInput“command.name”/&gt; &lt;＃在spring&gt; &lt;＃中指定htmlEscape = false  - 所有将来的字段都将与HTML转义绑定 - &gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-groovymarkup"><a class="anchor" href="#mvc-view-groovymarkup"></a> 1.9.3。Groovy Markup</h4>
<div class="paragraph">
<p><a href="http://groovy-lang.org/templating.html#_the_markuptemplateengine">Groovy标记模板引擎</a>主要用于生成类似XML的标记（XML，XHTML，HTML5等），但您可以使用它来生成任何基于文本的内容。Spring Framework有一个内置的集成，可以将Spring MVC与Groovy Markup结合使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy标记模板引擎需要Groovy 2.3.1+。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="mvc-view-groovymarkup-configuration"><a class="anchor" href="#mvc-view-groovymarkup-configuration"></a>组态</h5>
<div class="paragraph">
<p>以下示例显示如何配置Groovy标记模板引擎：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.groovy（）; } <span class="comment">//配置Groovy标记模板引擎...</span>

    <span class="annotation">@Bean</span> <span class="directive">public</span> GroovyMarkupConfigurer groovyMarkupConfigurer（）{GroovyMarkupConfigurer configurer = <span class="keyword">new</span> GroovyMarkupConfigurer（）; configurer.setResourceLoaderPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ WEB-INF /</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中配置相同的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：groovy</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：view-resolvers&gt;</span> <span class="comment">&lt;！ - 配置Groovy标记模板引擎...  - &gt;</span> <span class="tag">&lt;mvc：groovy- configurer</span> <span class="attribute-name">resource-loader-path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ WEB-INF /</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-groovymarkup-example"><a class="anchor" href="#mvc-view-groovymarkup-example"></a>例</h5>
<div class="paragraph">
<p>与传统的模板引擎不同，Groovy Markup依赖于使用构建器语法的DSL。以下示例显示了HTML页面的示例模板：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">yieldUnescaped <span class="string"><span class="delimiter">'</span> <span class="content">&lt;！DOCTYPE html&gt;</span> <span class="delimiter">'</span></span> html（ <span class="key">lang</span> ： <span class="string"><span class="delimiter">'</span> <span class="content">en</span> <span class="delimiter">'</span></span> ）{head {meta（ <span class="string"><span class="delimiter">'</span> <span class="content">http-equiv</span> <span class="delimiter">'</span></span> ： <span class="string"><span class="delimiter">'</span> <span class="content">“Content-Type”content =“text / html; charset = utf-8”</span> <span class="delimiter">'</span></span> ）title（ <span class="string"><span class="delimiter">'</span> <span class="content">My page</span> <span class="delimiter">'</span></span> ）} body {p（ <span class="string"><span class="delimiter">'</span> <span class="content">这是HTML内容</span> <span class="delimiter">的</span> <span class="content">一个例子</span> <span class="delimiter">'</span></span> ）}}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-script"><a class="anchor" href="#mvc-view-script"></a> 1.9.4。脚本视图</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-script">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework有一个内置的集成，可以将Spring MVC与任何可以在<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java脚本引擎之上运行的模板库一起使用。我们在不同的脚本引擎上测试了以下模板库：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">脚本库</th>
<th class="tableblock halign-left valign-top">脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://handlebarsjs.com/">把手</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">胡子</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://facebook.github.io/react/">应对</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.stuartellis.eu/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://jruby.org">JRuby的</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">字符串模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.jython.org/">Jython的</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin脚本模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://kotlinlang.org/">科特林</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="mvc-view-script-dependencies"><a class="anchor" href="#mvc-view-script-dependencies"></a>要求</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-script-dependencies">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您需要在类路径上安装脚本引擎，其详细信息因脚本引擎而异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript引擎随Java 8+一起提供。强烈建议使用最新的更新版本。</p>
</li>
<li>
<p>应该添加<a href="http://jruby.org">JRuby</a>作为Ruby支持的依赖项。</p>
</li>
<li>
<p>应该添加<a href="http://www.jython.org">Jython</a>作为Python支持的依赖项。</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和<code>META-INF/services/javax.script.ScriptEngineFactory</code>文件包含<code>org.jetbrains.kotlin.script.jsr223.应该为Kotlin脚本支持添加KotlinJsr223JvmLocalScriptEngineFactory</code>行。有关详细信息，请参阅<a href="https://github.com/sdeleuze/kotlin-script-templating">此示例</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要拥有脚本模板库。对Javascript这样做的一种方法是通过<a href="http://www.webjars.org/">WebJars</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-script-integrate"><a class="anchor" href="#mvc-view-script-integrate"></a>脚本模板</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-script-integrate">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以声明<code>ScriptTemplateConfigurer</code> bean以指定要使用的脚本引擎，要加载的脚本文件，要调用以呈现模板的函数，等等。以下示例使用Mustache模板和Nashorn JavaScript引擎：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.scriptTemplate（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> ScriptTemplateConfigurer configurer（）{ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer（）; configurer.setEngineName（ <span class="string"><span class="delimiter">“</span> <span class="content">nashorn</span> <span class="delimiter">”</span></span> ）; configurer.setScripts（ <span class="string"><span class="delimiter">“</span> <span class="content">mustache.js</span> <span class="delimiter">”</span></span> ）; configurer.setRenderObject（ <span class="string"><span class="delimiter">“</span> <span class="content">Mustache</span> <span class="delimiter">”</span></span> ）; configurer.setRenderFunction（ <span class="string"><span class="delimiter">“</span> <span class="content">render</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了XML中的相同排列：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：script-template</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：script-template-configurer</span> <span class="attribute-name">engine-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">nashorn</span> <span class="delimiter">”</span></span> <span class="attribute-name">render-object</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Mustache</span> <span class="delimiter">”</span></span> <span class="attribute-name">render-function</span> = <span class="string"><span class="delimiter">“</span> <span class="content">render</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;mvc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mustache.js</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：script-template-configurer&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于Java和XML配置，控制器看起来没有什么不同，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SampleController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ sample</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> test（Model model）{model.addObject（ <span class="string"><span class="delimiter">“</span> <span class="content">title</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Sample title</span> <span class="delimiter">”</span></span> ）; model.addObject（ <span class="string"><span class="delimiter">“</span> <span class="content">body</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Sample body</span> <span class="delimiter">”</span></span> ）; <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">模板</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了Mustache模板：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html"><span class="tag">&lt;html&gt;</span> <span class="tag">&lt;head&gt;</span> <span class="tag">&lt;title&gt;</span> {{title}} <span class="tag">&lt;/ title&gt;</span> <span class="tag">&lt;/ head&gt;</span> <span class="tag">&lt;body&gt;</span> <span class="tag">&lt;p&gt;</span> {{body}} <span class="tag">&lt;/ p&gt;</span> <span class="tag">&lt;/ body&gt;</span> <span class="tag">&lt;/ html&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用以下参数调用render函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code> ：模板内容</p>
</li>
<li>
<p><code>Map model</code> ：视图模型</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code> ： <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a> ，提供对应用程序上下文，区域设置，模板加载器和URL的访问（自5.0起）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code>本身与此签名兼容，因此您可以直接调用它。</p>
</div>
<div class="paragraph">
<p>如果您的模板技术需要一些自定义，您可以提供实现自定义渲染功能的脚本。例如， <a href="http://handlebarsjs.com">Handlerbars</a>需要使用它们之前编译模板和需要<a href="http://en.wikipedia.org/wiki/Polyfill">填充工具</a>来模拟浏览器的一些设施，不可用在服务器端脚本引擎。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.scriptTemplate（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> ScriptTemplateConfigurer configurer（）{ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer（）; configurer.setEngineName（ <span class="string"><span class="delimiter">“</span> <span class="content">nashorn</span> <span class="delimiter">”</span></span> ）; configurer.setScripts（ <span class="string"><span class="delimiter">“</span> <span class="content">polyfill.js</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">handlebars.js</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">render.js</span> <span class="delimiter">”</span></span> ）; configurer.setRenderFunction（ <span class="string"><span class="delimiter">“</span> <span class="content">render</span> <span class="delimiter">”</span></span> ）; configurer.setSharedEngine（ <span class="predefined-constant">false</span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当您使用非线程安全的脚本引擎以及不是为并发而设计的模板库（例如在Nashorn上运行的Handlebars或React）时，需要将<code>sharedEngine</code>属性设置为<code>false</code> 。在这种情况下，由于<a href="https://bugs.openjdk.java.net/browse/JDK-8076099">此错误</a> ，需要Java 8u60或更高版本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code>仅定义Handlebars正常运行所需的<code>window</code>对象，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">var</span> window = {};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个基本的<code>render.js</code>实现在使用之前编译模板。生产就绪的实现还应该存储任何重用的缓存模板或预编译的模板。您可以在脚本端执行此操作（并处理您需要的任何自定义 - 例如，管理模板引擎配置）。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">render</span> （template，model）{ <span class="keyword">var</span> compiledTemplate = Handlebars.compile（template）; <span class="keyword">return</span> compileTemplate（model）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多配置示例，请查看Spring Framework单元测试， <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script">Java</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script">资源</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jsp"><a class="anchor" href="#mvc-view-jsp"></a> 1.9.5。JSP和JSTL</h4>
<div class="paragraph">
<p>Spring Framework有一个内置的集成，用于将Spring MVC与JSP和JSTL一起使用。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-resolver"><a class="anchor" href="#mvc-view-jsp-resolver"></a>查看解析器</h5>
<div class="paragraph">
<p>使用JSP进行开发时，可以声明<code>InternalResourceViewResolver</code>或<code>ResourceBundleViewResolver</code> bean。</p>
</div>
<div class="paragraph">
<p><code>ResourceBundleViewResolver</code>依赖于属性文件来定义映射到类和URL的视图名称。使用<code>ResourceBundleViewResolver</code> ，您可以通过仅使用一个解析器来混合不同类型的视图，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  ResourceBundleViewResolver  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">viewResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view。ResourceBundleViewResolver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">basename</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">views</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> ＃使用示例属性文件（WEB-INF / classes中的views.properties）：welcome。（class）= org.springframework .web.servlet.view。JstlView welcome.url = / WEB-INF / jsp / welcome.jsp productList。（class）= org.springframework.web.servlet.view。JstlView productList.url = / WEB-INF / jsp / productlist.jsp</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>InternalResourceBundleViewResolver</code>也可用于JSP。作为最佳实践，我们强烈建议将JSP文件放在<code>'WEB-INF'</code>目录下的目录中，以便客户端无法直接访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">viewResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view。InternalResourceViewResolver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">viewClass</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.web.servlet.view。JstlView</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">前缀</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="content"><span class="delimiter">=”/</span> WEB-INF / JSP /</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">后缀</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=”</span> <span class="content">的<span class="delimiter"><span class="tag">.jsp“/&gt;</span></span></span></span> <span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-jstl"><a class="anchor" href="#mvc-view-jsp-jstl"></a> JSP与JSTL</h5>
<div class="paragraph">
<p>使用Java标准标记库时，必须使用特殊的视图类<code>JstlView</code> ，因为在I18N功能之类的东西可以工作之前，JSTL需要做一些准备工作。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-tags"><a class="anchor" href="#mvc-view-jsp-tags"></a> Spring的JSP标记库</h5>
<div class="paragraph">
<p>Spring提供了请求参数与命令对象的数据绑定，如前面章节所述。为了便于JSP页面的开发以及这些数据绑定功能，Spring提供了一些标签，使事情变得更加容易。所有Spring标记都具有HTML转义功能，可以启用或禁用字符转义。</p>
</div>
<div class="paragraph">
<p><code>spring.tld</code>标记库描述符（TLD）包含在<code>spring-webmvc.jar</code> 。有关各个标签的综合参考，请浏览<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description">API参考</a>或查看标签库说明。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib"><a class="anchor" href="#mvc-view-jsp-formtaglib"></a> Spring的表单标签库</h5>
<div class="paragraph">
<p>从版本2.0开始，Spring提供了一组全面的数据绑定感知标记，用于在使用JSP和Spring Web MVC时处理表单元素。每个标记都支持其相应HTML标记对应的属性集，使标记熟悉且直观易用。标记生成的HTML符合HTML 4.01 / XHTML 1.0。</p>
</div>
<div class="paragraph">
<p>与其他表单/输入标记库不同，Spring的表单标记库与Spring Web MVC集成，使标记可以访问命令对象和控制器处理的参考数据。正如我们在以下示例中所示，表单标记使JSP更易于开发，读取和维护。</p>
</div>
<div class="paragraph">
<p>我们浏览表单标签，查看每个标签的使用方法示例。我们已经包含生成的HTML代码段，其中某些代码需要进一步评论。</p>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-configuration"><a class="anchor" href="#mvc-view-jsp-formtaglib-configuration"></a>组态</h6>
<div class="paragraph">
<p>表单标记库捆绑在<code>spring-webmvc.jar</code> 。库描述符称为<code>spring-form.tld</code> 。</p>
</div>
<div class="paragraph">
<p>要使用此库中的标记，请将以下指令添加到JSP页面的顶部：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="error">&lt;</span> ％@ taglib prefix =“form”uri =“http://www.springframework.org/tags/form”％ <span class="error">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其中<code>form</code>是要用于此库中标记的标记名称前缀。</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-formtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-formtag"></a>表格标签</h6>
<div class="paragraph">
<p>此标记呈现HTML“form”元素，并公开内部标记的绑定路径以进行绑定。它将命令对象放在<code>PageContext</code>以便内部标记可以访问命令对象。此库中的所有其他标记都是<code>form</code>标记的嵌套标记。</p>
</div>
<div class="paragraph">
<p>假设我们有一个名为<code>User</code>的域对象。它是一个JavaBean，具有<code>firstName</code>和<code>lastName</code>等属性。我们可以将它用作表单控制器的表单支持对象，它返回<code>form.jsp</code> 。以下示例显示了<code>form.jsp</code>外观：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：输入</span> <span class="attribute-name">路径</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>最后名称： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：input</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">“</span> <span class="content">2</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Save更改</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>firstName</code>和<code>lastName</code>值是从页面控制器放置在<code>PageContext</code>的命令对象中检索的。继续阅读以查看更多关于内部标记如何与<code>form</code>标记一起使用的示例。</p>
</div>
<div class="paragraph">
<p>以下清单显示了生成的HTML，它看起来像标准格式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">POST</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Harry</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>姓氏： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Potter</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">“</span> <span class="content">2</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">保存更改</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的JSP假定表单支持对象的变量名是<code>command</code> 。如果已将表单支持对象放在另一个名称下的模型中（绝对是最佳实践），则可以将表单绑定到命名变量，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form</span> <span class="attribute-name">modelAttribute</span> = <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：input</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr &gt;</span> <span class="tag">&lt;td&gt;</span>姓氏： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：输入</span> <span class="attribute-name">路径</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">“</span> <span class="content">2</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">保存更改</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-inputtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-inputtag"></a> <code>input</code>标签</h6>
<div class="paragraph">
<p>此标记默认使用绑定值和<code>type='text'</code>呈现HTML <code>input</code>元素。有关此标记的示例，请参阅<a href="#mvc-view-jsp-formtaglib-formtag">表单标记</a> 。您还可以使用特定于HTML5的类型，例如<code>email</code> ， <code>tel</code> ， <code>date</code>等。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-checkboxtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-checkboxtag"></a> <code>checkbox</code>标记</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>标记，其<code>type</code>设置为<code>checkbox</code> 。</p>
</div>
<div class="paragraph">
<p>假设我们的<code>User</code>具有诸如简报订阅和爱好列表之类的偏好。以下示例显示了<code>Preferences</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Preferences</span> { <span class="directive">private</span> <span class="type">boolean</span> receiveNewsletter; <span class="directive">私人</span> <span class="predefined-type">String</span> <span class="type">[]</span>兴趣; <span class="directive">private</span> <span class="predefined-type">String</span> favouriteWord; <span class="directive">public</span> <span class="type">boolean</span> isReceiveNewsletter（）{ <span class="keyword">return</span> receiveNewsletter; <span class="directive">public</span> <span class="type">void</span> setReceiveNewsletter（ <span class="type">boolean</span> receiveNewsletter）{ <span class="local-variable">this</span> .receiveNewsletter = receiveNewsletter; <span class="directive">public</span> <span class="predefined-type">String</span> <span class="type">[]</span> getInterests（）{ <span class="keyword">return</span> interests; <span class="directive">public</span> <span class="type">void</span> setInterests（ <span class="predefined-type">String</span> <span class="type">[]</span> interests）{ <span class="local-variable">this</span> .interests = interests; <span class="directive">public</span> <span class="predefined-type">String</span> getFavouriteWord（）{ <span class="keyword">return</span> favouriteWord; <span class="directive">public</span> <span class="type">void</span> setFavouriteWord（ <span class="predefined-type">String</span> favouriteWord）{ <span class="local-variable">this</span> .favouriteWord = favouriteWord; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>相应的<code>form.jsp</code>可能类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>订阅时事通讯？： <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - 方法1：属性类型为java.lang。Boolean  - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：checkbox</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.receiveNewsletter</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>兴趣： <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - 方法2：属性为数组或java.util类型。集合 - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> Quidditch： <span class="tag">&lt;form：checkbox</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.interests</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Quidditch</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span>草药学： <span class="tag">&lt;form：checkbox</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.interests</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Herbology</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> Defense Against黑魔法： <span class="tag">&lt;form：checkbox</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.interests</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">黑魔法防御</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>最喜欢的单词： <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - - 方法3：属性是java.lang类型。对象 - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> Magic： <span class="tag">&lt;form：checkbox</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.favouriteWord</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Magic</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>checkbox</code>标签有三种方法，可以满足您的所有复选框需求。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法一：当绑定值是<code>java.lang.类型时<code>java.lang.Boolean</code> ，所述<code>input(checkbox)</code>作为标记<code>checked</code>如果绑定的值是<code>true</code> 。<code>value</code>属性对应于<code>setValue(Object)</code> value属性的已解析值。</p>
</li>
<li>
<p>方法二：当绑定值是<code>array</code>或<code>java.util.类型时<code>java.util.如果已绑定的<code>Collection</code>存在已配置的<code>setValue(Object)</code>值，则将Collection</code> ， <code>input(checkbox)</code>标记为已<code>checked</code> 。</p>
</li>
<li>
<p>方法三：对于任何其他绑定值类型，如果配置的<code>setValue(Object)</code>等于绑定值，则<code>input(checkbox)</code>将标记为已<code>checked</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，无论采用何种方法，都会生成相同的HTML结构。以下HTML代码段定义了一些复选框：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>兴趣： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> Quidditch： <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.interests</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">checkbox</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Quidditch</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">hidden</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">_ preferences.interests</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span>草药学： <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.interests</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">checkbox</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Herbology</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">hidden</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">_ preference.interests</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span>黑暗艺术防御： <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">preferences.interests</span> <span class="delimiter">“</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">checkbox</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">黑魔法防御</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">hidden</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1</span> <span class="delimiter">“</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">_ quote 。兴趣</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可能不希望在每个复选框后看到额外的隐藏字段。如果未检查HTML页面中的复选框，则在提交表单后，其值不会作为HTTP请求参数的一部分发送到服务器，因此我们需要在HTML中使用这种奇怪的解决方法来使Spring表单数据绑定起作用。<code>checkbox</code>标签遵循现有的Spring约定，包括每个复选框的前缀为下划线（ <code>_</code> ）的隐藏参数。通过这样做，你有效地告诉Spring“复选框在表单中是可见的，我希望表单数据绑定的对象反映复选框的状态，无论如何。”</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-checkboxestag"><a class="anchor" href="#mvc-view-jsp-formtaglib-checkboxestag"></a>标签<code>checkboxes</code></h6>
<div class="paragraph">
<p>此标记呈现多个HTML <code>input</code>标记，其<code>type</code>设置为<code>checkbox</code> 。</p>
</div>
<div class="paragraph">
<p>本节基于上一个<code>checkbox</code>标记部分的示例。有时，您不希望在JSP页面中列出所有可能的爱好。您宁愿在运行时提供可用选项的列表，并将其传递给标记。这就是<code>checkboxes</code>标签的用途。您可以传入包含<code>items</code>属性中可用选项的<code>Array</code> ， <code>List</code>或<code>Map</code> 。通常，绑定属性是一个集合，因此它可以保存用户选择的多个值。以下示例显示了使用此标记的JSP：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>兴趣： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="error">&lt;</span> ％ - 属性是数组或java.util类型。集合 - ％ <span class="error">&gt;</span> <span class="tag">&lt;form：checkboxes</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preferences.interests</span> <span class="delimiter">”</span></span> <span class="attribute-name">items</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {interestList}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此示例假定<code>interestList</code>是可用作模型属性的<code>List</code> ，其中包含要从中选择的值的字符串。如果使用<code>Map</code> ，则使用映射条目键作为值，并将映射条目的值用作要显示的标签。您还可以使用自定义对象，您可以使用<code>itemValue</code>提供值的属性名称，使用<code>itemLabel</code>标签。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-radiobuttontag"><a class="anchor" href="#mvc-view-jsp-formtaglib-radiobuttontag"></a> <code>radiobutton</code>标签</h6>
<div class="paragraph">
<p>此标记呈现<code>type</code>设置为<code>radio</code>的HTML <code>input</code>元素。</p>
</div>
<div class="paragraph">
<p>典型的使用模式涉及绑定到同一属性但具有不同值的多个标记实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>性别： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span>男： <span class="tag">&lt;form：radiobutton</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sex</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">M</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;br</span> <span class="tag">/&gt;</span>女： <span class="tag">&lt;form：radiobutton</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sex</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">F</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-radiobuttonstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-radiobuttonstag"></a> <code>radiobuttons</code>标签</h6>
<div class="paragraph">
<p>此标记呈现多个HTML <code>input</code>元素， <code>type</code>设置为<code>radio</code> 。</p>
</div>
<div class="paragraph">
<p>与<a href="#mvc-view-jsp-formtaglib-checkboxestag"><code>checkboxes</code>标记一样</a> ，您可能希望将可用选项作为运行时变量传递。对于此用法，您可以使用<code>radiobuttons</code>标记。传入包含<code>items</code>属性中可用选项的<code>Array</code> ， <code>List</code>或<code>Map</code> 。如果使用<code>Map</code> ，则使用映射条目键作为值，并将映射条目的值用作要显示的标签。您还可以使用自定义对象，您可以使用<code>itemValue</code>提供值的属性名称，使用<code>itemLabel</code>标签，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>性别： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：radiobuttons</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sex</span> <span class="delimiter">”</span></span> <span class="attribute-name">items</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {sexOptions}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-passwordtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-passwordtag"></a> <code>password</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>标记，其类型设置为带有绑定值的<code>password</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>密码： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：password</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，默认情况下，不显示密码值。如果确实需要显示密码值，可以将<code>showPassword</code>属性的值设置为<code>true</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>密码： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：password</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">^ 76525bvHGq</span> <span class="delimiter">”</span></span> <span class="attribute-name">showPassword</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-selecttag"><a class="anchor" href="#mvc-view-jsp-formtaglib-selecttag"></a> <code>select</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML“select”元素。它支持数据绑定到所选选项以及使用嵌套<code>option</code>和<code>options</code>标记。</p>
</div>
<div class="paragraph">
<p>假设<code>User</code>有一个技能列表。相应的HTML可以如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>技能： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：select</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">skills</span> <span class="delimiter">”</span></span> <span class="attribute-name">items</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {skills}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果<code>User's</code>技能在草药学中，则“技能”行的HTML源可能如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>技能： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;select</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">skills</span> <span class="delimiter">”</span></span> <span class="attribute-name">multiple</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Potions</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> Potions <span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Herbology</span> <span class="delimiter">”</span></span> <span class="attribute-name">selected</span> = <span class="string"><span class="delimiter">“已</span> <span class="content">选择</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>草药学<span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;选项</span> <span class="attribute-name">值</span> = <span class="string"><span class="delimiter">“</span> <span class="content">魁地奇</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>魁地奇<span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;/ select&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-optiontag"><a class="anchor" href="#mvc-view-jsp-formtaglib-optiontag"></a> <code>option</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>option</code>元素。它根据绑定值设置<code>selected</code> 。以下HTML显示了它的典型输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span> House： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：select</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">house</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;form：option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Gryffindor</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;form：option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Hufflepuff</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;form： option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Ravenclaw</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;form：option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Slytherin</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ form：select&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果<code>User's</code>房子在格兰芬多，那么'House'行的HTML源代码如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span> House： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;select</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">house</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Gryffindor</span> <span class="delimiter">”</span></span> <span class="attribute-name">selected</span> = <span class="string"><span class="delimiter">“</span> <span class="content">selected</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> Gryffindor <span class="tag">&lt;/ option&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Hufflepuff</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> Hufflepuff <span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Ravenclaw</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> Ravenclaw <span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Slytherin</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> Slytherin <span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;/ select&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ TR&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>请注意添加<code>selected</code>属性。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-optionstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-optionstag"></a> <code>options</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>option</code>元素的列表。它根据绑定值设置<code>selected</code>属性。以下HTML显示了它的典型输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>国家<span class="tag">/</span>地区： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：select</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">country</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;form：option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">-</span> <span class="delimiter">”</span></span> <span class="attribute-name">label</span> = <span class="string"><span class="delimiter">“</span></span> <span class="string"><span class="content">- 请</span></span> <span class="string"><span class="content">选择</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;form：options</span> <span class="attribute-name">items</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {countryList}</span> <span class="delimiter">”</span></span> <span class="attribute-name">itemValue</span> = <span class="string"><span class="delimiter">“</span> <span class="content">code</span> <span class="delimiter">”</span></span> <span class="attribute-name">itemLabel</span> = <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ form：select&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果<code>User</code>居住在英国，“国家/地区”行的HTML源代码如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>国家<span class="tag">/</span>地区： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;select</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">country</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">-</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="string"><span class="content">- 请</span></span>选择<span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;option</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">AT</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>奥地利<span class="tag">&lt;/选项&gt;</span> <span class="tag">&lt;选项</span> <span class="attribute-name">值</span> = <span class="string"><span class="delimiter">“</span> <span class="content">英国</span> <span class="delimiter">”</span></span> <span class="attribute-name">选择</span> = <span class="string"><span class="delimiter">“</span> <span class="content">选定</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>英国<span class="tag">&lt;/ option&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;期权</span> <span class="attribute-name">价值</span> = <span class="string"><span class="delimiter">“</span> <span class="content">美国</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>美国<span class="tag">&lt;/ option&gt;</span> <span class="tag">&lt;/ select&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>请注意添加<code>selected</code>属性。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如前面的示例所示， <code>option</code>标签与<code>options</code>标签的组合使用生成相同的标准HTML，但允许您在JSP中显式指定仅用于显示的值（它所属的位置），例如，例如：“ - 请选择”。</p>
</div>
<div class="paragraph">
<p><code>items</code>属性通常使用项目对象的集合或数组填充。
<code>itemValue</code>和<code>itemLabel</code>引用这些项目对象的bean属性（如果已指定）。否则，项目对象本身将变为字符串。或者，您可以指定项目的<code>Map</code> ，在这种情况下，地图关键字被解释为选项值，地图值对应于选项标签。如果恰好也指定了<code>itemValue</code>或<code>itemLabel</code> （或两者），则item value属性将应用于map键，而item label属性将应用于map值。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-textareatag"><a class="anchor" href="#mvc-view-jsp-formtaglib-textareatag"></a> <code>textarea</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>textarea</code>元素。以下HTML显示了它的典型输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>注意： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：textarea</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">notes</span> <span class="delimiter">”</span></span> <span class="attribute-name">rows</span> = <span class="string"><span class="delimiter">“</span> <span class="content">3</span> <span class="delimiter">”</span></span> <span class="attribute-name">cols</span> = <span class="string"><span class="delimiter">“</span> <span class="content">20</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：errors</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">注意</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-hiddeninputtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-hiddeninputtag"></a> <code>hidden</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>标记，其<code>type</code>设置为<code>hidden</code>具有绑定值。要提交未绑定的隐藏值，请使用<code>type</code>设置为<code>hidden</code>的HTML <code>input</code>标记。以下HTML显示了它的典型输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：hidden</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">house</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们选择将<code>house</code>价值作为隐藏<code>house</code>提交，则HTML将如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">house</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">hidden</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Gryffindor</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-errorstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-errorstag"></a> <code>errors</code>标签</h6>
<div class="paragraph">
<p>此标记在HTML <code>span</code>元素中呈现字段错误。它可以访问控制器中创建的错误或由与控制器关联的任何验证器创建的错误。</p>
</div>
<div class="paragraph">
<p>假设我们要在提交表单后显示<code>firstName</code>和<code>lastName</code>字段的所有错误消息。我们有一个名为<code>UserValidator</code>的<code>User</code>类实例的验证器，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">UserValidator</span> <span class="directive">实现</span> <span class="predefined-type">Validator</span> { <span class="directive">public</span> <span class="type">boolean</span> supports（ <span class="predefined-type">Class</span> candidate）{ <span class="keyword">return</span> User.class.isAssignableFrom（candidate）; <span class="directive">public</span> <span class="type">void</span> validate（ <span class="predefined-type">Object</span> obj，Errors errors）{ValidationUtils.rejectIfEmptyOrWhitespace（errors， <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">required</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Field is required。</span> <span class="delimiter">”</span></span> ）; ValidationUtils.rejectIfEmptyOrWhitespace（errors， <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">required</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Field is required。</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>form.jsp</code>可以如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：输入</span> <span class="attribute-name">路径</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - 显示firstName字段的错误 - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：errors</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>姓氏： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：input</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="tag">/ &gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - 显示lastName字段的错误 - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：errors</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">“</span> <span class="content">3</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">保存更改</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们在<code>firstName</code>和<code>lastName</code>字段中提交一个空值的表单，则HTML将如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">POST</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - 显示firstName字段的相关错误 - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;span</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName.errors</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>字段是必需的。 <span class="tag">&lt;/ span&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>姓氏： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="error">&lt;</span> ％ - 显示的lastName字段的关联错误 - ％ <span class="error">&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;span</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName.errors</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>字段是必需的。 <span class="tag">&lt;/ span&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">“</span> <span class="content">3</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">保存更改</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ FORM&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们想显示给定页面的整个错误列表怎么办？下一个示例显示<code>errors</code>标记还支持一些基本的通配符功能。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path="*"</code> ：显示所有错误。</p>
</li>
<li>
<p><code>path="lastName"</code> ：显示与<code>lastName</code>字段关联的所有错误。</p>
</li>
<li>
<p>如果省略<code>path</code> ，则仅显示对象错误。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示页面顶部的错误列表，然后是字段旁边的字段特定错误：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form&gt;</span> <span class="tag">&lt;form：errors</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="attribute-name">cssClass</span> = <span class="string"><span class="delimiter">“</span> <span class="content">errorBox</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：input</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="tag">/ &gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：errors</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>姓氏： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：input</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;form：errors</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">lastName</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">”</span> <span class="content">3</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">submit</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">保存更改</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>HTML将如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">POST</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;span</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">* .errors</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">errorBox</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>字段是必需的。 <span class="tag">&lt;br</span> <span class="tag">/&gt;</span>现场是必需的。 <span class="tag">&lt;/ span&gt;</span> <span class="tag">&lt;table&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>名字： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;span</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">firstName.errors</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>字段是必需的。 <span class="tag">&lt;/ span&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td&gt;</span>姓氏： <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;td&gt;</span> <span class="tag">&lt;span</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lastName.errors</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>字段是必需的。 <span class="tag">&lt;/ span&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;tr&gt;</span> <span class="tag">&lt;td</span> <span class="attribute-name">colspan</span> = <span class="string"><span class="delimiter">“</span> <span class="content">3</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">保存更改</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ td&gt;</span> <span class="tag">&lt;/ tr&gt;</span> <span class="tag">&lt;/ table&gt;</span> <span class="tag">&lt;/ FORM&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所述<code>spring-form.tld</code>标记库描述符（TLD）被包括在<code>spring-webmvc.jar</code> 。有关各个标签的综合参考，请浏览<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#package.description">API参考</a>或查看标签库说明。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-rest-method-conversion"><a class="anchor" href="#mvc-rest-method-conversion"></a> HTTP方法转换</h6>
<div class="paragraph">
<p>REST的一个关键原则是使用“统一接口”。这意味着可以使用相同的四种HTTP方法操作所有资源（URL）：GET，PUT，POST和DELETE。对于每个方法，HTTP规范定义了确切的语义。例如，GET应该始终是一个安全的操作，这意味着它没有副作用，PUT或DELETE应该是幂等的，这意味着你可以反复重复这些操作，但最终结果应该是相同的。虽然HTTP定义了这四种方法，但HTML只支持两种：GET和POST。幸运的是，有两种可能的解决方法：您可以使用JavaScript来执行PUT或DELETE，也可以使用“real”方法作为附加参数进行POST（在HTML表单中建模为隐藏输入字段）。Spring的<code>HiddenHttpMethodFilter</code>使用了后一种技巧。这个过滤器是一个普通的Servlet过滤器，因此，它可以与任何Web框架（不仅仅是Spring MVC）结合使用。将此过滤器添加到web.xml，并将带有隐藏<code>method</code>参数的POST转换为相应的HTTP方法请求。</p>
</div>
<div class="paragraph">
<p>为了支持HTTP方法转换，更新了Spring MVC表单标记以支持设置HTTP方法。例如，以下代码段来自Pet Clinic示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;form：form</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">delete</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;p</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">删除宠物</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ p&gt;</span> <span class="tag">&lt;/ form：form&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例执行HTTP POST，其中“real”DELETE方法隐藏在请求参数后面。它由<code>HiddenHttpMethodFilter</code> ，它在web.xml中定义，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;filter&gt; &lt;filter-name&gt; httpMethodFilter &lt;/ filter-name&gt; &lt;filter- <span class="type">class</span> &gt; <span class="class">org</span> .springframework.web.filter。HiddenHttpMethodFilter &lt;/ filter- <span class="type">class</span> &gt; &lt;/ <span class="class">filter</span> &gt; &lt;filter-mapping&gt; &lt;filter-name&gt; httpMethodFilter &lt;/ filter-name&gt; &lt;servlet-name&gt; petclinic &lt;/ servlet-name&gt; &lt;/ filter-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的<code>@Controller</code>方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestMapping</span> （method = RequestMethod。DELETE） <span class="directive">public</span> <span class="predefined-type">String</span> deletePet（ <span class="annotation">@PathVariable</span> <span class="type">int</span> ownerId， <span class="annotation">@ PathVariable</span> <span class="type">int</span> petId）{ <span class="local-variable">this</span> .clinic.deletePet（petId）; <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">redirect：/ owners /</span> <span class="delimiter">”</span></span> + ownerId; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-html5"><a class="anchor" href="#mvc-view-jsp-formtaglib-html5"></a> HTML5标签</h6>
<div class="paragraph">
<p>Spring表单标记库允许输入动态属性，这意味着您可以输入任何HTML5特定属性。</p>
</div>
<div class="paragraph">
<p>表单<code>input</code>标记支持输入<code>text</code>以外的类型属性。这旨在允许呈现新的HTML5特定输入类型，例如<code>email</code> ， <code>date</code> ， <code>range</code>等。请注意，不需要输入<code>type='text'</code> ，因为<code>text</code>是默认类型。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-tiles"><a class="anchor" href="#mvc-view-tiles"></a> 1.9.6。瓷砖</h4>
<div class="paragraph">
<p>您可以在使用Spring的Web应用程序中集成Tiles  - 就像任何其他视图技术一样。本节以广泛的方式介绍了如何执行此操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本节重点介绍Spring在<code>org.springframework.web.servlet.view.tiles3</code>包中对Tiles版本3的支持。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="mvc-view-tiles-dependencies"><a class="anchor" href="#mvc-view-tiles-dependencies"></a>依赖</h5>
<div class="paragraph">
<p>为了能够使用Tiles，您必须在Tiles 3.0.1或更高版本上添加依赖项<a href="http://tiles.apache.org/framework/dependency-management.html">及其</a>对项目的<a href="http://tiles.apache.org/framework/dependency-management.html">传递依赖性</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-tiles-integrate"><a class="anchor" href="#mvc-view-tiles-integrate"></a>组态</h5>
<div class="paragraph">
<p>为了能够使用Tiles，您必须使用包含定义的文件对其进行配置（有关定义和其他Tiles概念的基本信息，请参阅<a href="http://tiles.apache.org" class="bare">http://tiles.apache.org</a> ）。在Spring中，这是通过使用<code>TilesConfigurer</code>完成的。以下示例<code>ApplicationContext</code>配置显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">tilesConfigurer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.tiles3。TilesConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">definitions</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/general.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/widgets.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value &gt;</span> /WEB-INF/defs/administrator.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/customer.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/templates.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt; / list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例定义了包含定义的五个文件。这些文件都位于<code>WEB-INF/defs</code>目录中。在初始化<code>WebApplicationContext</code> ，将加载文件，并初始化定义工厂。完成此操作后，定义文件中包含的Tiles可用作Spring Web应用程序中的视图。为了能够使用这些视图，您必须拥有与<code>ViewResolver</code>一起使用的任何其他视图技术的<code>ViewResolver</code> 。您可以使用两种实现中的任何一种， <code>UrlBasedViewResolver</code>和<code>ResourceBundleViewResolver</code> 。</p>
</div>
<div class="paragraph">
<p>您可以通过添加下划线然后添加区域设置来指定特定于区域设置的Tiles定义，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">tilesConfigurer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.tiles3。TilesConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">definitions</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/tiles.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/tiles_fr_FR.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用上述配置， <code>tiles_fr_FR.xml</code>用于具有<code>fr_FR</code>语言环境的请求，默认情况下使用<code>tiles.xml</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于下划线用于表示区域设置，因此我们建议不要在Tiles定义的文件名中使用它们。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="mvc-view-tiles-url"><a class="anchor" href="#mvc-view-tiles-url"></a>使用<code>UrlBasedViewResolver</code></h6>
<div class="paragraph">
<p><code>UrlBasedViewResolver</code>为它必须解析的每个视图实例化给定的<code>viewClass</code> 。以下bean定义了<code>UrlBasedViewResolver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">viewResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view。UrlBasedViewResolver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">viewClass</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.web.servlet.view.tiles3。TilesView</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-tiles-resource"><a class="anchor" href="#mvc-view-tiles-resource"></a>使用<code>ResourceBundleViewResolver</code></h6>
<div class="paragraph">
<p>必须为<code>ResourceBundleViewResolver</code>提供一个属性文件，该文件包含解析程序可以使用的视图名称和视图类。以下示例显示了<code>ResourceBundleViewResolver</code>的bean定义以及相应的视图名称和视图类（取自Pet Clinic示例）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">viewResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view。ResourceBundleViewResolver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">basename</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">views</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">...welcomeView。（ <span class="type">class</span> ）= <span class="class">org</span> .springframework.web.servlet.view.tiles3。TilesView welcomeView.url = welcome（ <span class="local-variable">这</span>是Tiles定义的名称）vetsView。（ <span class="type">class</span> ）= <span class="class">org</span> .springframework.web.servlet.view.tiles3。TilesView vetsView.url = vetsView（再次， <span class="local-variable">这</span>是Tiles定义的名称）findOwnersForm。（ <span class="type">class</span> ）= <span class="class">org</span> .springframework.web.servlet.view。JstlView findOwnersForm.url = / WEB-INF / jsp / findOwners.jsp ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用<code>ResourceBundleViewResolver</code> ，可以轻松混合使用不同的视图技术。</p>
</div>
<div class="paragraph">
<p>请注意， <code>TilesView</code>类支持JSTL（JSP标准标记库）。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-tiles-preparer"><a class="anchor" href="#mvc-view-tiles-preparer"></a>使用<code>SimpleSpringPreparerFactory</code>和<code>SpringBeanPreparerFactory</code></h6>
<div class="paragraph">
<p>作为一项高级功能，Spring还支持两种特殊的Tiles <code>PreparerFactory</code>实现。有关如何在Tiles定义文件中使用<code>ViewPreparer</code>引用的详细信息，请参阅Tiles文档。</p>
</div>
<div class="paragraph">
<p>您可以指定<code>SimpleSpringPreparerFactory</code>以基于指定的<code>SimpleSpringPreparerFactory</code>自动装配<code>ViewPreparer</code>实例，应用Spring的容器回调以及应用已配置的Spring BeanPostProcessors。如果已激活Spring的上下文范围注释配置，则会自动检测并应用<code>ViewPreparer</code>类中的注释。请注意，这需要Tiles定义文件中的preparer类，作为默认的<code>PreparerFactory</code> 。</p>
</div>
<div class="paragraph">
<p>您可以指定<code>SpringBeanPreparerFactory</code>来操作指定的<code>SpringBeanPreparerFactory</code>名称（而不是类），从DispatcherServlet的应用程序上下文中获取相应的Spring bean。在这种情况下，完整的bean创建过程控制着Spring应用程序上下文，允许使用显式依赖项注入配置，作用域bean等。请注意，您需要为每个preparer名称定义一个Spring bean定义（在Tiles定义中使用）。以下示例显示如何在<code>TilesConfigurer</code> bean上定义一个<code>SpringBeanPreparerFactory</code>属性集：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">tilesConfigurer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.tiles3。TilesConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">definitions</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/general.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/widgets.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value &gt;</span> /WEB-INF/defs/administrator.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/customer.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> /WEB-INF/defs/templates.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt; / list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 将编写器名称解析为Spring bean定义名称 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">preparerFactoryClass</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.tiles3。SpringBeanPreparerFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-feeds"><a class="anchor" href="#mvc-view-feeds"></a> 1.9.7。RSS和Atom</h4>
<div class="paragraph">
<p><code>AbstractAtomFeedView</code>和<code>AbstractRssFeedView</code>都继承自<code>AbstractFeedView</code>基类，分别用于提供Atom和RSS Feed视图。它们基于java.net的<a href="https://rome.dev.java.net">ROME</a>项目，位于<code>org.springframework.web.servlet.view.feed</code>包中。</p>
</div>
<div class="paragraph">
<p><code>AbstractAtomFeedView</code>要求您实现<code>buildFeedEntries()</code>方法并可选地覆盖<code>buildFeedMetadata()</code>方法（默认实现为空）。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SampleContentAtomView</span> <span class="directive">延伸</span> AbstractAtomFeedView <span class="annotation">{@覆盖</span> <span class="directive">保护</span> <span class="type">无效</span> buildFeedMetadata（ <span class="predefined-type">地图</span> &lt; <span class="predefined-type">字符串</span> ， <span class="predefined-type">对象</span> &gt;模型，饲料饲料，HttpServletRequest的请求<span class="comment">）{//执行省略</span> } <span class="annotation">@覆盖</span> <span class="directive">保护</span> <span class="predefined-type">列表</span> &lt;输入&gt; buildFeedEntries（ <span class="predefined-type">地图</span> &lt; <span class="predefined-type">字符串</span> ， <span class="predefined-type">对象</span> &gt;模型，HttpServletRequest的请求，HttpServletResponse响应） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="comment">//实现省略</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类似的要求适用于实现<code>AbstractRssFeedView</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SampleContentAtomView</span> <span class="directive">延伸</span> AbstractRssFeedView <span class="annotation">{@覆盖</span> <span class="directive">保护</span> <span class="type">无效</span> buildFeedMetadata（ <span class="predefined-type">地图</span> &lt; <span class="predefined-type">字符串</span> ， <span class="predefined-type">对象</span> &gt;模型，进料<span class="predefined-type">通道</span> ，HttpServletRequest的请求<span class="comment">）{//执行省略</span> } <span class="annotation">@覆盖</span> <span class="directive">保护</span> <span class="predefined-type">列表</span>的&lt;item&gt; buildFeedItems（ <span class="predefined-type">地图</span> &lt; <span class="predefined-type">字符串</span> ， <span class="predefined-type">对象</span> &gt;模型，HttpServletRequest的请求，HttpServletResponse响应） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="comment">//实现省略</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您需要访问Locale， <code>buildFeedItems()</code>和<code>buildFeedEntries()</code>方法会传入HTTP请求。HTTP响应仅用于设置cookie或其他HTTP标头。方法返回后，Feed会自动写入响应对象。</p>
</div>
<div class="paragraph">
<p>有关创建Atom视图的示例，请参阅Alef Arendsen的Spring Team Blog <a href="https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support">条目</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-document"><a class="anchor" href="#mvc-view-document"></a> 1.9.8。PDF和Excel</h4>
<div class="paragraph">
<p>Spring提供了返回HTML以外的输出的方法，包括PDF和Excel电子表格。本节介绍如何使用这些功能。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-document-intro"><a class="anchor" href="#mvc-view-document-intro"></a>文档视图简介</h5>
<div class="paragraph">
<p>HTML页面并不总是用户查看模型输出的最佳方式，而Spring可以轻松地从模型数据动态生成PDF文档或Excel电子表格。该文档是视图，并从具有正确内容类型的服务器流式传输到（希望）使客户端PC能够运行其电子表格或PDF查看器应用程序作为响应。</p>
</div>
<div class="paragraph">
<p>要使用Excel视图，需要将Apache POI库添加到类路径中。对于PDF生成，您需要添加（最好）OpenPDF库。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果可能，您应该使用最新版本的基础文档生成库。特别是，我们强烈建议使用OpenPDF（例如，OpenPDF 1.0.5）而不是过时的原始iText 2.1.7，因为OpenPDF是主动维护的，并修复了不受信任的PDF内容的重要漏洞。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-document-pdf"><a class="anchor" href="#mvc-view-document-pdf"></a> PDF视图</h5>
<div class="paragraph">
<p>单词列表的简单PDF视图可以扩展<code>org.springframework.web.servlet.view.document.AbstractPdfView</code> <code>buildPdfDocument()</code>并实现<code>buildPdfDocument()</code>方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">PdfWordList</span> <span class="directive">扩展</span> AbstractPdfView { <span class="directive">protected</span> <span class="type">void</span> buildPdfDocument（ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; model， <span class="predefined-type">Document</span> doc，PdfWriter writer，HttpServletRequest request，HttpServletResponse response） <span class="directive">抛出</span> <span class="exception">Exception</span> { <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; words =（ <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt;）model.get（ <span class="string"><span class="delimiter">“</span> <span class="content">wordList</span> <span class="delimiter">“</span></span> ）; <span class="keyword">for</span> （ <span class="predefined-type">String</span> word：words）{doc.add（ <span class="keyword">new</span> Paragraph（word））; }}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>控制器可以从外部视图定义（通过名称引用它）返回这样的视图，也可以从处理程序方法返回<code>View</code>实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-document-pdf"><a class="anchor" href="#mvc-view-document-pdf"></a> Excel视图</h5>
<div class="paragraph">
<p>自Spring Framework 4.2以来， <code>org.springframework.web.servlet.view.document.AbstractXlsView</code>作为Excel视图的基类提供。它基于Apache POI，具有专门的子类（ <code>AbstractXlsxView</code>和<code>AbstractXlsxStreamingView</code> ），取代了过时的<code>AbstractExcelView</code>类。</p>
</div>
<div class="paragraph">
<p>编程模型类似于<code>AbstractPdfView</code> ， <code>buildExcelDocument()</code>作为中心模板方法，控制器能够从外部定义（通过名称）返回这样的视图，或者从处理程序方法返回<code>View</code>实例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jackson"><a class="anchor" href="#mvc-view-jackson"></a> 1.9.9。杰克逊</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-httpmessagewriter">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring为Jackson JSON库提供支持。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-json-mapping"><a class="anchor" href="#mvc-view-json-mapping"></a>基于杰克逊的JSON视图</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-httpmessagewriter">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>MappingJackson2JsonView</code>使用Jackson库的<code>ObjectMapper</code>将响应内容呈现为JSON。默认情况下，模型映射的全部内容（特定于框架的类除外）都编码为JSON。对于需要过滤地图内容的情况，您可以使用<code>modelKeys</code>属性指定要编码的特定模型属性集。您还可以使用<code>extractValueFromSingleKeyModel</code>属性来直接提取和序列化单键模型中的值，而不是作为模型属性的映射。</p>
</div>
<div class="paragraph">
<p>您可以使用Jackson提供的注释根据需要自定义JSON映射。当您需要进一步控制时，可以通过<code>ObjectMapper</code>属性注入自定义<code>ObjectMapper</code> ，以用于需要为特定类型提供自定义JSON序列化程序和反序列化程序的情况。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-xml-mapping"><a class="anchor" href="#mvc-view-xml-mapping"></a>基于Jackson的XML视图</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-httpmessagewriter">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>MappingJackson2XmlView</code>使用<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML扩展的</a> <code>XmlMapper</code>将响应内容呈现为XML。如果模型包含多个条目，则应使用<code>modelKey</code> bean属性显式设置要序列化的对象。如果模型包含单个条目，则会自动序列化。</p>
</div>
<div class="paragraph">
<p>您可以使用JAXB或Jackson提供的注释根据需要自定义XML映射。当您需要进一步控制时，可以通过<code>ObjectMapper</code>属性注入自定义<code>XmlMapper</code> ，以便自定义XML需要为特定类型提供序列化程序和反序列化程序。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xml-marshalling"><a class="anchor" href="#mvc-view-xml-marshalling"></a> 1.9.10。XML编组</h4>
<div class="paragraph">
<p><code>MarshallingView</code>使用XML <code>Marshaller</code> （在<code>org.springframework.oxm</code>包中定义）将响应内容呈现为XML。您可以使用<code>MarshallingView</code>实例的<code>modelKey</code> bean属性显式设置要编组的对象。或者，视图会迭代所有模型属性，并封送<code>Marshaller</code>支持的第一种类型。有关<code>org.springframework.oxm</code>包中功能的更多信息，请参阅<a href="data-access.html#oxm">使用O / X Mappers编组XML</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xslt"><a class="anchor" href="#mvc-view-xslt"></a> 1.9.11。XSLT视图</h4>
<div class="paragraph">
<p>XSLT是XML的转换语言，在Web应用程序中作为视图技术很受欢迎。如果您的应用程序自然地处理XML或者您的模型可以轻松转换为XML，那么XSLT可以作为视图技术的一个很好的选择。以下部分显示如何将XML文档生成为模型数据，并在Spring Web MVC应用程序中使用XSLT进行转换。</p>
</div>
<div class="paragraph">
<p>这个例子是一个简单的Spring应用程序，它在<code>Controller</code>中创建一个单词列表并将它们添加到模型映射中。返回映射以及XSLT视图的视图名称。有关Spring Web MVC的<code>Controller</code>接口的详细信息，请参阅带<a href="#mvc-controller">注释</a>的<code>Controller</code> 。XSLT控制器将单词列表转换为准备转换的简单XML文档。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-xslt-beandefs"><a class="anchor" href="#mvc-view-xslt-beandefs"></a>豆</h5>
<div class="paragraph">
<p>配置是简单的Spring Web应用程序的标准配置：MVC配置必须定义<code>XsltViewResolver</code> bean和常规MVC注释配置。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EnableWebMvc</span> <span class="annotation">@ComponentScan</span> <span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer { <span class="annotation">@Bean</span> <span class="directive">public</span> XsltViewResolver xsltViewResolver（）{XsltViewResolver viewResolver = <span class="keyword">new</span> XsltViewResolver（）; viewResolver.setPrefix（ <span class="string"><span class="delimiter">“</span> <span class="content">/ WEB-INF / xsl /</span> <span class="delimiter">”</span></span> ）; viewResolver.setSuffix（ <span class="string"><span class="delimiter">“。</span> <span class="content">xslt</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> viewResolver; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-xslt-controllercode"><a class="anchor" href="#mvc-view-xslt-controllercode"></a>调节器</h5>
<div class="paragraph">
<p>我们还需要一个封装我们的字生成逻辑的Controller。</p>
</div>
<div class="paragraph">
<p>控制器逻辑封装在<code>@Controller</code>类中，处理程序方法定义如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">XsltController</span> { <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> home（Model model） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="predefined-type">Document</span> document = <span class="predefined-type">DocumentBuilderFactory</span> .newInstance（）。newDocumentBuilder（）。newDocument（）; <span class="predefined-type">元素</span> root = document.createElement（ <span class="string"><span class="delimiter">“</span> <span class="content">wordList</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; words = <span class="predefined-type">Arrays</span> .asList（ <span class="string"><span class="delimiter">“</span> <span class="content">Hello</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Spring</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Framework</span> <span class="delimiter">”</span></span> ）; <span class="keyword">for</span> （ <span class="predefined-type">String</span> word：words）{ <span class="predefined-type">Element</span> wordNode = document.createElement（ <span class="string"><span class="delimiter">“</span> <span class="content">word</span> <span class="delimiter">”</span></span> ）; Text textNode = document.createTextNode（word）; wordNode.appendChild（textNode）; root.appendChild（wordNode）; } model.addAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">wordList</span> <span class="delimiter">”</span></span> ，root）; <span class="keyword">回归</span> <span class="string"><span class="delimiter">“</span> <span class="content">家</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>到目前为止，我们只创建了一个DOM文档并将其添加到模型映射中。请注意，您还可以将XML文件作为<code>Resource</code>加载并使用它而不是自定义DOM文档。</p>
</div>
<div class="paragraph">
<p>有一些软件包可以自动“控制”对象图，但是，在Spring中，您可以完全灵活地以您选择的任何方式从模型中创建DOM。这可以防止XML的转换在模型数据的结构中扮演太大的角色，这在使用工具管理DOM化过程时是一种危险。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-xslt-transforming"><a class="anchor" href="#mvc-view-xslt-transforming"></a>转型</h5>
<div class="paragraph">
<p>最后， <code>XsltViewResolver</code>解析“home”XSLT模板文件并将DOM文档合并到其中以生成我们的视图。如<code>XsltViewResolver</code>配置中所示，XSLT模板位于<code>WEB-INF/xsl</code>目录中的<code>war</code>文件中，并以<code>xslt</code>文件扩展名结尾。</p>
</div>
<div class="paragraph">
<p>以下示例显示了XSLT转换：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“utf-8”？&gt;</span> <span class="tag">&lt;xsl：stylesheet</span> <span class="attribute-name">version</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1.0</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsl</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/1999/XSL/Transform</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;xsl：output</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">html</span> <span class="delimiter">”</span></span> <span class="attribute-name">omit-xml-declaration</span> = <span class="string"><span class="delimiter">“</span> <span class="content">yes</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;xsl：template</span> <span class="attribute-name">match</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;html&gt;</span> <span class="tag">&lt;head&gt;</span> <span class="tag">&lt;title&gt;</span>你好！<span class="tag">&lt;/ title&gt;</span> <span class="tag">&lt;/ head&gt;</span> <span class="tag">&lt;body&gt;</span> <span class="tag">&lt;h1&gt;</span>我的第一句话<span class="tag">&lt;/ h1&gt;</span> <span class="tag">&lt;ul&gt;</span> <span class="tag">&lt;xsl：apply-templates</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ ul&gt;</span> <span class="tag">&lt;/ body&gt;</span> <span class="tag">&lt;/ html&gt;</span> <span class="tag">&lt;/ xsl：template&gt;</span> <span class="tag">&lt;xsl：template</span> <span class="attribute-name">match</span> = <span class="string"><span class="delimiter">“</span> <span class="content">word</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;li&gt;</span> <span class="tag">&lt;xsl：value-of</span> <span class="attribute-name">select</span> = <span class="string"><span class="delimiter">“</span> <span class="content">。</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ li&gt;</span> <span class="tag">&lt;/ xsl：template&gt;</span> <span class="tag">&lt;/ xsl：stylesheet&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述转换呈现为以下HTML：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="html"><span class="tag">&lt;html&gt;</span> <span class="tag">&lt;head&gt;</span> <span class="tag">&lt;META</span> <span class="attribute-name">http-equiv</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Content-Type</span> <span class="delimiter">”</span></span> <span class="attribute-name">content</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text / html; charset = UTF-8</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;title&gt;</span>您好！<span class="tag">&lt;/ title&gt;</span> <span class="tag">&lt;/ head&gt;</span> <span class="tag">&lt;body&gt;</span> <span class="tag">&lt;h1&gt;</span>我的第一句话<span class="tag">&lt;/ h1&gt;</span> <span class="tag">&lt;ul&gt;</span> <span class="tag">&lt;li&gt;</span>您好<span class="tag">&lt;/ li&gt;</span> <span class="tag">&lt;li&gt;</span>春天<span class="tag">&lt;/ li&gt;</span> <span class="tag">&lt;li&gt;</span>框架<span class="tag">&lt;/ li&gt;</span> <span class="tag">&lt;/ ul&gt;</span> <span class="tag">&lt;/ body&gt;</span> <span class="tag">&lt;/ html&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config"><a class="anchor" href="#mvc-config"></a> 1.10。MVC配置</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>MVC Java配置和MVC XML命名空间提供适用于大多数应用程序的默认配置，以及用于自定义它的配置API。</p>
</div>
<div class="paragraph">
<p>有关配置API中未提供的更高级自定义，请参阅<a href="#mvc-config-advanced-java">高级Java配置</a>和<a href="#mvc-config-advanced-xml">高级XML配置</a> 。</p>
</div>
<div class="paragraph">
<p>您无需了解MVC Java配置和MVC命名空间创建的基础bean。如果您想了解更多信息，请参阅<a href="#mvc-servlet-special-bean-types">特殊Bean类型</a>和<a href="#mvc-servlet-config">Web MVC配置</a> 。</p>
</div>
<div class="sect3">
<h4 id="mvc-config-enable"><a class="anchor" href="#mvc-config-enable"></a> 1.10.1。启用MVC配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-enable">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以使用<code>@EnableWebMvc</code>批注启用MVC配置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在XML配置中，您可以使用<code>&lt;mvc:annotation-driven&gt;</code>元素来启用MVC配置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：mvc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/mvc</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www。 w3.org/2001/XMLSchema-instance</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/mvc</span> <span class="content">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;mvc：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例注册了许多Spring MVC <a href="#mvc-servlet-special-bean-types">基础结构bean，</a>并适应类路径上可用的依赖项（例如，JSON，XML等的有效负载转换器）。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-customize"><a class="anchor" href="#mvc-config-customize"></a> 1.10.2。MVC配置API</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-customize">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以实现<code>WebMvcConfigurer</code>接口，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer { <span class="comment">//实现配置方法...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在XML中，您可以检查<code>&lt;mvc:annotation-driven/&gt;</code>属性和子元素。您可以查看<a href="http://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML架构</a>或使用IDE的代码完成功能来发现可用的属性和子元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-conversion"><a class="anchor" href="#mvc-config-conversion"></a> 1.10.3。类型转换</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-conversion">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>默认格式化，安装了<code>Number</code>和<code>Date</code>类型，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code>注释的支持。如果类路径中存在Joda-Time，则还会安装对Joda-Time格式库的完全支持。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以注册自定义格式化程序和转换器，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addFormatters（FormatterRegistry注册表<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：mvc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/mvc</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www。 w3.org/2001/XMLSchema-instance</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/mvc</span> <span class="content">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;mvc：annotation-driven</span> <span class="attribute-name">conversion-service</span> = <span class="string"><span class="delimiter">”</span> <span class="content">conversionService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">conversionService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.format.support。FormattingConversionServiceFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">converters</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example。MyConverter</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">formatters</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example。MyFormatter</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example。MyAnnotationFormatterFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">formatterRegistrars</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example。MyFormatterRegistrar</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关何时使用FormatterRegistrar实现的更多信息，请参阅<a href="core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>和<code>FormattingConversionServiceFactoryBean</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-validation"><a class="anchor" href="#mvc-config-validation"></a> 1.10.4。验证</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-validation">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，如果类路径上存在<a href="core.html#validation-beanvalidation-overview">Bean Validation</a> （例如，Hibernate Validator），则<code>LocalValidatorFactoryBean</code>将注册为全局<a href="core.html#validator">Validator</a> ，以便与控制器方法参数一起使用<code>@Valid</code>和<code>Validated</code> 。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以自定义全局<code>Validator</code>实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="predefined-type">验证</span> getValidator（）; { <span class="comment">// ......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：mvc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/mvc</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www。 w3.org/2001/XMLSchema-instance</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/mvc</span> <span class="content">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;mvc：annotation-driven</span> <span class="attribute-name">validator</span> = <span class="string"><span class="delimiter">”</span> <span class="content">globalValidator</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您还可以在本地注册<code>Validator</code>实现，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> { <span class="annotation">@InitBinder</span> <span class="directive">protected</span> <span class="type">void</span> initBinder（WebDataBinder binder）{binder.addValidators（ <span class="keyword">new</span> FooValidator（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果需要在某处注入<code>LocalValidatorFactoryBean</code> ，请创建一个bean并使用<code>@Primary</code>标记它，以避免与MVC配置中声明的那个冲突。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-interceptors"><a class="anchor" href="#mvc-config-interceptors"></a> 1.10.5。拦截器</h4>
<div class="paragraph">
<p>在Java配置中，您可以注册拦截器以应用传入请求，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addInterceptors（InterceptorRegistry注册表）{registry.addInterceptor（ <span class="keyword">新</span> LocaleChangeInterceptor（））; registry.addInterceptor（ <span class="keyword">new</span> ThemeChangeInterceptor（））。addPathPatterns（ <span class="string"><span class="delimiter">“</span> <span class="content">/ **</span> <span class="delimiter">”</span></span> ）。excludePathPatterns（ <span class="string"><span class="delimiter">“</span> <span class="content">/ admin / **</span> <span class="delimiter">”</span></span> ）; registry.addInterceptor（ <span class="keyword">new</span> SecurityInterceptor（））。addPathPatterns（ <span class="string"><span class="delimiter">“</span> <span class="content">/ secure / *</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：interceptors&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.i18n。LocaleChangeInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：interceptor&gt;</span> <span class="tag">&lt;mvc：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ **</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：exclude-mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ admin / **</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.web。 servlet.theme。ThemeChangeInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：interceptor&gt;</span> <span class="tag">&lt;mvc：interceptor&gt;</span> <span class="tag">&lt;mvc：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ secure / *</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example。SecurityInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：interceptor&gt;</span> <span class="tag">&lt;/ mvc：interceptors&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-content-negotiation"><a class="anchor" href="#mvc-config-content-negotiation"></a> 1.10.6。内容类型</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-content-negotiation">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以配置Spring MVC如何根据请求确定所请求的媒体类型（例如， <code>Accept</code>标头，URL路径扩展，查询参数等）。</p>
</div>
<div class="paragraph">
<p>默认情况下，首先检查URL路径扩展 - 将<code>json</code> ， <code>xml</code> ， <code>rss</code>和<code>atom</code>注册为已知扩展（取决于类路径依赖性）。第二个检查<code>Accept</code>标头。</p>
</div>
<div class="paragraph">
<p>请考虑将这些默认值更改为仅<code>Accept</code>标头，如果必须使用基于URL的内容类型解析，请考虑使用查询参数策略而不是路径扩展。有关更多详细信息，请参阅<a href="#mvc-ann-requestmapping-suffix-pattern-match">后缀匹配</a>和<a href="#mvc-ann-requestmapping-rfd">后缀匹配以及RFD</a> 。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以自定义请求的内容类型分辨率，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureContentNegotiation（ContentNegotiationConfigurer配置器）{configurer.mediaType（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“JSON”，</span></span></span></span>的MediaType。APPLICATION_JSON）; configurer.mediaType（ <span class="string"><span class="delimiter">“</span> <span class="content">xml</span> <span class="delimiter">”</span></span> ，MediaType。APPLICATION_XML）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：annotation-driven</span> <span class="attribute-name">content-negotiation-manager</span> = <span class="string"><span class="delimiter">“</span> <span class="content">contentNegotiationManager</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">contentNegotiationManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.accept。ContentNegotiationManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mediaTypes</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> json = application / json xml = application / xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-message-converters"><a class="anchor" href="#mvc-config-message-converters"></a> 1.10.7。消息转换器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-message-codecs">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以自定义<code>HttpMessageConverter</code>通过重写Java配置<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-"><code>configureMessageConverters()</code></a>更换由Spring MVC创建的默认转换器），或者通过覆盖<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-"><code>extendMessageConverters()</code></a>自定义默认的转换器或增加额外的转换器为默认的）。</p>
</div>
<div class="paragraph">
<p>以下示例使用自定义的<code>ObjectMapper</code>而不是默认的<code>ObjectMapper</code>添加XML和Jackson JSON转换器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfiguration</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureMessageConverters（ <span class="predefined-type">列表</span> &lt;HttpMessageConverter &lt;？&gt;&gt;转换器）{Jackson2ObjectMapperBuilder builder = <span class="keyword">new</span> Jackson2ObjectMapperBuilder（）。indentOutput（ <span class="predefined-constant">true</span> ）.dateFormat（ <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd</span> <span class="delimiter">”</span></span> ））.modulesToInstall（ <span class="keyword">new</span> ParameterNamesModule（））; converters.add（ <span class="keyword">new</span> MappingJackson2HttpMessageConverter（builder.build（）））; converters.add（ <span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter（builder.createXmlMapper（ <span class="predefined-constant">true</span> ）.build（）））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a>用于为<code>MappingJackson2HttpMessageConverter</code>和<code>MappingJackson2XmlHttpMessageConverter</code>创建通用配置，启用缩进，自定义日期格式以及<a href="https://github.com/FasterXML/jackson-module-parameter-names"><code>jackson-module-parameter-names</code></a> ，这增加了对访问参数名称的支持（添加了一项功能）在Java 8）。</p>
</div>
<div class="paragraph">
<p>此构建器自定义Jackson的默认属性，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature。FAIL_ON_UNKNOWN_PROPERTIES</code></a>已禁用。</p>
</li>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature。DEFAULT_VIEW_INCLUSION</code></a>已禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在类路径中检测到它们，它还会自动注册以下众所周知的模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a> ：支持Java 7类型，例如<code>java.nio.file.Path</code> 。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a> ：支持Joda-Time类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a> ：支持Java 8 Date和Time API类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a> ：支持其他Java 8类型，例如<code>Optional</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用Jackson XML支持启用缩进除了<a href="http://search.maven.org/#search|ga|1|a%3A&quot;jackson-dataformat-xml&quot;"><code>jackson-dataformat-xml</code></a>之外还需要<a href="http://search.maven.org/#search|gav|1|g%3A&quot;org.codehaus.woodstox&quot; AND a%3A&quot;woodstox-core-asl&quot;"><code>woodstox-core-asl</code></a>依赖。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其他有趣的杰克逊模块可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a> ：支持<code>javax.money</code>类型（非官方模块）。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a> ：支持特定于Hibernate的类型和属性（包括延迟加载方面）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：annotation-driven&gt;</span> <span class="tag">&lt;mvc：message-converters&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.http.converter.json。MappingJackson2HttpMessageConverter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectMapper</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectMapper</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.http.converter.xml。MappingJackson2XmlHttpMessageConverter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectMapper</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xmlMapper</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ mvc：message-converters&gt;</span> <span class="tag">&lt;/ mvc：annotation-driven&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectMapper</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework .http.converter.json。Jackson2ObjectMapperFactoryBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：indentOutput</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：simpleDateFormat</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yyyy-MM-dd</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：</span> <span class="string"><span class="content">modulesToInstall = <span class="string"><span class="delimiter">”</span> <span class="content">com.fasterxml.jackson.module.paramnames。ParameterNamesModule</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xmlMapper</span> <span class="delimiter">“</span></span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectMapper</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：createXmlMapper</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-view-controller"><a class="anchor" href="#mvc-config-view-controller"></a> 1.10.8。查看控制器</h4>
<div class="paragraph">
<p>这是定义<code>ParameterizableViewController</code>的快捷方式，该方法在调用时立即转发到视图。如果在视图生成响应之前没有要执行的Java控制器逻辑，则可以在静态情况下使用它。</p>
</div>
<div class="paragraph">
<p>以下Java配置示例将对<code>/</code>的请求转发给名为<code>home</code>的视图：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addViewControllers（ViewControllerRegistry注册表）{registry.addViewController（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/”）.setViewName（</span></span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">家</span> <span class="delimiter">”）;</span></span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例与前面的示例实现相同的功能，但使用XML，通过使用<code>&lt;mvc:view-controller&gt;</code>元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：view-controller</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> <span class="attribute-name">view-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">home</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-view-resolvers"><a class="anchor" href="#mvc-config-view-resolvers"></a> 1.10.9。查看解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-view-resolvers">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>MVC配置简化了视图解析器的注册。</p>
</div>
<div class="paragraph">
<p>以下Java配置示例使用JSP和Jackson作为JSON呈现的默认<code>View</code>来配置内容协商视图解析：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.enableContentNegotiation（ <span class="keyword">新</span> MappingJackson2JsonView（））; registry.jsp（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：content-negotiation&gt;</span> <span class="tag">&lt;mvc：default-views&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.json。MappingJackson2JsonView</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：default-views&gt;</span> <span class="tag">&lt;/ mvc：content-negotiation&gt;</span> <span class="tag">&lt;mvc：jsp</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：view-resolvers&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但请注意，FreeMarker，Tiles，Groovy Markup和脚本模板也需要配置底层视图技术。</p>
</div>
<div class="paragraph">
<p>MVC名称空间提供专用元素。以下示例适用于FreeMarker：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：content-negotiation&gt;</span> <span class="tag">&lt;mvc：default-views&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.view.json。MappingJackson2JsonView</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：default-views&gt;</span> <span class="tag">&lt;/ mvc：content-negotiation&gt;</span> <span class="tag">&lt;mvc：freemarker</span> <span class="attribute-name">cache</span> = <span class="string"><span class="delimiter">”</span> <span class="content">false</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：view-resolvers&gt;</span> <span class="tag">&lt;mvc：freemarker-configurer&gt;</span> <span class="tag">&lt;mvc：template -loader-path</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ freemarker</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：freemarker-configurer&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在Java配置中，您可以添加相应的<code>Configurer</code> bean，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.enableContentNegotiation（ <span class="keyword">新</span> MappingJackson2JsonView（））; registry.freeMarker（）。cache（ <span class="predefined-constant">false</span> ）; } <span class="annotation">@Bean</span> <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer（）{FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer（）; configurer.setTemplateLoaderPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ freemarker</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-static-resources"><a class="anchor" href="#mvc-config-static-resources"></a> 1.10.10。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-static-resources">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>此选项提供了一种从基于<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a>的位置列表中提供静态资源的便捷方法。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，给定以<code>/resources</code>开头的请求，相对路径用于在Web应用程序根目录下或在<code>/static</code>下的类路径上查找和提供相对于<code>/public</code>静态资源。资源将在未来一年内到期，以确保最大限度地使用浏览器缓存并减少浏览器发出的HTTP请求。还会评估<code>Last-Modified</code>标头，如果存在，则返回<code>304</code>状态代码。</p>
</div>
<div class="paragraph">
<p>以下清单显示了如何使用Java配置执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addResourceHandlers（ResourceHandlerRegistry注册表）{registry.addResourceHandler（ <span class="string"><span class="content"><span class="delimiter">“/</span>资源/ <span class="delimiter">**”）.addResourceLocations（</span></span></span> <span class="string"><span class="content"><span class="delimiter">“/</span>公众</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">类路径：/静态<span class="delimiter">/”）.setCachePeriod</span></span></span> （ <span class="integer">31556926</span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：resources</span> <span class="attribute-name">mapping</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ resources / **</span> <span class="delimiter">”</span></span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ public，classpath：/ static /</span> <span class="delimiter">”</span></span> <span class="attribute-name">cache-period</span> = <span class="string"><span class="delimiter">“</span> <span class="content">31556926</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参见<a href="#mvc-caching-static-resources">对静态资源的HTTP缓存支持</a> 。</p>
</div>
<div class="paragraph">
<p>资源处理程序还支持一系列<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceResolver.html"><code>ResourceResolver</code></a>实现和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a>实现，您可以使用它们创建工具链以使用优化的资源。</p>
</div>
<div class="paragraph">
<p>您可以将<code>VersionResourceResolver</code>用于基于从内容，固定应用程序版本或其他计算的MD5哈希的版本化资源URL。<code>ContentVersionStrategy</code> （MD5哈希）是一个不错的选择 - 有一些值得注意的例外，例如与模块加载器一起使用的JavaScript资源。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java配置中使用<code>VersionResourceResolver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addResourceHandlers（ResourceHandlerRegistry注册表）{registry.addResourceHandler（ <span class="string"><span class="content"><span class="delimiter">“/</span>资源/ <span class="delimiter">**”）.addResourceLocations（</span></span></span> <span class="string"><span class="content"><span class="delimiter">“/</span>公<span class="delimiter">/”）.resourceChain（</span></span></span> <span class="predefined-constant">真</span> ）.addResolver（ <span class="keyword">新</span> VersionResourceResolver（）。addContentVersionStrategy（ <span class="string"><span class="delimiter">“</span> <span class="content">/ **</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：resources</span> <span class="attribute-name">mapping</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ resources / **</span> <span class="delimiter">”</span></span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ public /</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;mvc：resource-chain&gt;</span> <span class="tag">&lt;mvc：resource-cache</span> <span class="tag">/&gt;</span> <span class="tag">&lt;mvc：resolvers&gt;</span> <span class="tag">&lt;mvc：version-resolver&gt;</span> <span class="tag">&lt;mvc ：content-version-strategy</span> <span class="attribute-name">patterns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ **</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：version-resolver&gt;</span> <span class="tag">&lt;/ mvc：resolvers&gt;</span> <span class="tag">&lt;/ mvc：resource-chain&gt;</span> <span class="tag">&lt;/ mvc：resources&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>ResourceUrlProvider</code>重写URL并应用完整的解析器和转换器链 - 例如，插入版本。MVC配置提供了<code>ResourceUrlProvider</code> bean，以便可以将其注入其他bean。您还可以使用针对Thymeleaf，JSP，FreeMarker和其他具有依赖于<code>HttpServletResponse#encodeURL</code> #creditURL的URL标记的<code>ResourceUrlEncodingFilter</code>使重写透明。</p>
</div>
<div class="paragraph">
<p>请注意，在使用<code>EncodedResourceResolver</code> （例如，用于提供gzip或brotli编码的资源）和<code>VersionedResourceResolver</code> ，必须按此顺序注册它们。这可确保始终基于未编码的文件可靠地计算基于内容的版本。</p>
</div>
<div class="paragraph">
<p><a href="http://www.webjars.org/documentation">WebJars</a>也通过<code>WebJarsResourceResolver</code>支持，并且当类路径中存在<code>org.webjars:webjars-locator</code>时会自动注册。解析器可以重写URL以包含jar的版本，也可以匹配没有版本的传入URL  - 例如，/ <code>/jquery/jquery.min.js</code>到<code>/jquery/1.2.0/jquery.min.js</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-default-servlet-handler"><a class="anchor" href="#mvc-default-servlet-handler"></a> 1.10.11。默认Servlet</h4>
<div class="paragraph">
<p>Spring MVC允许将<code>DispatcherServlet</code>映射到<code>/</code> （从而覆盖容器的默认Servlet的映射），同时仍然允许容器的默认Servlet处理静态资源请求。它配置<code>DefaultServletHttpRequestHandler</code> ，其URL映射为<code>/**</code>并且相对于其他URL映射具有最低优先级。</p>
</div>
<div class="paragraph">
<p>此处理程序将所有请求转发到默认Servlet。因此，它必须按所有其他URL <code>HandlerMappings</code>的顺序保持最后。如果您使用<code>&lt;mvc:annotation-driven&gt;</code>就是这种情况。或者，如果您设置自己的自定义<code>HandlerMapping</code>实例，请确保将其<code>order</code>属性设置为低于<code>DefaultServletHttpRequestHandler</code> （ <code>Integer.MAX_VALUE</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用默认设置启用该功能：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureDefaultServletHandling（DefaultServletHandlerConfigurer配置器）{configurer.enable（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：default-servlet-handler</span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>覆盖<code>/</code> Servlet映射的警告是，必须通过名称而不是路径来检索默认Servlet的<code>RequestDispatcher</code> 。<code>DefaultServletHttpRequestHandler</code>尝试使用大多数主要Servlet容器（包括Tomcat，Jetty，GlassFish，JBoss，Resin，WebLogic和WebSphere）的已知名称列表，在启动时自动检测容器的默认Servlet。如果使用不同的名称自定义配置了默认Servlet，或者在默认Servlet名称未知的情况下使用其他Servlet容器，则必须显式提供默认Servlet名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureDefaultServletHandling（DefaultServletHandlerConfigurer配置器）{configurer.enable（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“myCustomDefaultServlet”）;</span></span></span></span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：default-servlet-handler</span> <span class="attribute-name">default-servlet-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myCustomDefaultServlet</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-path-matching"><a class="anchor" href="#mvc-config-path-matching"></a> 1.10.12。路径匹配</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-path-matching">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以自定义与路径匹配和URL处理相关的选项。有关各个选项的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> Javadoc。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java配置中自定义路径匹配：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebMvcConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configurePathMatch（PathMatchConfigurer配置者）{配置者.setUseSuffixPatternMatch（ <span class="predefined-constant">真</span> ）.setUseTrailingSlashMatch（ <span class="predefined-constant">假</span> ）.setUseRegisteredSuffixPatternMatch（ <span class="predefined-constant">真</span> ）.setPathMatcher（antPathMatcher（））.setUrlPathHelper（urlPathHelper（）） .addPathPrefix（ <span class="string"><span class="delimiter">“</span> <span class="content">/ api</span> <span class="delimiter">”</span></span> ，HandlerTypePredicate.forAnnotation（RestController.class））; } <span class="annotation">@Bean</span> <span class="directive">public</span> UrlPathHelper urlPathHelper（）{ <span class="comment">// ...</span>} <span class="annotation">@Bean</span> <span class="directive">public</span> PathMatcher antPathMatcher（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在XML中实现相同的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;mvc：annotation-driven&gt;</span> <span class="tag">&lt;mvc：path-matching</span> <span class="attribute-name">suffix-pattern</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">trailing-slash</span> = <span class="string"><span class="delimiter">“</span> <span class="content">false</span> <span class="delimiter">”</span></span> <span class="attribute-name">registered-suffixes-only</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">path-helper</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pathHelper</span> <span class="delimiter">”</span></span> <span class="attribute-name">path-matcher</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pathMatcher</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ mvc：annotation-driven&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pathHelper</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example.app。MyPathHelper</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pathMatcher</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example.app。MyPathMatcher</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-advanced-java"><a class="anchor" href="#mvc-config-advanced-java"></a> 1.10.13。高级Java配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-advanced-java">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebMvc</code>导入<code>DelegatingWebMvcConfiguration</code> ，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为Spring MVC应用程序提供默认的Spring配置</p>
</li>
<li>
<p>检测并委派给<code>WebMvcConfigurer</code>实现以自定义该配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级模式，您可以删除<code>@EnableWebMvc</code>并直接从<code>DelegatingWebMvcConfiguration</code>扩展而不是实现<code>WebMvcConfigurer</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">扩展了</span> DelegatingWebMvcConfiguration { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<code>WebConfig</code>保留现有方法，但现在您也可以从基类覆盖bean声明，并且您仍然可以在类路径上拥有任意数量的其他<code>WebMvcConfigurer</code>实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-advanced-xml"><a class="anchor" href="#mvc-config-advanced-xml"></a> 1.10.14。高级XML配置</h4>
<div class="paragraph">
<p>MVC命名空间没有高级模式。如果您需要在bean上自定义一个您无法更改的属性，则可以使用Spring <code>ApplicationContext</code>的<code>BeanPostProcessor</code>生命周期钩子，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyPostProcessor</span> <span class="directive">实现</span> BeanPostProcessor { <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessBeforeInitialization（ <span class="predefined-type">Object</span> bean， <span class="predefined-type">String</span> name） <span class="directive">throws</span> BeansException { <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您需要将<code>MyPostProcessor</code>声明为bean，可以在XML中显式声明，也可以通过<code>&lt;component-scan/&gt;</code>声明来检测它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-http2"><a class="anchor" href="#mvc-http2"></a> 1.11。HTTP / 2</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-http2">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4容器需要支持HTTP / 2，Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要具体做什么。但是，存在与服务器配置相关的注意事项。有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP / 2 Wiki页面</a> 。</p>
</div>
<div class="paragraph">
<p>Servlet API确实公开了一个与HTTP / 2相关的构造。您可以使用<code>javax.servlet.http.PushBuilder</code>主动将资源推送到客户端，并且它被支持作为<code>@RequestMapping</code>方法的<a href="#mvc-ann-arguments">方法参数</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webmvc-client"><a class="anchor" href="#webmvc-client"></a> 2。REST客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍客户端访问REST端点的选项。</p>
</div>
<div class="sect2">
<h3 id="webmvc-resttemplate"><a class="anchor" href="#webmvc-resttemplate"></a> 2.1。使用<code>RestTemplate</code></h3>
<div class="paragraph">
<p><code>RestTemplate</code>是一个执行HTTP请求的同步客户端。它是最初的Spring REST客户端，并在底层HTTP客户端库上公开了一个简单的模板方法API。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.0开始，非阻塞，反应式<code>WebClient</code>提供了<code>RestTemplate</code>的现代替代方案，同时有效支持同步和异步以及流方案。<code>RestTemplate</code>将在未来版本中弃用，并且不会在未来添加主要的新功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅<a href="integration.html#rest-client-access">REST端点</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-webclient"><a class="anchor" href="#webmvc-webclient"></a> 2.2。使用<code>WebClient</code></h3>
<div class="paragraph">
<p><code>WebClient</code>是一个执行HTTP请求的非阻塞，被动的客户端。它在5.0中引入，提供了<code>RestTemplate</code>的现代替代方案，同时有效支持同步和异步以及流方案。</p>
</div>
<div class="paragraph">
<p>与<code>RestTemplate</code> ， <code>WebClient</code>支持以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>非阻塞I / O.</p>
</li>
<li>
<p>反应流回压。</p>
</li>
<li>
<p>高并发性，硬件资源更少。</p>
</li>
<li>
<p>功能风格，流畅的API，利用Java 8 lambdas。</p>
</li>
<li>
<p>同步和异步交互。</p>
</li>
<li>
<p>从服务器流式传输或向下传输。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="web-reactive.html#webflux-client">WebClient</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a> 3。测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-test">在Spring WebFlux中也是如此</a></span></p>
</div>
<div class="paragraph">
<p>本节总结了Spring MVC应用程序<code>spring-test</code>可用的选项。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servlet API模拟：用于单元测试控制器，过滤器和其他Web组件的Servlet API契约的模拟实现。有关更多详细信息，请参阅<a href="testing.html#mock-objects-servlet">Servlet API</a>模拟对象。</p>
</li>
<li>
<p>TestContext Framework：支持在JUnit和TestNG测试中加载Spring配置，包括跨测试方法高效缓存加载的配置，以及支持使用<code>MockServletContext</code>加载<code>WebApplicationContext</code> 。有关更多详细信息，请参阅<a href="testing.html#testcontext-framework">TestContext Framework</a> 。</p>
</li>
<li>
<p>Spring MVC Test：一个框架，也称为<code>MockMvc</code> ，用于通过<code>DispatcherServlet</code>测试带注释的控制器（即支持注释），完成Spring MVC基础结构但没有HTTP服务器。有关更多详细信息，请参阅<a href="testing.html#spring-mvc-test-framework">Spring MVC Test</a> 。</p>
</li>
<li>
<p>客户端REST： <code>spring-test</code>提供了一个<code>MockRestServiceServer</code> ，您可以将其用作模拟服务器，用于测试内部使用<code>RestTemplate</code>客户端代码。有关详细信息，请参阅<a href="testing.html#spring-mvc-test-client">客户端REST测试</a> 。</p>
</li>
<li>
<p><code>WebTestClient</code> ：专为测试WebFlux应用程序而构建，但它也可用于通过HTTP连接对任何服务器进行端到端集成测试。它是一个非阻塞，被动的客户端，非常适合测试异步和流式方案。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket"><a class="anchor" href="#websocket"></a> 4。的WebSockets</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>这部分参考文档包括对Servlet堆栈的支持，包括原始WebSocket交互的WebSocket消息传递，通过SockJS的WebSocket仿真，以及通过STOMP作为WebSocket上的子协议的发布 - 订阅消息传递。</p>
</div>
<div class="sect2">
<h3 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a> 4.1。WebSocket简介</h3>
<div class="paragraph">
<p>WebSocket协议<a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准化方法，可通过单个TCP连接在客户端和服务器之间建立全双工双向通信通道。它是来自HTTP的不同TCP协议，但设计为使用端口80和443通过HTTP工作，并允许重用现有防火墙规则。</p>
</div>
<div class="paragraph">
<p>WebSocket交互以HTTP请求开始，该HTTP请求使用HTTP <code>Upgrade</code>标头进行升级，或者在这种情况下，切换到WebSocket协议。以下示例显示了这样的交互：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>GET / spring-websocket-portfolio / portfolio HTTP / 1.1主机：localhost：8080升级：websocket &lt;1&gt;连接：升级&lt;2&gt; Sec-WebSocket-Key：Uc9l9TMkWGbHFD2qnFHltg == Sec-WebSocket-Protocol：v10.stomp，v11。 stomp Sec-WebSocket-Version：13来源：http：// localhost：8080</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>Upgrade</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>具有WebSocket支持的服务器返回类似于以下内容的输出，而不是通常的200状态代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre><strong>HTTP / 1.1 101交换协议</strong>升级：websocket连接：升级Sec-WebSocket-Accept：1qVdfYHU9hPOl4JYYNXF623Gzn0 = Sec-WebSocket-Protocol：v10.stomp</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>成功握手后，HTTP升级请求下的TCP套接字将保持打开状态，以便客户端和服务器继续发送和接收消息。</p>
</div>
<div class="paragraph">
<p>有关WebSockets如何工作的完整介绍超出了本文档的范围。请参阅RFC 6455，HTML5的WebSocket章节，或Web上的许多介绍和教程。</p>
</div>
<div class="paragraph">
<p>请注意，如果WebSocket服务器在Web服务器（例如nginx）后面运行，您可能需要将其配置为将WebSocket升级请求传递到WebSocket服务器。同样，如果应用程序在云环境中运行，请检查与WebSocket支持相关的云提供程序的说明。</p>
</div>
<div class="sect3">
<h4 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a> 4.1.1。HTTP与WebSocket</h4>
<div class="paragraph">
<p>尽管WebSocket被设计为与HTTP兼容并且以HTTP请求开始，但重要的是要理解这两种协议会导致非常不同的体系结构和应用程序编程模型。</p>
</div>
<div class="paragraph">
<p>在HTTP和REST中，应用程序被建模为多个URL。要与应用程序进行交互，客户端将访问这些URL，请求 - 响应样式。服务器根据HTTP URL，方法和标头将请求路由到适当的处理程序。</p>
</div>
<div class="paragraph">
<p>相比之下，在WebSockets中，初始连接通常只有一个URL。随后，所有应用程序消息都在同一TCP连接上流动。这指向完全不同的异步，事件驱动的消息传递体系结构。</p>
</div>
<div class="paragraph">
<p>WebSocket也是一种低级传输协议，与HTTP不同，它不对消息内容规定任何语义。这意味着除非客户端和服务器就消息语义达成一致，否则无法路由或处理消息。</p>
</div>
<div class="paragraph">
<p>WebSocket客户端和服务器可以通过HTTP握手请求上的<code>Sec-WebSocket-Protocol</code>标头协商使用更高级别的消息传递协议（例如，STOMP）。如果没有，他们需要提出自己的惯例。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a> 4.1.2。何时使用WebSockets</h4>
<div class="paragraph">
<p>WebSockets可以使网页变得动态和交互。但是，在许多情况下，Ajax和HTTP流式传输或长轮询的组合可以提供简单有效的解决方案。</p>
</div>
<div class="paragraph">
<p>例如，新闻，邮件和社交订阅源需要动态更新，但每隔几分钟就可以完全正常更新。另一方面，协作，游戏和财务应用程序需要更接近实时。</p>
</div>
<div class="paragraph">
<p>仅延迟不是决定因素。如果消息量相对较低（例如，监视网络故障），HTTP流式传输或轮询可以提供有效的解决方案。它是低延迟，高频率和高容量的组合，是WebSocket使用的最佳选择。</p>
</div>
<div class="paragraph">
<p>还要记住，通过Internet，受控制之外的限制性代理可能会阻止WebSocket交互，因为它们未配置为传递<code>Upgrade</code>标头，或者因为它们关闭看似空闲的长期连接。这意味着将WebSocket用于防火墙内的内部应用程序是一个比面向公众的应用程序更直接的决策。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-server"><a class="anchor" href="#websocket-server"></a> 4.2。WebSocket API</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework提供了一个WebSocket API，您可以使用它来编写处理WebSocket消息的客户端和服务器端应用程序。</p>
</div>
<div class="sect3">
<h4 id="websocket-server-handler"><a class="anchor" href="#websocket-server-handler"></a> 4.2.1。使用<code>WebSocketHandler</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-handler">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>创建WebSocket服务器就像实现<code>WebSocketHandler</code>一样简单，或者更有可能扩展<code>TextWebSocketHandler</code>或<code>BinaryWebSocketHandler</code> 。以下示例使用<code>TextWebSocketHandler</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.socket。WebSocketHandler</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket。WebSocketSession</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket。TextMessage</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="directive">扩展</span> <span class="class">MyHandler的</span> {TextWebSocketHandler <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleTextMessage（WebSocketSession会议，TextMessage的消息<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有专门的WebSocket Java配置和XML命名空间支持，用于将前面的WebSocket处理程序映射到特定的URL，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。EnableWebSocket</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。WebSocketConfigurer</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。WebSocketHandlerRegistry</span> ; <span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerWebSocketHandlers（WebSocketHandlerRegistry registry）{registry.addHandler（myHandler（）， <span class="string"><span class="delimiter">“</span> <span class="content">/ myHandler</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebSocketHandler myHandler（）{ <span class="keyword">return</span> <span class="keyword">new</span> MyHandler（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：handlers&gt;</span> <span class="tag">&lt;websocket：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ myHandler</span> <span class="delimiter">“</span></span> <span class="attribute-name">handler</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：handlers&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myHandler</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.samples。MyHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例用于Spring MVC应用程序，应包含在<a href="#mvc-servlet"><code>DispatcherServlet</code></a>的配置中。但是，Spring的WebSocket支持不依赖于Spring MVC。在<code>WebSocketHandler</code>的帮助下，将<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html"><code>WebSocketHttpRequestHandler</code></a>集成到其他HTTP服务环境中相对简单。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-handshake"><a class="anchor" href="#websocket-server-handshake"></a> 4.2.2。WebSocket握手</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-handshake">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>自定义初始HTTP WebSocket握手请求的最简单方法是通过<code>HandshakeInterceptor</code> ，它在<code>HandshakeInterceptor</code>之前“之前”和“之后”暴露方法。您可以使用此类拦截器来阻止握手或使<code>WebSocketSession</code>可以使用任何属性。以下示例使用内置拦截器将HTTP会话属性传递给WebSocket会话：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerWebSocketHandlers（WebSocketHandlerRegistry registry）{registry.addHandler（ <span class="keyword">new</span> MyHandler（）， <span class="string"><span class="delimiter">“</span> <span class="content">/ myHandler</span> <span class="delimiter">”</span></span> ）。addInterceptors（ <span class="keyword">new</span> HttpSessionHandshakeInterceptor（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：handlers&gt;</span> <span class="tag">&lt;websocket：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ myHandler</span> <span class="delimiter">“</span></span> <span class="attribute-name">handler</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;websocket：handshake-interceptors&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.socket.server.support。HttpSessionHandshakeInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：handshake-interceptors&gt;</span> <span class="tag">&lt;/ websocket：handlers&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myHandler</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.samples。MyHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>更高级的选项是扩展执行WebSocket握手步骤的<code>DefaultHandshakeHandler</code> ，包括验证客户端来源，协商子协议以及其他详细信息。如果应用程序需要配置自定义<code>RequestUpgradeStrategy</code>以适应WebSocket服务器引擎和尚不支持的版本，则应用程序可能还需要使用此选项（有关此主题的更多信息，请参阅<a href="#websocket-server-deployment">部署</a> ）。Java配置和XML命名空间都可以配置自定义<code>HandshakeHandler</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring提供了一个<code>WebSocketHandlerDecorator</code>基类，您可以使用它来装饰具有其他行为的<code>WebSocketHandler</code> 。使用WebSocket Java配置或XML命名空间时，默认情况下会提供并添加日志记录和异常处理实现。<code>ExceptionWebSocketHandlerDecorator</code>捕获由任何<code>WebSocketHandler</code>方法引起的所有未捕获的异常，并关闭状态为<code>1011</code>的WebSocket会话，这表示服务器错误。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-deployment"><a class="anchor" href="#websocket-server-deployment"></a> 4.2.3。部署</h4>
<div class="paragraph">
<p>Spring WebSocket API易于集成到Spring MVC应用程序中，其中<code>DispatcherServlet</code>提供HTTP WebSocket握手和其他HTTP请求。通过调用<code>WebSocketHttpRequestHandler</code>也可以轻松地集成到其他HTTP处理场景中。这很方便易懂。但是，特殊注意事项适用于JSR-356运行时。</p>
</div>
<div class="paragraph">
<p>Java WebSocket API（JSR-356）提供了两种部署机制。第一个涉及启动时的Servlet容器类路径扫描（Servlet 3功能）。另一个是在Servlet容器初始化时使用的注册API。这些机制都不能使用单个“前端控制器”进行所有HTTP处理 - 包括WebSocket握手和所有其他HTTP请求 - 例如Spring MVC的<code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p>这是JSR-356的一个重要限制，Spring的WebSocket支持解决了服务器特定的<code>RequestUpgradeStrategy</code>实现，即使在JSR-356运行时运行也是如此。目前，Tomcat，Jetty，GlassFish，WebLogic，WebSphere和Undertow（以及WildFly）都有这样的策略。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">已经创建了一个克服Java WebSocket API中的上述限制的请求，可以在<a href="https://github.com/eclipse-ee4j/websocket-api/issues/211">WEBSOCKET_SPEC-211中</a>进行跟踪。Tomcat，Undertow和WebSphere提供了自己的API替代方案，可以实现这一点，Jetty也是如此。我们希望更多服务器能够做到这一点。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第二个考虑因素是具有JSR-356支持的Servlet容器应该执行<code>ServletContainerInitializer</code> （SCI）扫描，这可能会减慢应用程序启动速度 - 在某些情况下会显着降低。如果在升级到支持JSR-356的Servlet容器版本后观察到重大影响，则应该可以通过在<code>web.xml</code>使用<code>&lt;absolute-ordering /&gt;</code>元素来选择性地启用或禁用Web片段（和SCI扫描） <code>web.xml</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://java.sun.com/xml/ns/javaee</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http ：//java.sun.com/xml/ns/javaee</span> <span class="content">http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd</span> <span class="delimiter">“</span></span> <span class="attribute-name">版本</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="delimiter"><span class="tag">3.0“&gt;</span></span></span></span> <span class="tag">&lt;绝对排序</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ web应用程序&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以按名称选择性地启用Web片段，例如Spring自己的<code>SpringServletContainerInitializer</code> ，它为Servlet 3 Java初始化API提供支持。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://java.sun.com/xml/ns/javaee</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http ：//java.sun.com/xml/ns/javaee</span> <span class="content">http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd</span> <span class="delimiter">“</span></span> <span class="attribute-name">版本</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="delimiter"><span class="tag">3.0“&gt;</span></span></span></span> <span class="tag">&lt;绝对排序&gt;</span> <span class="tag">&lt;名称&gt;</span> spring_web <span class="tag">&lt;/ name&gt;</span> <span class="tag">&lt;/ absolute-ordering&gt;</span> <span class="tag">&lt;/ web-app&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-runtime-configuration"><a class="anchor" href="#websocket-server-runtime-configuration"></a> 4.2.4。服务器配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-config">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>每个底层WebSocket引擎都公开控制运行时特征的配置属性，例如消息缓冲区大小，空闲超时等。</p>
</div>
<div class="paragraph">
<p>对于Tomcat，WildFly和GlassFish，您可以将<code>ServletServerContainerFactoryBean</code>添加到WebSocket Java配置中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Bean</span> <span class="directive">public</span> ServletServerContainerFactoryBean createWebSocketContainer（）{ServletServerContainerFactoryBean container = <span class="keyword">new</span> ServletServerContainerFactoryBean（）; container.setMaxTextMessageBufferSize（ <span class="integer">8192</span> ）; container.setMaxBinaryMessageBufferSize（ <span class="integer">8192</span> ）; <span class="keyword">回收</span>容器; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework ...ServletServerContainerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">maxTextMessageBufferSize</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">8192</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">maxBinaryMessageBufferSize</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">8192</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于客户端WebSocket配置，您应该使用<code>WebSocketContainerFactoryBean</code> （XML）或<code>ContainerProvider.getWebSocketContainer()</code> （Java配置）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于Jetty，您需要提供预配置的Jetty <code>WebSocketServerFactory</code>并通过WebSocket Java配置将其插入Spring的<code>DefaultHandshakeHandler</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerWebSocketHandlers（WebSocketHandlerRegistry registry）{registry.addHandler（echoWebSocketHandler（）， <span class="string"><span class="delimiter">“</span> <span class="content">/ echo</span> <span class="delimiter">”</span></span> ）。setHandshakeHandler（handshakeHandler（））; } <span class="annotation">@Bean</span> <span class="directive">public</span> DefaultHandshakeHandler handshakeHandler（）{WebSocketPolicy policy = <span class="keyword">new</span> WebSocketPolicy（WebSocketBehavior。服务器）; policy.setInputBufferSize（ <span class="integer">8192</span> ）; policy.setIdleTimeout（ <span class="integer">600000</span> ）; <span class="keyword">返回</span> <span class="keyword">new</span> DefaultHandshakeHandler（ <span class="keyword">new</span> JettyRequestUpgradeStrategy（ <span class="keyword">new</span> WebSocketServerFactory（policy）））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：handlers&gt;</span> <span class="tag">&lt;websocket：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ echo</span> <span class="delimiter">“</span></span> <span class="attribute-name">handler</span> = <span class="string"><span class="delimiter">”</span> <span class="content">echoHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;websocket：handshake-handler</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">handshakeHandler</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：handlers&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">handshakeHandler</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework ...DefaultHandshakeHandler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">upgradeStrategy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">upgradeStrategy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework ...JettyRequestUpgradeStrategy</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.eclipse.jetty ...WebSocketServerFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.eclipse.jetty ...WebSocketPolicy</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">SERVER</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">inputBufferSize</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">8092</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">idleTimeout</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">600000</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ constructor- arg&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-allowed-origins"><a class="anchor" href="#websocket-server-allowed-origins"></a> 4.2.5。允许起源</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-cors">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>从Spring Framework 4.1.5开始，WebSocket和SockJS的默认行为是仅接受同源请求。也可以允许所有或指定的起源列表。此检查主要是为浏览器客户端设计的。没有什么可以阻止其他类型的客户端修改<code>Origin</code>标头值（有关更多详细信息，请参阅<a href="https://tools.ietf.org/html/rfc6454">RFC 6454：Web Origin Concept</a> ）。</p>
</div>
<div class="paragraph">
<p>三种可能的行为是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅允许同源请求（默认）：在此模式下，启用SockJS时，Iframe HTTP响应标头<code>X-Frame-Options</code>设置为<code>SAMEORIGIN</code> ，并禁用JSONP传输，因为它不允许检查源的请求。因此，启用此模式时不支持IE6和IE7。</p>
</li>
<li>
<p>允许指定的来源列表：每个允许的来源必须以<code>http://</code>或<code>https://</code>开头。在此模式下，启用SockJS时，将禁用IFrame传输。因此，启用此模式时，不支持IE6到IE9。</p>
</li>
<li>
<p>允许所有来源：要启用此模式，您应提供<code>*</code>作为允许的原始值。在此模式下，所有传输都可用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以配置WebSocket和SockJS允许的源，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。EnableWebSocket</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。WebSocketConfigurer</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。WebSocketHandlerRegistry</span> ; <span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerWebSocketHandlers（WebSocketHandlerRegistry registry）{registry.addHandler（myHandler（）， <span class="string"><span class="delimiter">“</span> <span class="content">/ myHandler</span> <span class="delimiter">”</span></span> ）。setAllowedOrigins（ <span class="string"><span class="delimiter">“</span> <span class="content">http://mydomain.com</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebSocketHandler myHandler（）{ <span class="keyword">return</span> <span class="keyword">new</span> MyHandler（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：handlers</span> <span class="attribute-name">allowed-origins</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://mydomain.com</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket ：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ myHandler</span> <span class="delimiter">”</span></span> <span class="attribute-name">handler</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myHandler</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：handlers&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myHandler</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.samples。MyHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback"><a class="anchor" href="#websocket-fallback"></a> 4.3。SockJS后备</h3>
<div class="paragraph">
<p>在公共Internet上，受控制之外的限制性代理可能会阻止WebSocket交互，因为它们未配置为传递<code>Upgrade</code>标头，或者因为它们关闭看似空闲的长期连接。</p>
</div>
<div class="paragraph">
<p>此问题的解决方案是WebSocket仿真 - 即，首先尝试使用WebSocket，然后依靠基于HTTP的技术来模拟WebSocket交互并公开相同的应用程序级API。</p>
</div>
<div class="paragraph">
<p>在Servlet堆栈上，Spring Framework为SockJS协议提供服务器（以及客户端）支持。</p>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-overview"><a class="anchor" href="#websocket-fallback-sockjs-overview"></a> 4.3.1。概观</h4>
<div class="paragraph">
<p>SockJS的目标是让应用程序使用WebSocket API，但在运行时必要时可以回退到非WebSocket替代方案，而无需更改应用程序代码。</p>
</div>
<div class="paragraph">
<p>SockJS包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sockjs/sockjs-protocol">SockJS协议</a>以可执行的<a href="http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">叙述测试</a>的形式定义。</p>
</li>
<li>
<p><a href="https://github.com/sockjs/sockjs-client/">SockJS JavaScript客户端</a> - 用于浏览器的客户端库。</p>
</li>
<li>
<p>SockJS服务器实现，包括Spring Framework <code>spring-websocket</code>模块中的一个。</p>
</li>
<li>
<p><code>spring-websocket</code>模块中的SockJS Java客户端（自4.1版本起）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SockJS专为在浏览器中使用而设计。它使用各种技术来支持各种浏览器版本。有关SockJS传输类型和浏览器的完整列表，请参阅<a href="https://github.com/sockjs/sockjs-client/">SockJS客户端</a>页面。传输分为三大类：WebSocket，HTTP Streaming和HTTP Long Polling。有关这些类别的概述，请参阅<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">此博客文章</a> 。</p>
</div>
<div class="paragraph">
<p>SockJS客户端首先发送<code>GET /info</code>以从服务器获取基本信息。之后，它必须决定使用什么传输。如果可能，使用WebSocket。如果没有，在大多数浏览器中，至少有一个HTTP流选项。如果不是，则使用HTTP（长）轮询。</p>
</div>
<div class="paragraph">
<p>所有传输请求都具有以下URL结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>HTTP：//主机：端口/对myApp / myEndpoint / {服务器ID} / {会话ID} / {}运输</pre>
</div>
</div>
<div class="paragraph">
<p>哪里：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{server-id}</code>对于在集群中路由请求很有用，但是不使用。</p>
</li>
<li>
<p><code>{session-id}</code>关联属于SockJS会话的HTTP请求。</p>
</li>
<li>
<p><code>{transport}</code>表示传输类型（例如， <code>websocket</code> ， <code>xhr-streaming</code>等）。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>WebSocket传输只需要一个HTTP请求即可进行WebSocket握手。之后的所有消息都在该套接字上交换。</p>
</div>
<div class="paragraph">
<p>HTTP传输需要更多请求。例如，Ajax / XHR流依赖于一个长期运行的服务器到客户端消息请求以及针对客户端到服务器消息的额外HTTP POST请求。长轮询类似，只是它在每个服务器到客户端发送后结束当前请求。</p>
</div>
<div class="paragraph">
<p>SockJS增加了最小的消息框架。例如，服务器最初发送字母<code>o</code> （“打开”帧），消息作为<code>a["message1","message2"]</code> （JSON编码数组）发送，字母<code>h</code> （“heartbeat”帧）如果没有消息流动25秒（默认情况下）和字母<code>c</code> （“关闭”框架）以关闭会话。</p>
</div>
<div class="paragraph">
<p>要了解更多信息，请在浏览器中运行示例并观察HTTP请求。SockJS客户端允许修复传输列表，因此可以一次查看每个传输。SockJS客户端还提供调试标志，该标志在浏览器控制台中启用有用的消息。在服务器端，您可以为<code>org.springframework.web.socket</code>启用<code>TRACE</code>日志记录。有关更多详细信息，请参阅SockJS协议<a href="http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">叙述测试</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-enable"><a class="anchor" href="#websocket-fallback-sockjs-enable"></a> 4.3.2。启用S​​ockJS</h4>
<div class="paragraph">
<p>您可以通过Java配置启用SockJS，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerWebSocketHandlers（WebSocketHandlerRegistry registry）{registry.addHandler（myHandler（）， <span class="string"><span class="delimiter">“</span> <span class="content">/ myHandler</span> <span class="delimiter">”</span></span> ）。withSockJS（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebSocketHandler myHandler（）{ <span class="keyword">return</span> <span class="keyword">new</span> MyHandler（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：handlers&gt;</span> <span class="tag">&lt;websocket：mapping</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ myHandler</span> <span class="delimiter">“</span></span> <span class="attribute-name">handler</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;websocket：sockjs</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：handlers&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myHandler</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.samples。MyHandler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例用于Spring MVC应用程序，应该包含在<a href="#mvc-servlet"><code>DispatcherServlet</code></a>的配置中。但是，Spring的WebSocket和SockJS支持并不依赖于Spring MVC。在<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/socket/sockjs/support/SockJsHttpRequestHandler.html"><code>SockJsHttpRequestHandler</code></a>的帮助下，集成到其他HTTP服务环境中相对简单。</p>
</div>
<div class="paragraph">
<p>在浏览器端，应用程序可以使用<a href="https://github.com/sockjs/sockjs-client/"><code>sockjs-client</code></a> （版本1.0.x）。它模拟W3C WebSocket API并与服务器通信以选择最佳传输选项，具体取决于运行它的浏览器。请参阅<a href="https://github.com/sockjs/sockjs-client/">sockjs-client</a>页面和浏览器支持的传输类型列表。客户端还提供了几个配置选项 - 例如，指定要包含的传输。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-xhr-vs-iframe"><a class="anchor" href="#websocket-fallback-xhr-vs-iframe"></a> 4.3.3。IE 8和9</h4>
<div class="paragraph">
<p>Internet Explorer 8和9仍在使用中。他们是拥有SockJS的关键原因。本节介绍在这些浏览器中运行的重要注意事项。</p>
</div>
<div class="paragraph">
<p>SockJS客户端通过使用Microsoft的<a href="http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx"><code>XDomainRequest</code></a>在IE 8和9中支持Ajax / XHR流。这适用于域，但不支持发送cookie。Cookie通常对Java应用程序至关重要。但是，由于SockJS客户端可以与许多服务器类型（不仅仅是Java）一起使用，因此需要知道cookie是否重要。如果是这样，SockJS客户端更喜欢Ajax / XHR进行流式传输。否则，它依赖于基于iframe的技术。</p>
</div>
<div class="paragraph">
<p>来自SockJS客户端的第一个<code>/info</code>请求是对可能影响客户选择传输的信息的请求。其中一个细节是服务器应用程序是否依赖于cookie（例如，用于身份验证或使用粘性会话进行群集）。Spring的SockJS支持包括一个叫做物业<code>sessionCookieNeeded</code> 。它默认启用，因为大多数Java应用程序都依赖于<code>JSESSIONID</code> cookie。如果您的应用程序不需要它，您可以关闭此选项，然后SockJS客户端应该在IE 8和9中选择<code>xdr-streaming</code> 。</p>
</div>
<div class="paragraph">
<p>如果您确实使用基于iframe的传输，请记住，可以通过将HTTP响应标头<code>X-Frame-Options</code>为<code>DENY</code> ， <code>SAMEORIGIN</code>或<code>ALLOW-FROM &lt;origin&gt;</code>来指示浏览器阻止在给定页面上使用IFrame <code>ALLOW-FROM &lt;origin&gt;</code> 。这用于防止<a href="https://www.owasp.org/index.php/Clickjacking">点击劫持</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security 3.2+支持在每个响应上设置<code>X-Frame-Options</code> 。默认情况下，Spring Security Java配置将其设置为<code>DENY</code> 。在3.2中，Spring Security XML命名空间默认情况下不设置该标头，但可以配置为执行此操作。将来，它可以默认设置它。</p>
</div>
<div class="paragraph">
<p>有关如何配置<code>X-Frame-Options</code>标头设置的详细信息，请参阅Spring Security文档的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers">默认安全</a>标头。您还可以查看<a href="https://jira.spring.io/browse/SEC-2501">SEC-2501</a>的其他背景信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您的应用程序添加了<code>X-Frame-Options</code>响应标头（应该如此！）并且依赖于基于iframe的传输，您需要将标头值设置为<code>SAMEORIGIN</code>或<code>ALLOW-FROM &lt;origin&gt;</code> 。Spring SockJS支持还需要知道SockJS客户端的位置，因为它是从iframe加载的。默认情况下，iframe设置为从CDN位置下载SockJS客户端。配置此选项以使用与应用程序相同的源的URL是个好主意。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Java配置中执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocket</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerStompEndpoints（StompEndpointRegistry registry）{registry.addEndpoint（ <span class="string"><span class="delimiter">“</span> <span class="content">/ portfolio</span> <span class="delimiter">”</span></span> ）。withSockJS（）。setClientLibraryUrl（ <span class="string"><span class="delimiter">“</span> <span class="content">http：// localhost：8080 / myapp / js / sockjs -client.js</span> <span class="delimiter">“</span></span> ）; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>XML命名空间通过<code>&lt;websocket:sockjs&gt;</code>元素提供了类似的选项。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在初始开发期间，请启用SockJS客户端<code>devel</code>模式，以防止浏览器缓存否则将被缓存的SockJS请求（如iframe）。有关如何启用它的详细信息，请参阅<a href="https://github.com/sockjs/sockjs-client/">SockJS客户端</a>页面。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-heartbeat"><a class="anchor" href="#websocket-fallback-sockjs-heartbeat"></a> 4.3.4。心跳</h4>
<div class="paragraph">
<p>SockJS协议要求服务器发送心跳消息以阻止代理断定连接已挂起。Spring SockJS配置有一个名为<code>heartbeatTime</code>的属性，可用于自定义频率。默认情况下，假设在该连接上没有发送其他消息，则会在25秒后发送心跳。这个25秒的值符合以下<a href="http://tools.ietf.org/html/rfc6202">IETF</a>对公共互联网应用的<a href="http://tools.ietf.org/html/rfc6202">建议</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当通过WebSocket和SockJS使用STOMP时，如果STOMP客户端和服务器协商要交换的心跳，则禁用SockJS心跳。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring SockJS支持还允许您配置<code>TaskScheduler</code>以安排心跳任务。任务计划程序由线程池支持，默认设置基于可用处理器的数量。您应该考虑根据您的特定需求自定义设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-servlet3-async"><a class="anchor" href="#websocket-fallback-sockjs-servlet3-async"></a> 4.3.5。客户端断开连接</h4>
<div class="paragraph">
<p>HTTP流式传输和HTTP长轮询SockJS传输要求连接保持打开时间比平时长。有关这些技术的概述，请参阅<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">此博客文章</a> 。</p>
</div>
<div class="paragraph">
<p>在Servlet容器中，这是通过Servlet 3异步支持完成的，该支持允许退出Servlet容器线程，处理请求，并继续写入来自另一个线程的响应。</p>
</div>
<div class="paragraph">
<p>一个特定的问题是Servlet API不会为已经消失的客户端提供通知。请参阅<a href="https://java.net/jira/browse/SERVLET_SPEC-44">SERVLET_SPEC-44</a> 。但是，Servlet容器在后续尝试写入响应时引发异常。由于Spring的SockJS服务支持服务器发送的心跳（默认情况下每25秒），这意味着通常在该时间段内检测到客户端断开连接（或者更早，如果更频繁地发送消息）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">因此，可能会发生网络I / O故障，因为客户端已断开连接，这可能会使用不必要的堆栈跟踪填充日志。Spring尽最大努力识别代表客户端断开连接（特定于每个服务器）的此类网络故障，并使用专用日志类别<code>DISCONNECTED_CLIENT_LOG_CATEGORY</code> （在<code>AbstractSockJsSession</code>定义）记录最小消息。如果需要查看堆栈跟踪，可以将该日志类别设置为TRACE。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-cors"><a class="anchor" href="#websocket-fallback-cors"></a> 4.3.6。SockJS和CORS</h4>
<div class="paragraph">
<p>如果您允许跨源请求（请参阅<a href="#websocket-server-allowed-origins">允许的起源</a> ），则SockJS协议使用CORS在XHR流和轮询传输中进行跨域支持。因此，除非检测到响应中存在CORS头，否则将自动添加CORS头。因此，如果应用程序已配置为提供CORS支持（例如，通过Servlet过滤器），则Spring的<code>SockJsService</code>跳过此部分。</p>
</div>
<div class="paragraph">
<p>也可以通过在Spring的SockJsService中设置<code>suppressCors</code>属性来禁用这些CORS头的添加。</p>
</div>
<div class="paragraph">
<p>SockJS需要以下标头和值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Access-Control-Allow-Origin</code> ：从<code>Origin</code>请求标头的值初始化。</p>
</li>
<li>
<p><code>Access-Control-Allow-Credentials</code> ：始终设置为<code>true</code> 。</p>
</li>
<li>
<p><code>Access-Control-Request-Headers</code> ：从等效请求标头中的值初始化。</p>
</li>
<li>
<p><code>Access-Control-Allow-Methods</code> ：传输支持的HTTP方法（请参阅<code>TransportType</code>枚举）。</p>
</li>
<li>
<p><code>Access-Control-Max-Age</code> ：设置为31536000（1年）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于确切的实现，见<code>addCorsHeaders</code>在<code>AbstractSockJsService</code>和<code>TransportType</code>在源代码中枚举。</p>
</div>
<div class="paragraph">
<p>或者，如果CORS配置允许，请考虑使用SockJS端点前缀排除URL，从而让Spring的<code>SockJsService</code>处理它。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-client"><a class="anchor" href="#websocket-fallback-sockjs-client"></a> 4.3.7。使用<code>SockJsClient</code></h4>
<div class="paragraph">
<p>Spring提供了一个SockJS Java客户端，无需使用浏览器即可连接到远程SockJS端点。当需要通过公共网络在两个服务器之间进行双向通信时（即，网络代理可以排除使用WebSocket协议的情况下），这尤其有用。SockJS Java客户端对于测试目的也非常有用（例如，模拟大量并发用户）。</p>
</div>
<div class="paragraph">
<p>SockJS Java客户端支持<code>websocket</code> ， <code>xhr-streaming</code>和<code>xhr-polling</code>传输。其余的仅适用于浏览器。</p>
</div>
<div class="paragraph">
<p>您可以使用以下命令配置<code>WebSocketTransport</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JSR-356运行时中的<code>StandardWebSocketClient</code> 。</p>
</li>
<li>
<p><code>JettyWebSocketClient</code>使用Jetty 9+本机WebSocket API。</p>
</li>
<li>
<p>Spring的<code>WebSocketClient</code>任何实现。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据定义， <code>XhrTransport</code>支持<code>xhr-streaming</code>和<code>xhr-polling</code> ，因为从客户端的角度来看，除了用于连接服务器的URL之外没有其他区别。目前有两种实现方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RestTemplateXhrTransport</code>使用Spring的<code>RestTemplate</code>进行HTTP请求。</p>
</li>
<li>
<p><code>JettyXhrTransport</code>使用Jetty的<code>HttpClient</code>进行HTTP请求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示如何创建SockJS客户端并连接到SockJS端点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span> &lt;Transport&gt; transports = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> &lt;&gt;（ <span class="integer">2</span> ）; transports.add（ <span class="keyword">new</span> WebSocketTransport（ <span class="keyword">new</span> StandardWebSocketClient（）））; transports.add（ <span class="keyword">new</span> RestTemplateXhrTransport（））; SockJsClient sockJsClient = <span class="keyword">new</span> SockJsClient（transports）; sockJsClient.doHandshake（ <span class="keyword">新的</span> MyWebSocketHandler（）， <span class="string"><span class="delimiter">“</span> <span class="content">ws：//example.com：8080 / sockjs</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">SockJS使用JSON格式的数组进行消息传递。默认情况下，使用Jackson 2并且需要在类路径上。或者，您可以配置<code>SockJsMessageCodec</code>的自定义实现并在<code>SockJsClient</code>上配置它。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用<code>SockJsClient</code>模拟大量并发用户，您需要配置底层HTTP客户端（用于XHR传输）以允许足够数量的连接和线程。以下示例显示了如何使用Jetty执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient jettyHttpClient = <span class="keyword">new</span> HttpClient（）; jettyHttpClient.setMaxConnectionsPerDestination（ <span class="integer">1000</span> ）; jettyHttpClient.setExecutor（ <span class="keyword">new</span> QueuedThreadPool（ <span class="integer">1000</span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了您应该考虑自定义的服务器端SockJS相关属性（请参阅Javadoc以获取详细信息）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">扩展了</span> WebSocketMessageBrokerConfigurationSupport { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerStompEndpoints（StompEndpointRegistry registry）{registry.addEndpoint（ <span class="string"><span class="delimiter">“</span> <span class="content">/ sockjs</span> <span class="delimiter">”</span></span> ）。withSockJS（）。setStreamBytesLimit（ <span class="integer">512</span> * <span class="integer">1024</span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .setHttpMessageCacheSize（ <span class="integer">1000</span> ） <i class="conum" data-value="2"></i> <b>（2）</b> .setDisconnectDelay（ <span class="integer">30</span> * <span class="integer">1000</span> ）; <i class="conum" data-value="3"></i> <b>（3）</b> } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>将<code>streamBytesLimit</code>属性设置为512KB（默认值为128KB  - <code>128 * 1024</code> ）。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将<code>httpMessageCacheSize</code>属性设置为1,000（默认值为<code>100</code> ）。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将<code>disconnectDelay</code>属性设置为30个属性秒（默认值为5秒 - <code>5 * 1000</code> ）。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp"><a class="anchor" href="#websocket-stomp"></a> 4.4。STOMP</h3>
<div class="paragraph">
<p>WebSocket协议定义了两种类型的消息（文本和二进制），但它们的内容是未定义的。该协议定义了一种机制，供客户端和服务器协商子协议（即更高级别的消息传递协议），以便在WebSocket上使用，以定义每种消息可以发送的消息类型，格式是什么，内容每条消息，等等。子协议的使用是可选的，但无论哪种方式，客户端和服务器都需要就定义消息内容的某些协议达成一致。</p>
</div>
<div class="sect3">
<h4 id="websocket-stomp-overview"><a class="anchor" href="#websocket-stomp-overview"></a> 4.4.1。概观</h4>
<div class="paragraph">
<p><a href="http://stomp.github.io/stomp-specification-1.2.html#Abstract">STOMP</a> （简单文本导向的消息传递协议）最初是为脚本语言（如Ruby，Python和Perl）创建的，用于连接企业消息代理。它旨在解决常用消息传递模式的最小子集。STOMP可用于任何可靠的双向流网络协议，例如TCP和WebSocket。虽然STOMP是面向文本的协议，但消息有效负载可以是文本或二进制。</p>
</div>
<div class="paragraph">
<p>STOMP是一种基于帧的协议，其帧在HTTP上建模。以下清单显示了STOMP框架的结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>COMMAND header1：value1 header2：value2 Body ^ @</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>客户端可以使用<code>SEND</code>或<code>SUBSCRIBE</code>命令发送或订阅消息，以及描述消息内容和接收消息的<code>destination</code>头。这启用了一个简单的发布 - 订阅机制，您可以使用该机制通过代理将消息发送到其他连接的客户端，或者向服务器发送消息以请求执行某些工作。</p>
</div>
<div class="paragraph">
<p>当您使用Spring的STOMP支持时，Spring WebSocket应用程序充当客户端的STOMP代理。消息被路由到<code>@Controller</code>消息处理方法或简单的内存代理，该代理跟踪订阅并向订阅用户广播消息。您还可以将Spring配置为使用专用的STOMP代理（例如RabbitMQ，ActiveMQ等）来实现消息的实际广播。在这种情况下，Spring维护与代理的TCP连接，将消息中继到它，并将消息从它传递到连接的WebSocket客户端。因此，Spring Web应用程序可以依赖统一的基于HTTP的安全性，通用验证以及用于消息处理的熟悉的编程模型。</p>
</div>
<div class="paragraph">
<p>以下示例显示订阅接收股票报价的客户，服务器可以定期发出（例如，通过<code>SimpMessagingTemplate</code>向代理发送消息的计划任务）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>SUBSCRIBE id：sub-1 destination：/topic/price.stock。* ^ @</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了发送交易请求的客户端，服务器可以通过<code>@MessageMapping</code>方法处理该<code>@MessageMapping</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>发送目的地：/ queue / trade content-type：application / json content-length：44 {“action”：“BUY”，“ticker”：“MMM”，“shares”，44} ^ @</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>执行后，服务器可以向客户端广播交易确认消息和详细信息。</p>
</div>
<div class="paragraph">
<p>在STOMP规范中故意将目的地的含义保持不透明。它可以是任何字符串，完全取决于STOMP服务器来定义它们支持的目标的语义和语法。然而，很常见的是，目标是类似路径的字符串，其中<code>/topic/..</code>意味着发布 - 订阅（一对多）和<code>/queue/</code>意味着点对点（一对一）消息交流。</p>
</div>
<div class="paragraph">
<p>STOMP服务器可以使用<code>MESSAGE</code>命令向所有订户广播消息。以下示例显示了向订阅客户端发送股票报价的服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>MESSAGE message-id：nxahklf6-1 subscription：sub-1 destination：/topic/price.stock。MMM {“自动收报机”：“MMM”，“价格”：129.45} ^ @</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>服务器无法发送未经请求的消息。来自服务器的所有消息必须响应特定的客户端订阅，并且服务器消息的<code>subscription-id</code>头必须与客户端订阅的<code>id</code>头匹配。</p>
</div>
<div class="paragraph">
<p>前面的概述旨在提供对STOMP协议的最基本的了解。我们建议完整地查看协议<a href="http://stomp.github.io/stomp-specification-1.2.html">规范</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-benefits"><a class="anchor" href="#websocket-stomp-benefits"></a> 4.4.2。优点</h4>
<div class="paragraph">
<p>使用STOMP作为子协议，Spring Framework和Spring Security提供了比使用原始WebSocket更丰富的编程模型。关于HTTP与原始TCP以及它如何让Spring MVC和其他Web框架提供丰富的功能，可以做出同样的观点。以下是一系列好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无需发明自定义消息传递协议和消息格式。</p>
</li>
<li>
<p>可以使用STOMP客户端，包括Spring Framework中的<a href="#websocket-stomp-client">Java客户端</a> 。</p>
</li>
<li>
<p>您可以（可选）使用消息代理（例如RabbitMQ，ActiveMQ等）来管理订阅和广播消息。</p>
</li>
<li>
<p>可以在任意数量的<code>@Controller</code>实例中组织应用程序逻辑，并且可以基于STOMP目标标头将消息路由到它们，而不是使用给定连接的单个<code>WebSocketHandler</code>处理原始WebSocket消息。</p>
</li>
<li>
<p>您可以使用Spring Security根据STOMP目标和消息类型保护消息。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-enable"><a class="anchor" href="#websocket-stomp-enable"></a> 4.4.3。启用S​​TOMP</h4>
<div class="paragraph">
<p><code>spring-messaging</code>和<code>spring-websocket</code>模块提供STOMP over WebSocket支持。一旦有了这些依赖项，就可以通过带有<a href="#websocket-fallback">SockJS Fallback的</a> WebSocket公开STOMP端点，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。EnableWebSocketMessageBroker</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.socket.config.annotation。StompEndpointRegistry</span> ; <span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerStompEndpoints（StompEndpointRegistry registry）{registry.addEndpoint（ <span class="string"><span class="delimiter">“</span> <span class="content">/ portfolio</span> <span class="delimiter">”</span></span> ）。withSockJS（）; <i class="conum" data-value="1"></i> <b>（1）</b> } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureMessageBroker（MessageBrokerRegistry config）{config.setApplicationDestinationPrefixes（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="2"></i> <b>（2）</b> config.enableSimpleBroker（ <span class="string"><span class="delimiter">“</span> <span class="content">/ topic</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">/ queue</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="3"></i> <b>（3）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>/portfolio</code>是WebSocket（或SockJS）客户端为WebSocket握手需要连接的端点的HTTP URL。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>目标头以<code>/app</code>开头的STOMP消息将路由到<code>@Controller</code>类中的<code>@MessageMapping</code>方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用内置消息代理进行订阅和广播，并将目标头以<code>/topic `or `/queue</code>开头的消息路由到代理。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：message-broker</span> <span class="attribute-name">application-destination-prefix</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ app</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket： stomp-endpoint</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ portfolio</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：sockjs</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：stomp-endpoint&gt;</span> <span class="tag">&lt;websocket：simple-broker</span> <span class="attribute-name">prefix</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ topic，/ queue</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：message-broker&gt;</span> <span class="tag">&lt; /豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于内置的简单代理， <code>/topic</code>和<code>/queue</code>前缀没有任何特殊含义。它们仅仅是区分pub-sub和点对点消息传递的惯例（即，许多订阅者与一个消费者）。使用外部代理时，请检查代理的STOMP页面，以了解它支持的STOMP目标和前缀类型。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要从浏览器连接，对于SockJS，您可以使用<a href="https://github.com/sockjs/sockjs-client"><code>sockjs-client</code></a> 。对于STOMP，许多应用程序使用了<a href="https://github.com/jmesnil/stomp-websocket">jmesnil / stomp-websocket</a>库（也称为stomp.js），它是功能完备的，已经在生产中使用多年但不再维护。目前， <a href="https://github.com/JSteunou/webstomp-client">JSteunou / webstomp-client</a>是该库中最积极维护和不断发展的继任者。以下示例代码基于它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS（ <span class="string"><span class="delimiter">“</span> <span class="content">/ spring-websocket-portfolio / portfolio</span> <span class="delimiter">”</span></span> ）; <span class="keyword">var</span> stompClient = webstomp.over（socket）; stompClient.connect（{}， <span class="keyword">function</span> （frame）{}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果通过WebSocket连接（没有SockJS），则可以使用以下代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket（ <span class="string"><span class="delimiter">“</span> <span class="content">/ spring-websocket-portfolio / portfolio</span> <span class="delimiter">”</span></span> ）; <span class="keyword">var</span> stompClient = Stomp.over（socket）; stompClient.connect（{}， <span class="keyword">function</span> （frame）{}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，前面示例中的<code>stompClient</code>不需要指定<code>login</code>和<code>passcode</code>头。即使它确实如此，它们也会在服务器端被忽略（或者更确切地说，被覆盖）。有关<a href="#websocket-stomp-authentication">身份验证</a>的详细信息，请参阅<a href="#websocket-stomp-handle-broker-relay-configure">连接到代理</a>和<a href="#websocket-stomp-authentication">身份</a>验证。</p>
</div>
<div class="paragraph">
<p>有关更多示例代码，请参阅</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/guides/gs/messaging-stomp-websocket/">使用WebSocket构建交互式Web应用程序</a> - 入门指南。</p>
</li>
<li>
<p><a href="https://github.com/rstoyanchev/spring-websocket-portfolio">股票投资组合</a> - 示例应用程序。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-message-flow"><a class="anchor" href="#websocket-stomp-message-flow"></a> 4.4.4。消息流</h4>
<div class="paragraph">
<p>一旦暴露了STOMP端点，Spring应用程序就成为连接客户端的STOMP代理。本节介绍服务器端的消息流。</p>
</div>
<div class="paragraph">
<p><code>spring-messaging</code>模块包含对源自<a href="https://spring.io/spring-integration">Spring Integration的</a>消息传递应用程序的基础支持，后来被提取并整合到Spring Framework中，以便在许多<a href="https://spring.io/projects">Spring项目</a>和应用程序场景中得到更广泛的使用。以下列表简要介绍了一些可用的消息传递抽象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/Message.html">消息</a> ： <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/Message.html">消息的</a>简单表示，包括标头和有效负载。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html">MessageHandler</a> ：处理消息的合同。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/MessageChannel.html">MessageChannel</a> ：用于发送消息的合同，该消息允许生成者和使用者之间的松散耦合。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/SubscribableChannel.html">SubscribableChannel</a> ：具有<code>MessageHandler</code>订阅者的<code>MessageChannel</code> 。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html">ExecutorSubscribableChannel</a> ：使用<code>Executor</code>传递消息的<code>SubscribableChannel</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java配置（即<code>@EnableWebSocketMessageBroker</code> ）和XML命名空间配置（即<code>&lt;websocket:message-broker&gt;</code> ）都使用前面的组件来组装消息工作流。下图显示了启用简单内置消息代理时使用的组件：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message-flow-simple-broker.png" alt="消息流简单经纪人">
</div>
</div>
<div class="paragraph">
<p>上图显示了三个消息通道：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientInboundChannel</code> ：用于传递从WebSocket客户端收到的消息。</p>
</li>
<li>
<p><code>clientOutboundChannel</code> ：用于将服务器消息发送到WebSocket客户端。</p>
</li>
<li>
<p><code>brokerChannel</code> ：用于从服务器端应用程序代码中向消息代理发送消息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下图显示了配置外部代理（例如RabbitMQ）以管理订阅和广播消息时使用的组件：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message-flow-broker-relay.png" alt="消息流代理中继">
</div>
</div>
<div class="paragraph">
<p>前两个图的主要区别在于使用“代理中继”通过TCP将消息传递到外部STOMP代理，以及将消息从代理传递到订阅的客户端。</p>
</div>
<div class="paragraph">
<p>当从WebSocket连接接收消息时，它们被解码为STOMP帧，变为Spring <code>Message</code>表示，并发送到<code>clientInboundChannel</code>以进行进一步处理。例如，目标标头以<code>/app</code>开头的STOMP消息可以路由到<code>@MessageMapping</code>注释的控制器中的<code>@MessageMapping</code>方法，而<code>/topic</code>和<code>/queue</code>消息可以直接路由到消息代理。</p>
</div>
<div class="paragraph">
<p>带注释的<code>@Controller</code>来自客户端处理一个STOMP消息可以通过发送消息到消息代理<code>brokerChannel</code> ，并且代理广播消息通过匹配用户<code>clientOutboundChannel</code> 。同一个控制器也可以响应HTTP请求执行相同操作，因此客户端可以执行HTTP POST，然后<code>@PostMapping</code>方法可以向消息代理发送消息以向订阅的客户端广播。</p>
</div>
<div class="paragraph">
<p>我们可以通过一个简单的例子来追踪流程。请考虑以下示例，该示例设置服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerStompEndpoints（StompEndpointRegistry registry）{registry.addEndpoint（ <span class="string"><span class="delimiter">“</span> <span class="content">/ portfolio</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureMessageBroker（MessageBrokerRegistry registry）{registry.setApplicationDestinationPrefixes（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）; registry.enableSimpleBroker（ <span class="string"><span class="delimiter">“</span> <span class="content">/ topic</span> <span class="delimiter">”</span></span> ）; <span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">GreetingController</span> { <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ greeting</span> <span class="delimiter">”</span></span> ）{ <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="predefined-type">String</span> greeting）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">[</span> <span class="delimiter">”</span></span> + getTimestamp（）+ <span class="string"><span class="delimiter">“</span> <span class="content">：</span> <span class="delimiter">”</span></span> + greeting; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例支持以下流程：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端连接到<code><a href="http://localhost:8080/portfolio" class="bare">http://localhost:8080/portfolio</a></code> ，一旦建立了WebSocket连接，STOMP帧就开始在其上流动。</p>
</li>
<li>
<p>客户端发送SUBSCRIBE帧，其目标头为<code>/topic/greeting</code> 。收到并解码后，消息将发送到<code>clientInboundChannel</code> ，然后路由到存储客户端订阅的消息代理。</p>
</li>
<li>
<p>客户端向<code>/app/greeting</code>发送aSEND帧。<code>/app</code>前缀有助于将其路由到带注释的控制器。删除<code>/app</code>前缀后，目标的剩余<code>/greeting</code>部分将映射到<code>GreetingController</code>的<code>@MessageMapping</code>方法。</p>
</li>
<li>
<p>从返回的值<code>GreetingController</code>变成一个Spring <code>Message</code>基于该返回值和的默认目的地标题的有效载荷<code>/topic/greeting</code> （从与所输入的目的地导出<code>/app</code>通过替换<code>/topic</code> ）。生成的消息将发送到<code>brokerChannel</code>并由消息代理处理。</p>
</li>
<li>
<p>消息代理找到所有匹配的订阅者，并通过<code>clientOutboundChannel</code>向每个订阅者发送一个MESSAGE帧，消息被编码为STOMP帧并在WebSocket连接上发送。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下一节提供了有关注释方法的更多详细信息，包括支持的参数类型和返回值。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-annotations"><a class="anchor" href="#websocket-stomp-handle-annotations"></a> 4.4.5。带注释的控制器</h4>
<div class="paragraph">
<p>应用程序可以使用带注释的<code>@Controller</code>类来处理来自客户端的消息。这些类可以声明<code>@MessageMapping</code> ， <code>@SubscribeMapping</code>和<code>@ExceptionHandler</code>方法，如以下主题中所述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#websocket-stomp-message-mapping">使用<code>@MessageMapping</code></a></p>
</li>
<li>
<p><a href="#websocket-stomp-subscribe-mapping">使用<code>@SubscribeMapping</code></a></p>
</li>
<li>
<p><a href="#websocket-stomp-exception-handler">使用<code>@MessageExceptionHandler</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="websocket-stomp-message-mapping"><a class="anchor" href="#websocket-stomp-message-mapping"></a>使用<code>@MessageMapping</code></h5>
<div class="paragraph">
<p>您可以使用<code>@MessageMapping</code>来注释根据目标路由消息的方法。它在方法级别和类型级别受支持。在类型级别， <code>@MessageMapping</code>用于表示控制器中所有方法的共享映射。</p>
</div>
<div class="paragraph">
<p>默认情况下，映射值是Ant样式的路径模式（例如<code>/thing*</code> ， <code>/thing/**</code> ），包括对模板变量的支持（例如， <code>/thing/{id}</code> ）。可以通过<code>@DestinationVariable</code>方法参数引用这些值。应用程序还可以切换到以点分隔的映射目标约定，如<a href="#websocket-stomp-destination-separator">Dots as Separators中所述</a> 。</p>
</div>
<div class="sect5">
<h6 id="supported-method-arguments"><a class="anchor" href="#supported-method-arguments"></a>支持的方法参数</h6>
<div class="paragraph">
<p>下表描述了方法参数：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>信息</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问完整的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问<code>Message</code>的标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaderAccessor</code> ， <code>SimpMessageHeaderAccessor</code>和<code>StompHeaderAccessor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过类型化访问器方法访问标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问消息的有效负载，由已配置的<code>MessageConverter</code>转换（例如，从JSON）。
</p><p class="tableblock">不需要存在此注释，因为默认情况下，假设没有其他参数匹配。
</p><p class="tableblock">您可以使用<code>@javax.validation.注释有效负载参数<code>@javax.validation.Valid</code>或Spring的<code>@Validated</code> ，以自动验证有效负载参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Header</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问特定标头值 - 以及使用<code>org.springframework.core.convert.converter.进行类型转换<code>org.springframework.core.convert.converter.Converter</code> ，如有必要。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Headers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问消息中的所有标头。此参数必须可分配给<code>java.util.Map</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DestinationVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问从消息目标中提取的模板变量。根据需要将值转换为声明的方法参数类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security。主要</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">反映WebSocket HTTP握手时登录的用户。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="return-values"><a class="anchor" href="#return-values"></a>返回值</h6>
<div class="paragraph">
<p>默认情况下， <code>@MessageMapping</code>方法的返回值通过匹配的<code>MessageConverter</code>序列化为有效负载，并作为<code>Message</code>发送到<code>brokerChannel</code> ，从那里广播到订阅者。出站消息的目的地与入站消息的目的地相同，但前缀为<code>/topic</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@SendTo</code>和<code>@SendToUser</code>注释来自定义输出消息的目标。<code>@SendTo</code>用于自定义目标目标或指定多个目标。<code>@SendToUser</code>用于将输出消息定向到仅与输入消息关联的用户。请参阅<a href="#websocket-stomp-user-destination">用户目标</a> 。</p>
</div>
<div class="paragraph">
<p>您可以在同一方法上同时使用<code>@SendTo</code>和<code>@SendToUser</code> ，并且在类级别都支持它们，在这种情况下，它们充当类中方法的默认值。但是，请记住，任何方法级别的<code>@SendTo</code>或<code>@SendToUser</code>注释都会覆盖类级别的任何此类注释。</p>
</div>
<div class="paragraph">
<p>消息可以异步处理， <code>@MessageMapping</code>方法可以返回<code>ListenableFuture</code> ， <code>CompletableFuture</code>或<code>CompletionStage</code> 。</p>
</div>
<div class="paragraph">
<p>请注意， <code>@SendTo</code>和<code>@SendToUser</code>仅仅是一种便利，相当于使用<code>SimpMessagingTemplate</code>发送消息。如有必要，对于更高级的方案， <code>@MessageMapping</code>方法可以直接使用<code>SimpMessagingTemplate</code> 。这可以代替返回值，或者可能另外返回值。请参阅<a href="#websocket-stomp-handle-send">发送消息</a> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-stomp-subscribe-mapping"><a class="anchor" href="#websocket-stomp-subscribe-mapping"></a>使用<code>@SubscribeMapping</code></h5>
<div class="paragraph">
<p><code>@SubscribeMapping</code>类似于<code>@MessageMapping</code>但仅将映射缩小为订阅消息。它支持与<code>@MessageMapping</code>相同的<a href="#websocket-stomp-message-mapping">方法参数</a> 。但是对于返回值，默认情况下，消息将直接发送到客户端（通过<code>clientOutboundChannel</code> ，以响应订阅），而不是发送到代理（通过<code>brokerChannel</code> ，作为匹配订阅的广播）。添加<code>@SendTo</code>或<code>@SendToUser</code>会覆盖此行为<code>@SendToUser</code>送给代理。</p>
</div>
<div class="paragraph">
<p>什么时候有用？假设代理映射到<code>/topic</code>和<code>/queue</code> ，而应用控制器被映射到<code>/app</code> 。在此设置中，代理将所有订阅存储到<code>/topic</code>和<code>/queue</code> ，用于重复广播，并且不需要应用程序参与。客户端还可以订阅某个<code>/app</code>目的地，并且控制器可以返回响应于该订阅的值而不涉及代理而不再存储或使用订阅（实际上是一次性请求 - 回复交换）。一个用例是在启动时使用初始数据填充UI。</p>
</div>
<div class="paragraph">
<p>什么时候这没用？不要尝试将代理和控制器映射到相同的目标前缀，除非您由于某种原因希望两者都独立处理消息（包括订阅）。入站消息是并行处理的。无法保证代理或控制器是否首先处理给定的消息。如果在存储订阅并准备好广播时通知目标，则客户端应该在服务器支持时询问收据（简单代理不支持）。例如，使用Java <a href="#websocket-stomp-client">STOMP客户端</a> ，您可以执行以下操作来添加收据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span> <span class="directive">private</span> TaskScheduler messageBrokerTaskScheduler; <span class="comment">//初始化期间..</span>stompClient.setTaskScheduler（ <span class="local-variable">this</span> .messageBrokerTaskScheduler）; <span class="comment">//订阅时..</span>StompHeaders headers = <span class="keyword">new</span> StompHeaders（）; headers.setDestination（ <span class="string"><span class="delimiter">“</span> <span class="content">/ topic / ...</span> <span class="delimiter">”</span></span> ）; headers.setReceipt（ <span class="string"><span class="delimiter">“</span> <span class="content">r1</span> <span class="delimiter">”</span></span> ）; FrameHandler处理程序= ...; stompSession.subscribe（headers，handler）.addReceiptTask（（） - &gt; { <span class="comment">//订阅就绪......</span>}）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>服务器端选项是在<code>brokerChannel</code>上<a href="#websocket-stomp-interceptors">注册</a> <code>ExecutorChannelInterceptor</code> ，并实现在处理<code>afterMessageHandled</code>消息（包括订阅）后调用的<code>afterMessageHandled</code>方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-stomp-exception-handler"><a class="anchor" href="#websocket-stomp-exception-handler"></a>使用<code>@MessageExceptionHandler</code></h5>
<div class="paragraph">
<p>应用程序可以使用<code>@MessageExceptionHandler</code>方法来处理来自<code>@MessageMapping</code>方法的异常。如果要访问异常实例，可以在注释本身或通过方法参数声明异常。以下示例通过方法参数声明异常：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> { <span class="comment">// ...</span>

    <span class="annotation">@MessageExceptionHandler</span> <span class="directive">public</span> ApplicationError handleException（MyException exception）{ <span class="comment">// ...</span>
        <span class="keyword">return</span> appError; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@MessageExceptionHandler</code>方法支持灵活的方法签名和支持相同的方法的参数类型和返回值作为<a href="#websocket-stomp-message-mapping"><code>@MessageMapping</code></a>方法。</p>
</div>
<div class="paragraph">
<p>通常， <code>@MessageExceptionHandler</code>方法适用于声明它们的<code>@Controller</code>类（或类层次结构）。如果您希望这些方法更全局地应用（跨控制器），您可以在标有<code>@ControllerAdvice</code>的类中声明它们。这与Spring MVC中提供<a href="#mvc-ann-controller-advice">的类似支持</a>相当。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-send"><a class="anchor" href="#websocket-stomp-handle-send"></a> 4.4.6。发送消息</h4>
<div class="paragraph">
<p>如果要从应用程序的任何部分向连接的客户端发送消息，该怎么办？任何应用程序组件都可以向<code>brokerChannel</code>发送消息。最简单的方法是注入<code>SimpMessagingTemplate</code>并使用它来发送消息。通常，您将按类型注入它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">GreetingController</span> { <span class="directive">private</span> SimpMessagingTemplate模板; <span class="annotation">@Autowired</span> <span class="directive">public</span> GreetingController（SimpMessagingTemplate template）{ <span class="local-variable">this</span> .template = template; } <span class="annotation">@RequestMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ greetings</span> <span class="delimiter">”</span></span> ，method = POST） <span class="directive">public</span> <span class="type">void</span> greet（ <span class="predefined-type">String</span> greeting）{ <span class="predefined-type">String</span> text = <span class="string"><span class="delimiter">“</span> <span class="content">[</span> <span class="delimiter">”</span></span> + getTimestamp（）+ <span class="string"><span class="delimiter">“</span> <span class="content">]：</span> <span class="delimiter">”</span></span> + greeting; <span class="local-variable">这个</span> .template.convertAndSend（ <span class="string"><span class="delimiter">“</span> <span class="content">/ topic / greetings</span> <span class="delimiter">”</span></span> ，text）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，如果存在另一个相同类型的bean，您还可以通过其名称（ <code>brokerMessagingTemplate</code> ）对其进行限定。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-simple-broker"><a class="anchor" href="#websocket-stomp-handle-simple-broker"></a> 4.4.7。简单的经纪人</h4>
<div class="paragraph">
<p>内置的简单消息代理处理来自客户端的订阅请求，将它们存储在内存中，并将消息广播到具有匹配目标的连接客户端。代理支持类似路径的目标，包括对Ant样式目标模式的订阅。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">应用程序还可以使用点分隔（而不是斜线分隔）目标。将<a href="#websocket-stomp-destination-separator">点视为分隔符</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果配置了任务调度程序，则简单代理支持<a href="https://stomp.github.io/stomp-specification-1.2.html#Heart-beating">STOMP心跳</a> 。为此，您可以声明自己的调度程序或使用内部自动声明和使用的调度程序。以下示例显示如何声明自己的调度程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="directive">private</span> TaskScheduler messageBrokerTaskScheduler; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setMessageBrokerTaskScheduler（TaskScheduler taskScheduler）{ <span class="local-variable">this</span> .messageBrokerTaskScheduler = taskScheduler; } <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureMessageBroker（MessageBrokerRegistry注册表）{registry.enableSimpleBroker（ <span class="string"><span class="content"><span class="delimiter">“/</span>队列<span class="delimiter">/”，</span></span></span> <span class="string"><span class="content"><span class="delimiter">“/</span>主题<span class="delimiter">/”）.setHeartbeatValue（</span></span></span> <span class="keyword">新</span> <span class="type">长</span> <span class="type">[]</span> <span class="integer"><span class="integer">{10000，20000}）.setTaskScheduler（</span></span> <span class="local-variable">此</span> .messageBrokerTaskScheduler）; <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-broker-relay"><a class="anchor" href="#websocket-stomp-handle-broker-relay"></a> 4.4.8。外部经纪人</h4>
<div class="paragraph">
<p>简单的代理非常适合入门，但仅支持一部分STOMP命令（它不支持ack，收据和其他一些功能），依赖于简单的消息发送循环，不适合集群。作为替代方案，您可以升级应用程序以使用功能齐全的消息代理。</p>
</div>
<div class="paragraph">
<p>请参阅STOMP文档以了解您选择的消息代理（例如<a href="http://www.rabbitmq.com/stomp.html">RabbitMQ</a> ， <a href="http://activemq.apache.org/stomp.html">ActiveMQ</a>等），安装代理，并在启用STOMP支持的情况下运行它。然后，您可以在Spring配置中启用STOMP代理中继（而不是简单代理）。</p>
</div>
<div class="paragraph">
<p>以下示例配置启用功能齐全的代理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> registerStompEndpoints（StompEndpointRegistry registry）{registry.addEndpoint（ <span class="string"><span class="delimiter">“</span> <span class="content">/ portfolio</span> <span class="delimiter">”</span></span> ）。withSockJS（）; } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureMessageBroker（MessageBrokerRegistry registry）{registry.enableStompBrokerRelay（ <span class="string"><span class="delimiter">“</span> <span class="content">/ topic</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">/ queue</span> <span class="delimiter">”</span></span> ）; registry.setApplicationDestinationPrefixes（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：message-broker</span> <span class="attribute-name">application-destination-prefix</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ app</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket： stomp-endpoint</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ portfolio</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;websocket：sockjs</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：stomp-endpoint&gt;</span> <span class="tag">&lt;websocket：stomp-broker-relay</span> <span class="attribute-name">prefix</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ topic，/ queue</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：message-经纪人&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置中的STOMP代理中继是Spring <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html"><code>MessageHandler</code></a> ，它通过将消息转发到外部消息代理来处理消息。为此，它建立与代理的TCP连接，将所有消息转发给它，然后通过其WebSocket会话将从代理接收的所有消息转发给客户端。从本质上讲，它充当“转发”，可以在两个方向上转发消息。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">将<code>io.projectreactor.netty:reactor-netty</code> <code>io.netty:netty-all</code>和<code>io.netty:netty-all</code>依赖项添加到项目中以进行TCP连接管理。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此外，应用程序组件（例如HTTP请求处理方法，业务服务等）也可以向代理中继<a href="#websocket-stomp-handle-send">发送消息</a> ，如<a href="#websocket-stomp-handle-send">发送消息中所述</a> ，以向订阅的WebSocket客户端广播消息。</p>
</div>
<div class="paragraph">
<p>实际上，代理中继实现了健壮且可扩展的消息广播。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-broker-relay-configure"><a class="anchor" href="#websocket-stomp-handle-broker-relay-configure"></a> 4.4.9。连接到经纪人</h4>
<div class="paragraph">
<p>STOMP代理中继维护与代理的单个“系统”TCP连接。此连接仅用于源自服务器端应用程序的消息，而不用于接收消息。您可以为此连接配置STOMP凭据（即STOMP帧<code>login</code>和<code>passcode</code>头）。这在XML名称空间和Java配置中都显示为<code>systemLogin</code>和<code>systemPasscode</code>属性，其默认值为<code>guest</code>和<code>guest</code> 。</p>
</div>
<div class="paragraph">
<p>STOMP代理中继还为每个连接的WebSocket客户端创建单独的TCP连接。您可以配置用于代表客户端创建的所有TCP连接的STOMP凭据。这在XML命名空间和Java配置中都公开为<code>clientLogin and `clientPasscode</code>属性，默认值为<code>guest`and `guest</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">STOMP代理中继始终在每个<code>CONNECT</code>帧上设置<code>login</code>和<code>passcode</code>头，它代表客户端转发给代理。因此，WebSocket客户端无需设置这些标头。他们被忽略了。正如<a href="#websocket-stomp-authentication">身份验证</a>部分所述，WebSocket客户端应该依赖HTTP身份验证来保护WebSocket端点并建立客户端身份。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>STOMP代理中继还通过“系统”TCP连接向消息代理发送和接收心跳。您可以配置发送和接收心跳的间隔（默认情况下每个10秒）。如果与代理的连接丢失，代理中继将继续尝试每5秒重新连接一次，直到成功为止。</p>
</div>
<div class="paragraph">
<p>任何Spring bean都可以实现<code>ApplicationListener&lt;BrokerAvailabilityEvent&gt;</code> ，以便在与代理的“系统”连接丢失并重新建立时接收通知。例如，广播股票报价的股票报价服务可以在没有活动的“系统”连接时停止尝试发送消息。</p>
</div>
<div class="paragraph">
<p>默认情况下，STOMP代理中继始终连接（并在连接丢失时根据需要重新连接）到同一主机和端口。如果您希望提供多个地址，则在每次尝试连接时，您都可以配置地址供应商，而不是固定的主机和端口。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">扩展</span> AbstractWebSocketMessageBrokerConfigurer { <span class="comment">// ...</span>

    <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureMessageBroker（MessageBrokerRegistry registry）{registry.enableStompBrokerRelay（ <span class="string"><span class="delimiter">“</span> <span class="content">/ queue /</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">/ topic /</span> <span class="delimiter">”</span></span> ）。setTcpClient（createTcpClient（））; registry.setApplicationDestinationPrefixes（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）; } <span class="directive">private</span> ReactorNettyTcpClient &lt; <span class="type">byte</span> <span class="type">[]</span> &gt; createTcpClient（）{Consumer &lt;ClientOptions。生成器“？&gt;&gt; builderConsumer = builder  - &gt; {builder.connectAddress（（） - &gt; { <span class="comment">//选择要连接的地址...</span>}）; }; <span class="keyword">返回</span> <span class="keyword">新的</span> ReactorNettyTcpClient &lt;&gt;（builderConsumer， <span class="keyword">new</span> StompReactorNettyCodec（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>virtualHost</code>属性配置STOMP代理中继。此属性的值被设置为每个<code>CONNECT</code>帧的<code>host</code>头，并且可能很有用（例如，在建立TCP连接的实际主机与提供基于云的STOMP服务的主机不同的云环境中）。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-destination-separator"><a class="anchor" href="#websocket-stomp-destination-separator"></a> 4.4.10。点作为分隔符</h4>
<div class="paragraph">
<p>当消息路由到<code>@MessageMapping</code>方法时，它们与<code>AntPathMatcher</code>匹配。默认情况下，模式应使用斜杠（ <code>/</code> ）作为分隔符。这是Web应用程序中的一个很好的约定，类似于HTTP URL。但是，如果您更习惯于消息传递约定，则可以切换到使用点（ <code>.</code> ）作为分隔符。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Java配置中执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="comment">// ...</span>

    <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureMessageBroker（MessageBrokerRegistry registry）{registry.setPathMatcher（ <strong><span class="keyword">new</span> AntPathMatcher（ <span class="string"><span class="delimiter">“</span> <span class="content">。</span> <span class="delimiter">”</span></span> ））;</strong> registry.enableStompBrokerRelay（ <span class="string"><span class="delimiter">“</span> <span class="content">/ queue</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">/ topic</span> <span class="delimiter">”</span></span> ）; registry.setApplicationDestinationPrefixes（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：message-broker</span> <span class="attribute-name">application-destination-prefix</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ app</span> <span class="delimiter">“</span></span> <span class="attribute-name">path-matcher</span> = <span class="string"><span class="delimiter">“</span> <span class="content"><strong>pathMatcher</strong></span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：stomp-endpoint</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ stomp</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;websocket：stomp-broker-relay</span> <span class="attribute-name">prefix</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ topic，/ queue</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ websocket：message-broker&gt;</span> <strong><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pathMatcher</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.util。AntPathMatcher</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span> = <span class="string"><span class="delimiter">”</span> <span class="content">0</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">。</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></strong> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>之后，控制器可以使用点（ <code>.</code> ）作为<code>@MessageMapping</code>方法中的分隔符，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">erd</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">RedController</span> { <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">blue。{green}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handleGreen（ <span class="annotation">@DestinationVariable</span> <span class="predefined-type">String</span> green）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>客户现在可以向<code>/app/red.blue.green123</code>发送消息。</p>
</div>
<div class="paragraph">
<p>在前面的示例中，我们没有更改“代理中继”上的前缀，因为它们完全依赖于外部消息代理。请参阅您使用的代理的STOMP文档页面，以查看它为目标标头支持的约定。</p>
</div>
<div class="paragraph">
<p>另一方面，“简单代理”确实依赖于配置的<code>PathMatcher</code> ，因此，如果切换分隔符，则该更改也适用于代理以及代理将目标从消息与预订中的模式匹配的方式。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-authentication"><a class="anchor" href="#websocket-stomp-authentication"></a> 4.4.11。认证</h4>
<div class="paragraph">
<p>WebSocket消息传递会话中的每个STOMP都以HTTP请求开头。这可以是升级到WebSockets的请求（即WebSocket握手），或者在SockJS回退的情况下，是一系列SockJS HTTP传输请求。</p>
</div>
<div class="paragraph">
<p>许多Web应用程序已经具有用于保护HTTP请求的身份验证和授权。通常，通过使用某些机制（如登录页面，HTTP基本身份验证或其他方式）通过Spring Security对用户进行身份验证。经过身份验证的用户的安全上下文保存在HTTP会话中，并与同一个基于cookie的会话中的后续请求相关联。</p>
</div>
<div class="paragraph">
<p>因此，对于WebSocket握手或SockJS HTTP传输请求，通常已经通过<code>HttpServletRequest#getUserPrincipal()</code>访问已经过身份验证的用户。Spring自动将该用户与为其创建的WebSocket或SockJS会话相关联，随后通过用户头与该会话上传输的所有STOMP消息相关联。</p>
</div>
<div class="paragraph">
<p>简而言之，典型的Web应用程序除了已经为安全性做的事情之外，不需要做任何事情。用户在HTTP请求级别进行身份验证，其安全上下文通过基于cookie的HTTP会话（然后与为该用户创建的WebSocket或SockJS会话相关联）进行维护，并导致在每个<code>Message</code>流上标记用户标头通过申请。</p>
</div>
<div class="paragraph">
<p>请注意，STOMP协议在<code>CONNECT</code>帧上确实有<code>login</code>和<code>passcode</code>头。这些最初设计用于并且仍然需要，例如，用于TCP上的STOMP。但是，对于STOMP over WebSocket，默认情况下，Spring会忽略STOMP协议级别的授权标头，假定用户已在HTTP传输级别进行了身份验证，并且期望WebSocket或SockJS会话包含经过身份验证的用户。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Security提供<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket">WebSocket子协议授权</a> ，该<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket">授权</a>使用<code>ChannelInterceptor</code>根据其中的用户头来授权消息。此外，Spring Session提供了<a href="http://docs.spring.io/spring-session/docs/current/reference/html5/#websocket">WebSocket集成</a> ，可确保在WebSocket会话仍处于活动状态时用户HTTP会话不会过期。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-authentication-token-based"><a class="anchor" href="#websocket-stomp-authentication-token-based"></a> 4.4.12。令牌认证</h4>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-security-oauth">Spring Security OAuth</a>支持基于令牌的安全性，包括JSON Web令牌（JWT）。您可以将其用作Web应用程序中的身份验证机制，包括STOMP over WebSocket交互，如上一节所述（即通过基于cookie的会话维护身份）。</p>
</div>
<div class="paragraph">
<p>同时，基于cookie的会话并不总是最合适的（例如，在不维护服务器端会话的应用程序中，或者在通常使用标头进行身份验证的移动应用程序中）。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc6455#section-10.5">WebSocket协议RFC 6455</a> “没有规定服务器在WebSocket握手期间可以对客户端进行身份验证的任何特定方式。”但实际上，浏览器客户端只能使用标准身份验证标头（即基本HTTP身份验证）或cookie，而不能（例如）提供自定义标头。同样，SockJS JavaScript客户端不提供使用SockJS传输请求发送HTTP标头的方法。请参阅<a href="https://github.com/sockjs/sockjs-client/issues/196">sockjs-client issue 196</a> 。相反，它确实允许发送可用于发送令牌的查询参数，但这有其自身的缺点（例如，令牌可能无意中使用服务器日志中的URL记录）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">上述限制适用于基于浏览器的客户端，不适用于基于Spring Java的STOMP客户端，它支持使用WebSocket和SockJS请求发送标头。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>因此，希望避免使用cookie的应用程序可能没有任何良好的HTTP协议级别的身份验证替代方案。他们可能更喜欢在STOMP消息传递协议级别使用标头进行身份验证而不是使用cookie。这样做需要两个简单的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用STOMP客户端在连接时传递身份验证标头。</p>
</li>
<li>
<p>使用<code>ChannelInterceptor</code>处理身份验证标头。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下一个示例使用服务器端配置来注册自定义身份验证拦截器。请注意，拦截器只需要在CONNECT <code>Message</code>上进行身份验证和设置用户头。Spring记录并保存经过身份验证的用户，并将其与同一会话中的后续STOMP消息相关联。以下示例显示如何注册自定义身份验证拦截器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureClientInboundChannel（ChannelRegistration registration）{registration.interceptors（ <span class="keyword">new</span> ChannelInterceptor（）{ <span class="annotation">@Override</span> <span class="directive">public</span> Message &lt;？&gt; preSend（消息&lt;？&gt; message，MessageChannel channel）{StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor（message，StompHeaderAccessor.class）; <span class="keyword">如果</span> （StompCommand。CONNECT.equals（accessor.getCommand（）））{Authentication user = ...; <span class="comment">// access authentication header（s）</span> accessor.setUser（user）; } <span class="keyword">return</span> message; }}; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请注意，当您使用Spring Security的消息授权时，您需要确保在Spring Security之前订购身份验证<code>ChannelInterceptor</code>配置。最好通过在自己的<code>WebSocketMessageBrokerConfigurer</code>实现中声明自定义拦截器来实现，该实现使用<code>@Order(Ordered.标记<code>@Order(Ordered.HIGHEST_PRECEDENCE + 99)</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-user-destination"><a class="anchor" href="#websocket-stomp-user-destination"></a> 4.4.13。用户目的地</h4>
<div class="paragraph">
<p>应用程序可以发送针对特定用户的消息，Spring的STOMP支持可识别以<code>/user/</code>为前缀的目标。例如，客户端可能订阅<code>/user/queue/position-updates</code>目的地。此目标由<code>UserDestinationMessageHandler</code>处理，并转换为用户会话唯一的目标（例如<code>/queue/position-updates-user123</code> ）。这提供了订阅一般命名的目的地的便利，同时确保不与订阅相同目的地的其他用户发生冲突，使得每个用户可以接收唯一的库存位置更新。</p>
</div>
<div class="paragraph">
<p>在发送方，可以将消息发送到目的地，例如<code>/user/{username}/queue/position-updates</code> ，然后由<code>UserDestinationMessageHandler</code>将其转换为一个或多个目的地，每个目的地对应于与用户相关联的每个会话。这使得应用程序中的任何组件都可以发送针对特定用户的消息，而无需了解其名称和通用目标。通过注释和消息传递模板也支持此功能。</p>
</div>
<div class="paragraph">
<p>消息处理方法可以向与通过<code>@SendToUser</code>注释处理的消息相关联的用户发送消息（在类级别上也支持共享公共目标），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">PortfolioController</span> { <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ trade</span> <span class="delimiter">”</span></span> ） <span class="annotation">@SendToUser</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ queue / position-updates</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> TradeResult executeTrade（Trade trade， <span class="predefined-type">Principal</span> principal）{ <span class="comment">// ...</span>
        <span class="keyword">return</span> tradeResult; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果用户具有多个会话，则默认情况下，订阅到给定目标的所有会话都是目标。但是，有时，可能需要仅定位发送正在处理的消息的会话。您可以通过将<code>broadcast</code>属性设置为false来执行此操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> { <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ action</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handleAction（） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="comment">// raise MyBusinessException here</span> } <span class="annotation">@MessageExceptionHandler</span> <span class="annotation">@SendToUser</span> （destinations = <span class="string"><span class="delimiter">“</span> <span class="content">/ queue / errors</span> <span class="delimiter">”</span></span> ，broadcast = <span class="predefined-constant">false</span> ） <span class="directive">public</span> ApplicationError handleException（ MyBusinessException异常）{ <span class="comment">// ...</span>
        <span class="keyword">return</span> appError; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">虽然用户目的地通常意味着经过身份验证的用户，但并不是严格要求的。与经过身份验证的用户无关的WebSocket会话可以订阅用户目标。在这种情况下， <code>@SendToUser</code>注释的行为与<code>broadcast=false</code>完全相同（即，仅定位发送正在处理的消息的会话）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以从任何应用程序组件向用户目标发送消息，例如，注入由Java配置或XML命名空间创建的<code>SimpMessagingTemplate</code> 。（如果需要使用<code>@Qualifier</code>进行限定，则bean名称为<code>"brokerMessagingTemplate"</code> 。）以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">TradeServiceImpl</span> <span class="directive">实现</span> TradeService { <span class="directive">private</span> <span class="directive">final</span> SimpMessagingTemplate messagingTemplate; <span class="annotation">@Autowired</span> <span class="directive">public</span> TradeServiceImpl（SimpMessagingTemplate messagingTemplate）{ <span class="local-variable">this</span> .messagingTemplate = messagingTemplate; } <span class="comment">// ...</span>

    <span class="directive">public</span> <span class="type">void</span> afterTradeExecuted（Trade trade）{ <span class="local-variable">this</span> .messagingTemplate.convertAndSendToUser（trade.getUserName（）， <span class="string"><span class="delimiter">“</span> <span class="content">/ queue / position-updates</span> <span class="delimiter">”</span></span> ，trade.getResult（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">将用户目标与外部消息代理一起使用时，应检查代理文档，了解如何管理非活动队列，以便在用户会话结束时删除所有唯一用户队列。例如，当您使用目标（例如<code>/exchange/amq.direct/position-updates</code>时，RabbitMQ会创建自动删除队列。因此，在这种情况下，客户端可以订阅<code>/user/exchange/amq.direct/position-updates</code> 。同样，ActiveMQ具有用于清除非活动目标的<a href="http://activemq.apache.org/delete-inactive-destinations.html">配置选项</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在多应用程序服务器方案中，用户目标可能仍未解析，因为用户已连接到其他服务器。在这种情况下，您可以配置目标以广播未解析的消息，以便其他服务器有机会尝试。这可以通过Java配置中的<code>MessageBrokerRegistry</code>的<code>userDestinationBroadcast</code>属性和XML中的<code>message-broker</code>元素的<code>user-destination-broadcast</code>属性来完成。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-ordered-messages"><a class="anchor" href="#websocket-stomp-ordered-messages"></a> 4.4.14。消息顺序</h4>
<div class="paragraph">
<p>来自代理的消息将发布到<code>clientOutboundChannel</code> ，从那里将它们写入WebSocket会话。由于通道由<code>ThreadPoolExecutor</code>支持，因此消息在不同的线程中处理，并且客户端接收的结果序列可能与发布的确切顺序不匹配。</p>
</div>
<div class="paragraph">
<p>如果这是一个问题，请启用<code>setPreservePublishOrder</code>标志，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="type">void</span> configureMessageBroker（MessageBrokerRegistry registry）{ <span class="comment">// ...</span>registry.setPreservePublishOrder（ <span class="predefined-constant">true</span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：message-broker</span> <span class="attribute-name">preserve-publish-order</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - ...  - &gt;</span> <span class="tag">&lt;/ websocket：message-broker&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>设置标志后，同一客户端会话中的消息将一次发布到<code>clientOutboundChannel</code> ，以便保证发布顺序。请注意，这会导致较小的性能开销，因此只有在需要时才应启用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-appplication-context-events"><a class="anchor" href="#websocket-stomp-appplication-context-events"></a> 4.4.15。活动</h4>
<div class="paragraph">
<p>发布了几个<code>ApplicationContext</code>事件，可以通过实现Spring的<code>ApplicationListener</code>接口来接收它们：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BrokerAvailabilityEvent</code> ：指示代理何时可用或不可用。虽然“简单”代理在启动时立即可用，并且在应用程序运行时仍然如此，但STOMP“代理中继”可能会丢失与全功能代理的连接（例如，如果代理重新启动）。代理中继具有重新连接逻辑，并在它返回时重新建立与代理的“系统”连接。因此，只要状态从连接变为断开连接，就会发布此事件，反之亦然。使用<code>SimpMessagingTemplate</code>组件应订阅此事件，并避免在代理不可用时发送消息。在任何情况下，他们都应该准备好在发送消息时处理<code>MessageDeliveryException</code> 。</p>
</li>
<li>
<p><code>SessionConnectEvent</code> ：在收到新的STOMP CONNECT时发布，以指示新客户端会话的开始。该事件包含表示连接的消息，包括会话ID，用户信息（如果有）以及客户端发送的任何自定义标头。这对于跟踪客户端会话很有用。订阅此事件的组件可以使用<code>SimpMessageHeaderAccessor</code>或<code>StompMessageHeaderAccessor</code>包装所包含的消息。</p>
</li>
<li>
<p><code>SessionConnectedEvent</code> ：当代理发送了一个STOMP CONNECTED帧以响应CONNECT时，在<code>SessionConnectEvent</code>之后不久发布。此时，可以认为STOMP会话已完全建立。</p>
</li>
<li>
<p><code>SessionSubscribeEvent</code> ：在收到新的STOMP SUBSCRIBE时发布。</p>
</li>
<li>
<p><code>SessionUnsubscribeEvent</code> ：收到新的STOMP UNSUBSCRIBE时发布。</p>
</li>
<li>
<p><code>SessionDisconnectEvent</code> ：在STOMP会话结束时发布。DISCONNECT可能已从客户端发送，或者可能在WebSocket会话关闭时自动生成。在某些情况下，此事件每次会话发布多次。对于多个断开连接事件，组件应该是幂等的。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当您使用功能齐全的代理时，如果代理暂时不可用，STOMP“代理中继”会自动重新连接“系统”连接。但是，客户端连接不会自动重新连接。假设启用了心跳，客户端通常会注意到代理在10秒内没有响应。客户端需要实现自己的重新连接逻辑。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-interceptors"><a class="anchor" href="#websocket-stomp-interceptors"></a> 4.4.16。截击</h4>
<div class="paragraph">
<p><a href="#websocket-stomp-appplication-context-events">事件</a>为STOMP连接的生命周期提供通知，但不为每个客户端消息提供通知。应用程序还可以注册<code>ChannelInterceptor</code>来拦截任何消息以及处理链的任何部分。以下示例显示如何拦截来自客户端的入站邮件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureClientInboundChannel（ChannelRegistration registration）{registration.interceptors（ <span class="keyword">new</span> MyChannelInterceptor（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>自定义<code>ChannelInterceptor</code>可以使用<code>StompHeaderAccessor</code>或<code>SimpMessageHeaderAccessor</code>来访问有关消息的信息，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyChannelInterceptor</span> <span class="directive">实现</span> ChannelInterceptor <span class="annotation">{@覆盖</span> <span class="directive">公共</span>消息&lt;？&gt; preSend（消息&lt;？&gt; message，MessageChannel channel）{StompHeaderAccessor accessor = StompHeaderAccessor.wrap（message）; StompCommand command = accessor.getStompCommand（）; <span class="comment">// ...</span>
        <span class="keyword">返回</span>消息; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>应用程序还可以实现<code>ExecutorChannelInterceptor</code> ，它是<code>ChannelInterceptor</code>的子接口，在处理消息的线程中具有回调。虽然为发送到通道的每个消息调用一次<code>ChannelInterceptor</code> ，但<code>ExecutorChannelInterceptor</code>在订阅来自通道的消息的每个<code>MessageHandler</code>的线程中提供挂钩。</p>
</div>
<div class="paragraph">
<p>请注意，与<code>SesionDisconnectEvent</code>描述的<code>SesionDisconnectEvent</code>一样，DISCONNECT消息可以来自客户端，也可以在WebSocket会话关闭时自动生成。在某些情况下，拦截器可能会为每个会话多次拦截此消息。对于多个断开连接事件，组件应该是幂等的。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-client"><a class="anchor" href="#websocket-stomp-client"></a> 4.4.17。STOMP客户端</h4>
<div class="paragraph">
<p>Spring通过WebSocket客户端提供STOMP，通过TCP客户端提供STOMP。</p>
</div>
<div class="paragraph">
<p>首先，您可以创建和配置<code>WebSocketStompClient</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebSocketClient webSocketClient = <span class="keyword">new</span> StandardWebSocketClient（）; WebSocketStompClient stompClient = <span class="keyword">new</span> WebSocketStompClient（webSocketClient）; stompClient.setMessageConverter（ <span class="keyword">new</span> StringMessageConverter（））; stompClient.setTaskScheduler（的TaskScheduler）; <span class="comment">//用于心跳</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以将<code>StandardWebSocketClient</code>替换为<code>SockJsClient</code> ，因为它也是<code>WebSocketClient</code>的实现。<code>SockJsClient</code>可以使用WebSocket或基于HTTP的传输作为后备。有关更多详细信息，请参阅<a href="#websocket-fallback-sockjs-client">使用<code>SockJsClient</code></a> 。</p>
</div>
<div class="paragraph">
<p>接下来，您可以建立连接并为STOMP会话提供处理程序，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> url = <span class="string"><span class="delimiter">“</span> <span class="content">ws：//127.0.0.1：8080 / endpoint</span> <span class="delimiter">”</span></span> ; StompSessionHandler sessionHandler = <span class="keyword">new</span> MyStompSessionHandler（）; stompClient.connect（url，sessionHandler）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当会话准备好使用时，将通知处理程序，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyStompSessionHandler</span> <span class="directive">扩展</span> StompSessionHandlerAdapter <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> afterConnected（StompSession会议，StompHeaders <span class="comment">connectedHeaders）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>建立会话后，可以发送任何有效负载并使用配置的<code>MessageConverter</code>序列化，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">session.send（ <span class="string"><span class="delimiter">“</span> <span class="content">/ topic / something</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">payload</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以订阅目的地。<code>subscribe</code>方法需要处理订阅消息的处理程序，并返回可用于取消订阅的<code>Subscription</code>句柄。对于每个收到的消息，处理程序可以指定要对其进行反序列化的目标<code>Object</code>类型，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">session.subscribe（ <span class="string"><span class="content"><span class="delimiter">“/</span>主题/的东西</span> <span class="delimiter">”，</span></span> <span class="keyword">新</span> <span class="annotation">StompFrameHandler（）{@覆盖</span> <span class="directive">公共</span> <span class="predefined-type">类型</span> getPayloadType（StompHeaders头）{ <span class="keyword">返回</span> <span class="predefined-type">字符串</span>的.class;} <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleFrame（StompHeaders头， <span class="predefined-type">对象</span>有效负载<span class="comment">）{// ...</span>}};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要启用STOMP心跳，可以使用<code>TaskScheduler</code>配置<code>WebSocketStompClient</code> ，并可选择自定义心跳间隔（写入不活动10秒，导致心跳发送，读取不活动10秒，关闭连接）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当您使用<code>WebSocketStompClient</code>进行性能测试来模拟来自同一台计算机的数千个客户端时，请考虑关闭心跳，因为每个连接都会调度自己的心跳任务，而不是针对在同一台计算机上运行的大量客户端进行优化。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>STOMP协议还支持收据，其中客户端必须添加<code>receipt</code>标头，服务器在处理发送或订阅后用RECEIPT帧响应。为了支持这一点， <code>StompSession</code>提供了<code>setAutoReceipt(boolean)</code> ，它导致在每个后续的send或subscribe事件中添加一个<code>receipt</code>头。或者，您也可以手动将收据标题添加到<code>StompHeaders</code> 。发送和订阅都返回一个<code>Receiptable</code>实例，您可以使用它来注册接收成功和失败回调。对于此功能，您必须使用<code>TaskScheduler</code>和收据到期前的时间（默认为15秒）配置客户端。</p>
</div>
<div class="paragraph">
<p>需要注意的是<code>StompSessionHandler</code>本身就是一个<code>StompFrameHandler</code> ，可以让它处理错误帧除了<code>handleException</code>回调从操纵消息和例外<code>handleTransportError</code>运输级别的错误，包括<code>ConnectionLostException</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-websocket-scope"><a class="anchor" href="#websocket-stomp-websocket-scope"></a> 4.4.18。WebSocket范围</h4>
<div class="paragraph">
<p>每个WebSocket会话都有一个属性映射。映射作为标头附加到入站客户端消息，可以从控制器方法访问，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> { <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ action</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（SimpMessageHeaderAccessor headerAccessor）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; attrs = headerAccessor.getSessionAttributes（）; <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<code>websocket</code>范围中声明一个Spring管理的bean。您可以将WebSocket范围的bean注入控制器以及在<code>clientInboundChannel</code>上注册的任何通道拦截器。这些通常是单身，比任何单独的WebSocket会话都更长寿。因此，您需要对WebSocket范围的bean使用范围代理模式，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="annotation">@Scope</span> （scopeName = <span class="string"><span class="delimiter">“</span> <span class="content">websocket</span> <span class="delimiter">”</span></span> ，proxyMode = ScopedProxyMode。TARGET_CLASS） <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyBean</span> { <span class="annotation">@PostConstruct</span> <span class="directive">public</span> <span class="type">void</span> init（）{ <span class="comment">//在注入依赖项后调用</span> } <span class="comment">// ...</span>

    <span class="annotation">@PreDestroy</span> <span class="directive">public</span> <span class="type">void</span> destroy（）{ <span class="comment">//当WebSocket会话结束时调用</span> }} <span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> { <span class="directive">private</span> <span class="directive">final</span> MyBean myBean; <span class="annotation">@Autowired</span> <span class="directive">public</span> MyController（MyBean myBean）{ <span class="local-variable">this</span> .myBean = myBean; } <span class="annotation">@MessageMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ action</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（）{ <span class="comment">//来自当前WebSocket会话的this.myBean</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与任何自定义作用域一样，Spring在第一次从控制器访问时初始化一个新的<code>MyBean</code>实例，并将该实例存储在WebSocket会话属性中。随后返回相同的实例，直到会话结束。WebSocket范围的bean调用了所有Spring生命周期方法，如前面的示例所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-configuration-performance"><a class="anchor" href="#websocket-stomp-configuration-performance"></a> 4.4.19。性能</h4>
<div class="paragraph">
<p>在性能方面没有银弹。许多因素都会影响它，包括消息的大小和数量，应用程序方法是否执行需要阻塞的工作，以及外部因素（如网络速度和其他问题）。本部分的目标是提供可用配置选项的概述以及有关如何推理缩放的一些想法。</p>
</div>
<div class="paragraph">
<p>在消息传递应用程序中，消息通过通道进行传递，以进行由线程池支持的异步执行。配置此类应用程序需要充分了解通道和消息流。因此，建议查看<a href="#websocket-stomp-message-flow">消息流</a> 。</p>
</div>
<div class="paragraph">
<p>显而易见的起点是配置支持<code>clientInboundChannel</code>和<code>clientOutboundChannel</code>的线程池。默认情况下，两者都配置为可用处理器数量的两倍。</p>
</div>
<div class="paragraph">
<p>如果注释方法中的消息处理主要受CPU限制，则<code>clientInboundChannel</code>的线程数应保持接近处理器数。如果他们所做的工作更多地受IO限制并且需要阻塞或等待数据库或其他外部系统，则可能需要增加线程池大小。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ThreadPoolExecutor</code>有三个重要属性：核心线程池大小，最大线程池大小，以及队列存储没有可用线程的任务的容量。</p>
</div>
<div class="paragraph">
<p>常见的混淆点是配置核心池大小（例如，10）和最大池大小（例如，20）会导致具有10到20个线程的线程池。实际上，如果容量保留为其默认值Integer。MAX_VALUE，线程池永远不会超出核心池大小，因为所有其他任务都排队。</p>
</div>
<div class="paragraph">
<p>请参阅<code>ThreadPoolExecutor</code>的Javadoc以了解这些属性如何工作并理解各种排队策略。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在<code>clientOutboundChannel</code>方面，它是关于向WebSocket客户端发送消息的全部内容。如果客户端位于快速网络上，则线程数应保持接近可用处理器的数量。如果它们很慢或带宽较低，它们需要更长的时间来使用消息并给线程池带来负担。因此，增加线程池大小变得必要。</p>
</div>
<div class="paragraph">
<p>虽然<code>clientInboundChannel</code>的工作负载可以预测 - 毕竟，它基于应用程序的工作 - 如何配置“clientOutboundChannel”更难，因为它基于应用程序无法控制的因素。出于这个原因，另外两个属性与发送消息有关： <code>sendTimeLimit</code>和<code>sendBufferSizeLimit</code> 。您可以使用这些方法配置允许发送的时间以及向客户端发送消息时可以缓冲的数据量。</p>
</div>
<div class="paragraph">
<p>一般的想法是，在任何给定时间，只有一个线程可用于发送给客户端。同时，所有其他消息都会被缓冲，您可以使用这些属性来决定允许发送消息的时间长度以及在此期间可以缓冲多少数据。有关重要的其他详细信息，请参阅此配置的Javadoc和XML架构文档。</p>
</div>
<div class="paragraph">
<p>以下示例显示了可能的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureWebSocketTransport（WebSocketTransportRegistration registration）{registration.setSendTimeLimit（ <span class="integer">15</span> * <span class="integer">1000</span> ）.setSendBufferSizeLimit（ <span class="integer">512</span> * <span class="integer">1024</span> ）; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：message-broker&gt;</span> <span class="tag">&lt;websocket：transport</span> <span class="attribute-name">send-timeout</span> = <span class="string"><span class="delimiter">”</span> <span class="content">15000</span> <span class="delimiter">“</span></span> <span class="attribute-name">send- buffer-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">524288</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;/ websocket：message-broker&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用前面显示的WebSocket传输配置来配置传入STOMP消息的最大允许大小。从理论上讲，WebSocket消息的大小几乎是无限的。实际上，WebSocket服务器施加了限制 - 例如，Tomcat上的8K和Jetty上的64K。出于这个原因，STOMP客户端（例如JavaScript <a href="https://github.com/JSteunou/webstomp-client">webstomp-client</a>等）在16K边界处拆分较大的STOMP消息，并将它们作为多个WebSocket消息发送，这需要服务器缓冲和重新组装。</p>
</div>
<div class="paragraph">
<p>Spring的STOMP-over-WebSocket支持实现了这一点，因此应用程序可以配置STOMP消息的最大大小，而不管WebSocket服务器特定的消息大小。请记住，必要时会自动调整WebSocket消息大小，以确保它们至少可以携带16K WebSocket消息。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一种可能的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebSocketMessageBroker</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebSocketConfig</span> <span class="directive">实现</span> WebSocketMessageBrokerConfigurer { <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureWebSocketTransport（WebSocketTransportRegistration registration）{registration.setMessageSizeLimit（ <span class="integer">128</span> * <span class="integer">1024</span> ）; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与前面示例等效的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：websocket</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / websocket</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/websocket</span> <span class="content">http://www.springframework.org/schema/websocket/spring-websocket.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;websocket：message-broker&gt;</span> <span class="tag">&lt;websocket：transport</span> <span class="attribute-name">message-size</span> = <span class="string"><span class="delimiter">”</span> <span class="content">131072</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;/ websocket：message-broker&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>关于扩展的一个重点涉及使用多个应用程序实例。目前，您无法使用简单代理执行此操作。但是，当您使用功能齐全的代理（例如RabbitMQ）时，每个应用程序实例都会连接到代理，从一个应用程序实例广播的消息可以通过代理广播到通过任何其他应用程序实例连接的WebSocket客户端。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-stats"><a class="anchor" href="#websocket-stomp-stats"></a> 4.4.20。监控</h4>
<div class="paragraph">
<p>使用<code>@EnableWebSocketMessageBroker</code>或<code>&lt;websocket:message-broker&gt;</code> ，关键基础架构组件会自动收集统计信息和计数器，以便对应用程序的内部状态提供重要信息。该配置还声明了一个类型为<code>WebSocketMessageBrokerStats</code>的bean，它在一个地方收集所有可用信息，默认情况下，每隔30分钟在<code>INFO</code>级别收集一次。这个bean可以通过Spring的<code>MBeanExporter</code>导出到JMX，以便在运行时查看（例如，通过JDK的<code>jconsole</code> ）。以下列表总结了可用信息：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">客户端WebSocket会话</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">当前</dt>
<dd>
<p>指示当前有多少客户端会话，其中计数进一步按WebSocket与HTTP流分析和轮询SockJS会话进行细分。</p>
</dd>
<dt class="hdlist1">总</dt>
<dd>
<p>表示已建立的会话总数。</p>
</dd>
<dt class="hdlist1">异常关闭</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">连接失败</dt>
<dd>
<p>已建立但在60秒内未收到任何消息后关闭的会话。这通常表示代理或网络问题。</p>
</dd>
<dt class="hdlist1">超出发送限制</dt>
<dd>
<p>超过配置的发送超时或发送缓冲区限制后，会话关闭，这可能发生在慢速客户端上（请参阅上一节）。</p>
</dd>
<dt class="hdlist1">运输错误</dt>
<dd>
<p>传输错误后会话关闭，例如无法读取或写入WebSocket连接或HTTP请求或响应。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">STOMP框架</dt>
<dd>
<p>处理的CONNECT，CONNECTED和DISCONNECT帧总数，表示STOMP级别连接的客户端数量。请注意，当会话异常关闭或客户端关闭而不发送DISCONNECT帧时，DISCONNECT计数可能会更低。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">STOMP经纪人接力</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">TCP连接</dt>
<dd>
<p>指示代表客户端WebSocket会话建立到代理的TCP连接数。这应该等于客户端WebSocket会话的数量+ 1个用于从应用程序内发送消息的额外共享“系统”连接。</p>
</dd>
<dt class="hdlist1">STOMP框架</dt>
<dd>
<p>代表客户端转发到代理或从代理接收的CONNECT，CONNECTED和DISCONNECT帧的总数。请注意，无论客户端WebSocket会话如何关闭，都会将DISCONNECT帧发送到代理。因此，较低的DISCONNECT帧计数表示代理主动关闭连接（可能是因为心跳没有及时到达，输入帧无效或其他问题）。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">客户端入站通道</dt>
<dd>
<p>来自支持<code>clientInboundChannel</code>的线程池的统计信息，用于深入了解传入消息处理的运行状况。在此排队的任务表明应用程序可能太慢而无法处理消息。如果存在I / O绑定任务（例如，慢速数据库查询，对第三方REST API的HTTP请求等），请考虑增加线程池大小。</p>
</dd>
<dt class="hdlist1">客户出站频道</dt>
<dd>
<p>来自支持<code>clientOutboundChannel</code>的线程池的统计<code>clientOutboundChannel</code> ，用于深入了解向客户端广播消息的运行状况。在此排队的任务表明客户端消耗消息的速度太慢。解决此问题的一种方法是增加线程池大小以适应预期的并发慢客户端数量。另一种选择是减少发送超时和发送缓冲区大小限制（参见上一节）。</p>
</dd>
<dt class="hdlist1">SockJS任务计划程序</dt>
<dd>
<p>来自SockJS任务调度程序的线程池的统计信息，用于发送检测信号。请注意，在STOMP级别协商心跳时，将禁用SockJS心跳。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-testing"><a class="anchor" href="#websocket-stomp-testing"></a> 4.4.21。测试</h4>
<div class="paragraph">
<p>当您使用Spring的STOMP-over-WebSocket支持时，有两种主要的方法来测试应用程序。第一种是编写服务器端测试来验证控制器的功能及其带注释的消息处理方法。第二种是编写涉及运行客户端和服务器的完整端到端测试。</p>
</div>
<div class="paragraph">
<p>这两种方法并不相互排斥。相反，每个人都在整体测试策略中占有一席之地。服务器端测试更集中，更易于编写和维护。另一方面，端到端集成测试更完整，测试更多，但它们也更多地参与编写和维护。</p>
</div>
<div class="paragraph">
<p>最简单的服务器端测试形式是编写控制器单元测试。但是，这还不够用，因为控制器的大部分功能取决于其注释。纯单元测试根本无法测试。</p>
</div>
<div class="paragraph">
<p>理想情况下，测试中的控制器应该在运行时调用，就像测试使用Spring MVC Test框架处理HTTP请求的控制器的方法一样 - 也就是说，不运行Servlet容器但依赖于Spring Framework来调用带注释的控制器。与Spring MVC Test一样，这里有两个可能的替代方案，使用“基于上下文”或使用“独立”设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在Spring TestContext框架的帮助下加载实际的Spring配置，将<code>clientInboundChannel</code>作为测试字段注入，并使用它发送要由控制器方法处理的消息。</p>
</li>
<li>
<p>手动设置调用控制器所需的最小Spring框架基础结构（即<code>SimpAnnotationMethodMessageHandler</code> ），并将控制器的消息直接传递给它。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">在股票投资组合</a>示例应用程序的<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试</a>中演示了这两种设置方案。</p>
</div>
<div class="paragraph">
<p>第二种方法是创建端到端集成测试。为此，您需要以嵌入模式运行WebSocket服务器并将其作为WebSocket客户端连接到该服务器，该客户端发送包含STOMP帧的WebSocket消息。<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">股票投资组合</a>示例应用程序的<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试</a>还通过使用Tomcat作为嵌入式WebSocket服务器和用于测试目的的简单STOMP客户端来演示此方法。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="web-integration"><a class="anchor" href="#web-integration"></a> 5。其他Web框架</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章详细介绍了Spring与第三方Web框架的集成。</p>
</div>
<div class="paragraph">
<p>Spring Framework的核心价值主张之一就是支持<em>选择</em> 。从一般意义上讲，Spring并没有强迫您使用或购买任何特定的架构，技术或方法（尽管它肯定会推荐一些其他架构，技术或方法）。这种选择与开发人员及其开发团队最相关的架构，技术或方法的自由在Web领域最为明显，其中Spring提供了自己的Web框架（ <a href="#mvc">Spring MVC</a> ），同时，提供与许多流行的第三方Web框架的集成。</p>
</div>
<div class="sect2">
<h3 id="web-integration-common"><a class="anchor" href="#web-integration-common"></a> 5.1。通用配置</h3>
<div class="paragraph">
<p>在深入研究每个受支持的Web框架的集成细节之前，让我们先来看看不是特定于任何一个Web框架的Spring配置。（本节同样适用于Spring自己的Web框架Spring MVC。）</p>
</div>
<div class="paragraph">
<p>Spring的轻量级应用程序模型支持的一个概念（缺少更好的词）是分层架构的概念。请记住，在“经典”分层架构中，Web层只是众多层中的一个。它充当服务器端应用程序的入口点之一，并且它委托给服务层中定义的服务对象（外观），以满足特定于业务（和表示技术不可知）的用例。在Spring中，这些服务对象，任何其他特定于业务的对象，数据访问对象和其他对象存在于不同的“业务上下文”中，该业务上下文不包含Web或表示层对象（表示对象，例如Spring MVC控制器，通常是在不同的“演示文稿上下文”中配置。本节详细介绍了如何配置包含应用程序中所有“业务bean”的Spring容器（ <code>WebApplicationContext</code> ）。</p>
</div>
<div class="paragraph">
<p>转到具体细节，您需要做的只是在Web应用程序的标准Java EE servlet <code>web.xml</code>文件中声明<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/context/ContextLoaderListener.html"><code>ContextLoaderListener</code></a> ，并添加<code>contextConfigLocation</code> &lt;context-param /&gt;部分（在同一文件中），定义哪个集合要加载的Spring XML配置文件。</p>
</div>
<div class="paragraph">
<p>请考虑以下<code>&lt;listener/&gt;</code>配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;listener&gt;</span> <span class="tag">&lt;listener-class&gt;</span> org.springframework.web.context。ContextLoaderListener <span class="tag">&lt;/ listener-class&gt;</span> <span class="tag">&lt;/ listener&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步考虑以下<code>&lt;context-param/&gt;</code>配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> /WEB-INF/applicationContext*.xml <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ context-param&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果未指定<code>contextConfigLocation</code>上下文参数，则<code>ContextLoaderListener</code>将查找要加载的名为<code>/WEB-INF/applicationContext.xml</code>的文件。加载上下文文件后，Spring会根据bean定义创建一个<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/context/WebApplicationContext.html"><code>WebApplicationContext</code></a>对象，并将其存储在Web应用程序的<code>ServletContext</code>中。</p>
</div>
<div class="paragraph">
<p>所有Java Web框架都构建在Servlet API之上，因此您可以使用以下代码段来访问<code>ContextLoaderListener</code>创建的此“业务上下文” <code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何获取<code>WebApplicationContext</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext（servletContext）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/context/support/WebApplicationContextUtils.html"><code>WebApplicationContextUtils</code></a>类是为了方便起见，因此您无需记住<code>ServletContext</code>属性的名称。如果<code>WebApplicationContext.下不存在对象，则其<code>getWebApplicationContext()</code>方法返回<code>null</code> <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>键。不要冒险在应用程序中获取<code>NullPointerExceptions</code> ，最好使用<code>getRequiredWebApplicationContext()</code>方法。当<code>ApplicationContext</code>丢失时，此方法抛出异常。</p>
</div>
<div class="paragraph">
<p>一旦引用了<code>WebApplicationContext</code> ，就可以按名称或类型检索bean。大多数开发人员按名称检索bean，然后将其转换为其实现的接口之一。</p>
</div>
<div class="paragraph">
<p>幸运的是，本节中的大多数框架都有更简单的查找bean的方法。它们不仅可以轻松地从Spring容器中获取bean，而且还允许您在其控制器上使用依赖注入。每个Web框架部分都有关于其特定集成策略的更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="jsf"><a class="anchor" href="#jsf"></a> 5.2。JSF</h3>
<div class="paragraph">
<p>JavaServer Faces（JSF）是JCP标准的基于组件，事件驱动的Web用户界面框架。从Java EE 5开始，它是Java EE保护伞的官方部分。</p>
</div>
<div class="paragraph">
<p>对于流行的JSF运行时以及流行的JSF组件库，请查看<a href="http://myfaces.apache.org/">Apache MyFaces项目</a> 。MyFaces项目还提供了常见的JSF扩展，例如<a href="http://myfaces.apache.org/orchestra/">MyFaces Orchestra</a> （一种基于Spring的JSF扩展，提供丰富的会话范围支持）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Web Flow 2.0通过其新建立的Spring Faces模块提供了丰富的JSF支持，既用于以JSF为中心的用法（如本节所述），也用于以Spring为中心的用法（在Spring MVC调度程序中使用JSF视图）。有关详细信息，请参见<a href="http://projects.spring.io/spring-webflow">Spring Web Flow网站</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring的JSF集成中的关键元素是JSF <code>ELResolver</code>机制。</p>
</div>
<div class="sect3">
<h4 id="jsf-springbeanfaceselresolver"><a class="anchor" href="#jsf-springbeanfaceselresolver"></a> 5.2.1。春豆解析器</h4>
<div class="paragraph">
<p><code>SpringBeanFacesELResolver</code>是一个符合JSF 1.2+标准的<code>ELResolver</code>实现，与JSF 1.2和JSP 2.1使用的标准Unified EL集成。作为<code>SpringBeanVariableResolver</code> ，它首先委托Spring的“业务上下文” <code>WebApplicationContext</code> ，然后委托给底层JSF实现的默认解析器。</p>
</div>
<div class="paragraph">
<p>在配置方面，您可以在JSF <code>faces-context.xml</code>文件中定义<code>SpringBeanFacesELResolver</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;faces-config&gt;</span> <span class="tag">&lt;application&gt;</span> <span class="tag">&lt;el-resolver&gt;</span> org.springframework.web.jsf.el。SpringBeanFacesELResolver <span class="tag">&lt;/ el-resolver&gt;</span> ...
    <span class="tag">&lt;/ application&gt;</span> <span class="tag">&lt;/ faces-config&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jsf-facescontextutils"><a class="anchor" href="#jsf-facescontextutils"></a> 5.2.2。使用<code>FacesContextUtils</code></h4>
<div class="paragraph">
<p>在<code>faces-config.xml</code>中将属性映射到bean时，自定义<code>VariableResolver</code>有效，但有时您可能需要显式获取bean。<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/jsf/FacesContextUtils.html"><code>FacesContextUtils</code></a>类使这很容易。它类似于<code>WebApplicationContextUtils</code> ，除了它采用<code>FacesContext</code>参数而不是<code>ServletContext</code>参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>FacesContextUtils</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = FacesContextUtils.getWebApplicationContext（FacesContext.getCurrentInstance（））;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="struts"><a class="anchor" href="#struts"></a> 5.3。Apache Struts 2.x</h3>
<div class="paragraph">
<p><a href="http://struts.apache.org">Struts</a>由Craig McClanahan发明，是一个由Apache Software Foundation托管的开源项目。当时，它大大简化了JSP / Servlet编程范例，并赢得了许多使用专有框架的开发人员。它简化了编程模型，它是开源的（因此在啤酒中是免费的），它有一个庞大的社区，让项目在Java Web开发人员中成长并变得流行。</p>
</div>
<div class="paragraph">
<p>查看Struts <a href="https://struts.apache.org/release/2.3.x/docs/spring-plugin.html">Spring插件</a> ，了解Struts附带的内置Spring集成。</p>
</div>
</div>
<div class="sect2">
<h3 id="tapestry"><a class="anchor" href="#tapestry"></a> 5.4。Tapestry 5.x</h3>
<div class="paragraph">
<p><a href="http://tapestry.apache.org/">Tapestry</a>是一个“”面向组件的框架，用于在Java中创建动态，健壮，高度可伸缩的Web应用程序。“</p>
</div>
<div class="paragraph">
<p>虽然Spring拥有自己<a href="#mvc">强大的Web层</a> ，但是通过将Tapestry用于Web用户界面和Spring容器用于较低层，构建企业Java应用程序有许多独特的优势。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅Tapestry <a href="https://tapestry.apache.org/integrating-with-spring-framework.html">针对Spring</a>的专用<a href="https://tapestry.apache.org/integrating-with-spring-framework.html">集成模块</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="web-integration-resources"><a class="anchor" href="#web-integration-resources"></a> 5.5。更多资源</h3>
<div class="paragraph">
<p>以下链接涉及有关本章中描述的各种Web框架的更多资源。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html">JSF</a>主页</p>
</li>
<li>
<p><a href="http://struts.apache.org/">Struts</a>主页</p>
</li>
<li>
<p><a href="http://tapestry.apache.org/">Tapestry</a>主页</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>