<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>WebTestClient</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="webtestclient" class="book" dir="ltr">
<div id="header">
<h1>WebTestClient</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><code>WebTestClient</code>是围绕<a href="web-reactive.html#webflux-webclient">WebClient的</a>一个瘦shell，使用它来执行请求并公开一个专用的，流畅的API来验证响应。
<code>WebTestClient</code>通过使用<a href="testing.html#mock-objects-web-reactive">模拟请求和响应</a>绑定到WebFlux应用程序，或者它可以通过HTTP连接测试任何Web服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Kotlin用户：请参阅<a href="languages.html#kotlin-webtestclient-issue">本节</a>与<code>WebTestClient</code>使用相关的<code>WebTestClient</code> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webtestclient-setup"><a class="anchor" href="#webtestclient-setup"></a> 1。建立</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要创建<code>WebTestClient</code>您必须选择多个服务器设置选项之一。实际上，您要么将WebFlux应用程序配置为绑定到，要么使用URL连接到正在运行的服务器。</p>
</div>
<div class="sect2">
<h3 id="webtestclient-controller-config"><a class="anchor" href="#webtestclient-controller-config"></a> 1.1。绑定到控制器</h3>
<div class="paragraph">
<p>以下示例显示如何创建服务器设置以一次测试一个<code>@Controller</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client = WebTestClient.bindToController（ <span class="keyword">new</span> TestController（））。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例加载<a href="web-reactive.html#webflux-config">WebFlux Java配置</a>并注册给定的控制器。通过使用模拟请求和响应对象，在没有HTTP服务器的情况下测试生成的WebFlux应用程序。构建器上有更多方法可以自定义默认的WebFlux Java配置。</p>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-fn-config"><a class="anchor" href="#webtestclient-fn-config"></a> 1.2。绑定到路由器功能</h3>
<div class="paragraph">
<p>以下示例显示如何从<a href="web-reactive.html#webflux-fn">RouterFunction</a>设置服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction &lt;？&gt; route = ...client = WebTestClient.bindToRouterFunction（route）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在内部，配置传递给<code>RouterFunctions.toWebHandler</code> 。通过使用模拟请求和响应对象，在没有HTTP服务器的情况下测试生成的WebFlux应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-context-config"><a class="anchor" href="#webtestclient-context-config"></a> 1.3。绑定到<code>ApplicationContext</code></h3>
<div class="paragraph">
<p>以下示例说明如何从应用程序的Spring配置或其某个子集设置服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">        <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> （classes = WebConfig.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyTests</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> ApplicationContext context; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">私有</span> WebTestClient客户端; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setUp（）{client = WebTestClient.bindToApplicationContext（context）.build（）; <i class="conum" data-value="3"></i> <b>（3）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定要加载的配置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入配置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建<code>WebTestClient</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在内部，配置被传递给<code>WebHttpHandlerBuilder</code>以设置请求处理链。有关更多详细信息，请参阅<a href="web-reactive.html#webflux-web-handler-api">WebHandler API</a> 。通过使用模拟请求和响应对象，在没有HTTP服务器的情况下测试生成的WebFlux应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-server-config"><a class="anchor" href="#webtestclient-server-config"></a> 1.4。绑定到服务器</h3>
<div class="paragraph">
<p>以下服务器设置选项允许您连接到正在运行的服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client = WebTestClient.bindToServer（）。baseUrl（ <span class="string"><span class="delimiter">“</span> <span class="content">http：// localhost：8080</span> <span class="delimiter">”</span></span> ）。build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-client-config"><a class="anchor" href="#webtestclient-client-config"></a> 1.5。Client Builder</h3>
<div class="paragraph">
<p>除了前面介绍的服务器设置选项之外，您还可以配置客户端选项，包括基本URL，默认标头，客户端过滤器等。<code>bindToServer</code>可以使用这些选项。对于所有其他人，您需要使用<code>configureClient()</code>从服务器配置转换为客户端配置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client = WebTestClient.bindToController（ <span class="keyword">new</span> TestController（））。configureCompient（）。baseUrl（ <span class="string"><span class="delimiter">“</span> <span class="content">/ test</span> <span class="delimiter">”</span></span> ）。build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webtestclient-tests"><a class="anchor" href="#webtestclient-tests"></a> 2。写测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>WebTestClient</code>是围绕<a href="web-reactive.html#webflux-webclient">WebClient</a>的瘦shell。它提供了一个相同的API，直到使用<code>exchange()</code>执行请求。在<code>exchange()</code>是用于验证响应的链式API工作流。</p>
</div>
<div class="paragraph">
<p>通常，您首先声明响应状态和标头，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / 1</span> <span class="delimiter">”</span></span> ）。accept（MediaType。APPLICATION_JSON_UTF8）.exchange（）。exppectStatus（）。isOk（）。exppectHeader（）。contentType（MediaType。APPLICATION_JSON_UTF8） <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后指定如何解码和使用响应正文：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectBody(Class&lt;T&gt;)</code> ：解码为单个对象。</p>
</li>
<li>
<p><code>expectBodyList(Class&lt;T&gt;)</code> ：将对象解码并收集到<code>List&lt;T&gt;</code> 。</p>
</li>
<li>
<p><code>expectBody()</code> ：为<a href="#webtestclient-json">JSON内容</a>或空体解码为<code>byte[]</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后你可以使用内置的断言为身体。以下示例显示了一种方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ）。exchange（）。exppectStatus（）。isOk（）。expectBodyList（Person.class）.hasSize（ <span class="integer">3</span> ）.contains（person）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以超越内置断言并创建自己的断言，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>client.get（）。uri（“/ persons / 1”）。expand（）。exppectStatus（）。isOk（）。exppectBody（Person.class）.consumeWith（result  - &gt; {// custom assertions（例如AssertJ））。 ..}）;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以退出工作流程并获得结果，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>EntityExchangeResult &lt;Person&gt; result = client.get（）。uri（“/ persons / 1”）。exchange（）。exppectStatus（）。isOk（）。appendBody（Person.class）.returnResult（）;</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">当您需要使用泛型解码到目标类型时，请查找接受{api-spring-framework} /core/ParameterizedTypeReference.html [ <code>ParameterizedTypeReference</code> ]而不是<code>Class&lt;T&gt;</code>的重载方法。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="webtestclient-no-content"><a class="anchor" href="#webtestclient-no-content"></a> 2.1。无内容</h3>
<div class="paragraph">
<p>如果响应没有内容（或者您不关心它），请使用<code>Void.class</code> ，以确保释放资源。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / 123</span> <span class="delimiter">”</span></span> ）。exchange（）。exppectStatus（）。isNotFound（）。appendBody（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果要断言没有响应内容，可以使用类似于以下内容的代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.post（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ）。body（personMono，Person.class）.exchange（）。exppectStatus（）。isCreated（）。emerpectBody（）。isEmpty（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-json"><a class="anchor" href="#webtestclient-json"></a> 2.2。JSON内容</h3>
<div class="paragraph">
<p>使用<code>expectBody()</code> ，响应将作为<code>byte[]</code> 。这对原始内容断言很有用。例如，您可以使用<a href="http://jsonassert.skyscreamer.org">JSONAssert</a>来验证JSON内容，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / 1</span> <span class="delimiter">”</span></span> ）。expand（）。exppectStatus（）。isOk（）。appendBody（）。json（ <span class="string"><span class="delimiter">“</span> <span class="content">{</span> <span class="char">\”</span> <span class="content">name</span> <span class="char">\“</span> <span class="content">：</span> <span class="char">\”</span> <span class="content">Jane</span> <span class="char">\“</span> <span class="content">}</span> <span class="delimiter">”</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<a href="https://github.com/jayway/JsonPath">JSONPath</a>表达式，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ）。exchange（）。exppectStatus（）。isOk（）。appendBody（）。jsonPath（ <span class="string"><span class="delimiter">“</span> <span class="content">$ [0] .name</span> <span class="delimiter">”</span></span> ）。isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">Jane</span> <span class="delimiter">”</span></span> ）。jsonPath （ <span class="string"><span class="delimiter">“</span> <span class="content">$ [1] .name</span> <span class="delimiter">”</span></span> ）。isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">Jason</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-stream"><a class="anchor" href="#webtestclient-stream"></a> 2.3。流式响应</h3>
<div class="paragraph">
<p>要测试无限流（例如， <code>"text/event-stream"</code>或<code>"application/stream+json"</code> ），您需要在响应状态和标头断言之后立即退出链式API（通过使用<code>returnResult</code> ），如下所示示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FluxExchangeResult &lt;MyEvent&gt; result = client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ events</span> <span class="delimiter">”</span></span> ）。accept（TEXT_EVENT_STREAM）.exchange（）。exppectStatus（）。isOk（）.returnResult（MyEvent.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在您可以使用<code>Flux&lt;T&gt;</code> ，在它们到来时断言已解码的对象，然后在满足测试目标时取消。我们建议使用<code>reactor-test</code>模块中的<code>StepVerifier</code>来执行此操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt; <span class="predefined-type">Event</span> &gt; eventFux = result.getResponseBody（）; StepVerifier.create（eventFlux）.expectNext（person）.expectNextCount（ <span class="integer">4</span> ）.consumeNextWith（p  - &gt; ...）.thenCancel（）。verify（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient-request-body"><a class="anchor" href="#webtestclient-request-body"></a> 2.4。请求机构</h3>
<div class="paragraph">
<p>在构建请求时， <code>WebTestClient</code>提供了与<code>WebClient</code>相同的API，实现主要是简单的传递。有关如何使用正文准备请求的示例，请参阅<a href="web-reactive.html#webflux-client-body">WebClient文档</a> ，包括提交表单数据，多部分请求等。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
</body>
</html>