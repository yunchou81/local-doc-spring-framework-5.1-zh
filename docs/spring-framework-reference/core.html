<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>核心技术</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="spring-core" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>核心技术</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#beans">1。IoC容器</a>
<ul class="sectlevel2">
<li><a href="#beans-introduction">1.1。Spring IoC容器和Bean简介</a></li>
<li><a href="#beans-basics">1.2。集装箱概览</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-metadata">1.2.1。配置元数据</a></li>
<li><a href="#beans-factory-instantiation">1.2.2。实例化容器</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-xml-import">编写基于XML的配置元数据</a></li>
<li><a href="#groovy-bean-definition-dsl">Groovy Bean定义DSL</a></li>
</ul>
</li>
<li><a href="#beans-factory-client">1.2.3。使用容器</a></li>
</ul>
</li>
<li><a href="#beans-definition">1.3。Bean概述</a>
<ul class="sectlevel3">
<li><a href="#beans-beanname">1.3.1。命名豆</a>
<ul class="sectlevel4">
<li><a href="#beans-beanname-alias">在Bean定义之外别名Bean</a></li>
</ul>
</li>
<li><a href="#beans-factory-class">1.3.2。实例化豆​​类</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-class-ctor">使用构造函数实例化</a></li>
<li><a href="#beans-factory-class-static-factory-method">使用静态工厂方法实例化</a></li>
<li><a href="#beans-factory-class-instance-factory-method">使用实例工厂方法实例化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-dependencies">1.4。依赖</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-collaborators">1.4.1。依赖注入</a>
<ul class="sectlevel4">
<li><a href="#beans-constructor-injection">基于构造函数的依赖注入</a></li>
<li><a href="#beans-setter-injection">基于Setter的依赖注入</a></li>
<li><a href="#beans-dependency-resolution">依赖性解决过程</a></li>
<li><a href="#beans-some-examples">依赖注入的示例</a></li>
</ul>
</li>
<li><a href="#beans-factory-properties-detailed">1.4.2。依赖关系和配置细节</a>
<ul class="sectlevel4">
<li><a href="#beans-value-element">直值（基元，字符串等）</a></li>
<li><a href="#beans-ref-element">参考其他豆类（合作者）</a></li>
<li><a href="#beans-inner-beans">内豆</a></li>
<li><a href="#beans-collection-elements">集合</a></li>
<li><a href="#beans-null-element">空字符串值和空字符串值</a></li>
<li><a href="#beans-p-namespace">带有p命名空间的XML快捷方式</a></li>
<li><a href="#beans-c-namespace">带有c命名空间的XML快捷方式</a></li>
<li><a href="#beans-compound-property-names">复合属性名称</a></li>
</ul>
</li>
<li><a href="#beans-factory-dependson">1.4.3。使用<code>depends-on</code></a></li>
<li><a href="#beans-factory-lazy-init">1.4.4。懒惰初始化的豆类</a></li>
<li><a href="#beans-factory-autowire">1.4.5。自动化协作者</a>
<ul class="sectlevel4">
<li><a href="#beans-autowired-exceptions">自动装配的局限和缺点</a></li>
<li><a href="#beans-factory-autowire-candidate">从自动装配中排除Bean</a></li>
</ul>
</li>
<li><a href="#beans-factory-method-injection">1.4.6。方法注入</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lookup-method-injection">查找方法注入</a></li>
<li><a href="#beans-factory-arbitrary-method-replacement">任意方法替换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-scopes">1.5。Bean范围</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-scopes-singleton">1.5.1。单身范围</a></li>
<li><a href="#beans-factory-scopes-prototype">1.5.2。原型范围</a></li>
<li><a href="#beans-factory-scopes-sing-prot-interaction">1.5.3。具有原型bean依赖关系的单例Bean</a></li>
<li><a href="#beans-factory-scopes-other">1.5.4。请求，会话，应用程序和WebSocket范围</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-other-web-configuration">初始Web配置</a></li>
<li><a href="#beans-factory-scopes-request">请求范围</a></li>
<li><a href="#beans-factory-scopes-session">会话范围</a></li>
<li><a href="#beans-factory-scopes-application">适用范围</a></li>
<li><a href="#beans-factory-scopes-other-injection">作为依赖关系的Scoped Bean</a></li>
</ul>
</li>
<li><a href="#beans-factory-scopes-custom">1.5.5。自定义范围</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-custom-creating">创建自定义范围</a></li>
<li><a href="#beans-factory-scopes-custom-using">使用自定义范围</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-nature">1.6。定制Bean的本质</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-lifecycle">1.6.1。生命周期回调</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lifecycle-initializingbean">初始化回调</a></li>
<li><a href="#beans-factory-lifecycle-disposablebean">毁灭回调</a></li>
<li><a href="#beans-factory-lifecycle-default-init-destroy-methods">默认初始化和销毁​​方法</a></li>
<li><a href="#beans-factory-lifecycle-combined-effects">结合生命周期机制</a></li>
<li><a href="#beans-factory-lifecycle-processor">启动和关闭回调</a></li>
<li><a href="#beans-factory-shutdown">在非Web应用程序中优雅地关闭Spring IoC容器</a></li>
</ul>
</li>
<li><a href="#beans-factory-aware">1.6.2。<code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></li>
<li><a href="#aware-list">1.6.3。其他<code>Aware</code>接口</a></li>
</ul>
</li>
<li><a href="#beans-child-bean-definitions">1.7。Bean定义继承</a></li>
<li><a href="#beans-factory-extension">1.8。集装箱扩建点</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-extension-bpp">1.8.1。使用<code>BeanPostProcessor</code>自定义Bean</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-extension-bpp-examples-hw">示例：Hello World， <code>BeanPostProcessor</code> style</a></li>
<li><a href="#beans-factory-extension-bpp-examples-rabpp">示例： <code>RequiredAnnotationBeanPostProcessor</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factory-postprocessors">1.8.2。使用<code>BeanFactoryPostProcessor</code>自定义配置元数据</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-placeholderconfigurer">示例：类名替换<code>PropertyPlaceholderConfigurer</code></a></li>
<li><a href="#beans-factory-overrideconfigurer">示例： <code>PropertyOverrideConfigurer</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factorybean">1.8.3。使用<code>FactoryBean</code>自定义实例化逻辑</a></li>
</ul>
</li>
<li><a href="#beans-annotation-config">1.9。基于注释的容器配置</a>
<ul class="sectlevel3">
<li><a href="#beans-required-annotation">1.9.1。@需要</a></li>
<li><a href="#beans-autowired-annotation">1.9.2。使用<code>@Autowired</code></a></li>
<li><a href="#beans-autowired-annotation-primary">1.9.3。使用<code>@Primary</code>微调基于注释的自动装配</a></li>
<li><a href="#beans-autowired-annotation-qualifiers">1.9.4。使用限定符微调基于注释的自动装配</a></li>
<li><a href="#beans-generics-as-qualifiers">1.9.5。使用泛型作为自动装配限定符</a></li>
<li><a href="#beans-custom-autowire-configurer">1.9.6。使用<code>CustomAutowireConfigurer</code></a></li>
<li><a href="#beans-resource-annotation">1.9.7。使用<code>@Resource</code>注入</a></li>
<li><a href="#beans-postconstruct-and-predestroy-annotations">1.9.8。使用<code>@PostConstruct</code>和<code>@PreDestroy</code></a></li>
</ul>
</li>
<li><a href="#beans-classpath-scanning">1.10。类路径扫描和托管组件</a>
<ul class="sectlevel3">
<li><a href="#beans-stereotype-annotations">1.10.1。<code>@Component</code>和进一步的刻板印象注释</a></li>
<li><a href="#beans-meta-annotations">1.10.2。使用元注释和组合注释</a></li>
<li><a href="#beans-scanning-autodetection">1.10.3。自动检测类和注册Bean定义</a></li>
<li><a href="#beans-scanning-filters">1.10.4。使用过滤器自定义扫描</a></li>
<li><a href="#beans-factorybeans-annotations">1.10.5。在组件中定义Bean元数据</a></li>
<li><a href="#beans-scanning-name-generator">1.10.6。命名自动检测组件</a></li>
<li><a href="#beans-scanning-scope-resolver">1.10.7。为自动检测组件提供范围</a></li>
<li><a href="#beans-scanning-qualifiers">1.10.8。使用注释提供限定符元数据</a></li>
<li><a href="#beans-scanning-index">1.10.9。生成候选组件索引</a></li>
</ul>
</li>
<li><a href="#beans-standard-annotations">1.11。使用JSR 330标准注释</a>
<ul class="sectlevel3">
<li><a href="#beans-inject-named">1.11.1。使用<code>@Inject</code>和<code>@Named</code>依赖注入</a></li>
<li><a href="#beans-named">1.11.2。<code>@Named</code>和<code>@ManagedBean</code> ： <code>@Component</code>注释的标准等价物</a></li>
<li><a href="#beans-standard-annotations-limitations">1.11.3。JSR-330标准注释的局限性</a></li>
</ul>
</li>
<li><a href="#beans-java">1.12。基于Java的容器配置</a>
<ul class="sectlevel3">
<li><a href="#beans-java-basic-concepts">1.12.1。基本概念： <code>@Bean</code>和<code>@Configuration</code></a></li>
<li><a href="#beans-java-instantiating-container">1.12.2。使用<code>AnnotationConfigApplicationContext</code>实例化Spring容器</a>
<ul class="sectlevel4">
<li><a href="#beans-java-instantiating-container-contstructor">简单的施工</a></li>
<li><a href="#beans-java-instantiating-container-register">使用<code>register(Class&lt;?以编程方式构建容器<code>register(Class&lt;?&gt; ...）</code></a></li>
<li><a href="#beans-java-instantiating-container-scan">使用<code>scan(String…​)</code>启用组件<code>scan(String…​)</code></a></li>
<li><a href="#beans-java-instantiating-container-web">使用<code>AnnotationConfigWebApplicationContext</code>支持Web应用程序</a></li>
</ul>
</li>
<li><a href="#beans-java-bean-annotation">1.12.3。使用<code>@Bean</code>注释</a>
<ul class="sectlevel4">
<li><a href="#beans-java-declaring-a-bean">声明一个Bean</a></li>
<li><a href="#beans-java-dependencies">Bean依赖项</a></li>
<li><a href="#beans-java-lifecycle-callbacks">接收生命周期回调</a></li>
<li><a href="#beans-java-specifying-bean-scope">指定Bean范围</a></li>
<li><a href="#beans-java-customizing-bean-naming">自定义Bean命名</a></li>
<li><a href="#beans-java-bean-aliasing">Bean Aliasing</a></li>
<li><a href="#beans-java-bean-description">Bean描述</a></li>
</ul>
</li>
<li><a href="#beans-java-configuration-annotation">1.12.4。使用<code>@Configuration</code>注释</a>
<ul class="sectlevel4">
<li><a href="#beans-java-injecting-dependencies">注入bean间依赖关系</a></li>
<li><a href="#beans-java-method-injection">查找方法注入</a></li>
<li><a href="#beans-java-further-information-java-config">有关基于Java的配置如何在内部工作的更多信息</a></li>
</ul>
</li>
<li><a href="#beans-java-composing-configuration-classes">1.12.5。编写基于Java的配置</a>
<ul class="sectlevel4">
<li><a href="#beans-java-using-import">使用<code>@Import</code> Annotation</a></li>
<li><a href="#beans-java-conditional">有条件地包含<code>@Configuration</code>类或<code>@Bean</code>方法</a></li>
<li><a href="#beans-java-combining">结合Java和XML配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-environment">1.13。环境抽象</a>
<ul class="sectlevel3">
<li><a href="#beans-definition-profiles">1.13.1。Bean定义配置文件</a>
<ul class="sectlevel4">
<li><a href="#beans-definition-profiles-java">使用<code>@Profile</code></a></li>
<li><a href="#beans-definition-profiles-xml">XML Bean定义配置文件</a></li>
<li><a href="#beans-definition-profiles-enable">激活个人资料</a></li>
<li><a href="#beans-definition-profiles-default">默认配置文件</a></li>
</ul>
</li>
<li><a href="#beans-property-source-abstraction">1.13.2。<code>PropertySource</code>抽象</a></li>
<li><a href="#beans-using-propertysource">1.13.3。使用<code>@PropertySource</code></a></li>
<li><a href="#beans-placeholder-resolution-in-statements">1.13.4。占位符决议在声明中</a></li>
</ul>
</li>
<li><a href="#context-load-time-weaver">1.14。注册<code>LoadTimeWeaver</code></a></li>
<li><a href="#context-introduction">1.15。<code>ApplicationContext</code>附加功能</a>
<ul class="sectlevel3">
<li><a href="#context-functionality-messagesource">1.15.1。使用<code>MessageSource</code>国际化</a></li>
<li><a href="#context-functionality-events">1.15.2。标准和自定义事件</a>
<ul class="sectlevel4">
<li><a href="#context-functionality-events-annotation">基于注释的事件监听器</a></li>
<li><a href="#context-functionality-events-async">异步监听器</a></li>
<li><a href="#context-functionality-events-order">订购听众</a></li>
<li><a href="#context-functionality-events-generics">通用事件</a></li>
</ul>
</li>
<li><a href="#context-functionality-resources">1.15.3。方便地访问低级资源</a></li>
<li><a href="#context-create">1.15.4。方便的Web应用程序的ApplicationContext实例化</a></li>
<li><a href="#context-deploy-rar">1.15.5。将Spring <code>ApplicationContext</code>部署为Java EE RAR文件</a></li>
</ul>
</li>
<li><a href="#beans-beanfactory">1.16。<code>BeanFactory</code></a>
<ul class="sectlevel3">
<li><a href="#context-introduction-ctx-vs-beanfactory">1.16.1。<code>BeanFactory</code>或<code>ApplicationContext</code> ？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">2。资源</a>
<ul class="sectlevel2">
<li><a href="#resources-introduction">2.1。介绍</a></li>
<li><a href="#resources-resource">2.2。资源接口</a></li>
<li><a href="#resources-implementations">2.3。内置资源实现</a>
<ul class="sectlevel3">
<li><a href="#resources-implementations-urlresource">2.3.1。<code>UrlResource对象</code></a></li>
<li><a href="#resources-implementations-classpathresource">2.3.2。<code>使用ClassPathResource</code></a></li>
<li><a href="#resources-implementations-filesystemresource">2.3.3。<code>的FileSystemResource</code></a></li>
<li><a href="#resources-implementations-servletcontextresource">2.3.4。<code>ServletContextResource</code></a></li>
<li><a href="#resources-implementations-inputstreamresource">2.3.5。<code>的InputStreamResource</code></a></li>
<li><a href="#resources-implementations-bytearrayresource">2.3.6。<code>使用ByteArrayResource</code></a></li>
</ul>
</li>
<li><a href="#resources-resourceloader">2.4。<code>ResourceLoader</code></a></li>
<li><a href="#resources-resourceloaderaware">2.5。<code>ResourceLoaderAware</code>接口</a></li>
<li><a href="#resources-as-dependencies">2.6。资源作为依赖关系</a></li>
<li><a href="#resources-app-ctx">2.7。应用程序上下文和资源路径</a>
<ul class="sectlevel3">
<li><a href="#resources-app-ctx-construction">2.7.1。构建应用程序上下文</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-classpathxml">构造<code>ClassPathXmlApplicationContext</code>实例 - 快捷方式</a></li>
</ul>
</li>
<li><a href="#resources-app-ctx-wildcards-in-resource-paths">2.7.2。应用程序上下文构造函数资源路径中的通配符</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-ant-patterns-in-paths">蚂蚁风格的图案</a></li>
<li><a href="#resources-classpath-wildcards"><code>classpath*:</code>前缀</a></li>
<li><a href="#resources-wildcards-in-path-other-stuff">有关通配符的其他说明</a></li>
</ul>
</li>
<li><a href="#resources-filesystemresource-caveats">2.7.3。<code>FileSystemResource</code>警告</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#validation">3。验证，数据绑定和类型转换</a>
<ul class="sectlevel2">
<li><a href="#validator">3.1。使用Spring的Validator接口验证</a></li>
<li><a href="#validation-conversion">3.2。将代码解析为错误消息</a></li>
<li><a href="#beans-beans">3.3。Bean操作和<code>BeanWrapper</code></a>
<ul class="sectlevel3">
<li><a href="#beans-beans-conventions">3.3.1。设置和获取基本和嵌套属性</a></li>
<li><a href="#beans-beans-conversion">3.3.2。内置<code>PropertyEditor</code>实现</a>
<ul class="sectlevel4">
<li><a href="#beans-beans-conversion-customeditor-registration">注册其他自定义<code>PropertyEditor</code>实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core-convert">3.4。弹簧类型转换</a>
<ul class="sectlevel3">
<li><a href="#core-convert-Converter-API">3.4.1。转换器SPI</a></li>
<li><a href="#core-convert-ConverterFactory-SPI">3.4.2。使用<code>ConverterFactory</code></a></li>
<li><a href="#core-convert-GenericConverter-SPI">3.4.3。使用<code>GenericConverter</code></a>
<ul class="sectlevel4">
<li><a href="#core-convert-ConditionalGenericConverter-SPI">使用<code>ConditionalGenericConverter</code></a></li>
</ul>
</li>
<li><a href="#core-convert-ConversionService-API">3.4.4。<code>ConversionService</code> API</a></li>
<li><a href="#core-convert-Spring-config">3.4.5。配置<code>ConversionService</code></a></li>
<li><a href="#core-convert-programmatic-usage">3.4.6。以编程方式使用<code>ConversionService</code></a></li>
</ul>
</li>
<li><a href="#format">3.5。Spring Field格式</a>
<ul class="sectlevel3">
<li><a href="#format-Formatter-SPI">3.5.1。<code>Formatter</code> SPI</a></li>
<li><a href="#format-CustomFormatAnnotations">3.5.2。注释驱动的格式</a>
<ul class="sectlevel4">
<li><a href="#format-annotations-api">格式注释API</a></li>
</ul>
</li>
<li><a href="#format-FormatterRegistry-SPI">3.5.3。<code>FormatterRegistry</code> SPI</a></li>
<li><a href="#format-FormatterRegistrar-SPI">3.5.4。<code>FormatterRegistrar</code> SPI</a></li>
<li><a href="#format-configuring-formatting-mvc">3.5.5。在Spring MVC中配置格式化</a></li>
</ul>
</li>
<li><a href="#format-configuring-formatting-globaldatetimeformat">3.6。配置全局日期和时间格式</a></li>
<li><a href="#validation-beanvalidation">3.7。弹簧验证</a>
<ul class="sectlevel3">
<li><a href="#validation-beanvalidation-overview">3.7.1。JSR-303 Bean Validation API概述</a></li>
<li><a href="#validation-beanvalidation-spring">3.7.2。配置Bean验证提供程序</a>
<ul class="sectlevel4">
<li><a href="#validation-beanvalidation-spring-inject">注入验证器</a></li>
<li><a href="#validation-beanvalidation-spring-constraints">配置自定义约束</a></li>
<li><a href="#validation-beanvalidation-spring-method">弹簧驱动的方法验证</a></li>
<li><a href="#validation-beanvalidation-spring-other">其他配置选项</a></li>
</ul>
</li>
<li><a href="#validation-binder">3.7.3。配置<code>DataBinder</code></a></li>
<li><a href="#validation-mvc">3.7.4。Spring MVC 3验证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions">4。春季表达语言（SpEL）</a>
<ul class="sectlevel2">
<li><a href="#expressions-evaluation">4.1。评估</a>
<ul class="sectlevel3">
<li><a href="#expressions-evaluation-context">4.1.1。了解<code>EvaluationContext</code></a>
<ul class="sectlevel4">
<li><a href="#expressions-type-conversion">类型转换</a></li>
</ul>
</li>
<li><a href="#expressions-parser-configuration">4.1.2。分析器配置</a></li>
<li><a href="#expressions-spel-compilation">4.1.3。SpEL编译</a>
<ul class="sectlevel4">
<li><a href="#expressions-compiler-configuration">编译器配置</a></li>
<li><a href="#expressions-compiler-limitations">编译器限制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions-beandef">4.2。Bean定义中的表达式</a>
<ul class="sectlevel3">
<li><a href="#expressions-beandef-xml-based">4.2.1。XML配置</a></li>
<li><a href="#expressions-beandef-annotation-based">4.2.2。注释配置</a></li>
</ul>
</li>
<li><a href="#expressions-language-ref">4.3。语言参考</a>
<ul class="sectlevel3">
<li><a href="#expressions-ref-literal">4.3.1。文字表达</a></li>
<li><a href="#expressions-properties-arrays">4.3.2。属性，数组，列表，地图和索引器</a></li>
<li><a href="#expressions-inline-lists">4.3.3。内联列表</a></li>
<li><a href="#expressions-inline-maps">4.3.4。内联地图</a></li>
<li><a href="#expressions-array-construction">4.3.5。数组构造</a></li>
<li><a href="#expressions-methods">4.3.6。方法</a></li>
<li><a href="#expressions-operators">4.3.7。运营商</a>
<ul class="sectlevel4">
<li><a href="#expressions-operators-relational">关系运算符</a></li>
<li><a href="#expressions-operators-logical">逻辑运算符</a></li>
<li><a href="#expressions-operators-mathematical">数学运算符</a></li>
<li><a href="#expressions-assignment">作业运营商</a></li>
</ul>
</li>
<li><a href="#expressions-types">4.3.8。类型</a></li>
<li><a href="#expressions-constructors">4.3.9。构造函数</a></li>
<li><a href="#expressions-ref-variables">4.3.10。变量</a>
<ul class="sectlevel4">
<li><a href="#expressions-this-root"><code>#this</code>和<code>#root</code>变量</a></li>
</ul>
</li>
<li><a href="#expressions-ref-functions">4.3.11。功能</a></li>
<li><a href="#expressions-bean-references">4.3.12。Bean参考</a></li>
<li><a href="#expressions-operator-ternary">4.3.13。三元运算符（If-Then-Else）</a></li>
<li><a href="#expressions-operator-elvis">4.3.14。猫王运营商</a></li>
<li><a href="#expressions-operator-safe-navigation">4.3.15。安全导航操作员</a></li>
<li><a href="#expressions-collection-selection">4.3.16。收藏选择</a></li>
<li><a href="#expressions-collection-projection">4.3.17。收集投影</a></li>
<li><a href="#expressions-templating">4.3.18。表达模板</a></li>
</ul>
</li>
<li><a href="#expressions-example-classes">4.4。示例中使用的类</a></li>
</ul>
</li>
<li><a href="#aop">5。面向方面的Spring编程</a>
<ul class="sectlevel2">
<li><a href="#aop-introduction-defn">5.1。AOP概念</a></li>
<li><a href="#aop-introduction-spring-defn">5.2。Spring AOP功能和目标</a></li>
<li><a href="#aop-introduction-proxies">5.3。AOP代理</a></li>
<li><a href="#aop-ataspectj">5.4。@AspectJ支持</a>
<ul class="sectlevel3">
<li><a href="#aop-aspectj-support">5.4.1。启用@AspectJ支持</a>
<ul class="sectlevel4">
<li><a href="#aop-enable-aspectj-java">使用Java配置启用@AspectJ支持</a></li>
<li><a href="#aop-enable-aspectj-xml">使用XML配置启用@AspectJ支持</a></li>
</ul>
</li>
<li><a href="#aop-at-aspectj">5.4.2。声明一个方面</a></li>
<li><a href="#aop-pointcuts">5.4.3。声明切入点</a>
<ul class="sectlevel4">
<li><a href="#aop-pointcuts-designators">支持的切入点指示符</a></li>
<li><a href="#aop-pointcuts-combining">结合Pointcut表达式</a></li>
<li><a href="#aop-common-pointcuts">共享公共切入点定义</a></li>
<li><a href="#aop-pointcuts-examples">例子</a></li>
<li><a href="#writing-good-pointcuts">写好切入点</a></li>
</ul>
</li>
<li><a href="#aop-advice">5.4.4。宣布建议</a>
<ul class="sectlevel4">
<li><a href="#aop-advice-before">在建议之前</a></li>
<li><a href="#aop-advice-after-returning">返回建议后</a></li>
<li><a href="#aop-advice-after-throwing">投掷建议后</a></li>
<li><a href="#aop-advice-after-finally">之后（最后）建议</a></li>
<li><a href="#aop-ataspectj-around-advice">围绕建议</a></li>
<li><a href="#aop-ataspectj-advice-params">建议参数</a></li>
</ul>
</li>
<li><a href="#aop-schema-advice">5.4.5。宣布建议</a>
<ul class="sectlevel4">
<li><a href="#aop-schema-advice-before">在建议之前</a></li>
<li><a href="#aop-schema-advice-after-returning">返回建议后</a></li>
<li><a href="#aop-schema-advice-after-throwing">投掷建议后</a></li>
<li><a href="#aop-schema-advice-after-finally">之后（最后）建议</a></li>
<li><a href="#aop-schema-advice-around">围绕建议</a></li>
<li><a href="#aop-schema-params">建议参数</a></li>
<li><a href="#aop-ordering">建议订购</a></li>
</ul>
</li>
<li><a href="#aop-schema-introductions">5.4.6。简介</a></li>
<li><a href="#aop-schema-instatiation-models">5.4.7。Aspect实例化模型</a></li>
<li><a href="#aop-schema-advisors">5.4.8。顾问</a></li>
<li><a href="#aop-schema-example">5.4.9。AOP架构示例</a></li>
</ul>
</li>
<li><a href="#aop-choosing">5.5。选择要使用的AOP声明样式</a>
<ul class="sectlevel3">
<li><a href="#aop-spring-or-aspectj">5.5.1。Spring AOP还是Full AspectJ？</a></li>
<li><a href="#aop-ataspectj-or-xml">5.5.2。@AspectJ或Spring for AOP的XML？</a></li>
</ul>
</li>
<li><a href="#aop-mixing-styles">5.6。混合方面类型</a></li>
<li><a href="#aop-proxying">5.7。代理机制</a>
<ul class="sectlevel3">
<li><a href="#aop-understanding-aop-proxies">5.7.1。了解AOP代理</a></li>
</ul>
</li>
<li><a href="#aop-aspectj-programmatic">5.8。程序化创建@AspectJ代理</a></li>
<li><a href="#aop-using-aspectj">5.9。在Spring应用程序中使用AspectJ</a>
<ul class="sectlevel3">
<li><a href="#aop-atconfigurable">5.9.1。使用AspectJ依赖于使用Spring注入域对象</a>
<ul class="sectlevel4">
<li><a href="#aop-configurable-testing">单元测试<code>@Configurable</code> Objects</a></li>
<li><a href="#aop-configurable-container">使用多个应用程序上下文</a></li>
</ul>
</li>
<li><a href="#aop-ajlib-other">5.9.2。AspectJ的其他Spring方面</a></li>
<li><a href="#aop-aj-configure">5.9.3。使用Spring IoC配置AspectJ方面</a></li>
<li><a href="#aop-aj-ltw">5.9.4。在Spring框架中使用AspectJ进行加载时编织</a>
<ul class="sectlevel4">
<li><a href="#aop-aj-ltw-first-example">第一个例子</a></li>
<li><a href="#aop-aj-ltw-the-aspects">方面</a></li>
<li><a href="#aop-aj-ltw-aop_dot_xml">'META-INF / aop.xml文件'</a></li>
<li><a href="#aop-aj-ltw-libraries">必需的库（JARS）</a></li>
<li><a href="#aop-aj-ltw-spring">弹簧配置</a></li>
<li><a href="#aop-aj-ltw-environments">特定于环境的配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-resources">5.10。更多资源</a></li>
</ul>
</li>
<li><a href="#aop-api">6。Spring AOP API</a>
<ul class="sectlevel2">
<li><a href="#aop-api-pointcuts">6.1。Spring中的Pointcut API</a>
<ul class="sectlevel3">
<li><a href="#aop-api-concepts">6.1.1。概念</a></li>
<li><a href="#aop-api-pointcut-ops">6.1.2。切入点的操作</a></li>
<li><a href="#aop-api-pointcuts-aspectj">6.1.3。AspectJ表达式切入点</a></li>
<li><a href="#aop-api-pointcuts-impls">6.1.4。便利切入点实现</a>
<ul class="sectlevel4">
<li><a href="#aop-api-pointcuts-static">静态切入点</a></li>
<li><a href="#aop-api-pointcuts-dynamic">动态切入点</a></li>
</ul>
</li>
<li><a href="#aop-api-pointcuts-superclasses">6.1.5。切入点超级课程</a></li>
<li><a href="#aop-api-pointcuts-custom">6.1.6。自定义切入点</a></li>
</ul>
</li>
<li><a href="#aop-api-advice">6.2。Spring中的建议API</a>
<ul class="sectlevel3">
<li><a href="#aop-api-advice-lifecycle">6.2.1。建议生命周期</a></li>
<li><a href="#aop-api-advice-types">6.2.2。Spring中的建议类型</a>
<ul class="sectlevel4">
<li><a href="#aop-api-advice-around">拦截建议</a></li>
<li><a href="#aop-api-advice-before">在建议之前</a></li>
<li><a href="#aop-api-advice-throws">抛出建议</a></li>
<li><a href="#aop-api-advice-after-returning">返回建议后</a></li>
<li><a href="#aop-api-advice-introduction">简介建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-api-advisor">6.3。Spring中的Advisor API</a></li>
<li><a href="#aop-pfb">6.4。使用<code>ProxyFactoryBean</code>创建AOP代理</a>
<ul class="sectlevel3">
<li><a href="#aop-pfb-1">6.4.1。基本</a></li>
<li><a href="#aop-pfb-2">6.4.2。JavaBean属性</a></li>
<li><a href="#aop-pfb-proxy-types">6.4.3。基于JDK和CGLIB的代理</a></li>
<li><a href="#aop-api-proxying-intf">6.4.4。代理接口</a></li>
<li><a href="#aop-api-proxying-class">6.4.5。代理类</a></li>
<li><a href="#aop-global-advisors">6.4.6。使用“全球”顾问</a></li>
</ul>
</li>
<li><a href="#aop-concise-proxy">6.5。简明的代理定义</a></li>
<li><a href="#aop-prog">6.6。使用<code>ProxyFactory</code>编程方式创建AOP代理</a></li>
<li><a href="#aop-api-advised">6.7。操纵建议的对象</a></li>
<li><a href="#aop-autoproxy">6.8。使用“自动代理”工具</a>
<ul class="sectlevel3">
<li><a href="#aop-autoproxy-choices">6.8.1。自动代理Bean定义</a>
<ul class="sectlevel4">
<li><a href="#aop-api-autoproxy"><code>的BeanNameAutoProxyCreator</code></a></li>
<li><a href="#aop-api-autoproxy-default"><code>DefaultAdvisorAutoProxyCreator的</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-targetsource">6.9。使用<code>TargetSource</code>实现</a>
<ul class="sectlevel3">
<li><a href="#aop-ts-swap">6.9.1。热插拔目标源</a></li>
<li><a href="#aop-ts-pool">6.9.2。汇集目标来源</a></li>
<li><a href="#aop-ts-prototype">6.9.3。原型目标来源</a></li>
<li><a href="#aop-ts-threadlocal">6.9.4。<code>ThreadLocal</code>目标源</a></li>
</ul>
</li>
<li><a href="#aop-extensibility">6.10。定义新的建议类型</a></li>
</ul>
</li>
<li><a href="#null-safety">7。空安全</a>
<ul class="sectlevel2">
<li><a href="#use-cases">7.1。用例</a></li>
<li><a href="#jsr-305-meta-annotations">7.2。JSR 305元注释</a></li>
</ul>
</li>
<li><a href="#databuffers">8。数据缓冲区和编解码器</a>
<ul class="sectlevel2">
<li><a href="#code-databufferfactory-code">8.1。<code>DataBufferFactory</code></a></li>
<li><a href="#the-code-databuffer-code-interface">8.2。<code>DataBuffer</code>接口</a>
<ul class="sectlevel3">
<li><a href="#code-pooleddatabuffer-code">8.2.1。<code>PooledDataBuffer</code></a>
<ul class="sectlevel4">
<li><a href="#databuffer-reference-counting">参考计数</a></li>
</ul>
</li>
<li><a href="#code-databufferutils-code">8.2.2。<code>DataBufferUtils</code></a></li>
</ul>
</li>
<li><a href="#codecs">8.3。编解码器</a></li>
</ul>
</li>
<li><a href="#appendix">9。附录</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">9.1。XML模式</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-util">9.1.1。<code>util</code> Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-util-constant">使用<code>&lt;util:constant/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-property-path">使用<code>&lt;util:property-path/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-properties">使用<code>&lt;util:properties/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-list">使用<code>&lt;util:list/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-map">使用<code>&lt;util:map/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-set">使用<code>&lt;util:set/&gt;</code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-aop">9.1.2。<code>aop</code> Schema</a></li>
<li><a href="#xsd-schemas-context">9.1.3。<code>context</code>架构</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-context-pphc">使用<code>&lt;property-placeholder/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-ac">使用<code>&lt;annotation-config/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-component-scan">使用<code>&lt;component-scan/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-ltw">使用<code>&lt;load-time-weaver/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-sc">使用<code>&lt;spring-configured/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-mbe">使用<code>&lt;mbean-export/&gt;</code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-beans">9.1.4。豆类架构</a></li>
</ul>
</li>
<li><a href="#xml-custom">9.2。XML Schema Authoring</a>
<ul class="sectlevel3">
<li><a href="#xsd-custom-schema">9.2.1。编写架构</a></li>
<li><a href="#xsd-custom-namespacehandler">9.2.2。编码<code>NamespaceHandler</code></a></li>
<li><a href="#xsd-custom-parser">9.2.3。使用<code>BeanDefinitionParser</code></a></li>
<li><a href="#xsd-custom-registration">9.2.4。注册处理程序和架构</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-registration-spring-handlers">编写<code>META-INF/spring.handlers</code></a></li>
<li><a href="#xsd-custom-registration-spring-schemas">写'META-INF / spring.schemas'</a></li>
</ul>
</li>
<li><a href="#xsd-custom-using">9.2.5。在Spring XML配置中使用自定义扩展</a></li>
<li><a href="#xsd-custom-meat">9.2.6。更详细的例子</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-custom-nested">在自定义元素中嵌套自定义元素</a></li>
<li><a href="#xsd-custom-custom-just-attributes">“普通”元素的自定义属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>这部分参考文档涵盖了Spring Framework绝对不可或缺的所有技术。</p>
</div>
<div class="paragraph">
<p>其中最重要的是Spring Framework的控制反转（IoC）容器。对Spring框架的IoC容器进行彻底的处理后，我们将全面介绍Spring的面向方面编程（AOP）技术。Spring Framework有自己的AOP框架，它在概念上易于理解，并成功解决了Java企业编程中AOP要求的80％最佳点。</p>
</div>
<div class="paragraph">
<p>还提供了Spring与AspectJ集成的覆盖范围（目前最丰富的 - 在功能方面 - 当然也是Java企业领域中最成熟的AOP实现）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans"><a class="anchor" href="#beans"></a> 1。IoC容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍Spring的控制反转（IoC）容器。</p>
</div>
<div class="sect2">
<h3 id="beans-introduction"><a class="anchor" href="#beans-introduction"></a> 1.1。Spring IoC容器和Bean简介</h3>
<div class="paragraph">
<p>本章介绍了控制反转（IoC）原理的Spring Framework实现。（参见<a href="overview.html#background-ioc">控制反转</a> 。）IoC也称为依赖注入（DI）。这是一个过程，通过这个过程，对象只能通过构造函数参数，工厂方法的参数或在从工厂方法构造或返回的对象实例上设置的属性来定义它们的依赖关系（即，它们使用的其他对象）。 。然后容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的逆（因此名称，控制反转）。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring Framework的IoC容器的基础。<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>接口提供了一种能够管理任何类型对象的高级配置机制。
<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>是<code>BeanFactory</code>的子接口。它补充说：*更容易与Spring的AOP功能集成*消息资源处理（用于国际化）*事件发布*特定于应用程序层的上下文，例如<code>WebApplicationContext</code> ，用于Web应用程序。</p>
</div>
<div class="paragraph">
<p>简而言之， <code>BeanFactory</code>提供配置框架和基本功能， <code>ApplicationContext</code>添加了更多特定于企业的功能。<code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集，在本章中仅用于Spring的IoC容器的描述。有关使用<code>BeanFactory</code>而不是<code>ApplicationContext,</code>更多信息<code>ApplicationContext,</code>请参阅<a href="#beans-beanfactory"><code>BeanFactory</code></a> 。</p>
</div>
<div class="paragraph">
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化，组装和管理的对象。否则，bean只是应用程序中众多对象之一。Bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-basics"><a class="anchor" href="#beans-basics"></a> 1.2。集装箱概览</h3>
<div class="paragraph">
<p><code>org.springframework.context.ApplicationContext</code>接口表示Spring IoC容器，负责实例化，配置和组装bean。容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指令。配置元数据以XML，Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖性。</p>
</div>
<div class="paragraph">
<p>Spring提供了<code>ApplicationContext</code>接口的几个实现。在独立应用程序中，通常会创建<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>或<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a>的实例。虽然XML是定义配置元数据的传统格式，但您可以通过提供少量XML配置来声明容器使用Java注释或代码作为元数据格式，以声明方式启用对这些其他元数据格式的支持。</p>
</div>
<div class="paragraph">
<p>在大多数应用程序方案中，不需要显式用户代码来实例化Spring IoC容器的一个或多个实例。例如，在Web应用程序场景中，应用程序的<code>web.xml</code>文件中的简单八行（左右）样板Web描述符XML通常就足够了（请参阅<a href="#context-create">Web应用程序的便捷ApplicationContext实例化</a> ）。如果您使用<a href="https://spring.io/tools/sts">Spring Tool Suite</a> （基于Eclipse的开发环境），只需点击几下鼠标或按键即可轻松创建此样板配置。</p>
</div>
<div class="paragraph">
<p>下图显示了Spring如何工作的高级视图。您的应用程序类与配置元数据相结合，以便在创建和初始化<code>ApplicationContext</code>之后，您拥有一个完全配置且可执行的系统或应用程序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/container-magic.png" alt="容器魔术">
</div>
<div class="title">图1。Spring IoC容器</div>
</div>
<div class="sect3">
<h4 id="beans-factory-metadata"><a class="anchor" href="#beans-factory-metadata"></a> 1.2.1。配置元数据</h4>
<div class="paragraph">
<p>如上图所示，Spring IoC容器使用一种配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉Spring容器在应用程序中实例化，配置和组装对象。</p>
</div>
<div class="paragraph">
<p>传统上，配置元数据以简单直观的XML格式提供，本章大部分内容用于传达Spring IoC容器的关键概念和功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">基于XML的元数据不是唯一允许的配置元数据形式。Spring IoC容器本身完全与实际编写此配置元数据的格式分离。目前，许多开发人员为其Spring应用程序选择<a href="#beans-java">基于Java的配置</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关在Spring容器中使用其他形式的元数据的信息，请参阅：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-annotation-config">基于注释的配置</a> ：Spring 2.5引入了对基于注释的配置元数据的支持。</p>
</li>
<li>
<p><a href="#beans-java">基于Java的配置</a> ：从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring Framework的一部分。因此，您可以使用Java而不是XML文件在应用程序类外部定义bean。要使用这些新功能，请参阅<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>和<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a>注解。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring配置由容器必须管理的至少一个且通常不止一个bean定义组成。基于XML的配置元数据配置这些豆类如<code>&lt;bean/&gt;</code>顶层内部元件<code>&lt;beans/&gt;</code>元素。Java配置通常在<code>@Configuration</code>类中使用<code>@Bean</code> -annotated方法。</p>
</div>
<div class="paragraph">
<p>这些bean定义对应于构成应用程序的实际对象。通常，您定义服务层对象，数据访问对象（DAO），表示对象（如Struts <code>Action</code>实例），基础结构对象（如Hibernate <code>SessionFactories</code> ，JMS <code>Queues</code>等）。通常，不会在容器中配置细粒度域对象，因为创建和加载域对象通常由DAO和业务逻辑负责。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。请参阅<a href="#aop-atconfigurable">使用AspectJ使用Spring依赖注入域对象</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了基于XML的配置元数据的基本结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">...</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">...</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="comment">&lt;！ - 这个bean的协作者和配置在这里 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这个bean的协作者和配置go这里 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 更多bean定义到这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>id</code>属性是一个标识单个bean定义的字符串。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>class</code>属性定义bean的类型并使用完全限定的classname。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>id</code>属性的值指的是协作对象。在此示例中未显示用于引用协作对象的XML。有关更多信息，请参阅<a href="#beans-dependencies">依赖项</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-instantiation"><a class="anchor" href="#beans-factory-instantiation"></a> 1.2.2。实例化容器</h4>
<div class="paragraph">
<p>提供给<code>ApplicationContext</code>构造函数的位置路径是资源字符串，它允许容器从各种外部资源（如本地文件系统，Java <code>CLASSPATH</code>等）加载配置元数据。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">services.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">daos.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意：在了解了Spring的IoC容器之后，您可能想要了解有关Spring的<code>Resource</code>抽象的更多信息（如<a href="#resources">参考资料中所述</a> ），它提供了一种从URI语法中定义的位置读取InputStream的便捷机制。特别是， <code>Resource</code>路径用于构建应用程序上下文，如<a href="#resources-app-ctx">应用程序上下文和资源路径中所述</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了服务层对象<code>(services.xml)</code>配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  services  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">petStore</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org。 springframework.samples.jpetstore.services。PetStoreServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountDao</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">itemDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">itemDao</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 此bean的其他协作者和配置到这里 - &gt;</span> <span class="tag">&lt;/ bean &gt;</span> <span class="comment">&lt;！ - 服务的更多bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了数据访问对象<code>daos.xml</code>文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.samples.jpetstore.dao。 JPA。JpaAccountDao</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 此bean的其他协作者和配置在这里 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">itemDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.samples.jpetstore.dao.jpa。JpaItemDao</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这个bean的其他协作者和配置在这里 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 更多数据访问对象的bean定义到这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，服务层由<code>PetStoreServiceImpl</code>类和两个类型为<code>JpaAccountDao</code>和<code>JpaItemDao</code>数据访问对象<code>JpaItemDao</code> （基于JPA对象关系映射标准）。<code>property name</code>元素引用JavaBean属性的名称， <code>ref</code>元素引用另一个bean定义的名称。<code>id</code>和<code>ref</code>元素之间的这种联系表达了协作对象之间的依赖关系。有关配置对象的依赖项的详细信息，请参阅<a href="#beans-dependencies">依赖项</a> 。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-xml-import"><a class="anchor" href="#beans-factory-xml-import"></a>编写基于XML的配置元数据</h5>
<div class="paragraph">
<p>让bean定义跨越多个XML文件会很有用。通常，每个单独的XML配置文件都代表架构中的逻辑层或模块。</p>
</div>
<div class="paragraph">
<p>您可以使用应用程序上下文构造函数从所有这些XML片段加载bean定义。此构造函数采用多个<code>Resource</code>位置，如上<a href="#beans-factory-instantiation">一节中</a>所示。或者，使用一个或多个<code>&lt;import/&gt;</code>元素来从另一个或多个文件加载bean定义。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;豆&gt;</span> <span class="tag">&lt;进口</span> <span class="attribute-name">资源</span> = <span class="string"><span class="content"><span class="delimiter">“services.xml</span>中</span> <span class="delimiter"><span class="tag">”/&gt;</span></span></span> <span class="tag">&lt;进口</span> <span class="attribute-name">资源</span> = <span class="string"><span class="delimiter">“</span> <span class="content">资源/ <span class="delimiter"><span class="tag">messageSource.xml”/&gt;</span></span></span></span> <span class="tag">&lt;进口</span> <span class="attribute-name">资源</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“/resources/themeSource.xml”/&gt;</span></span></span></span></span> <span class="tag">&lt;豆</span> <span class="attribute-name">ID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“bean1”</span></span></span></span> <span class="attribute-name">类</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">bean2</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，外部bean定义从三个文件加载： <code>services.xml</code> ， <code>messageSource.xml</code>和<code>themeSource.xml</code> 。所有位置路径都与执行导入的定义文件相关，因此<code>services.xml</code>必须与执行导入的文件位于相同的目录或类路径位置，而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须位于该位置下的<code>resources</code>位置导入文件。如您所见，忽略前导斜杠。但是，鉴于这些路径是相对的，最好不要使用斜杠。根据Spring Schema，正在导入的文件的内容（包括顶级<code>&lt;beans/&gt;</code>元素）必须是有效的XML bean定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以（但不建议）使用相对“../”路径引用父目录中的文件。这样做会对当前应用程序之外的文件创建依赖关系。特别是，不建议对<code>classpath:</code>使用此引用<code>classpath:</code> URL（例如， <code>classpath:../services.xml</code> ），其中运行时解析过程选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能导致选择不同的，不正确的目录。</p>
</div>
<div class="paragraph">
<p>您始终可以使用完全限定的资源位置而不是相对路径：例如， <code>file:C:/config/services.xml</code>或<code>classpath:/config/services.xml</code> 。但是，请注意您将应用程序的配置与特定的绝对位置耦合。通常最好为这样的绝对位置保持间接 - 例如，通过在运行时针对JVM系统属性解析的“$ {...}”占位符。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>命名空间本身提供了导入指令功能。除了普通bean定义之外的其他配置功能在Spring提供的一系列XML命名空间中可用 - 例如， <code>context</code>和<code>util</code>命名空间。</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy-bean-definition-dsl"><a class="anchor" href="#groovy-bean-definition-dsl"></a> Groovy Bean定义DSL</h5>
<div class="paragraph">
<p>作为外部化配置元数据的另一个示例，bean定义也可以在Spring的Groovy Bean定义DSL中表示，如Grails框架中所知。通常，此类配置位于“.groovy”文件中，其结构如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">beans {dataSource（BasicDataSource）{driverClassName = <span class="string"><span class="delimiter">“</span> <span class="content">org.hsqldb.jdbcDriver</span> <span class="delimiter">”</span></span> url = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc：hsqldb：mem：grailsDB</span> <span class="delimiter">”</span></span> username = <span class="string"><span class="delimiter">“</span> <span class="content">sa</span> <span class="delimiter">”</span></span> password = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> settings = [mynew： <span class="string"><span class="delimiter">“</span> <span class="content">setting</span> <span class="delimiter">”</span></span> ]} sessionFactory（SessionFactory） {dataSource = dataSource} myService（MyService）{nestedBean = {AnotherBean bean  - &gt; dataSource = dataSource}}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此配置样式在很大程度上等同于XML bean定义，甚至支持Spring的XML配置命名空间。它还允许通过<code>importBeans</code>指令导入XML bean定义文件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-client"><a class="anchor" href="#beans-factory-client"></a> 1.2.3。使用容器</h4>
<div class="paragraph">
<p><code>ApplicationContext</code>是高级工厂的接口，能够维护不同bean及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code> ，您可以检索bean的实例。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code>允许您读取bean定义并访问它们，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//创建和配置bean</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">services.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">daos.xml</span> <span class="delimiter">”</span></span> ）; <span class="comment">//检索配置的实例</span> PetStoreService service = context.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">petStore</span> <span class="delimiter">”</span></span> ，PetStoreService.class）; <span class="comment">//使用已配置的实例</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; userList = service.getUsernameList（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用Groovy配置，bootstrapping看起来非常相似。它有一个不同的上下文实现类，它是Groovy-aware（但也理解XML bean定义）。以下示例显示了Groovy配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">services.groovy</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">daos.groovy</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最灵活的变体是<code>GenericApplicationContext</code>与读者委托相结合 - 例如，使用XML文件的<code>XmlBeanDefinitionReader</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext（）; <span class="keyword">new</span> XmlBeanDefinitionReader（context）.loadBeanDefinitions（ <span class="string"><span class="delimiter">“</span> <span class="content">services.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">daos.xml</span> <span class="delimiter">”</span></span> ）; context.refresh（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以将<code>GroovyBeanDefinitionReader</code>用于Groovy文件，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext（）; <span class="keyword">new</span> GroovyBeanDefinitionReader（context）.loadBeanDefinitions（ <span class="string"><span class="delimiter">“</span> <span class="content">services.groovy</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">daos.groovy</span> <span class="delimiter">”</span></span> ）; context.refresh（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在同一个<code>ApplicationContext</code>上混合和匹配这些读者委托，从不同的配置源中读取bean定义。</p>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>getBean</code>来检索Bean的实例。<code>ApplicationContext</code>接口有一些其他方法可以检索bean，但理想情况下，应用程序代码永远不应该使用它们。实际上，您的应用程序代码根本不应该调用<code>getBean()</code>方法，因此根本不依赖于Spring API。例如，Spring与Web框架的集成为各种Web框架组件（如控制器和JSF托管bean）提供依赖注入，允许您通过元数据（例如自动装配注释）声明对特定bean的依赖性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-definition"><a class="anchor" href="#beans-definition"></a> 1.3。Bean概述</h3>
<div class="paragraph">
<p>Spring IoC容器管理一个或多个bean。这些bean是使用您提供给容器的配置元数据创建的（例如，以XML <code>&lt;bean/&gt;</code>定义的形式）。</p>
</div>
<div class="paragraph">
<p>在容器本身内，这些bean定义表示为<code>BeanDefinition</code>对象，其中包含（以及其他信息）以下元数据：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包限定的类名：通常是正在定义的bean的实际实现类。</p>
</li>
<li>
<p>Bean行为配置元素，说明bean在容器中的行为方式（范围，生命周期回调等）。</p>
</li>
<li>
<p>引用bean执行其工作所需的其他bean。这些引用也称为协作者或依赖项。</p>
</li>
<li>
<p>要在新创建的对象中设置的其他配置设置 - 例如，池的大小限制或在管理连接池的Bean中使用的连接数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此元数据转换为组成每个bean定义的一组属性。下表描述了这些属性：</p>
</div>
<table id="beans-factory-bean-definition-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。bean的定义</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">解释在......</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">实例化豆​​类</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-beanname">命名豆</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">范围</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes">Bean范围</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">构造函数参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动装配模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-autowire">自动化协作者</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">延迟初始化模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lazy-init">懒惰初始化的豆类</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">初始化方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-initializingbean">初始化回调</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">破坏方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-disposablebean">毁灭回调</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了包含有关如何创建特定bean的信息的bean定义之外， <code>ApplicationContext</code>实现还允许注册在容器外部（由用户）创建的现有对象。这是通过<code>getBeanFactory()</code>方法访问ApplicationContext的BeanFactory来完成的，该方法返回BeanFactory <code>DefaultListableBeanFactory</code>实现。<code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型应用程序仅适用于通过元数据bean定义定义的bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">需要尽早注册Bean元数据和手动提供的单例实例，以便容器在自动装配和其他内省步骤期间正确推理它们。虽然在某种程度上支持覆盖现有元数据和现有单例实例，但是在运行时注册新bean（与对工厂的实时访问同时）并未得到官方支持，并且可能导致并发访问异常，bean容器中的状态不一致，或者都。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-beanname"><a class="anchor" href="#beans-beanname"></a> 1.3.1。命名豆</h4>
<div class="paragraph">
<p>每个bean都有一个或多个标识符。这些标识符在托管bean的容器中必须是唯一的。bean通常只有一个标识符。但是，如果它需要多个，则额外的可以被视为别名。</p>
</div>
<div class="paragraph">
<p>在基于XML的配置元数据中，使用<code>id</code>属性， <code>name</code>属性或两者来指定bean标识符。<code>id</code>属性允许您指定一个id。通常，这些名称是字母数字（'myBean'，'someService'等），但它们也可以包含特殊字符。如果要为bean引入其他别名，还可以在<code>name</code>属性中指定它们，用逗号（ <code>,</code> ），分号（ <code>;</code> ）或空格分隔。作为历史记录，在Spring 3.1之前的版本中， <code>id</code>属性被定义为<code>xsd:ID</code>类型，它约束了可能的字符。从3.1开始，它被定义为<code>xsd:string</code>类型。请注意，bean <code>id</code>唯一性仍由容器强制执行，但不再由XML解析器强制执行。</p>
</div>
<div class="paragraph">
<p>您不需要为bean提供<code>name</code>或<code>id</code> 。如果未明确提供<code>name</code>或<code>id</code> ，则容器会为该Bean生成唯一的名称。但是，如果要通过名称引用该bean，通过使用<code>ref</code>元素或<a href="#beans-servicelocator">Service Locator</a>样式查找，则必须提供名称。不提供名称的动机与使用<a href="#beans-inner-beans">内部bean</a>和<a href="#beans-factory-autowire">自动装配协作者有关</a> 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bean命名约定</div>
<div class="paragraph">
<p>惯例是在命名bean时使用标准Java约定作为实例字段名称。也就是说，bean名称以小写字母开头，并从那里开始驼峰。这样的名字的例子包括<code>accountManager</code> ， <code>accountService</code> ， <code>userDao</code> ， <code>loginController</code> ，等等。</p>
</div>
<div class="paragraph">
<p>命名bean始终使您的配置更易于阅读和理解。此外，如果您使用Spring AOP，那么在将建议应用于与名称相关的一组bean时，它会有很大帮助。</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过类路径中的组件扫描，Spring按照前面描述的规则为未命名的组件生成bean名称：基本上，采用简单的类名并将其初始字符转换为小写。但是，在（不常见的）特殊情况下，当有多个字符并且第一个和第二个字符都是大写字母时，原始外壳将被保留。这些规则与<code>java.beans.定义的规则相同<code>java.beans.Introspector.decapitalize</code> （Spring在这里使用）。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-beanname-alias"><a class="anchor" href="#beans-beanname-alias"></a>在Bean定义之外别名Bean</h5>
<div class="paragraph">
<p>在bean定义本身中，您可以为bean提供多个名称，方法是使用<code>id</code>属性指定的最多一个名称和<code>name</code>属性中的任意数量的其他名称。这些名称可以是同一个bean的等效别名，对某些情况很有用，例如让应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖项。</p>
</div>
<div class="paragraph">
<p>但是，指定实际定义bean的所有别名并不总是足够的。有时需要为其他地方定义的bean引入别名。在大型系统中通常就是这种情况，其中配置在每个子系统之间分配，每个子系统具有其自己的一组对象定义。在基于XML的配置元数据中，您可以使用<code>&lt;alias/&gt;</code>元素来完成此任务。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fromName</span> <span class="delimiter">”</span></span> <span class="attribute-name">alias</span> = <span class="string"><span class="delimiter">“</span> <span class="content">toName</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，在使用此别名定义之后，名为<code>fromName</code>的bean（在同一容器中）也可以称为<code>toName</code> 。</p>
</div>
<div class="paragraph">
<p>例如，子系统A的配置元数据可以通过<code>subsystemA-dataSource</code>的名称来引用DataSource。子系统B的配置元数据可以通过<code>subsystemB-dataSource</code>的名称来引用DataSource。在编写使用这两个子系统的主应用程序时，主应用程序通过<code>myApp-dataSource</code>的名称引用DataSource。要使所有三个名称引用同一对象，可以将以下别名定义添加到配置元数据中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">subsystemA-dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">alias</span> = <span class="string"><span class="delimiter">“</span> <span class="content">subsystemB-dataSource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;alias</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">subsystemA-dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">alias</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myApp-dataSource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，每个组件和主应用程序都可以通过一个唯一的名称引用dataSource，并保证不与任何其他定义冲突（有效地创建命名空间），但它们引用相同的bean。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Java的配置</div>
<div class="paragraph">
<p>如果使用Javaconfiguration，则<code>@Bean</code>注释可用于提供别名。有关详细信息，请参阅<a href="#beans-java-bean-annotation">使用<code>@Bean</code>批注</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-class"><a class="anchor" href="#beans-factory-class"></a> 1.3.2。实例化豆​​类</h4>
<div class="paragraph">
<p>bean定义本质上是用于创建一个或多个对象的配方。容器在被询问时查看命名bean的配方，并使用由该bean定义封装的配置元数据来创建（或获取）实际对象。</p>
</div>
<div class="paragraph">
<p>如果使用基于XML的配置元数据，则指定要在<code>&lt;bean/&gt;</code>元素的<code>class</code>属性中实例化的对象的类型（或类）。此<code>class</code>属性（其内部，是一<code>Class</code>在一个属性<code>BeanDefinition</code>实例）通常是必需的。（有关例外，请参阅<a href="#beans-factory-class-instance-factory-method">使用实例工厂方法</a>和<a href="#beans-child-bean-definitions">Bean定义继承</a> <a href="#beans-factory-class-instance-factory-method">进行实例化</a> 。）您可以通过以下两种方式之一使用<code>Class</code>属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常，在容器本身通过反向调用其构造函数直接创建bean的情况下指定要构造的bean类，稍微等同于使用<code>new</code>运算符的Java代码。</p>
</li>
<li>
<p>要指定包含为创建对象而调用的<code>static</code>工厂方法的实际类，在不太常见的情况下，容器在类上调用<code>static</code>工厂方法来创建bean。从<code>static</code>工厂方法的调用返回的对象类型可以完全是同一个类或另一个类。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<div class="title">内部类名</div>
<p>如果要为<code>static</code>嵌套类配置bean定义，则必须使用嵌套类的二进制名称。</p>
</div>
<div class="paragraph">
<p>例如，如果在<code>com.example</code>包中有一个名为<code>SomeThing</code>的类，并且此<code>SomeThing</code>类具有一个名为<code>OtherThing</code>的<code>static</code>嵌套类，则bean定义上的<code>class</code>属性值将为<code>com.example.SomeThing$OtherThing</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，在名称中使用<code>$</code>字符可以将嵌套类名与外部类名分开。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-ctor"><a class="anchor" href="#beans-factory-class-ctor"></a>使用构造函数实例化</h5>
<div class="paragraph">
<p>当您通过构造方法创建bean时，所有普通类都可以使用并与Spring兼容。也就是说，正在开发的类不需要实现任何特定接口或以特定方式编码。简单地指定bean类就足够了。但是，根据您为该特定bean使用的IoC类型，您可能需要一个默认（空）构造函数。</p>
</div>
<div class="paragraph">
<p>Spring IoC容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的JavaBeans。大多数Spring用户更喜欢实际的JavaBeans，只有一个默认（无参数）构造函数，并且在容器中的属性之后建模了适当的setter和getter。您还可以在容器中拥有更多异国情调的非bean样式类。例如，如果您需要使用绝对不符合JavaBean规范的旧连接池，那么Spring也可以对其进行管理。</p>
</div>
<div class="paragraph">
<p>使用基于XML的配置元数据，您可以按如下方式指定bean类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">anotherExample</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">examples。ExampleBeanTwo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关为构造函数提供参数的机制（如果需要）以及在构造对象后设置对象实例属性的详细信息，请参阅<a href="#beans-factory-collaborators">注入依赖项</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-static-factory-method"><a class="anchor" href="#beans-factory-class-static-factory-method"></a>使用静态工厂方法实例化</h5>
<div class="paragraph">
<p>定义使用静态工厂方法创建的bean时，请使用<code>class</code>属性指定包含<code>static</code>工厂方法的类和名为<code>factory-method</code>的属性，以指定工厂方法本身的名称。您应该能够调用此方法（使用可选参数，如稍后所述）并返回一个活动对象，随后将其视为通过构造函数创建的对象。这种bean定义的一个用途是在遗留代码中调用<code>static</code>工厂。</p>
</div>
<div class="paragraph">
<p>以下bean定义指定通过调用工厂方法来创建bean。该定义未指定返回对象的类型（类），仅指定包含工厂方法的类。在此示例中， <code>createInstance()</code>方法必须是静态方法。以下示例显示如何指定工厂方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">clientService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ClientService</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">createInstance</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了一个可以使用前面的bean定义的类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ClientService</span> { <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientService（）; <span class="directive">private</span> ClientService（）{} <span class="directive">public</span> <span class="directive">static</span> ClientService createInstance（）{ <span class="keyword">return</span> clientService; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关在从工厂返回对象后为工厂方法提供（可选）参数和设置对象实例属性的机制的详细信息，请参阅<a href="#beans-factory-properties-detailed">依赖关系和详细配置</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-instance-factory-method"><a class="anchor" href="#beans-factory-class-instance-factory-method"></a>使用实例工厂方法实例化</h5>
<div class="paragraph">
<p>与通过<a href="#beans-factory-class-static-factory-method">静态工厂方法</a>实例化类似，使用实例<a href="#beans-factory-class-static-factory-method">工厂方法进行</a>实例化会从容器调用现有bean的非静态方法来创建新bean。要使用此机制，请将<code>class</code>属性保留为空，并在<code>factory-bean</code>属性中指定当前（或父级或祖先）容器中bean的名称，该容器包含要调用以创建对象的实例方法。使用<code>factory-method</code>属性设置工厂方法本身的名称。以下示例显示如何配置此类bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 工厂bean，它包含一个名为createInstance（）的方法 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serviceLocator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。DefaultServiceLocator</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 注入此定位器bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 通过工厂bean创建的bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">clientService</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceLocator</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">createClientServiceInstance</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的Java类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> { <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl（）; <span class="directive">public</span> ClientService createClientServiceInstance（）{ <span class="keyword">return</span> clientService; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一个工厂类也可以包含多个工厂方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serviceLocator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。DefaultServiceLocator</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 注入此定位器bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">clientService</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceLocator</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">createClientServiceInstance</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceLocator</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">createAccountServiceInstance</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的Java类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> { <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl（）; <span class="directive">private</span> <span class="directive">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl（）; <span class="directive">public</span> ClientService createClientServiceInstance（）{ <span class="keyword">return</span> clientService; <span class="directive">public</span> AccountService createAccountServiceInstance（）{ <span class="keyword">return</span> accountService; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法表明可以通过依赖注入（DI）来管理和配置工厂bean本身。请参阅<a href="#beans-factory-properties-detailed">详细信息中的依赖关系和配置</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在Spring文档中，“工厂bean”是指在Spring容器中配置并通过<a href="#beans-factory-class-instance-factory-method">实例</a>或<a href="#beans-factory-class-static-factory-method">静态</a>工厂方法创建对象的bean。相比之下， <code>FactoryBean</code> （注意大小写）是指Spring特定的<a href="#beans-factory-extension-factorybean"><code>FactoryBean</code></a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-dependencies"><a class="anchor" href="#beans-dependencies"></a> 1.4。依赖</h3>
<div class="paragraph">
<p>典型的企业应用程序不包含单个对象（或Spring用法中的bean）。即使是最简单的应用程序也有一些对象可以协同工作，以呈现最终用户所看到的连贯应用程序。下一节将介绍如何定义多个独立的bean定义，以及对象协作实现目标的完全实现的应用程序。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-collaborators"><a class="anchor" href="#beans-factory-collaborators"></a> 1.4.1。依赖注入</h4>
<div class="paragraph">
<p>依赖注入（DI）是一个过程，通过这个过程，对象只能通过构造函数参数，工厂方法的参数或在构造对象实例后在对象实例上设置的属性来定义它们的依赖关系（即，它们使用的其他对象）。从工厂方法返回。然后容器在创建bean时注入这些依赖项。这个过程基本上是bean本身的反向（因此名称，控制反转），通过使用类的直接构造或服务定位器模式来控制其依赖项的实例化或位置。</p>
</div>
<div class="paragraph">
<p>使用DI原则的代码更清晰，当对象提供其依赖项时，解耦更有效。该对象不查找其依赖项，也不知道依赖项的位置或类。因此，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，这允许在单元测试中使用存根或模拟实现。</p>
</div>
<div class="paragraph">
<p>DI存在两个主要变体： <a href="#beans-constructor-injection">基于构造函数的依赖注入</a>和<a href="#beans-setter-injection">基于Setter的依赖注入</a> 。</p>
</div>
<div class="sect4">
<h5 id="beans-constructor-injection"><a class="anchor" href="#beans-constructor-injection"></a>基于构造函数的依赖注入</h5>
<div class="paragraph">
<p>基于构造函数的DI由容器调用具有多个参数的构造函数来完成，每个参数表示一个依赖项。调用具有特定参数的<code>static</code>工厂方法来构造bean几乎是等效的，本讨论同样处理构造函数和<code>static</code>工厂方法的参数。以下示例显示了一个只能使用构造函数注入进行依赖注入的类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="comment">// SimpleMovieLister依赖于MovieFinder</span> <span class="directive">私有</span> MovieFinder movieFinder; <span class="comment">//一个构造函数，以便Spring容器可以注入一个MovieFinder</span> <span class="directive">public</span> SimpleMovieLister（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">//省略了实际使用注入的MovieFinder的业务逻辑...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，这个类没有什么特别之处。它是一个POJO，它不依赖于容器特定的接口，基类或注释。</p>
</div>
<div class="sect5">
<h6 id="beans-factory-ctor-arguments-resolution"><a class="anchor" href="#beans-factory-ctor-arguments-resolution"></a>构造函数参数解析</h6>
<div class="paragraph">
<p>使用参数的类型进行构造函数参数解析匹配。如果bean定义的构造函数参数中不存在潜在的歧义，那么在bean定义中定义构造函数参数的顺序是在实例化bean时将这些参数提供给适当的构造函数的顺序。考虑以下课程：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">xy</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">ThingOne</span> { <span class="directive">public</span> ThingOne（ThingTwo thingTwo，ThingTeree thing3）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设<code>ThingTwo</code>和<code>ThingThree</code>类与继承无关，则不存在潜在的歧义。因此，以下配置工作正常，您无需在<code>&lt;constructor-arg/&gt;</code>元素中显式指定构造函数参数索引或类型。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thingOne</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyThingOne</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingTwo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingThree</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingTwo</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyThingTwo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingThree</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyThingThree</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当引用另一个bean时，类型是已知的，并且可以进行匹配（与前面的示例一样）。当使用简单类型时，例如<code>&lt;value&gt;true&lt;/value&gt;</code> ，Spring无法确定值的类型，因此无法在没有帮助的情况下按类型进行匹配。考虑以下课程：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包装</span> <span class="namespace">示例</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="comment">//计算Ultimate Answer</span> <span class="directive">private</span> <span class="type">int</span> years的年数; <span class="comment">//对生命，宇宙和一切的回答</span> <span class="directive">private</span> <span class="predefined-type">String</span> ultimateAnswer; <span class="directive">public</span> ExampleBean（ <span class="type">int</span> years， <span class="predefined-type">String</span> ultimateAnswer）{ <span class="local-variable">this</span> .years = years; <span class="local-variable">这个</span> .ultimateAnswer = ultimateAnswer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-type"></a>构造函数参数类型匹配</div>
<div class="content">
<div class="paragraph">
<p>在前面的场景中，如果使用<code>type</code>属性显式指定构造函数参数的类型，则容器可以使用与简单类型的类型匹配。如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">int</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">7500000</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">java.lang。字符串</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">42</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-index"></a>构造函数参数索引</div>
<div class="content">
<div class="paragraph">
<p>您可以使用<code>index</code>属性显式指定构造函数参数的索引，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span> = <span class="string"><span class="delimiter">”</span> <span class="content">0</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">7500000</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">42</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了解决多个简单值的歧义之外，指定索引还可以解决构造函数具有相同类型的两个参数的歧义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该指数从0开始。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-name"></a>构造函数参数名称</div>
<div class="content">
<div class="paragraph">
<p>您还可以使用构造函数参数名称进行值消歧，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">years</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">7500000</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ultimateAnswer</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">42</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请记住，为了使这项工作开箱即用，必须在启用调试标志的情况下编译代码，以便Spring可以从构造函数中查找参数名称。如果您不能或不想使用debug标志编译代码，则可以使用<a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK批注显式命名构造函数参数。然后，示例类必须如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包装</span> <span class="namespace">示例</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="comment">//字段省略</span> <span class="annotation">@ConstructorProperties</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">years</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">ultimateAnswer</span> <span class="delimiter">”</span></span> }） <span class="directive">public</span> ExampleBean（ <span class="type">int</span> years， <span class="predefined-type">String</span> ultimateAnswer）{ <span class="local-variable">this</span> .years = years; <span class="local-variable">这个</span> .ultimateAnswer = ultimateAnswer; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-setter-injection"><a class="anchor" href="#beans-setter-injection"></a>基于Setter的依赖注入</h5>
<div class="paragraph">
<p>在调用无参数构造函数或无参数<code>static</code>工厂方法来实例化bean之后，基于setter的DI由bean上的容器调用setter方法完成。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个只能通过使用纯setter注入进行依赖注入的类。这个类是传统的Java。它是一个POJO，它不依赖于容器特定的接口，基类或注释。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="comment">// SimpleMovieLister依赖于MovieFinder</span> <span class="directive">私有</span> MovieFinder movieFinder; <span class="comment">//一个setter方法，以便Spring容器可以注入一个MovieFinder</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">//省略了实际使用注入的MovieFinder的业务逻辑...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code>支持它管理的bean的基于构造函数和基于setter的DI。在通过构造函数方法注入了一些依赖项之后，它还支持基于setter的DI。您可以以<code>BeanDefinition</code>的形式配置依赖项，并将其与<code>PropertyEditor</code>实例结合使用，以将属性从一种格式转换为另一种格式。但是，大多数Spring用户不直接使用这些类（即以编程方式），而是使用XML <code>bean</code>定义，带注释的组件（即使用<code>@Component</code> <code>@Bean</code> ， <code>@Controller</code> <code>@Bean</code>等注释的<code>@Component</code> ）或<code>@Bean</code>方法。基于Java的<code>@Configuration</code>类。然后，这些源在内部转换为<code>BeanDefinition</code>实例，并用于加载整个Spring IoC容器实例。</p>
</div>
<div id="beans-constructor-vs-setter-injection" class="sidebarblock">
<div class="content">
<div class="title">基于构造函数或基于setter的DI？</div>
<div class="paragraph">
<p>由于您可以混合基于构造函数和基于setter的DI，因此将构造函数用于强制依赖项和setter方法或可选依赖项的配置方法是一个很好的经验法则。请注意，在setter方法上使用<a href="#beans-required-annotation">@Required</a>注释可用于使属性成为必需的依赖项。</p>
</div>
<div class="paragraph">
<p>Spring团队通常提倡构造函数注入，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为<code>null</code> 。此外，构造函数注入的组件总是以完全初始化的状态返回到客户端（调用）代码。作为旁注，大量的构造函数参数是一个糟糕的代码气味，暗示该类可能有太多的责任，应该重构以更好地解决关注点的正确分离。</p>
</div>
<div class="paragraph">
<p>Setter注入应主要仅用于可在类中指定合理默认值的可选依赖项。否则，必须在代码使用依赖项的任何位置执行非空检查。setter注入的一个好处是setter方法使该类的对象可以在以后重新配置或重新注入。因此，通过<a href="integration.html#jmx">JMX MBean进行</a>管理是二次注入的一个引人注目的用例。</p>
</div>
<div class="paragraph">
<p>使用对特定类最有意义的DI样式。有时，在处理您没有源的第三方类时，会选择您。例如，如果第三方类没有公开任何setter方法，那么构造函数注入可能是唯一可用的DI形式。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-dependency-resolution"><a class="anchor" href="#beans-dependency-resolution"></a>依赖性解决过程</h5>
<div class="paragraph">
<p>容器执行bean依赖性解析，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ApplicationContext</code>是使用描述所有bean的配置元数据创建和初始化的。配置元数据可以由XML，Java代码或注释指定。</p>
</li>
<li>
<p>对于每个bean，它的依赖关系以属性，构造函数参数或static-factory方法的参数的形式表示（如果使用它而不是普通的构造函数）。实际创建bean时，会将这些依赖项提供给bean。</p>
</li>
<li>
<p>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。</p>
</li>
<li>
<p>作为值的每个属性或构造函数参数都从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将以字符串格式提供的值转换为所有内置类型，例如<code>int</code> ， <code>long</code> ， <code>String</code> ， <code>boolean</code>等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring容器在创建容器时验证每个bean的配置。但是，在实际创建bean之前，不会设置bean属性本身。创建容器时会创建单例作用域并设置为预先实例化（默认值）的Bean。范围在<a href="#beans-factory-scopes">Bean范围</a>中定义。否则，仅在请求时才创建bean。创建bean可能会导致创建bean的图形，因为bean的依赖关系及其依赖关系（依此类推）被创建和分配。请注意，这些依赖项之间的解决方案不匹配可能会显示较晚 - 也就是说，首次创建受影响的bean时。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">循环依赖</div>
<div class="paragraph">
<p>如果您主要使用构造函数注入，则可以创建无法解析的循环依赖关系场景。</p>
</div>
<div class="paragraph">
<p>例如：类A通过构造函数注入需要类B的实例，而类B通过构造函数注入需要类A的实例。如果为A类和B类配置bean以便相互注入，则Spring IoC容器会在运行时检测此循环引用，并抛出<code>BeanCurrentlyInCreationException</code> 。</p>
</div>
<div class="paragraph">
<p>一种可能的解决方案是编辑由setter而不是构造函数配置的某些类的源代码。或者，避免构造函数注入并仅使用setter注入。换句话说，尽管不推荐使用，但您可以使用setter注入配置循环依赖关系。</p>
</div>
<div class="paragraph">
<p>与典型情况（没有循环依赖）不同，bean A和bean B之间的循环依赖强制其中一个bean在完全初始化之前被注入另一个bean（经典的鸡与鸡蛋场景）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>你通常可以信任Spring做正确的事。它在容器加载时检测配置问题，例如对不存在的bean和循环依赖的引用。当实际创建bean时，Spring会尽可能晚地设置属性并解析依赖项。这意味着，如果在创建该对象或其中一个依赖项时出现问题，则在请求对象时，正确加载的Spring容器可以在以后生成异常 - 例如，bean因缺少或无效而抛出异常属性。这可能会延迟一些配置问题的可见性，这就是默认情况下<code>ApplicationContext</code>实现预先实例化单例bean的原因。以实际需要之前创建这些bean的一些前期时间和内存为代价，您会在创建<code>ApplicationContext</code>时发现配置问题，而不是更晚。您仍然可以覆盖此默认行为，以便单例bean可以懒惰地初始化，而不是预先实例化。</p>
</div>
<div class="paragraph">
<p>如果不存在循环依赖，当一个或多个协作bean被注入依赖bean时，每个协作bean在被注入依赖bean之前完全配置。这意味着，如果bean A依赖于bean B，则Spring IoC容器在调用bean A上的setter方法之前完全配置bean B.换句话说，bean被实例化（如果它不是预先实例化的单例），设置其依赖项，并调用相关的生命周期方法（如<a href="#beans-factory-lifecycle-initializingbean">配置的init方法</a>或<a href="#beans-factory-lifecycle-initializingbean">InitializingBean回调方法</a> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-some-examples"><a class="anchor" href="#beans-some-examples"></a>依赖注入的示例</h5>
<div class="paragraph">
<p>以下示例将基于XML的配置元数据用于基于setter的DI。 Spring XML配置文件的一小部分指定了一些bean定义，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 使用嵌套的ref元素进行setter注入 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beanOne</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">anotherExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 使用neater ref属性进行setter注入 - - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">beanTwo</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">yetAnotherBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">integerProperty</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">anotherExampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。AnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yetAnotherBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。YetAnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的<code>ExampleBean</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="directive">private</span> AnotherBean beanOne; <span class="directive">private</span> YetAnotherBean beanTwo; <span class="directive">私人</span> <span class="type">诠释</span>我; <span class="directive">public</span> <span class="type">void</span> setBeanOne（AnotherBean beanOne）{ <span class="local-variable">this</span> .beanOne = beanOne; <span class="directive">public</span> <span class="type">void</span> setBeanTwo（YetAnotherBean beanTwo）{ <span class="local-variable">this</span> .beanTwo = beanTwo; <span class="directive">public</span> <span class="type">void</span> setIntegerProperty（ <span class="type">int</span> i）{ <span class="local-variable">this</span> .i = i; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，setter被声明为与XML文件中指定的属性匹配。以下示例使用基于构造函数的DI：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 构造函数注入使用嵌套的ref元素 - &gt;</span> <span class="tag">&lt;constructor-arg&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">anotherExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ constructor-arg&gt;</span> <span class="comment">&lt;！ - 构造函数注入使用neater ref属性 - &gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">yetAnotherBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">int</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">anotherExampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。AnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yetAnotherBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。YetAnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的<code>ExampleBean</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="directive">private</span> AnotherBean beanOne; <span class="directive">private</span> YetAnotherBean beanTwo; <span class="directive">私人</span> <span class="type">诠释</span>我; <span class="directive">public</span> ExampleBean（AnotherBean anotherBean，YetAnotherBean yetAnotherBean， <span class="type">int</span> i）{ <span class="local-variable">this</span> .beanOne = anotherBean; <span class="local-variable">这个</span> .beanTwo = yetAnotherBean; <span class="local-variable">这个</span> .i = i; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>bean定义中指定的构造函数参数用作<code>ExampleBean</code>的构造函数的<code>ExampleBean</code> 。</p>
</div>
<div class="paragraph">
<p>现在考虑这个示例的变体，其中，不使用构造函数，而是告诉Spring调用<code>static</code>工厂方法来返回对象的实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">createInstance</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">anotherExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yetAnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">anotherExampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。AnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yetAnotherBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。YetAnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的<code>ExampleBean</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="comment">//私有构造函数</span> <span class="directive">private</span> ExampleBean（...）{...} <span class="comment">//静态工厂方法;这个方法的参数可以</span> <span class="comment">//被认为是返回的bean的依赖关系，</span> <span class="comment">//无论这些参数是如何实际使用的。</span>
    <span class="directive">public</span> <span class="directive">static</span> ExampleBean createInstance（AnotherBean anotherBean，YetAnotherBean yetAnotherBean， <span class="type">int</span> i）{ExampleBean eb = <span class="keyword">new</span> ExampleBean（...）; <span class="comment">//其他一些操作......</span>
        <span class="keyword">返回</span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>static</code>工厂方法<code>&lt;constructor-arg/&gt;</code>由<code>&lt;constructor-arg/&gt;</code>元素提供，与实际使用的构造函数完全相同。工厂方法返回的类的类型不必与包含<code>static</code>工厂方法的类相同（尽管在此示例中，它是）。实例（非静态）工厂方法可以以基本相同的方式使用（除了使用<code>factory-bean</code>属性而不是<code>class</code>属性），因此我们不在这里讨论这些细节。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-properties-detailed"><a class="anchor" href="#beans-factory-properties-detailed"></a> 1.4.2。依赖关系和配置细节</h4>
<div class="paragraph">
<p>如上<a href="#beans-factory-collaborators">一节所述</a> ，您可以将bean属性和构造函数参数定义为对其他托管bean（协作者）的引用，或者作为内联定义的值。Spring的基于XML的配置元数据为此目的支持其<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>元素中的子元素类型。</p>
</div>
<div class="sect4">
<h5 id="beans-value-element"><a class="anchor" href="#beans-value-element"></a>直值（基元，字符串等）</h5>
<div class="paragraph">
<p><code>&lt;property/&gt;</code>元素的<code>value</code>属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring的<a href="#core-convert-ConversionService-API">转换服务</a>用于将这些值从<code>String</code>转换为属性或参数的实际类型。以下示例显示了要设置的各种值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 导致setDriverClassName（String）调用 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mysql.jdbc。驱动程序</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：mysql：// localhost：3306 / mydb</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">root</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">password</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">masterkaoli</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例使用<a href="#beans-p-namespace">p命名空间</a>进行更简洁的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：p</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / p</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：driverClassName</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mysql.jdbc。驱动程序</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：url</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：mysql：// localhost：3306 / mydb</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：username</span> = <span class="string"><span class="delimiter">”</span> <span class="content">root</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：password</span> = <span class="string"><span class="delimiter">”</span> <span class="content">masterkaoli</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的XML更简洁。但是，除非您在创建bean定义时使用支持自动属性完成的IDE（例如<a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>或<a href="https://spring.io/tools/sts">Spring Tool Suite</a> ），否则会在运行时而不是设计时发现拼写错误。强烈建议使用此类IDE帮助。</p>
</div>
<div class="paragraph">
<p>您还可以配置<code>java.util.Properties</code>实例，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mappings</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPlaceholderConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 作为java.util输入。属性 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">properties</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> jdbc.driver.className = com.mysql.jdbc。驱动程序jdbc.url = jdbc：mysql：// localhost：3306 / mydb <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring容器将<code>&lt;value/&gt;</code>元素内的文本转换为<code>java.util.使用JavaBeans <code>PropertyEditor</code>机制实现Properties</code>实例。这是一个很好的快捷方式，并且是Spring团队支持在<code>value</code>属性样式上使用嵌套<code>&lt;value/&gt;</code>元素的少数几个地方之一。</p>
</div>
<div class="sect5">
<h6 id="beans-idref-element"><a class="anchor" href="#beans-idref-element"></a> <code>idref</code>元素</h6>
<div class="paragraph">
<p><code>idref</code>元素只是一种防错方法，可以将容器中另一个bean的<code>id</code> （字符串值 - 而不是引用）传递给<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素。以下示例显示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theTargetBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theClientBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">targetName</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;idref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theTargetBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的bean定义代码段与以下代码段完全等效（在运行时）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theTargetBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">client</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">targetName</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theTargetBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一种形式优于第二种形式，因为使用<code>idref</code>标记允许容器在部署时验证引用的命名bean实际存在。在第二个变体中，不对传递给<code>client</code> bean的<code>targetName</code>属性的值执行验证。当<code>client</code> bean实际被实例化时，才会发现错别字（最可能是致命的结果）。如果<code>client</code> bean是<a href="#beans-factory-scopes">原型</a> bean，则只能在部署容器后很长时间才能发现此错误和产生的异常。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">4.0 beans XSD中不再支持<code>idref</code>元素的<code>local</code>属性，因为它不再提供常规<code>bean</code>引用的值。升级到4.0架构时，将现有的<code>idref local</code>引用更改为<code>idref bean</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>&lt;idref/&gt;</code>元素带来值的一个常见位置（至少在Spring 2.0之前的版本中）是在<code>ProxyFactoryBean</code> bean定义中的<a href="#aop-pfb-1">AOP拦截器</a>的配置中。指定拦截器名称时使用<code>&lt;idref/&gt;</code>元素可以防止拼写错误的拦截器ID。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-ref-element"><a class="anchor" href="#beans-ref-element"></a>参考其他豆类（合作者）</h5>
<div class="paragraph">
<p><code>ref</code>元素是<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>定义元素中的最后一个元素。在这里，您将bean的指定属性的值设置为对容器管理的另一个bean（协作者）的引用。引用的bean是要设置其属性的bean的依赖项，并且在设置该属性之前根据需要对其进行初始化。（如果协作者是一个单例bean，它可能已经被容器初始化了。）所有引用最终都是对另一个对象的引用。范围和验证取决于您是通过<code>bean</code> ， <code>local,</code>或<code>parent</code>属性指定其他对象的ID还是名称。</p>
</div>
<div class="paragraph">
<p>通过<code>&lt;ref/&gt;</code>标记的<code>bean</code>属性指定目标bean是最常用的形式，并允许创建对同一容器或父容器中的任何bean的引用，而不管它是否在同一XML文件中。<code>bean</code>属性的值可以与目标bean的<code>id</code>属性相同，或者与目标bean的<code>name</code>属性中的值之一相同。以下示例显示如何使用<code>ref</code>元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">“</span> <span class="content">someBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过<code>parent</code>属性指定目标bean会创建对当前容器的父容器中的bean的引用。<code>parent</code>属性的值可以与目标bean的<code>id</code>属性或目标bean的<code>name</code>属性中的值之一相同。目标bean必须位于当前bean的父容器中。您应该使用此bean引用变量，主要是在您具有容器层次结构并且希望将现有bean包装在父容器中，并使用与父bean具有相同名称的代理。以下一对列表显示了如何使用<code>parent</code>属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 在父上下文中 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。SimpleAccountService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 根据需要插入依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 在子（后代）上下文中 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="error">&lt;</span> <span class="error">！</span> <span class="attribute-name">-</span> <span class="attribute-name">豆</span> <span class="attribute-name">的名字</span> <span class="attribute-name">是</span> <span class="attribute-name"><span class="attribute-name"><span class="attribute-name">相同</span></span></span> <span class="attribute-name">的</span> <span class="attribute-name">父</span> <span class="attribute-name">bean</span> <span class="attribute-name">-</span> <span class="tag">&gt;</span>类=“org.springframework.aop.framework。ProxyFactoryBean“ <span class="error">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">target</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 注意我们如何引用父bean  - &gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 根据需要插入其他配置和依赖项这里 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">4.0 beans XSD不再支持<code>ref</code>元素的<code>local</code>属性，因为它不再提供常规<code>bean</code>引用的值。升级到4.0架构时，将现有的<code>ref local</code>引用更改为<code>ref bean</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-inner-beans"><a class="anchor" href="#beans-inner-beans"></a>内豆</h5>
<div class="paragraph">
<p><code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素中的<code>&lt;bean/&gt;</code>元素定义了内部bean，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">outer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 而不是使用对目标bean的引用，只需定义目标bean内联 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">target</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。Person</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这是内部bean  - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Fiona Apple</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">25</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>内部bean定义不需要定义的ID或名称。如果指定，则容器不使用此类值作为标识符。容器还会在创建时忽略<code>scope</code>标志，因为内部bean始终是匿名的，并且始终使用外部bean创建。不可能独立访问内部bean或将它们注入协作bean而不是封闭bean。</p>
</div>
<div class="paragraph">
<p>作为一个极端情况，可以从自定义范围接收销毁回调 - 例如，对于包含在单例bean中的请求范围的内部bean。内部bean实例的创建与其包含bean相关联，但是销毁回调允许它参与请求范围的生命周期。这不是常见的情况。内部bean通常只是共享其包含bean的范围。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-collection-elements"><a class="anchor" href="#beans-collection-elements"></a>集合</h5>
<div class="paragraph">
<p><code>&lt;list/&gt;</code> ， <code>&lt;set/&gt;</code> ， <code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别设置Java <code>Collection</code>类型<code>List</code> ， <code>Set</code> ， <code>Map</code>和<code>Properties</code>的属性和参数。以下示例显示了如何使用它们：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">moreComplexObject</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。ComplexObject</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 导致setAdminEmails（java.util。属性）调用 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">adminEmails</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">administrator</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> administrator@example.org <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">support</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> support@example.org <span class="tag">&lt;/ prop &gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">development</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> development@example.org <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 产生一个setSomeList（java.util。List）调用 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">someList</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span>一个列表元素后跟一个引用<span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 导致setSomeMap（java.util。Map）调用 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">someMap</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">一个条目</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">只是一些字符串</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">a ref</span> <span class="delimiter">”</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="tag">/ &gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 导致setSomeSet（java.util。Set）call  - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">someSet</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;value&gt;</span>只是一些字符串<span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>映射键或值的值或设置值也可以是以下任何元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">豆| ref | idref |列表|设置|地图|道具|价值|空值</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-merging"><a class="anchor" href="#beans-collection-elements-merging"></a>合并合并</h6>
<div class="paragraph">
<p>Spring容器还支持合并集合。应用程序开发人员可以定义父<code>&lt;list/&gt;</code> ， <code>&lt;map/&gt;</code> ， <code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，并具有子<code>&lt;list/&gt;</code> ， <code>&lt;map/&gt;</code> ， <code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素继承和覆盖父集合中的值。也就是说，子集合的值是合并父集合和子集合的元素的结果，子集合的元素覆盖父集合中指定的值。</p>
</div>
<div class="paragraph">
<p>关于合并的这一部分讨论了父子bean机制。不熟悉父母和子bean定义的读者可能希望在继续之前阅读<a href="#beans-child-bean-definitions">相关部分</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例演示了集合合并：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">parent</span> <span class="delimiter">”</span></span> <span class="attribute-name">abstract</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。ComplexObject</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">adminEmails</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">administrator</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> administrator@example.com <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">support</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> support@example.com <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">child</span> <span class="delimiter">”</span></span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">“</span> <span class="content">parent</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">adminEmails</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 在</span> <span class="string"><span class="content">子集合</span></span> <span class="comment">定义上指定合并 - &gt;</span> <span class="tag">&lt;props</span> <span class="attribute-name">merge</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sales</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> sales@example.com <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">support</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> support@example.co.uk <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt; / bean&gt;</span> <span class="tag">&lt;beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意在<code>child</code> bean定义的<code>adminEmails</code>属性的<code>&lt;props/&gt;</code>元素上使用<code>merge=true</code>属性。当<code>child</code>豆得到解决，由容器实例化后，生成的实例有<code>adminEmails</code> <code>Properties</code>集合，其中包含合并的孩子的结果<code>adminEmails</code>与父集合<code>adminEmails</code>集合。以下清单显示了结果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>administrator=administrator@example.com sales=sales@example.com support=support@example.co.uk</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>子<code>Properties</code>集合的值集继承父<code>&lt;props/&gt;</code>所有属性元素，子值的<code>support</code>值覆盖父集合中的值。</p>
</div>
<div class="paragraph">
<p>此合并行为同样适用于<code>&lt;list/&gt;</code> ， <code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合类型。在<code>&lt;list/&gt;</code>元素的特定情况下，保持与<code>List</code>集合类型相关联的语义（即， <code>ordered</code>的值集合的概念）。父级的值位于所有子级列表的值之前。对于<code>Map</code> ， <code>Set</code>和<code>Properties</code>集合类型，不存在排序。因此，对于作为容器内部使用的关联<code>Map</code> ， <code>Set</code>和<code>Properties</code>实现类型的基础的集合类型，没有排序语义有效。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-merge-limitations"><a class="anchor" href="#beans-collection-merge-limitations"></a>收集合并的局限性</h6>
<div class="paragraph">
<p>您无法合并不同的集合类型（例如<code>Map</code>和<code>List</code> ）。如果您尝试这样做，则会抛出相应的<code>Exception</code> 。必须在较低的继承子定义上指定<code>merge</code>属性。在父集合定义上指定<code>merge</code>属性是多余的，并且不会导致所需的合并。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-strongly-typed"><a class="anchor" href="#beans-collection-elements-strongly-typed"></a>强烈的收藏品</h6>
<div class="paragraph">
<p>通过在Java 5中引入泛型类型，您可以使用强类型集合。也就是说，可以声明<code>Collection</code>类型，使其只能包含（例如） <code>String</code>元素。如果使用Spring将强类型<code>Collection</code>依赖注入到bean中，则可以利用Spring的类型转换支持，以便强类型<code>Collection</code>实例的元素在添加到类型之前转换为适当的类型。 <code>Collection</code> 。以下Java类和bean定义显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomeClass</span> { <span class="directive">private</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Float</span> &gt; accounts; <span class="directive">public</span> <span class="type">void</span> setAccounts（ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Float</span> &gt; accounts）{ <span class="local-variable">this</span> .accounts = accounts; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">something</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xySomeClass</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accounts</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">one</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">9.99</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">two</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">2.75</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">six</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">3.99</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当<code>accounts</code>的财产<code>something</code> bean被制备用于注射，关于强类型的元素类型泛型信息<code>Map&lt;String, Float&gt;</code>可通过反射。因此，Spring的类型转换基础结构将各种值元素识别为<code>Float</code>类型，并将字符串值（ <code>9.99, 2.75</code>和<code>3.99</code> ）转换为实际的<code>Float</code>类型。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-null-element"><a class="anchor" href="#beans-null-element"></a>空字符串值和空字符串值</h5>
<div class="paragraph">
<p>Spring将属性等的空参数视为空<code>Strings</code> 。以下基于XML的配置元数据片段将<code>email</code>属性设置为空<code>String</code>值（“”）。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ExampleBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">email</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例等效于以下Java代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>&lt;null/&gt;</code>元素处理<code>null</code>值。以下清单显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ExampleBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">email</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;null</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置等同于以下Java代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail（ <span class="predefined-constant">null</span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-p-namespace"><a class="anchor" href="#beans-p-namespace"></a>带有p命名空间的XML快捷方式</h5>
<div class="paragraph">
<p>p-namespace允许您使用<code>bean</code>元素的属性（而不是嵌套的<code>&lt;property/&gt;</code>元素）来描述属性值协作bean，或两者。</p>
</div>
<div class="paragraph">
<p>Spring支持<a href="#xsd-schemas">具有命名空间的</a>可扩展配置格式，这些<a href="#xsd-schemas">命名空间</a>基于XML Schema定义。本章中讨论的<code>beans</code>配置格式在XML Schema文档中定义。但是，p-namespace未在XSD文件中定义，仅存在于Spring的核心中。</p>
</div>
<div class="paragraph">
<p>以下示例显示了两个XML片段（第一个使用标准XML格式，第二个使用p命名空间），它们解析为相同的结果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：p</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / p</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classic</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。ExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">email</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someone@somewhere.com</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">p-namespace</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.example。ExampleBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：email</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someone@somewhere.com</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例显示了bean定义中名为<code>email</code>的p命名空间中的属性。这告诉Spring包含一个属性声明。如前所述，p命名空间没有架构定义，因此您可以将属性的名称设置为属性名称。</p>
</div>
<div class="paragraph">
<p>下一个示例包括另外两个bean定义，它们都引用了另一个bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：p</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / p</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">john-classic</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。Person</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">John Doe</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">spouse</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jane</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">john-modern</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com。例。人</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">John Doe</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：spouse-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jane</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jane</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.example。Person</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Jane Doe</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此示例不仅包含使用p命名空间的属性值，还使用特殊格式来声明属性引用。第一个bean定义使用<code>&lt;property name="spouse" ref="jane"/&gt;</code>来创建从bean <code>john</code>到bean <code>jane</code>的引用，而第二个bean定义使用<code>p:spouse-ref="jane"</code>作为要执行的属性完全相同的事情。在这种情况下， <code>spouse</code>是属性名称，而<code>-ref</code>部分表示这不是直接值，而是对另一个bean的引用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">p命名空间不如标准XML格式灵活。例如，声明属性引用的格式与以<code>Ref</code>结尾的属性冲突，而标准XML格式则不然。我们建议您仔细选择您的方法并将其传达给您的团队成员，以避免生成同时使用所有三种方法的XML文档。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-c-namespace"><a class="anchor" href="#beans-c-namespace"></a>带有c命名空间的XML快捷方式</h5>
<div class="paragraph">
<p>类似于<a href="#beans-p-namespace">带有p-namespace</a>的<a href="#beans-p-namespace">XML Shortcut，</a> Spring 3.1中引入的c-namespace允许内联属性来配置构造函数参数，而不是嵌套的<code>constructor-arg</code>元素。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>c:</code> namespace来执行与<a href="#beans-constructor-injection">基于Constructor的依赖注入相同的操作</a> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：c</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / c</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thingOne</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyThingTwo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingTwo</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyThingThree</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 传统声明 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingOne</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyThingOne</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingTwo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingThree</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">something@somewhere.com</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ -  c-名称空间声明 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thingOne</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyThingOne</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：thingTwo-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingTwo</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：thingThree-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingThree</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：email</span> = <span class="string"><span class="delimiter">”</span> <span class="content">something@somewhere.com</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>c:</code>名称空间使用与<code>p:</code> one（bean引用的尾随<code>-ref</code> ）相同的约定，用于按名称设置构造函数参数。类似地，它需要声明，即使它没有在XSD架构中定义（它存在于Spring核心内）。</p>
</div>
<div class="paragraph">
<p>对于构造函数参数名称不可用的罕见情况（通常如果字节码是在没有调试信息的情况下编译的），您可以使用回退到参数索引，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  c-namespace index declaration  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thingOne</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyThingOne</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：_0-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingTwo</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：_1-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thingThree</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于XML语法，索引表示法需要存在前导<code>_</code> ，因为XML属性名称不能以数字开头（即使某些IDE允许它）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>实际上，构造函数解析<a href="#beans-factory-ctor-arguments-resolution">机制</a>在匹配参数方面非常有效，因此除非您确实需要，否则我们建议在整个配置中使用名称表示法。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-compound-property-names"><a class="anchor" href="#beans-compound-property-names"></a>复合属性名称</h5>
<div class="paragraph">
<p>只要除最终属性名称之外的路径的所有组件都不为<code>null</code>您可以在设置bean属性时使用复合或嵌套属性名称。考虑以下bean定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">something</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thing。ThingOne</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fred.bob.sammy</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">123</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<code>something</code> Bean有一个<code>fred</code>财产，其中有一个<code>bob</code>的财产，其中有一个<code>sammy</code>属性，那最后<code>sammy</code>属性被设置为值<code>123</code> 。为了使其工作，在构造bean之后， <code>something</code>的<code>fred</code>属性和<code>fred</code>的<code>bob</code>属性不能为<code>null</code> 。否则，抛出<code>NullPointerException</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-dependson"><a class="anchor" href="#beans-factory-dependson"></a> 1.4.3。使用<code>depends-on</code></h4>
<div class="paragraph">
<p>如果bean是另一个bean的依赖项，那通常意味着将一个bean设置为另一个bean的属性。通常，您可以使用基于XML的配置元数据中的<a href="#beans-ref-element"><code>&lt;ref/&gt;</code>元素</a>来完成此操作。但是，有时bean之间的依赖关系不那么直接。例如，需要触发类中的静态初始化程序，例如数据库驱动程序注册。在初始化使用此元素的bean之前， <code>depends-on</code>属性可以显式强制初始化一个或多个bean。以下示例使用<code>depends-on</code>属性表示对单个bean的依赖关系：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">beanOne</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ExampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">depends-on</span> = <span class="string"><span class="delimiter">“</span> <span class="content">manager</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">manager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ManagerBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要表示对多个bean的依赖关系，请提供bean名称列表作为<code>depends-on</code>属性的值（逗号，空格和分号是有效的分隔符）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">beanOne</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ExampleBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">depends-on</span> = <span class="string"><span class="delimiter">“</span> <span class="content">manager，accountDao</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">manager</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">manager</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">manager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ManagerBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyjdbc。JdbcAccountDao</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意：bean定义中的<code>depends-on</code>属性既可以指定初始化时间依赖关系，也可以指定仅限<a href="#beans-factory-scopes-singleton">单例</a> bean的相应销毁时间依赖关系。在给定的bean本身被销毁之前，首先销毁定义与给定bean的<code>depends-on</code>关系的从属bean。因此， <code>depends-on</code>也可以控制关​​闭顺序。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-lazy-init"><a class="anchor" href="#beans-factory-lazy-init"></a> 1.4.4。懒惰初始化的豆类</h4>
<div class="paragraph">
<p>默认情况下， <code>ApplicationContext</code>实现会急切地创建和配置所有<a href="#beans-factory-scopes-singleton">单例</a> bean，作为初始化过程的一部分。通常，这种预先实例化是可取的，因为配置或周围环境中的错误是立即发现的，而不是几小时甚至几天后。如果不希望出现这种情况，可以通过将bean定义标记为延迟初始化来阻止单例bean的预实例化。延迟初始化的bean告诉IoC容器在第一次请求时创建bean实例，而不是在启动时创建。</p>
</div>
<div class="paragraph">
<p>在XML中，此行为由<code>&lt;bean/&gt;</code>元素上的<code>lazy-init</code>属性控制，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lazy</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。ExpensiveToCreateBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">lazy-init</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">not.lazy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.something。AnotherBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当<code>ApplicationContext</code>使用前面的配置时，在<code>ApplicationContext</code>启动时，不会急切地预先实例化<code>lazy</code> bean，而是急切地预先实例化<code>not.lazy</code> bean。</p>
</div>
<div class="paragraph">
<p>但是，当延迟初始化的bean是不是延迟初始化的单例bean的依赖项时， <code>ApplicationContext</code>会在启动时创建延迟初始化的bean，因为它必须满足单例的依赖关系。惰性初始化的bean被注入到其他地方的单例bean中，而不是懒惰初始化的。</p>
</div>
<div class="paragraph">
<p>您还可以使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性在容器级别控制延迟初始化，以下示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-lazy-init</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 没有bean预先实例化...  - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-autowire"><a class="anchor" href="#beans-factory-autowire"></a> 1.4.5。自动化协作者</h4>
<div class="paragraph">
<p>Spring容器可以自动连接协作bean之间的关系。您可以通过检查<code>ApplicationContext</code>的内容让Spring自动为您的bean解析协作者（其他bean）。自动装配具有以下优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动装配可以显着减少指定属性或构造函数参数的需要。（ <a href="#beans-child-bean-definitions">在本章其他地方讨论的</a>其他机制，如bean模板<a href="#beans-child-bean-definitions">，</a>在这方面也很有价值。）</p>
</li>
<li>
<p>自动装配可以随着对象的发展更新配置。例如，如果需要向类添加依赖项，则可以自动满足该依赖项，而无需修改配置。因此，自动装配在开发期间尤其有用，而不会在代码库变得更稳定时否定切换到显式布线的选项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用基于XML的配置元数据（请参阅<a href="#beans-factory-collaborators">依赖注入</a> ）时，可以使用<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性为bean定义指定autowire模式。自动装配功能有四种模式。您指定每个bean的自动装配，因此可以选择要自动装配的那些。下表描述了四种自动装配模式：</p>
</div>
<table id="beans-factory-autowiring-modes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表2。自动装配模式</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">模式</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>没有</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认）无自动装配。Bean引用必须由<code>ref</code>元素定义。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>按名字</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">按属性名称自动装配。Spring查找与需要自动装配的属性同名的bean。例如，如果bean定义按名称设置为autowire并且它包含<code>master</code>属性（即，它具有<code>setMaster(..)</code>方法），则Spring会查找名为<code>master</code>的bean定义并使用它来设置属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byType的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果容器中只存在一个属性类型的bean，则允许自动装配属性。如果存在多个，则抛出致命异常，这表示您不能对该bean使用<code>byType</code>自动装配。如果没有匹配的bean，则不会发生任何事情（未设置该属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>构造函数</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似于<code>byType</code>但适用于构造函数参数。如果容器中没有构造函数参数类型的一个bean，则会引发致命错误。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用<code>byType</code>或<code>constructor</code>自动装配模式，您可以连接数组和类型集合。在这种情况下，提供容器内与预期类型匹配的所有autowire候选者以满足依赖性。如果预期的键类型是<code>String</code>则可以自动装配强类型的<code>Map</code>实例。自动装配的<code>Map</code>实例的值由与预期类型匹配的所有bean实例组成， <code>Map</code>实例的键包含相应的bean名称。</p>
</div>
<div class="paragraph">
<p>您可以将autowire行为与依赖关系检查结合起来，这是在自动装配完成后执行的。</p>
</div>
<div class="sect4">
<h5 id="beans-autowired-exceptions"><a class="anchor" href="#beans-autowired-exceptions"></a>自动装配的局限和缺点</h5>
<div class="paragraph">
<p>自动装配在项目中一致使用时效果最佳。如果一般不使用自动装配，那么开发人员使用它来连接一个或两个bean定义可能会让人感到困惑。</p>
</div>
<div class="paragraph">
<p>考虑自动装配的局限和缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>property</code>和<code>constructor-arg</code>设置中的显式依赖项始终覆盖自动装配。您不能自动装配简单属性，例如基元， <code>Strings</code>和<code>Classes</code> （以及此类简单属性的数组）。这种限制是按设计的。</p>
</li>
<li>
<p>自动装配不如显式布线精确。虽然如前面的表中所述，Spring谨慎地避免在可能产生意外结果的模糊性的情况下进行猜测。您不再明确记录Spring管理对象之间的关系。</p>
</li>
<li>
<p>可能无法为可能从Spring容器生成文档的工具提供接线信息。</p>
</li>
<li>
<p>容器中的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。对于数组，集合或<code>Map</code>实例，这不一定是个问题。但是，对于期望单个值的依赖关系，这种模糊性不是任意解决的。如果没有可用的唯一bean定义，则抛出异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在后一种情况下，您有几种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>放弃自动装配以支持显式布线。</p>
</li>
<li>
<p>通过将<code>autowire-candidate</code>属性设置为<code>false</code> ，避免对bean定义进行<code>autowire-candidate</code> ，如<a href="#beans-factory-autowire-candidate">下一节所述</a> 。</p>
</li>
<li>
<p>通过将其<code>&lt;bean/&gt;</code>元素的<code>primary</code>属性设置为<code>true</code> ，将单个bean定义指定为主要候选者。</p>
</li>
<li>
<p>实现基于注释的配置可用的更细粒度控制，如<a href="#beans-annotation-config">基于注释的容器配置中所述</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-autowire-candidate"><a class="anchor" href="#beans-factory-autowire-candidate"></a>从自动装配中排除Bean</h5>
<div class="paragraph">
<p>在每个bean的基础上，您可以从自动装配中排除bean。在Spring的XML格式中，将<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性设置为<code>false</code> 。容器使特定的bean定义对自动装配基础结构不可用（包括注释样式配置，如<a href="#beans-autowired-annotation"><code>@Autowired</code></a> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>autowire-candidate</code>属性旨在仅影响基于类型的自动装配。它不会影响名称的显式引用，即使指定的bean未标记为autowire候选，也会解析它。因此，如果名称匹配，则按名称自动装配会注入bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以根据针对bean名称的模式匹配来限制autowire候选者。顶级<code>&lt;beans/&gt;</code>元素在其<code>default-autowire-candidates</code>属性中接受一个或多个模式。例如，要将autowire候选状态限制为名称以<code>Repository</code>结尾的任何bean，请提供值<code>*Repository</code> 。要提供多个模式，请在逗号分隔的列表中定义它们。bean定义的<code>autowire-candidate</code>属性的显式值<code>true</code>或<code>false</code>始终优先。对于此类bean，模式匹配规则不适用。</p>
</div>
<div class="paragraph">
<p>这些技术对于您永远不希望通过自动装配注入其他bean的bean非常有用。这并不意味着使用自动装配本身不能配置排除的bean。相反，bean本身不是自动装配其他bean的候选者。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-method-injection"><a class="anchor" href="#beans-factory-method-injection"></a> 1.4.6。方法注入</h4>
<div class="paragraph">
<p>在大多数应用程序场景中，容器中的大多数bean都是<a href="#beans-factory-scopes-singleton">单例</a> 。当单例bean需要与另一个单例bean协作或非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。当bean生命周期不同时会出现问题。假设单例bean A需要使用非单例（原型）bean B，可能是在A上的每个方法调用上。容器只创建一次单独的bean A，因此只有一次机会来设置属性。每次需要时，容器都不能为bean A提供bean B的新实例。</p>
</div>
<div class="paragraph">
<p>解决方案是放弃一些控制反转。您可以通过实现<code>ApplicationContextAware</code>接口<a href="#beans-factory-aware">使bean A了解容器</a> ，并通过<a href="#beans-factory-aware">对容器</a> <a href="#beans-factory-client">进行<code>getBean("B")</code>调用，</a>每次bean A需要时都要求（通常是新的）bean B实例。以下示例显示了此方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//一个使用有状态Command样式类来执行某些处理</span> <span class="keyword">包</span> <span class="namespace">feana.apple的类</span> ; <span class="comment">// Spring-API导入</span> <span class="keyword">导入</span> <span class="include">org.springframework.beans。BeansException</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContextAware</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">CommandManager</span> <span class="directive">实现</span> ApplicationContextAware { <span class="directive">private</span> ApplicationContext applicationContext; <span class="directive">public</span> <span class="predefined-type">Object</span> process（ <span class="predefined-type">Map</span> commandState）{ <span class="comment">//获取相应Command</span> Command命令<span class="comment">的新实例</span> = createCommand（）; <span class="comment">//在（希望是全新的）命令实例</span> command.setState（commandState） <span class="comment">上设置状态</span> ; <span class="keyword">return</span> command.execute（）; } <span class="directive">protected</span>命令createCommand（）{ <span class="comment">//注意Spring API依赖！</span>
        <span class="keyword">返回</span> <span class="local-variable">此</span> .applicationContext.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">command</span> <span class="delimiter">”</span></span> ，Command.class）; <span class="directive">public</span> <span class="type">void</span> setApplicationContext（ApplicationContext applicationContext） <span class="directive">抛出</span> BeansException { <span class="local-variable">this</span> .applicationContext = applicationContext; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的内容是不可取的，因为业务代码知道并耦合到Spring Framework。方法注入是Spring IoC容器的一个高级功能，可以让您干净地处理这个用例。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>您可以在<a href="https://spring.io/blog/2004/08/06/method-injection/">此博客条目中</a>阅读有关Method Injection的动机的更多信息。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lookup-method-injection"><a class="anchor" href="#beans-factory-lookup-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>Lookup方法注入是容器覆盖容器管理bean上的方法并返回容器中另一个命名bean的查找结果的能力。查找通常涉及原型bean，如上<a href="#beans-factory-method-injection">一节</a>中描述的场景。Spring Framework通过使用CGLIB库中的字节码生成来动态生成覆盖该方法的子类来实现此方法注入。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>为了使这个动态子类工作，Spring bean容器子类不能是<code>final</code>类，要覆盖的方法也不能是<code>final</code> 。</p>
</li>
<li>
<p>单元测试是有一类<code>abstract</code>方法需要你对自己继承的类及提供的存根实现<code>abstract</code>方法。</p>
</li>
<li>
<p>组件扫描也需要具体的方法，这需要具体的类来获取。</p>
</li>
<li>
<p>另一个关键限制是查找方法不适用于工厂方法，特别是配置类中的<code>@Bean</code>方法，因为在这种情况下，容器不负责创建实例，因此无法创建运行时生成子类在飞行中。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于前面代码片段中的<code>CommandManager</code>类，Spring容器动态地覆盖<code>createCommand()</code>方法的实现。<code>CommandManager</code>类没有任何Spring依赖项，因为重写的示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">fiona.apple</span> ; <span class="comment">//没有更多春季进口！</span>

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> { <span class="directive">public</span> <span class="predefined-type">Object</span> process（ <span class="predefined-type">Object</span> commandState）{ <span class="comment">//获取相应命令接口的新实例</span>命令command = createCommand（）; <span class="comment">//在（希望是全新的）命令实例</span> command.setState（commandState） <span class="comment">上设置状态</span> ; <span class="keyword">return</span> command.execute（）; } <span class="comment">//好吧......但是这个方法的实现在哪里？</span>
    <span class="directive">protected</span> <span class="directive">abstract</span>命令createCommand（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在包含要注入的方法的客户机类（在本例中为<code>CommandManager</code> ）中，要注入的方法需要以下形式的签名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;公共</span> <span class="error">|</span> <span class="attribute-name">protected</span> <span class="tag">&gt;</span> [abstract] <span class="tag">&lt;return-type&gt;</span> theMethodName（无参数）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果方法是<code>abstract</code> ，则动态生成的子类实现该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 作为原型部署的有状态bean（非单例） - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myCommand</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fiona.apple。AsyncCommand</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 根据需要在这里注入依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ -  commandProcessor使用statefulCommandHelper  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">commandManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fiona.apple。CommandManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lookup-method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">createCommand</span> <span class="delimiter">“</span></span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myCommand</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>标识为<code>commandManager</code>的bean在需要<code>myCommand</code> bean的新实例时调用自己的<code>createCommand()</code>方法。如果实际需要，您必须小心将<code>myCommand</code> bean部署为原型。如果它是<a href="#beans-factory-scopes-singleton">单例</a> ，则每次都返回<code>myCommand</code> bean的相同实例。</p>
</div>
<div class="paragraph">
<p>或者，在基于注释的组件模型中，您可以通过<code>@Lookup</code>注释声明查找方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> { <span class="directive">public</span> <span class="predefined-type">Object</span> process（ <span class="predefined-type">Object</span> commandState）{command command = createCommand（）; command.setState（commandState）; <span class="keyword">return</span> command.execute（）; } <span class="annotation">@Lookup</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">myCommand</span> <span class="delimiter">”</span></span> ） <span class="directive">protected</span> <span class="directive">abstract</span>命令createCommand（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，更具惯用性，您可以依赖于针对查找方法的声明返回类型解析目标bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> { <span class="directive">public</span> <span class="predefined-type">Object</span> process（ <span class="predefined-type">Object</span> commandState）{MyCommand command = createCommand（）; command.setState（commandState）; <span class="keyword">return</span> command.execute（）; } <span class="annotation">@Lookup</span> <span class="directive">protected</span> <span class="directive">abstract</span> MyCommand createCommand（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您通常应该使用具体的存根实现来声明这种带注释的查找方法，以使它们与Spring的组件扫描规则兼容，其中默认情况下抽象类被忽略。此限制不适用于显式注册或显式导入的bean类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>访问不同范围的目标bean的另一种方法是<code>ObjectFactory</code> / <code>Provider</code>注入点。将<a href="#beans-factory-scopes-other-injection">Scoped Beans视为依赖关系</a> 。</p>
</div>
<div class="paragraph">
<p>您可能还会发现<code>ServiceLocatorFactoryBean</code> （在<code>org.springframework.beans.factory.config</code>包中）很有用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-arbitrary-method-replacement"><a class="anchor" href="#beans-factory-arbitrary-method-replacement"></a>任意方法替换</h5>
<div class="paragraph">
<p>与查找方法注入相比，一种不太有用的方法注入形式是能够使用另一个方法实现替换托管bean中的任意方法。您可以安全地跳过本节的其余部分，直到您确实需要此功能。</p>
</div>
<div class="paragraph">
<p>使用基于XML的配置元数据，您可以使用被<code>replaced-method</code>元素将已有的方法实现替换为已部署的bean。考虑以下类，它有一个我们想要覆盖的名为<code>computeValue</code>的方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyValueCalculator</span> { <span class="directive">public</span> <span class="predefined-type">String</span> computeValue（ <span class="predefined-type">String</span> input）{ <span class="comment">//一些真实代码......</span>} <span class="comment">//其他一些方法......</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实现<code>org.springframework.beans.factory.support.类<code>org.springframework.beans.factory.support.MethodReplacer</code>接口提供了新的方法定义，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/ ** *意味着用于覆盖MyValueCalculator * /</span> <span class="directive">public</span> <span class="type">类中</span> <span class="comment">的现有computeValue（String）*实现</span> <span class="class">ReplacementComputeValue</span> <span class="directive">实现</span> MethodReplacer { <span class="directive">public</span> <span class="predefined-type">Object</span> reimplement（ <span class="predefined-type">Object</span> o， <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="comment">// get the输入值，使用它，并返回计算结果</span> <span class="predefined-type">String</span> input =（ <span class="predefined-type">String</span> ）args [ <span class="integer">0</span> ]; ...回来......; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>部署原始类并指定方法覆盖的bean定义类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myValueCalculator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyzMyValueCalculator</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 任意方法替换 - &gt;</span> <span class="tag">&lt;被替换方法</span> <span class="attribute-name">名称</span> = <span class="string"><span class="delimiter">”</span> <span class="content">computeValue</span> <span class="delimiter">“</span></span> <span class="attribute-name">replacer</span> = <span class="string"><span class="delimiter">”</span> <span class="content">replacementComputeValue</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;arg-type&gt;</span>字符串<span class="tag">&lt;/ arg-type&gt;</span> <span class="tag">&lt;/</span> <span class="string"><span class="content">replacement</span></span> <span class="tag">-method&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">replacementComputeValue</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">abcReplacementComputeValue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<code>&lt;replaced-method/&gt;</code>元素中使用一个或多个<code>&lt;arg-type/&gt;</code>元素来指​​示被覆盖的方法的方法签名。仅当方法重载且类中存在多个变体时，才需要参数的签名。为方便起见，参数的类型字符串可以是完全限定类型名称的子字符串。例如，以下所有内容都匹配<code>java.lang.String</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">java.lang中。String <span class="predefined-type">String</span> Str</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为参数的数量通常足以区分每个可能的选择，所以通过让您只键入与参数类型匹配的最短字符串，此快捷方式可以节省大量的输入。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-scopes"><a class="anchor" href="#beans-factory-scopes"></a> 1.5。Bean范围</h3>
<div class="paragraph">
<p>创建bean定义时，可以创建用于创建该bean定义所定义的类的实际实例的配方。bean定义是一个配方的想法很重要，因为它意味着，与一个类一样，您可以从一个配方创建许多对象实例。</p>
</div>
<div class="paragraph">
<p>您不仅可以控制要插入到从特定bean定义创建的对象中的各种依赖项和配置值，还可以控制从特定bean定义创建的对象的范围。这种方法功能强大且灵活，因为您可以选择通过配置创建的对象的范围，而不必在Java类级别烘焙对象的范围。可以将Bean定义为部署在多个范围之一中。Spring Framework支持六个范围，其中四个范围仅在您使用支持Web的<code>ApplicationContext</code>时才可用。您还可以创建<a href="#beans-factory-scopes-custom">自定义范围。</a></p>
</div>
<div class="paragraph">
<p>下表描述了支持的范围：</p>
</div>
<table id="beans-factory-scopes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表3。Bean范围</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">范围</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-singleton">独生子</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认）将单个bean定义范围限定为每个Spring IoC容器的单个对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-prototype">原型</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为任意数量的对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-request">请求</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。仅在Web感知Spring <code>ApplicationContext</code>的上下文中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-session">会议</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为HTTP <code>Session</code>的生命周期。仅在Web感知Spring <code>ApplicationContext</code>的上下文中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-application">应用</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为<code>ServletContext</code>的生命周期。仅在Web感知Spring <code>ApplicationContext</code>的上下文中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#websocket-stomp-websocket-scope">的WebSocket</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为<code>WebSocket</code>的生命周期。仅在Web感知Spring <code>ApplicationContext</code>的上下文中有效。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring 3.0开始，线程范围可用，但默认情况下未注册。有关更多信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a>的文档。有关如何注册此范围或任何其他自定义范围的说明，请参阅<a href="#beans-factory-scopes-custom-using">使用自定义范围</a> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-singleton"><a class="anchor" href="#beans-factory-scopes-singleton"></a> 1.5.1。单身范围</h4>
<div class="paragraph">
<p>只管理单个bean的一个共享实例，并且对具有与该bean定义匹配的ID或ID的bean的所有请求都会导致Spring容器返回一个特定的bean实例。</p>
</div>
<div class="paragraph">
<p>换句话说，当您定义一个bean定义并且它的范围是一个单例时，Spring IoC容器只创建该bean定义定义的对象的一个​​实例。此单个实例存储在此类单例bean的缓存中，并且该命名Bean的所有后续请求和引用都将返回缓存对象。下图显示了单例范围的工作原理：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/singleton.png" alt="独生子">
</div>
</div>
<div class="paragraph">
<p>Spring的单例bean概念不同于Gang of Four（GoF）模式书中定义的单例模式。GoF单例对一个对象的范围进行硬编码，使得每个ClassLoader创建一个且只有一个特定类的实例。Spring单例的范围最好描述为每容器和每个bean。这意味着，如果在单个Spring容器中为特定类定义一个bean，则Spring容器将创建该bean定义所定义的类的唯一一个实例。单例范围是Spring中的默认范围。要将bean定义为XML中的单例，您可以定义bean，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。DefaultAccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 以下是等效的，虽然是冗余的（单例范围是默认值） - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.something。DefaultAccountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">singleton</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-prototype"><a class="anchor" href="#beans-factory-scopes-prototype"></a> 1.5.2。原型范围</h4>
<div class="paragraph">
<p>bean部署的非单例原型范围导致每次发出对该特定bean的请求时都创建新的bean实例。也就是说，bean被注入另一个bean，或者通过对容器的<code>getBean()</code>方法调用来请求它。通常，您应该对所有有状态bean使用原型范围，对无状态bean使用单例范围。</p>
</div>
<div class="paragraph">
<p>下图说明了Spring原型范围：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/prototype.png" alt="原型">
</div>
</div>
<div class="paragraph">
<p>（数据访问对象（DAO）通常不配置为原型，因为典型的DAO不保持任何会话状态。我们更容易重用单例图的核心。）</p>
</div>
<div class="paragraph">
<p>以下示例将bean定义为XML中的原型：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。DefaultAccountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与其他范围相比，Spring不管理原型bean的完整生命周期。容器实例化，配置和组装原型对象并将其交给客户端，而没有该原型实例的进一步记录。因此，尽管无论范围如何都在所有对象上调用初始化生命周期回调方法，但在原型的情况下，不会调用已配置的销毁生命周期回调。客户端代码必须清理原型范围的对象并释放原型bean所拥有的昂贵资源。要让Spring容器释放原型范围内的bean所拥有的资源，请尝试使用自定义<a href="#beans-factory-extension-bpp">bean后处理器</a> ，它包含对需要清理的bean的引用。</p>
</div>
<div class="paragraph">
<p>在某些方面，Spring容器关于原型范围bean的角色是Java <code>new</code>运算符的替代品。超过该点的所有生命周期管理必须由客户端处理。（有关Spring容器中bean的生命周期的详细信息，请参阅<a href="#beans-factory-lifecycle">Lifecycle Callbacks</a> 。）</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-sing-prot-interaction"><a class="anchor" href="#beans-factory-scopes-sing-prot-interaction"></a> 1.5.3。具有原型bean依赖关系的单例Bean</h4>
<div class="paragraph">
<p>当您使用具有依赖于原型bean的单例作用域bean时，请注意在实例化时解析依赖项。因此，如果依赖项将原型范围的bean注入到单例范围的bean中，则会实例化一个新的原型bean，然后将依赖注入到单例bean中。原型实例是唯一提供给单例范围bean的实例。</p>
</div>
<div class="paragraph">
<p>但是，假设您希望单例范围的bean在运行时重复获取原型范围的bean的新实例。您不能将原型范围的bean依赖注入到您的单例bean中，因为当Spring容器实例化单例bean并解析并注入其依赖项时，该注入只发生一次。如果您需要在运行时多次使用原型bean的新实例，请参阅<a href="#beans-factory-method-injection">方法注入</a></p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-other"><a class="anchor" href="#beans-factory-scopes-other"></a> 1.5.4。请求，会话，应用程序和WebSocket范围</h4>
<div class="paragraph">
<p>只有在使用Web感知的Spring <code>ApplicationContext</code>实现（例如<code>XmlWebApplicationContext</code> ）时，才能使用<code>request</code> ， <code>session</code> ， <code>application</code>和<code>websocket</code>范围。如果将这些作用域与常规的Spring IoC容器（例如<code>ClassPathXmlApplicationContext</code> ，则会<code>IllegalStateException</code>抱怨未知bean作用域的<code>IllegalStateException</code> 。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-web-configuration"><a class="anchor" href="#beans-factory-scopes-other-web-configuration"></a>初始Web配置</h5>
<div class="paragraph">
<p>要在<code>request</code> ， <code>session</code> ， <code>application</code>和<code>websocket</code>级别（Web范围的bean）支持bean的范围，在定义bean之前需要一些小的初始配置。（标准范围不需要此初始设置： <code>singleton</code>和<code>prototype</code> 。）</p>
</div>
<div class="paragraph">
<p>如何完成此初始设置取决于您的特定Servlet环境。</p>
</div>
<div class="paragraph">
<p>如果您在Spring Web MVC中访问scoped bean，实际上是在Spring <code>DispatcherServlet</code>处理的请求中，则无需进行特殊设置。
<code>DispatcherServlet</code>已经公开了所有相关状态。</p>
</div>
<div class="paragraph">
<p>如果您使用Servlet 2.5 Web容器，并且在Spring的<code>DispatcherServlet</code>之外处理请求（例如，使用JSF或Struts时），则需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code> 。对于Servlet 3.0+，可以使用<code>WebApplicationInitializer</code>接口以编程方式完成此操作。或者，或者对于旧容器，将以下声明添加到Web应用程序的<code>web.xml</code>文件中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span> ...
    <span class="tag">&lt;listener&gt;</span> <span class="tag">&lt;listener-class&gt;</span> org.springframework.web.context.request.RequestContextListener <span class="tag">&lt;/ listener-class&gt;</span> <span class="tag">&lt;/ listener&gt;</span> ...
<span class="tag">&lt;/ web的应用&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果您的侦听器设置存在问题，请考虑使用Spring的<code>RequestContextFilter</code> 。过滤器映射取决于周围的Web应用程序配置，因此您必须根据需要进行更改。以下清单显示了Web应用程序的过滤器部分：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span> ...
    <span class="tag">&lt;filter&gt;</span> <span class="tag">&lt;filter-name&gt;</span> requestContextFilter <span class="tag">&lt;/ filter-name&gt;</span> <span class="tag">&lt;filter-class&gt;</span> org.springframework.web.filter。RequestContextFilter <span class="tag">&lt;/ filter-class&gt;</span> <span class="tag">&lt;/ filter&gt;</span> <span class="tag">&lt;filter-mapping&gt;</span> <span class="tag">&lt;filter-name&gt;</span> requestContextFilter <span class="tag">&lt;/ filter-name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> / * <span class="tag">&lt;/ url-pattern&gt;</span> <span class="tag">&lt;/ filter-mapping&gt;</span> ...
<span class="tag">&lt;/ web的应用&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code> ， <code>RequestContextListener</code>和<code>RequestContextFilter</code>都完全相同，即将HTTP请求对象绑定到为该请求提供服务的<code>Thread</code> 。这使得请求和会话范围的bean可以在调用链的下游进一步使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-request"><a class="anchor" href="#beans-factory-scopes-request"></a>请求范围</h5>
<div class="paragraph">
<p>考虑bean定义的以下XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">loginAction</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。LoginAction</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">request</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring容器通过对每个HTTP请求使用<code>loginAction</code> bean定义来创建<code>LoginAction</code> bean的新实例。也就是说， <code>loginAction</code> bean的范围是HTTP请求级别。您可以根据需要更改创建的实例的内部状态，因为从同一<code>loginAction</code> bean定义创建的其他实例在状态中看不到这些更改。它们特别针对个人要求。当请求完成处理时，将放弃作用于请求的bean。</p>
</div>
<div class="paragraph">
<p>使用注释驱动的组件或Java配置时，可以使用<code>@RequestScope</code>注释将组件分配给<code>request</code>范围。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@RequestScope</span></strong> <span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">LoginAction</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-session"><a class="anchor" href="#beans-factory-scopes-session"></a>会话范围</h5>
<div class="paragraph">
<p>考虑bean定义的以下XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userPreferences</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。UserPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">session</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring容器通过在单个HTTP <code>Session</code>的生存<code>userPreferences</code>使用<code>userPreferences</code> bean定义来创建<code>UserPreferences</code> bean的新实例。换句话说， <code>userPreferences</code> bean在HTTP <code>Session</code>级别有效地作用域。与请求范围的bean一样，您可以根据需要更改创建的实例的内部状态，因为知道同样使用从同一<code>userPreferences</code> bean定义创建的实例的其他HTTP <code>Session</code>实例在状态中看不到这些更改，因为它们特定于单个HTTP <code>Session</code> 。当HTTP <code>Session</code>被最终被废弃，范围限定于特定的HTTP豆<code>Session</code>也丢弃。</p>
</div>
<div class="paragraph">
<p>使用注释驱动的组件或Java配置时，可以使用<code>@SessionScope</code>批注将组件分配给<code>session</code>范围。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@SessionScope</span></strong> <span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">UserPreferences</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-application"><a class="anchor" href="#beans-factory-scopes-application"></a>适用范围</h5>
<div class="paragraph">
<p>考虑bean定义的以下XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">appPreferences</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。AppPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">application</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring容器通过对整个Web应用程序使用<code>appPreferences</code> bean定义一次来创建<code>AppPreferences</code> bean的新实例。也就是说， <code>appPreferences</code> bean的作用域是<code>ServletContext</code>级别，并存储为常规的<code>ServletContext</code>属性。这有点类似于Spring单例bean，但在两个重要方面有所不同：它是每个<code>ServletContext</code>的单例，而不是每个Spring的'ApplicationContext'（在任何给定的Web应用程序中可能有几个），它实际上是暴露的，因此作为<code>ServletContext</code>属性可见。</p>
</div>
<div class="paragraph">
<p>使用注释驱动的组件或Java配置时，可以使用<code>@ApplicationScope</code>批注将组件分配给<code>application</code>范围。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@ApplicationScope</span></strong> <span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AppPreferences</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-injection"><a class="anchor" href="#beans-factory-scopes-other-injection"></a>作为依赖关系的Scoped Bean</h5>
<div class="paragraph">
<p>Spring IoC容器不仅管理对象（bean）的实例化，还管理协作者（或依赖关系）的连接。如果要将HTTP请求范围的bean注入（例如）另一个具有较长寿命范围的bean，则可以选择注入AOP代理来代替范围内的bean。也就是说，您需要注入一个代理对象，该对象公开与范围对象相同的公共接口，但也可以从相关范围（例如HTTP请求）检索真实目标对象，并将方法调用委托给真实对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您还可以在作为<code>singleton</code>作用域的bean之间使用<code>&lt;aop:scoped-proxy/&gt;</code> ，然后引用通过可序列化的中间代理，从而能够在反序列化时重新获取目标单例bean。</p>
</div>
<div class="paragraph">
<p>当针对范围<code>prototype</code>的bean声明<code>&lt;aop:scoped-proxy/&gt;</code>时，共享代理上的每个方法调用都会导致创建一个新的目标实例，然后将该呼叫转发到该目标实例。</p>
</div>
<div class="paragraph">
<p>此外，范围代理不是以生命周期安全的方式从较短范围访问bean的唯一方法。您还可以将您的注入点（即构造函数或setter参数或自动装配字段）声明为<code>ObjectFactory&lt;MyTargetBean&gt;</code> ，允许<code>getObject()</code>调用在每次需要时按需检索当前实例 - 而无需保留实例或单独存储它。</p>
</div>
<div class="paragraph">
<p>作为扩展变体，您可以声明<code>ObjectProvider&lt;MyTargetBean&gt;</code> ，它提供了几个额外的访问变体，包括<code>getIfAvailable</code>和<code>getIfUnique</code> 。</p>
</div>
<div class="paragraph">
<p>JSR-330的变体称为<code>Provider</code> ，与每个检索尝试的<code>Provider&lt;MyTargetBean&gt;</code>声明和相应的<code>get()</code>调用一起使用。有关JSR-330整体的更多详细信息，请参见<a href="#beans-standard-annotations">此处</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例中的配置只有一行，但了解“为什么”以及它背后的“如何”非常重要：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 作为代理公开的HTTP会话范围的bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userPreferences</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。UserPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">session</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 指示容器代理周围的bean  - &gt;</span> <span class="tag">&lt;aop：scoped-proxy</span> <span class="tag">/&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 用上面的bean注入代理的单例范围的bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。SimpleUserService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 对代理的userPreferences bean的引用 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>定义代理的行。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要创建此类代理，请将子<code>&lt;aop:scoped-proxy/&gt;</code>元素插入到作用域bean定义中（请参阅<a href="#beans-factory-scopes-other-injection-proxies">选择要创建的代理类型</a>和<a href="#xsd-schemas">基于XML架构的配置</a> ）。为什么在<code>request</code> ， <code>session</code>和自定义范围级别定义bean的定义需要<code>&lt;aop:scoped-proxy/&gt;</code>元素？考虑以下单例bean定义，并将其与您需要为上述范围定义的内容进行对比（请注意，以下<code>userPreferences</code> bean定义不完整）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userPreferences</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。UserPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">session</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.something。UserManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，单例bean（ <code>userManager</code> ）注入了对HTTP <code>Session</code> -scoped bean（ <code>userPreferences</code> ）的引用。这里的重点是<code>userManager</code> bean是一个单例：它每个容器只实例化一次，它的依赖项（在这种情况下只有一个， <code>userPreferences</code> bean）也只注入一次。这意味着<code>userManager</code> bean仅对完全相同的<code>userPreferences</code>对象（即最初注入它的对象）进行操作。</p>
</div>
<div class="paragraph">
<p>当将一个寿命较短的scoped bean注入一个寿命较长的scoped bean时，这不是你想要的行为（例如，将一个HTTP <code>Session</code> -scoped协作bean作为依赖注入singleton bean）。相反，您需要一个<code>userManager</code>对象，并且，对于HTTP <code>Session</code>的生命周期，您需要一个特定于HTTP <code>Session</code>的<code>userPreferences</code>对象。因此，容器创建一个对象，该对象公开与<code>UserPreferences</code>类（理想情况下是<code>UserPreferences</code>实例的对象）完全相同的公共接口，该对象可以从作用域机制（HTTP请求， <code>Session</code>等）获取真实的<code>UserPreferences</code>对象。 。容器将此代理对象注入<code>userManager</code> bean，该bean不知道此<code>UserPreferences</code>引用是代理。在此示例中，当<code>UserManager</code>实例在依赖注入的<code>UserPreferences</code>对象上调用方法时，它实际上是在代理上调用方法。代理然后取真正<code>UserPreferences</code>从对象（在这种情况下）的HTTP <code>Session</code>和代表方法调用到所检索的实际<code>UserPreferences</code>对象。</p>
</div>
<div class="paragraph">
<p>因此，在将<code>request-</code>和<code>session-scoped</code> bean注入协作对象时，您需要以下（正确和完整）配置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userPreferences</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。UserPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">session</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：scoped-proxy</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.something。UserManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-scopes-other-injection-proxies"><a class="anchor" href="#beans-factory-scopes-other-injection-proxies"></a>选择要创建的代理类型</h6>
<div class="paragraph">
<p>默认情况下，当Spring容器为使用<code>&lt;aop:scoped-proxy/&gt;</code>元素标记的bean创建代理时，将创建基于CGLIB的类代理。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">CGLIB代理只拦截公共方法调用！不要在这样的代理上调用非公共方法。它们不会委托给实际的作用域目标对象。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>或者，您可以通过为<code>&lt;aop:scoped-proxy/&gt;</code>元素的<code>proxy-target-class</code>属性的值指定<code>false</code>来配置Spring容器，以便为此类作用域bean创建基于JDK接口的标准<code>&lt;aop:scoped-proxy/&gt;</code> 。使用基于JDK接口的代理意味着您不需要在应用程序类路径中使用其他库来影响此类代理。但是，它还意味着scoped bean的类必须至少实现一个接口，并且注入scoped bean的所有协作者必须通过其中一个接口引用bean。以下示例显示基于接口的代理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  DefaultUserPreferences实现UserPreferences接口 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userPreferences</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.stuff。DefaultUserPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">session</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：scoped-proxy</span> <span class="attribute-name">proxy-target-class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">false</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.stuff。UserManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关选择基于类或基于接口的代理的更多详细信息，请参阅<a href="#aop-proxying">代理机制</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-custom"><a class="anchor" href="#beans-factory-scopes-custom"></a> 1.5.5。自定义范围</h4>
<div class="paragraph">
<p>bean范围机制是可扩展的。您可以定义自己的范围，甚至可以重新定义现有范围，尽管后者被认为是不好的做法，您无法覆盖内置的<code>singleton</code>和<code>prototype</code>范围。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-creating"><a class="anchor" href="#beans-factory-scopes-custom-creating"></a>创建自定义范围</h5>
<div class="paragraph">
<p>要将自定义作用域集成到Spring容器中，需要实现<code>org.springframework.beans.factory.config.Scope</code>界面，在本节中描述。有关如何实现自己的作用域的想法，请参阅Spring Framework本身和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code> Javadoc</a>提供的<code>Scope</code>实现，它解释了您需要更详细地实现的方法。</p>
</div>
<div class="paragraph">
<p><code>Scope</code>接口有四种方法可以从作用域中获取对象，将其从作用域中删除，然后将其销毁。</p>
</div>
<div class="paragraph">
<p>例如，会话范围实现返回会话范围的bean（如果它不存在，则该方法在将其绑定到会话以供将来参考之后返回该bean的新实例）。以下方法从基础范围返回对象：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> get（ <span class="predefined-type">String</span> name， <span class="predefined-type">ObjectFactory</span> objectFactory）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，会话范围实现从基础会话中删除会话范围的bean。应返回该对象，但如果找不到具有指定名称的对象，则可以返回null。以下方法从基础范围中删除对象：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">对象</span>删除（ <span class="predefined-type">字符串</span>名称）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下方法注册范围应在销毁时或在范围中指定的对象被销毁时应执行的回调：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerDestructionCallback（ <span class="predefined-type">String</span> name， <span class="predefined-type">Runnable</span> destructionCallback）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关销毁回调的更多信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback">Javadoc</a>或Spring作用域实现。</p>
</div>
<div class="paragraph">
<p>以下方法获取基础范围的对话标识符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> getConversationId（）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每个范围的标识符都不同。对于会话范围实现，此标识符可以是会话标识符。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-using"><a class="anchor" href="#beans-factory-scopes-custom-using"></a>使用自定义范围</h5>
<div class="paragraph">
<p>在编写并测试一个或多个自定义<code>Scope</code>实现之后，您需要让Spring容器知道您的新范围。以下方法是使用Spring容器注册新<code>Scope</code>的核心方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerScope（ <span class="predefined-type">String</span> scopeName，Scope scope）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此方法在<code>ConfigurableBeanFactory</code>接口上声明，该接口可通过Spring附带的大多数具体<code>ApplicationContext</code>实现上的<code>BeanFactory</code>属性获得。</p>
</div>
<div class="paragraph">
<p><code>registerScope(..)</code>方法的第一个参数是与范围关联的唯一名称。Spring容器本身中的这些名称的示例是<code>singleton</code>和<code>prototype</code> 。<code>registerScope(..)</code>方法的第二个参数是您希望注册和使用的自定义<code>Scope</code>实现的实际实例。</p>
</div>
<div class="paragraph">
<p>假设您编写自定义<code>Scope</code>实现，然后注册它，如下一个示例所示。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">下一个示例使用<code>SimpleThreadScope</code> ，它包含在Spring中，但默认情况下未注册。您自己的自定义<code>Scope</code>实现的说明是相同的。
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">范围threadScope = <span class="keyword">new</span> SimpleThreadScope（）; beanFactory.registerScope（ <span class="string"><span class="delimiter">“</span> <span class="content">thread</span> <span class="delimiter">”</span></span> ，threadScope）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以创建符合自定义<code>Scope</code>的作用域规则的bean定义，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thread</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用自定义<code>Scope</code>实现，您不仅限于范围的编程注册。您还可以使用<code>CustomScopeConfigurer</code>类以声明方式执行<code>Scope</code>注册，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans.factory.config。CustomScopeConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">scopes</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thread</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.context.support。SimpleThreadScope</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ entry&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thing2</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyThing2</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thread</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Rick</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：scoped-proxy</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thing1</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyThing1</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thing2</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">thing2</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当您在<code>FactoryBean</code>实现中放置<code>&lt;aop:scoped-proxy/&gt;</code>时，它是作用域的工厂bean本身，而不是从<code>getObject()</code>返回的对象。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-nature"><a class="anchor" href="#beans-factory-nature"></a> 1.6。定制Bean的本质</h3>
<div class="paragraph">
<p>Spring Framework提供了许多可用于自定义bean特性的接口。本节将它们分组如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-factory-lifecycle">生命周期回调</a></p>
</li>
<li>
<p><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p>
</li>
<li>
<p><a href="#aware-list">其他<code>Aware</code>接口</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beans-factory-lifecycle"><a class="anchor" href="#beans-factory-lifecycle"></a> 1.6.1。生命周期回调</h4>
<div class="paragraph">
<p>要与容器的bean生命周期管理进行交互，可以实现Spring <code>InitializingBean</code>和<code>DisposableBean</code>接口。容器为前者调用<code>afterPropertiesSet()</code> ，为后者调用<code>destroy()</code> ，让bean在初始化和销毁​​bean时执行某些操作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR-250 <code>@PostConstruct</code>和<code>@PreDestroy</code>注释通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean不会耦合到特定于Spring的接口。有关详细信息，请参阅<a href="#beans-postconstruct-and-predestroy-annotations">使用<code>@PostConstruct</code>和<code>@PreDestroy</code></a> 。</p>
</div>
<div class="paragraph">
<p>如果您不想使用JSR-250注释但仍想删除耦合，请考虑使用<code>init-method</code>和<code>destroy-method</code>对象定义元数据。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在内部，Spring Framework使用<code>BeanPostProcessor</code>实现来处理它可以找到的任何回调接口并调用适当的方法。如果您需要Spring默认提供的自定义功能或其他生命周期行为，您可以自己实现<code>BeanPostProcessor</code> 。有关更多信息，请参阅<a href="#beans-factory-extension">容器扩展点</a> 。</p>
</div>
<div class="paragraph">
<p>除了初始化和销毁​​回调之外，Spring管理的对象还可以实现<code>Lifecycle</code>接口，以便这些对象可以参与启动和关闭过程，这是由容器自身的生命周期驱动的。</p>
</div>
<div class="paragraph">
<p>本节描述了生命周期回调接口。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-initializingbean"><a class="anchor" href="#beans-factory-lifecycle-initializingbean"></a>初始化回调</h5>
<div class="paragraph">
<p><code>org.springframework.beans.factory.InitializingBean</code>接口允许bean在容器已在bean上设置所有必需属性后执行初始化工作。<code>InitializingBean</code>接口指定一个方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterPropertiesSet（） <span class="directive">抛出</span> <span class="exception">异常</span> ;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它会不必要地将代码耦合到Spring。或者，我们建议使用<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a>注释或指定POJO初始化方法。对于基于XML的配置元数据，可以使用<code>init-method</code>属性指定具有void无参数签名的方法的名称。随着Java的配置，你可以使用<code>initMethod</code>的属性<code>@Bean</code> 。请参阅<a href="#beans-java-lifecycle-callbacks">接收生命周期回调</a> 。请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleInitBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">init-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">init</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="directive">public</span> <span class="type">void</span> init（）{ <span class="comment">//做一些初始化工作</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例与以下示例（由两个列表组成）具有几乎完全相同的效果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleInitBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。AnotherExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">AnotherExampleBean</span> <span class="directive">实现</span> InitializingBean { <span class="directive">public</span> <span class="type">void</span> afterPropertiesSet（）{ <span class="comment">//做一些初始化工作</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，前面两个示例中的第二个没有将代码耦合到Spring。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-disposablebean"><a class="anchor" href="#beans-factory-lifecycle-disposablebean"></a>毁灭回调</h5>
<div class="paragraph">
<p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口允许bean在包含它的容器被销毁时获得回调。<code>DisposableBean</code>接口指定一个方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> destroy（） <span class="directive">抛出</span> <span class="exception">异常</span> ;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它会不必要地将代码耦合到Spring。或者，我们建议使用<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a>注释或指定bean定义支持的泛型方法。使用基于XML的配置元数据，您可以在<code>&lt;bean/&gt;</code>上使用<code>destroy-method</code>属性。随着Java的配置，可以使用<code>destroyMethod</code>的属性<code>@Bean</code> 。请参阅<a href="#beans-java-lifecycle-callbacks">接收生命周期回调</a> 。考虑以下定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleInitBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cleanup</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> { <span class="directive">public</span> <span class="type">void</span> cleanup（）{ <span class="comment">//做一些破坏工作（比如发布池化连接）</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的定义与以下定义几乎完全相同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleInitBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。AnotherExampleBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">AnotherExampleBean</span> <span class="directive">实现</span> DisposableBean { <span class="directive">public</span> <span class="type">void</span> destroy（）{ <span class="comment">//做一些破坏工作（比如发布池化连接）</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，前面两个定义中的第二个没有将代码耦合到Spring。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以为<code>&lt;bean&gt;</code>元素的<code>destroy-method</code>属性分配一个特殊的<code>(inferred)</code>值，该值指示Spring自动检测特定bean类的公共<code>close</code>或<code>shutdown</code>方法。（任何实现<code>java.lang.类<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code> ，因此将匹配）。您还可以在<code>&lt;beans&gt;</code>元素的<code>default-destroy-method</code>属性上设置此特殊<code>(inferred)</code>值，以将此行为应用于整组Bean（请参阅<a href="#beans-factory-lifecycle-default-init-destroy-methods">默认初始化和销毁​​方法</a> ）。请注意，这是Java配置的默认行为。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-default-init-destroy-methods"><a class="anchor" href="#beans-factory-lifecycle-default-init-destroy-methods"></a>默认初始化和销毁​​方法</h5>
<div class="paragraph">
<p>当您编写初始化和销毁​​不使用特定于Spring的<code>InitializingBean</code>和<code>DisposableBean</code>回调接口的方法回调时，通常会编写名称为<code>init()</code> ， <code>initialize()</code> ， <code>dispose()</code>等的方法。理想情况下，此类生命周期回调方法的名称在项目中是标准化的，以便所有开发人员使用相同的方法名称并确保一致性。</p>
</div>
<div class="paragraph">
<p>您可以将Spring容器配置为“查找”命名初始化并销毁每个bean上的回调方法名称。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为<code>init()</code>的初始化回调，而无需为每个bean定义配置<code>init-method="init"</code>属性。Spring IoC容器在创建bean时调用该方法（并且符合<a href="#beans-factory-lifecycle">前面描述</a>的标准生命周期回调契约）。此功能还强制执行初始化和销毁​​方法回调的一致命名约定。</p>
</div>
<div class="paragraph">
<p>假设您的初始化回调方法名为<code>init()</code>而您的destroy回调方法名为<code>destroy()</code> 。然后，您的类类似于以下示例中的类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultBlogService</span> <span class="directive">实现</span> BlogService { <span class="directive">private</span> BlogDao blogDao; <span class="directive">public</span> <span class="type">void</span> setBlogDao（BlogDao blogDao）{ <span class="local-variable">this</span> .blogDao = blogDao; <span class="comment">这是（不出所料）初始化回调方法</span> <span class="directive">public</span> <span class="type">void</span> init（）{ <span class="keyword">if</span> （ <span class="local-variable">this</span> .blogDao == <span class="predefined-constant">null</span> ）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">必须设置[blogDao]属性。</span> <span class="delimiter">”</span></span> ）; }}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以在类似于以下内容的bean中使用该类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-init-method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">init</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">blogService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.something。DefaultBlogService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">blogDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">blogDao</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>顶级<code>&lt;beans/&gt;</code>元素属性上存在<code>default-init-method</code>属性会导致Spring IoC容器将bean类上的<code>init</code>方法识别为初始化方法回调。当bean被创建和组装时，如果bean类具有这样的方法，则在适当的时候调用它。</p>
</div>
<div class="paragraph">
<p>您可以使用顶级<code>&lt;beans/&gt;</code>元素上的<code>default-destroy-method</code>属性，以类似方式（在XML中）配置destroy方法回调。</p>
</div>
<div class="paragraph">
<p>如果现有bean类已经具有与约定一致的变量命名的回调方法，则可以通过使用<code>&lt;bean/&gt;</code>的<code>init-method</code>和<code>destroy-method</code>属性指定（在XML中，即）方法名称来覆盖缺省值。 <code>&lt;bean/&gt;</code>本身。</p>
</div>
<div class="paragraph">
<p>Spring容器保证在为bean提供所有依赖项之后立即调用已配置的初始化回调。因此，在原始bean引用上调用初始化回调，这意味着AOP拦截器等尚未应用于bean。首先完全创建目标bean，然后应用带有拦截器链的AOP代理（例如）。如果目标bean和代理是分开定义的，那么您的代码甚至可以绕过代理与原始目标bean进行交互。因此，将拦截器应用于<code>init</code>方法是不一致的，因为这样做会将目标bean的生命周期耦合到其代理或拦截器，并在代码直接与原始目标bean交互时留下奇怪的语义。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-combined-effects"><a class="anchor" href="#beans-factory-lifecycle-combined-effects"></a>结合生命周期机制</h5>
<div class="paragraph">
<p>从Spring 2.5开始，您有三个控制bean生命周期行为的选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a>和<a href="#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a>回调接口</p>
</li>
<li>
<p>自定义<code>init()</code>和<code>destroy()</code>方法</p>
</li>
<li>
<p><a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code>和<code>@PreDestroy</code>注释</a> 。您可以组合这些机制来控制给定的bean。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果为bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名称，则每个配置的方法都按照此注释后列出的顺序执行。但是，如果为初始化方法配置了相同的方法名称（例如， <code>init()</code> - 对于多个这些生命周期机制，该方法将执行一次，如上<a href="#beans-factory-lifecycle-default-init-destroy-methods">一节中所述</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为同一个bean配置的多个生命周期机制，具有不同的初始化方法，如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用<code>@PostConstruct</code>注释的方法</p>
</li>
<li>
<p><code>afterPropertiesSet()</code>由<code>InitializingBean</code>回调接口定义</p>
</li>
<li>
<p>自定义配置的<code>init()</code>方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Destroy方法以相同的顺序调用：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用<code>@PreDestroy</code>注释的<code>@PreDestroy</code></p>
</li>
<li>
<p><code>destroy()</code> ，由<code>DisposableBean</code>回调接口定义</p>
</li>
<li>
<p>自定义配置的<code>destroy()</code>方法</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-processor"><a class="anchor" href="#beans-factory-lifecycle-processor"></a>启动和关闭回调</h5>
<div class="paragraph">
<p><code>Lifecycle</code>接口为具有自己的生命周期要求的任何对象定义基本方法（例如启动和停止某些后台进程）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lifecycle</span> { <span class="type">void</span> start（）; <span class="type">void</span> stop（）; <span class="type">boolean</span> isRunning（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>任何Spring管理的对象都可以实现<code>Lifecycle</code>接口。然后，当<code>ApplicationContext</code>本身接收到启动和停止信号时（例如，对于运行时的停止/重启场景），它会将这些调用级联到该上下文中定义的所有<code>Lifecycle</code>实现。它通过委托<code>LifecycleProcessor</code>完成此操作，如下面的清单所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">LifecycleProcessor</span> <span class="directive">扩展了</span>生命周期{ <span class="type">void</span> onRefresh（）; <span class="type">void</span> onClose（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>LifecycleProcessor</code>本身是<code>Lifecycle</code>接口的扩展。它还添加了另外两种方法来响应刷新和关闭的上下文。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意常规的<code>org.springframework.context.Lifecycle</code>接口是显式启动和停止通知的简单合约，并不意味着在上下文刷新时自动启动。要对特定bean的自动启动进行细粒度控制（包括启动阶段），请考虑实现<code>org.springframework.context.SmartLifecycle</code> 。</p>
</div>
<div class="paragraph">
<p>此外，请注意，在销毁之前不保证停止通知。在常规关闭时，所有<code>Lifecycle</code> bean在传播一般销毁回调之前首先收到停止通知。但是，在上下文生命周期中的热刷新或中止刷新尝试时，仅调用destroy方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启动和关闭调用的顺序非常重要。如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，并且在其依赖之前停止。但是，有时，直接依赖性是未知的。您可能只知道某种类型的对象应该在另一种类型的对象之前开始。在这些情况下， <code>SmartLifecycle</code>接口定义了另一个选项，即在其超级接口<code>Phased</code>上定义的<code>getPhase()</code>方法。以下清单显示了<code>Phased</code>接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">Phased</span> { <span class="type">int</span> getPhase（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了<code>SmartLifecycle</code>接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">SmartLifecycle</span> <span class="directive">扩展了</span> Lifecycle，Phased { <span class="type">boolean</span> isAutoStartup（）; <span class="type">void</span> stop（ <span class="predefined-type">Runnable</span> callback）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>启动时，具有最低相位的对象首先开始。停止时，遵循相反的顺序。因此，实现<code>SmartLifecycle</code>并且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>将是第一个开始，最后一个停止。在频谱的另一端，相位值为<code>Integer.MAX_VALUE</code>表示该对象应该在最后启动并首先停止（可能是因为它依赖于正在运行的其他进程）。在考虑阶段值时，同样重要的是要知道未实现<code>SmartLifecycle</code>任何“正常” <code>Lifecycle</code>对象的默认阶段为<code>0</code> 。因此，任何负相位值都表示对象应该在这些标准组件之前启动（并在它们之后停止）。任何正相值都是相反的。</p>
</div>
<div class="paragraph">
<p><code>SmartLifecycle</code>定义的stop方法接受回调。在该实现的关闭过程完成之后，任何实现都必须调用该回调的<code>run()</code>方法。这样可以在必要时启用异步关闭，因为<code>LifecycleProcessor</code>接口的默认实现<code>DefaultLifecycleProcessor</code>等待每个阶段内对象组的超时值以调用该回调。默认的每阶段超时为30秒。您可以通过在上下文中定义名为<code>lifecycleProcessor</code>的bean来覆盖缺省生命周期处理器实例。如果您只想修改超时，则定义以下内容就足够了：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lifecycleProcessor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.context.support。DefaultLifecycleProcessor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 超时值（以毫秒为单位） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">timeoutPerShutdownPhase</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">10000</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如前所述， <code>LifecycleProcessor</code>接口还定义了用于刷新和关闭上下文的回调方法。后者驱动关闭过程，就像显式调用了<code>stop()</code>一样，但是当上下文关闭时会发生。另一方面，'refresh'回调启用了<code>SmartLifecycle</code> bean的另一个功能。刷新上下文时（在实例化并初始化所有对象之后），将调用该回调。此时，默认生命周期处理器检查每个<code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>方法返回的布尔值。如果为<code>true</code> ，则在该点启动该对象，而不是等待显式调用上下文或其自己的<code>start()</code>方法（与上下文刷新不同，上下文启动不会自动发生在标准上下文实现中）。<code>phase</code>值和任何“依赖”关系确定如前所述的启动顺序。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-shutdown"><a class="anchor" href="#beans-factory-shutdown"></a>在非Web应用程序中优雅地关闭Spring IoC容器</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本节仅适用于非Web应用程序。Spring的基于Web的<code>ApplicationContext</code>实现已经具有代码，可以在关闭相关Web应用程序时正常关闭Spring IoC容器。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果在非Web应用程序环境中使用Spring的IoC容器（例如，在富客户机桌面环境中），请使用JVM注册关闭挂钩。这样做可确保正常关闭并在单例bean上调用相关的destroy方法，以便释放所有资源。您仍然必须正确配置和实现这些销毁回调。</p>
</div>
<div class="paragraph">
<p>要注册关闭挂钩，请调用<code>ConfigurableApplicationContext</code>接口上声明的<code>registerShutdownHook()</code>方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context。ConfigurableApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> {ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ）; <span class="comment">//为上面的上下文添加一个关闭钩子...</span>ctx.registerShutdownHook（）; <span class="comment">// app在这里运行......</span>

        <span class="comment">// main方法退出，在应用程序关闭之前调用hook ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-aware"><a class="anchor" href="#beans-factory-aware"></a> 1.6.2。<code>ApplicationContextAware</code>和<code>BeanNameAware</code></h4>
<div class="paragraph">
<p>当<code>ApplicationContext</code>创建实现<code>org.springframework.context.的对象实例时<code>org.springframework.context.ApplicationContextAware</code>接口中，该实例提供了对该<code>ApplicationContext</code>的引用。以下清单显示了<code>ApplicationContextAware</code>接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ApplicationContextAware</span> { <span class="type">void</span> setApplicationContext（ApplicationContext applicationContext） <span class="directive">抛出</span> BeansException; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此，豆类可以编程方式操作<code>ApplicationContext</code>创建它们，通过<code>ApplicationContext</code>界面或通过铸造的参考本接口（诸如的已知子类<code>ConfigurableApplicationContext</code> ，获得更多的功能）。一种用途是对其他bean进行编程检索。有时这种能力很有用。但是，一般情况下，您应该避免使用它，因为它将代码耦合到Spring并且不遵循Inversion of Control样式，其中协作者作为属性提供给bean。<code>ApplicationContext</code>其他方法提供对文件资源的访问，发布应用程序事件和访问<code>MessageSource</code> 。<a href="#context-introduction"><code>ApplicationContext</code></a>附加功能中描述了这些附加功能。</p>
</div>
<div class="paragraph">
<p>从Spring 2.5开始，自动装配是另一种获取<code>ApplicationContext</code>引用的替代方法。“传统” <code>constructor</code>和<code>byType</code>自动<a href="#beans-factory-autowire">装配</a>模式（如<a href="#beans-factory-autowire">自动装配协作者中所述</a> ）可以分别为构造函数参数或setter方法参数提供<code>ApplicationContext</code>类型的依赖关系。要获得更大的灵活性，包括自动装配字段和多参数方法的功能，请使用基于注释的新自动装配功能。如果这样做， <code>ApplicationContext</code>将自动装入一个字段，构造函数参数或方法参数，如果相关的字段，构造函数或方法带有<code>@Autowired</code>注释，则该参数需要<code>ApplicationContext</code>类型。有关更多信息，请参阅<a href="#beans-autowired-annotation">使用<code>@Autowired</code></a> 。</p>
</div>
<div class="paragraph">
<p>当<code>ApplicationContext</code>创建一个实现<code>org.springframework.beans.factory.的类时<code>org.springframework.beans.factory.BeanNameAware</code>接口，该类提供了对其关联对象定义中定义的名称的引用。以下清单显示了BeanNameAware接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeanNameAware</span> { <span class="type">void</span> setBeanName（ <span class="predefined-type">String</span> name） <span class="directive">throws</span> BeansException; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在普通bean属性填充之后但在初始化回调之前（例如<code>InitializingBean</code> ， <code>afterPropertiesSet</code>或自定义init方法）之前调用回调。</p>
</div>
</div>
<div class="sect3">
<h4 id="aware-list"><a class="anchor" href="#aware-list"></a> 1.6.3。其他<code>Aware</code>接口</h4>
<div class="paragraph">
<p>除了<code>ApplicationContextAware</code>和<code>BeanNameAware</code> （前面已讨论<a href="#beans-factory-aware">过</a> ）之外，Spring还提供了一系列<code>Aware</code>接口，让bean向容器指示它们需要某种基础结构依赖性。作为一般规则，名称是依赖类型的良好指示。下表总结了最重要的<code>Aware</code>接口：</p>
</div>
<table id="beans-factory-nature-aware-list" class="tableblock frame-all grid-all spread">
<caption class="title">表4。意识到的接口</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">注入依赖</th>
<th class="tableblock halign-left valign-top">解释在......</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>了ApplicationContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明<code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEventPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">封闭<code>ApplicationContext</code>事件发布者。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction"><code>ApplicationContext</code>附加功能</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanClassLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于加载bean类的类加载器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">实例化豆​​类</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>实现BeanFactoryAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明<code>BeanFactory</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明bean的名称。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BootstrapContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">容器运行的资源适配器<code>BootstrapContext</code> 。通常仅在JCA感知的<code>ApplicationContext</code>实例中可用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#cci">JCA CCI</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LoadTimeWeaverAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义的weaver用于在加载时处理类定义。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#aop-aj-ltw">在Spring框架中使用AspectJ进行加载时编织</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageSourceAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于解析消息的已配置策略（支持参数化和国际化）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction"><code>ApplicationContext</code>附加功能</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotificationPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring JMX通知发布者。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#jmx-notifications">通知</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置的加载程序，用于对资源进行低级访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resources">资源</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletConfigAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">容器运行的当前<code>ServletConfig</code> 。仅在Web感知的Spring <code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">容器运行的当前<code>ServletContext</code> 。仅在Web感知的Spring <code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请再次注意，使用这些接口会将您的代码绑定到Spring API，而不会遵循Inversion of Control样式。因此，我们建议将它们用于需要以编程方式访问容器的基础架构bean。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-child-bean-definitions"><a class="anchor" href="#beans-child-bean-definitions"></a> 1.7。Bean定义继承</h3>
<div class="paragraph">
<p>bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用父bean和子bean定义可以节省大量的输入。实际上，这是一种模板形式。</p>
</div>
<div class="paragraph">
<p>如果以编程方式使用<code>ApplicationContext</code>接口，则子bean定义由<code>ChildBeanDefinition</code>类表示。大多数用户不在此级别上使用它们。相反，它们在类（如<code>ClassPathXmlApplicationContext</code>中以声明方式配置bean定义。使用基于XML的配置元数据时，可以使用<code>parent</code>属性指定子bean定义，将父bean指定为此属性的值。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">inheritedTestBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">abstract</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">parent</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">inheritsWithDifferentClass</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans 。DerivedTestBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">”</span> <span class="content">inheritedTestBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">init-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">initialize</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">override</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  age属性值为1将继承自parent  - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>请注意<code>parent</code>属性。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有指定，则bean bean定义使用父定义中的bean类，但也可以覆盖它。在后一种情况下，子bean类必须与父类兼容（即，它必须接受父类的属性值）。</p>
</div>
<div class="paragraph">
<p>子bean定义从父级继承范围，构造函数参数值，属性值和方法覆盖，并具有添加新值的选项。您指定的任何范围，初始化方法，销毁方法或<code>static</code>工厂方法设置都会覆盖相应的父设置。</p>
</div>
<div class="paragraph">
<p>其余设置始终取自子定义：取决于，autowire模式，依赖性检查，单例和惰性初始化。</p>
</div>
<div class="paragraph">
<p>前面的示例通过使用<code>abstract</code>属性将父bean定义显式标记为abstract。如果父定义未指定类，则需要将父bean定义显式标记为<code>abstract</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">inheritedTestBeanWithoutClass</span> <span class="delimiter">”</span></span> <span class="attribute-name">abstract</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">parent</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">age</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">inheritsWithClass</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans。DerivedTestBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">”</span> <span class="content">inheritedTestBeanWithoutClass</span> <span class="delimiter">“</span></span> <span class="attribute-name">init-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">initialize</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">override</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  age将从父bean定义继承值1  - &gt;</span> <span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>父bean不能单独实例化，因为它不完整，并且也明确标记为<code>abstract</code> 。当定义是<code>abstract</code> ，它只能用作纯模板bean定义，用作子定义的父定义。尝试使用这样一个<code>abstract</code>父bean，通过将它作为另一个bean的ref属性引用或者使用父bean ID进行显式的<code>getBean()</code>调用会返回错误。类似地，容器的内部<code>preInstantiateSingletons()</code>方法忽略定义为abstract的bean定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>ApplicationContext</code>默认情况下预先实例化所有单例。因此，重要的是（至少对于单例bean），如果您有一个（父）bean定义，您打算仅将其用作模板，并且此定义指定了一个类，则必须确保将<em>abstract</em>属性设置为<em>true</em>否则应用程序上下文将实际（尝试）预先实例化<code>abstract</code> bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-extension"><a class="anchor" href="#beans-factory-extension"></a> 1.8。集装箱扩建点</h3>
<div class="paragraph">
<p>通常，应用程序开发人员不需要子类化<code>ApplicationContext</code>实现类。相反，可以通过插入特殊集成接口的实现来扩展Spring IoC容器。接下来的几节将介绍这些集成接口。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-bpp"><a class="anchor" href="#beans-factory-extension-bpp"></a> 1.8.1。使用<code>BeanPostProcessor</code>自定义Bean</h4>
<div class="paragraph">
<p><code>BeanPostProcessor</code>接口定义了可以实现的回调方法，以提供您自己的（或覆盖容器的默认）实例化逻辑，依赖关系解析逻辑等。如果要在Spring容器完成实例化，配置和初始化bean之后实现某些自定义逻辑，则可以插入一个或多个<code>BeanPostProcessor</code>实现。</p>
</div>
<div class="paragraph">
<p>您可以配置多个<code>BeanPostProcessor</code>实例，并且可以通过设置<code>order</code>属性来控制这些<code>BeanPostProcessor</code>实例的执行<code>order</code> 。仅当<code>BeanPostProcessor</code>实现<code>Ordered</code>接口时，才能设置此属性。如果编写自己的<code>BeanPostProcessor</code> ，则应考虑实现<code>Ordered</code>接口。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><code>BeanPostProcessor</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a>接口的Javadoc。另请参阅有关<a href="#beans-factory-programmatically-registering-beanpostprocessors"><code>BeanPostProcessor</code>实例的编程注册</a>的说明。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>BeanPostProcessor</code>实例在bean（或对象）实例上运行。也就是说，Spring IoC容器实例化一个bean实例，然后<code>BeanPostProcessor</code>实例完成它们的工作。</p>
</div>
<div class="paragraph">
<p><code>BeanPostProcessor</code>实例的范围是每个容器的范围。仅当您使用容器层次结构时，这才是相关的。如果在一个容器中定义<code>BeanPostProcessor</code> ，它只对该容器中的bean进行后处理。换句话说，在一个容器中定义的<code>BeanPostProcessor</code>不会被另一个容器中定义的<code>BeanPostProcessor</code>后处理，即使两个容器都是同一层次结构的一部分。</p>
</div>
<div class="paragraph">
<p>要改变实际的bean定义（也就是定义bean的蓝图），而不是你需要使用一个<code>BeanFactoryPostProcessor</code> ，如在<a href="#beans-factory-extension-factory-postprocessors">一个定制配置元数据<code>BeanFactoryPostProcessor</code></a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口恰好包含两个回调方法。当这样的类被注册为容器的后处理器时，对于容器创建的每个bean实例，后处理器在容器初始化方法之前从容器中获取回调（例如<code>InitializingBean.afterPropertiesSet()</code> ，在调用任何声明的<code>init</code>方法之后，并在任何bean初始化回调之后。后处理器可以对bean实例执行任何操作，包括完全忽略回调。bean后处理器通常检查回调接口，或者它可以用代理包装bean。一些Spring AOP基础结构类实现为bean后处理器，以便提供代理包装逻辑。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code>自动检测在实现<code>BeanPostProcessor</code>接口的配置元数据中定义的任何bean。<code>ApplicationContext</code>将这些bean注册为后处理器，以便在创建bean时可以稍后调用它们。Bean后处理器可以以与任何其他bean相同的方式部署在容器中。</p>
</div>
<div class="paragraph">
<p>请注意，在配置类上使用<code>@Bean</code>工厂方法声明<code>BeanPostProcessor</code> ，工厂方法的返回类型应该是实现类本身或至少是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，清楚地表明该BeanPostProcessor</code>的后处理器性质。否则， <code>ApplicationContext</code>无法在完全创建之前按类型自动检测它。由于<code>BeanPostProcessor</code>需要尽早实例化以便应用于上下文中其他bean的初始化，因此这种早期类型检测至关重要。</p>
</div>
<div id="beans-factory-programmatically-registering-beanpostprocessors" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">以编程方式注册<code>BeanPostProcessor</code>实例</div>虽然<code>BeanPostProcessor</code>注册的推荐方法是通过<code>ApplicationContext</code>自动检测（如前所述），但您可以使用<code>addBeanPostProcessor</code>方法以编程方式对<code>ConfigurableBeanFactory</code>进行注册。当您需要在注册之前评估条件逻辑或甚至跨层次结构中的上下文复制Bean post处理器时，这非常有用。但请注意，以编程方式添加的<code>BeanPostProcessor</code>实例不遵循<code>Ordered</code>接口。这里，注册顺序决定了执行的顺序。另请注意，以编程方式注册的<code>BeanPostProcessor</code>实例始终在通过自动检测注册的实例之前处理，而不管任何显式排序。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title"><code>BeanPostProcessor</code>实例和AOP自动代理</div>
<div class="paragraph">
<p>实现<code>BeanPostProcessor</code>接口的类是特殊的，容器<code>BeanPostProcessor</code>它们进行不同的处理。作为<code>ApplicationContext</code>的特殊启动阶段的一部分，它们直接引用的所有<code>BeanPostProcessor</code>实例和bean都会在启动时实例化。接下来，所有<code>BeanPostProcessor</code>实例都以排序方式注册，并应用于容器中的所有其他bean。因为AOP自动代理是作为<code>BeanPostProcessor</code>本身实现的，所以<code>BeanPostProcessor</code>实例和它们直接引用的bean都没有资格进行自动代理，因此没有编织方面。</p>
</div>
<div class="paragraph">
<p>对于任何此类bean，您应该看到一条信息性日志消息： <code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code> 。</p>
</div>
<div class="paragraph">
<p>如果您通过使用自动装配或<code>@Resource</code> （可能会回退到自动装配）将bean连接到<code>BeanPostProcessor</code> ，则Spring可能会在搜索类型匹配依赖项候选项时访问意外的bean，从而使它们不符合自动代理或其他类型的条件豆后处理。例如，如果您有一个使用<code>@Resource</code>注释的依赖项，其中字段或setter名称不直接对应于bean的声明名称而且没有使用name属性，则Spring会访问其他bean以按类型匹配它们。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何在<code>ApplicationContext</code>编写，注册和使用<code>BeanPostProcessor</code>实例。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-hw"><a class="anchor" href="#beans-factory-extension-bpp-examples-hw"></a>示例：Hello World， <code>BeanPostProcessor</code> style</h5>
<div class="paragraph">
<p>第一个例子说明了基本用法。该示例显示了一个自定义<code>BeanPostProcessor</code>实现，该实现在容器创建时调用每个bean的<code>toString()</code>方法，并将生成的字符串输出到系统控制台。</p>
</div>
<div class="paragraph">
<p>以下清单显示了自定义<code>BeanPostProcessor</code>实现类定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">脚本</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.config。BeanPostProcessor</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">InstantiationTracingBeanPostProcessor</span> <span class="directive">实现</span> BeanPostProcessor { <span class="comment">//只返回实例化的bean as-is</span> <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessBeforeInitialization（ <span class="predefined-type">Object</span> bean， <span class="predefined-type">String</span> beanName）{ <span class="keyword">return</span> bean; <span class="comment">//我们可以在这里返回任何对象引用...</span><span class="directive">public</span> <span class="predefined-type">Object</span> postProcessAfterInitialization（ <span class="predefined-type">Object</span> bean， <span class="predefined-type">String</span> beanName）{ <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span> <span class="content">Bean'</span> <span class="delimiter">”</span></span> + beanName + <span class="string"><span class="delimiter">“</span> <span class="content">'created：</span> <span class="delimiter">”</span></span> + bean.toString（））; <span class="keyword">返回</span>豆子; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下<code>beans</code>元素使用<code>InstantiationTracingBeanPostProcessor</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：lang</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/lang</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/lang</span> <span class="content">http://www.springframework.org/schema/lang/spring-lang.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="attribute-name">script-source</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：org / springframework /scripting/groovy/Messenger.groovy</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">message</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Fiona Apple</span></span> <span class="string"><span class="content">真是太棒了</span></span> <span class="string"><span class="content">。</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ lang：groovy&gt;</span> <span class="comment">&lt;！ - 当上面的bean（信使）是实例化后，这个自定义BeanPostProcessor实现会将事实输出到系统控制台 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">scripting。InstantiationTracingBeanPostProcessor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意如何仅定义<code>InstantiationTracingBeanPostProcessor</code> 。它甚至没有名称，并且，因为它是一个bean，它可以像任何其他bean一样依赖注入。（前面的配置还定义了一个由Groovy脚本支持的bean。Spring动态语言支持在“ <a href="languages.html#dynamic-language">动态语言支持</a> ”一章中有详细介绍。</p>
</div>
<div class="paragraph">
<p>以下Java应用程序运行上述代码和配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.scripting。信使</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> {ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">scripting / beans.xml</span> <span class="delimiter">”</span></span> ）; Messenger messenger =（Messenger）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">messenger</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">System</span> .out.println（messenger）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述应用程序的输出类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>Bean'sensenger'创建：org.springframework.scripting.groovy。GroovyMessenger @ 272961 org.springframework.scripting.groovy。GroovyMessenger @ 272961</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-rabpp"><a class="anchor" href="#beans-factory-extension-bpp-examples-rabpp"></a>示例： <code>RequiredAnnotationBeanPostProcessor</code></h5>
<div class="paragraph">
<p>将回调接口或注释与自定义<code>BeanPostProcessor</code>实现结合使用是扩展Spring IoC容器的常用方法。一个例子是Spring的<code>RequiredAnnotationBeanPostProcessor</code> - 一个随Spring发行版一起提供的<code>BeanPostProcessor</code>实现，它确保标记有（任意）注释的bean上的JavaBean属性实际上（配置为）依赖注入值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factory-postprocessors"><a class="anchor" href="#beans-factory-extension-factory-postprocessors"></a> 1.8.2。使用<code>BeanFactoryPostProcessor</code>自定义配置元数据</h4>
<div class="paragraph">
<p>我们看到的下一个扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code> 。此接口的语义类似于<code>BeanPostProcessor</code>的语义，但有一个主要区别： <code>BeanFactoryPostProcessor</code>对bean配置元数据进行操作。也就是说，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据，并可能在容器实例<code>BeanFactoryPostProcessor</code>实例之外的任何bean <em>之前</em>更改它。</p>
</div>
<div class="paragraph">
<p>您可以配置多个<code>BeanFactoryPostProcessor</code>实例，并且可以通过设置<code>order</code>属性来控制这些<code>BeanFactoryPostProcessor</code>实例的运行<code>order</code> 。但是，如果<code>BeanFactoryPostProcessor</code>实现<code>Ordered</code>接口，则只能设置此属性。如果编写自己的<code>BeanFactoryPostProcessor</code> ，则应考虑实现<code>Ordered</code>接口。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html"><code>BeanFactoryPostProcessor</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a>接口的Javadoc。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要更改实际的bean实例（即，从配置元数据创建的对象），则需要使用<code>BeanPostProcessor</code> （前面在<a href="#beans-factory-extension-bpp">使用<code>BeanPostProcessor</code>定制Bean中进行了</a>描述）。虽然技术上可以在<code>BeanFactoryPostProcessor</code>使用bean实例（例如，通过使用<code>BeanFactory.getBean()</code> ），但这样做会导致过早的bean实例化，从而违反标准容器生命周期。这可能会导致负面影响，例如绕过bean后期处理。</p>
</div>
<div class="paragraph">
<p>此外， <code>BeanFactoryPostProcessor</code>实例的范围是每个容器。仅当您使用容器层次结构时，这才有意义。如果在一个容器中定义<code>BeanFactoryPostProcessor</code> ，则它仅应用于该容器中的bean定义。一个容器中的Bean定义不会被另一个容器中的<code>BeanFactoryPostProcessor</code>实例进行后处理，即使两个容器都是同一层次结构的一部分。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>bean工厂后处理器在<code>ApplicationContext</code>声明时自动执行，以便将更改应用于定义容器的配置元数据。Spring包含许多预定义的bean工厂后处理器，例如<code>PropertyOverrideConfigurer</code>和<code>PropertyPlaceholderConfigurer</code> 。您还可以使用自定义<code>BeanFactoryPostProcessor</code> - 例如，注册自定义属性编辑器。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code>自动检测部署到其中的任何实现<code>BeanFactoryPostProcessor</code>接口的bean。它在适当的时候使用这些bean作为bean工厂后处理器。您可以像处理任何其他bean一样部署这些后处理器bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与<code>BeanPostProcessor</code> ，您通常不希望为延迟初始化配置<code>BeanFactoryPostProcessor</code> 。如果没有其他bean引用<code>Bean(Factory)PostProcessor</code> ，则该后处理器根本不会被实例化。因此，将忽略将其标记为延迟初始化，即使在<code>&lt;beans /&gt;</code>元素的声明中将<code>default-lazy-init</code>属性设置为<code>true</code> ，也会急切地实例化<code>Bean(Factory)PostProcessor</code> 。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-factory-placeholderconfigurer"><a class="anchor" href="#beans-factory-placeholderconfigurer"></a>示例：类名替换<code>PropertyPlaceholderConfigurer</code></h5>
<div class="paragraph">
<p>您可以使用<code>PropertyPlaceholderConfigurer</code>通过使用标准Java <code>Properties</code>格式从单独文件中的bean定义外部化属性值。这样做可以使部署应用程序的人员自定义特定于环境的属性，例如数据库URL和密码，而不会出现修改主XML定义文件或容器文件的复杂性或风险。</p>
</div>
<div class="paragraph">
<p>请考虑以下基于XML的配置元数据片段，其中定义了具有占位符值的<code>DataSource</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPlaceholderConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">locations</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：com / something / jdbc.properties</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.apache。 commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例显示了从外部<code>Properties</code>文件配置的<code>Properties</code> 。在运行时， <code>PropertyPlaceholderConfigurer</code>应用于替换DataSource的某些属性的元数据。要替换的值被指定为<code>${property-name}</code>形式的占位符，它遵循Ant和log4j以及JSP EL样式。</p>
</div>
<div class="paragraph">
<p>实际值来自标准Java <code>Properties</code>格式的另一个文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>jdbc.driverClassName = org.hsqldb.jdbcDriver jdbc.url = jdbc：hsqldb：hsql：// production：9002 jdbc.username = sa jdbc.password = root</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此， <code>${jdbc.username}</code>字符串在运行时将替换为值'sa'，并且同样适用于与属性文件中的键匹配的其他占位符值。<code>PropertyPlaceholderConfigurer</code>检查bean定义的大多数属性和属性中的占位符。此外，您可以自定义占位符前缀和后缀。</p>
</div>
<div class="paragraph">
<p>使用Spring 2.5中引入的<code>context</code>命名空间，您可以使用专用配置元素配置属性占位符。您可以在<code>location</code>属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context：property-placeholder</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / something / jdbc.properties</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>PropertyPlaceholderConfigurer</code>不仅在您指定的<code>Properties</code>文件中查找属性。默认情况下，如果它在指定的属性文件中找不到属性，它还会检查Java <code>System</code>属性。您可以通过使用以下三个受支持的整数值之一设置configurer的<code>systemPropertiesMode</code>属性来自定义此行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>never</code> （0）：从不检查系统属性。</p>
</li>
<li>
<p><code>fallback</code> （1）：如果在指定的属性文件中无法解析，则检查系统属性。这是默认值。</p>
</li>
<li>
<p><code>override</code> （2）：在尝试指定的属性文件之前，首先检查系统属性。这使系统属性可以覆盖任何其他属性源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"><code>PropertyPlaceholderConfigurer</code></a> Javadoc。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用<code>PropertyPlaceholderConfigurer</code>替换类名，这在您必须在运行时选择特定实现类时有时很有用。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPlaceholderConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">locations</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> classpath：com / something / strategy.properties <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">properties</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> custom.strategy.class = com。一些东西。DefaultStrategy <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serviceStrategy</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {custom.strategy.class}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果在运行时无法将类解析为有效类，则在即将创建bean时，bean的解析将失败，这是在非lazy-init bean的<code>ApplicationContext</code>的<code>preInstantiateSingletons()</code>阶段期间。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-overrideconfigurer"><a class="anchor" href="#beans-factory-overrideconfigurer"></a>示例： <code>PropertyOverrideConfigurer</code></h5>
<div class="paragraph">
<p><code>PropertyOverrideConfigurer</code>是另一个bean工厂后处理器，类似于<code>PropertyPlaceholderConfigurer</code> ，但与后者不同，原始定义可以具有默认值，或者根本不具有bean属性的值。如果重写的<code>Properties</code>文件没有某个bean属性的条目，则使用默认的上下文定义。</p>
</div>
<div class="paragraph">
<p>请注意，bean定义不知道被覆盖，因此从XML定义文件中可以立即看出正在使用覆盖配置器。如果多个<code>PropertyOverrideConfigurer</code>实例为同一个bean属性定义了不同的值，则由于覆盖机制，最后一个实例会获胜。</p>
</div>
<div class="paragraph">
<p>属性文件配置行采用以下格式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>beanName.property =值</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了格式的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>dataSource.driverClassName = com.mysql.jdbc。驱动程序dataSource.url = jdbc：mysql：mydb</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此示例文件可以与容器定义一起使用，该容器定义包含名为<code>dataSource</code>的bean，该bean具有<code>driver</code>和<code>url</code>属性。</p>
</div>
<div class="paragraph">
<p>复制属性名称也受支持，只要路径的每个组件（重写的最终属性除外）都已经非空（可能由构造函数初始化）。在下面的示例中， <code>tom</code> bean的<code>fred</code>属性的<code>bob</code>属性的<code>sammy</code>属性设置为标量值<code>123</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>tom.fred.bob.sammy = 123</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">指定的覆盖值始终是文字值。它们不会被翻译成bean引用。当XML bean定义中的原始值指定bean引用时，此约定也适用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用Spring 2.5中引入的<code>context</code>命名空间，可以使用专用配置元素配置属性覆盖，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context：property-override</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：override.properties</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factorybean"><a class="anchor" href="#beans-factory-extension-factorybean"></a> 1.8.3。使用<code>FactoryBean</code>自定义实例化逻辑</h4>
<div class="paragraph">
<p>您可以实现<code>org.springframework.beans.factory.FactoryBean</code>接口，用于本身为工厂的对象。</p>
</div>
<div class="paragraph">
<p><code>FactoryBean</code>接口是Spring IoC容器实例化逻辑的可插拔点。如果你有一个复杂的初始化代码，用Java表示，而不是（可能）冗长的XML，你可以创建自己的<code>FactoryBean</code> ，在该类中编写复杂的初始化，然后将自定义<code>FactoryBean</code>插入容器。</p>
</div>
<div class="paragraph">
<p><code>FactoryBean</code>接口提供三种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object getObject()</code> ：返回此工厂创建的对象的实例。实例可以共享，具体取决于此工厂是返回单例还是原型。</p>
</li>
<li>
<p><code>boolean isSingleton()</code> ：如果此<code>FactoryBean</code>返回单例，则返回<code>true</code> ， <code>FactoryBean</code>返回<code>false</code> 。</p>
</li>
<li>
<p><code>Class getObjectType()</code> ：返回<code>getObject()</code>方法返回的对象类型，如果事先不知道类型，则返回<code>null</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>FactoryBean</code>概念和接口用于Spring Framework中的许多位置。<code>FactoryBean</code>接口的50多个实现随Spring一起提供。</p>
</div>
<div class="paragraph">
<p>当您需要向容器询问实际的<code>FactoryBean</code>实例本身而不是它生成的bean时，在调用<code>ApplicationContext</code>的<code>getBean()</code>方法时，使用＆符号（ <code>&amp;</code> ）作为bean的<code>id</code> <code>FactoryBean</code> 。因此，对于<code>id</code>为<code>myBean</code>的给定<code>FactoryBean</code> ，在容器上调用<code>getBean("myBean")</code>将返回<code>FactoryBean</code>的产品，而调用<code>getBean("&amp;myBean")</code>返回<code>FactoryBean</code>实例本身。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-annotation-config"><a class="anchor" href="#beans-annotation-config"></a> 1.9。基于注释的容器配置</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">注释是否比配置Spring的XML更好？</div>
<div class="paragraph">
<p>基于注释的配置的引入引发了这种方法是否比XML“更好”的问题。简短的回答是“它取决于”。答案很长，每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，注释在其声明中提供了大量上下文，从而导致更短更简洁的配置。但是，XML擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将布线靠近源，而另一些开发人员则认为注释类不再是POJO，而且配置变得分散且难以控制。</p>
</div>
<div class="paragraph">
<p>无论选择如何，Spring都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其<a href="#beans-java">JavaConfig</a>选项，Spring允许以非侵入方式使用注释，而无需触及目标组件源代码，并且在工具方面， <a href="https://spring.io/tools/sts">Spring Tool Suite</a>支持所有配置样式。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>基于注释的配置提供了XML设置的替代方案，该配置依赖于字节码元数据来连接组件而不是角括号声明。开发人员不是使用XML来描述bean连接，而是通过在相关的类，方法或字段声明上使用注释将配置移动到组件类本身。如<a href="#beans-factory-extension-bpp-examples-rabpp">示例中所述： <code>RequiredAnnotationBeanPostProcessor</code></a> ，将<code>BeanPostProcessor</code>与注释结合使用是扩展Spring IoC容器的常用方法。例如，Spring 2.0引入了使用<a href="#beans-required-annotation"><code>@Required</code></a>注释强制执行所需属性的可能性。Spring 2.5使得有可能采用相同的通用方法来驱动Spring的依赖注入。从本质上讲，@ <code>@Autowired</code>注释提供的功能与<a href="#beans-factory-autowire">自动装配协作者中</a>描述的相同，但具有更细粒度的控制和更广泛的适用性。Spring 2.5还增加了对JSR-250注释的支持，例如@ <code>@PostConstruct</code>和<code>@PreDestroy</code> 。Spring 3.0增加了对<code>javax.inject</code>包中包含的JSR-330（Java的依赖注入）注释的支持，例如<code>@Inject</code>和<code>@Named</code> 。有关这些注释的详细信息，请参阅<a href="#beans-standard-annotations">相关章节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在注入XML之前执行注释注入。因此，XML配置会覆盖通过这两种方法连接的属性的注释。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与往常一样，您可以将它们注册为单独的bean定义，但也可以通过在基于XML的Spring配置中包含以下标记来隐式注册它们（请注意包含<code>context</code>命名空间）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（隐式注册的后处理器包括<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a>和前面提到的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a> 。）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>&lt;context:annotation-config/&gt;</code>仅查找在定义它的同一应用程序上下文中的bean上的注释。这意味着，如果将<code>&lt;context:annotation-config/&gt;</code>放在<code>DispatcherServlet</code>的<code>WebApplicationContext</code>中，它只检查控制器中的<code>@Autowired</code> bean，而不检查您的服务。有关更多信息，请参阅<a href="web.html#mvc-servlet">DispatcherServlet</a> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a> 1.9.1。@需要</h4>
<div class="paragraph">
<p><code>@Required</code>注释适用于bean属性setter方法，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Required</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此注释指示必须在配置时通过bean定义中的显式属性值或通过自动装配填充受影响的bean属性。如果尚未填充受影响的bean属性，则容器将引发异常。这允许急切和显式的失败，以后避免<code>NullPointerException</code>实例等。我们仍然建议您将断言放入bean类本身（例如，转换为init方法）。即使您在容器外使用类，这样做也会强制执行那些必需的引用和值。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a> 1.9.2。使用<code>@Autowired</code></h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">可以使用JSR 330的<code>@Inject</code>注释代替本节中包含的示例中的Spring的<code>@Autowired</code>注释。有关详细信息，请参见<a href="#beans-standard-annotations">此处</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以将<code>@Autowired</code>批注应用于构造函数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="directive">私人</span> <span class="directive">最终</span> CustomerPreferenceDao customerPreferenceDao; <span class="annotation">@Autowired</span> <span class="directive">public</span> MovieRecommender（CustomerPreferenceDao customerPreferenceDao）{ <span class="local-variable">this</span> .customerPreferenceDao = customerPreferenceDao; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring Framework 4.3开始，如果目标bean只定义了一个开头的构造函数，则不再需要在这样的构造函数上使用<code>@Autowired</code>注释。但是，如果有几个构造器可用，则必须注释至少一个构造器以教导容器使用哪一个。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以将<code>@Autowired</code>注释应用于“传统”setter方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以将注释应用于具有任意名称和多个参数的方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="directive">private</span> MovieCatalog movieCatalog; <span class="directive">私人</span> CustomerPreferenceDao customerPreferenceDao; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> prepare（MovieCatalog movieCatalog，CustomerPreferenceDao customerPreferenceDao）{ <span class="local-variable">this</span> .movi​​eCatalog = movieCatalog; <span class="local-variable">这个</span> .customerPreferenceDao = customerPreferenceDao; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以将<code>@Autowired</code>应用于字段，甚至将其与构造函数混合，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="directive">私人</span> <span class="directive">最终</span> CustomerPreferenceDao customerPreferenceDao; <span class="annotation">@Autowired</span> <span class="directive">私人</span> MovieCatalog movieCatalog; <span class="annotation">@Autowired</span> <span class="directive">public</span> MovieRecommender（CustomerPreferenceDao customerPreferenceDao）{ <span class="local-variable">this</span> .customerPreferenceDao = customerPreferenceDao; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保您的目标组件（例如， <code>MovieCatalog</code>或<code>CustomerPreferenceDao</code> ）始终按照用于<code>@Autowired</code>注释注入点的类型声明。否则，由于在运行时未找到类型匹配，注入可能会失败。</p>
</div>
<div class="paragraph">
<p>对于通过类路径扫描找到的XML定义的bean或组件类，容器通常预先知道具体类型。但是，对于<code>@Bean</code>工厂方法，您需要确保声明的返回类型具有足够的表达能力。对于实现多个接口的组件或可能由其实现类型引用的组件，请考虑在工厂方法上声明最具体的返回类型（至少与引用bean的注入点所需的特定类型一致）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以通过将注释添加到需要该类型数组的字段或方法，从<code>ApplicationContext</code>提供特定类型的所有bean，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">课</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> MovieCatalog <span class="type">[]</span> movieCatalogs; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这同样适用于类型化集合，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="directive">private</span> <span class="predefined-type">Set</span> &lt;MovieCatalog&gt; movieCatalogs; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs（ <span class="predefined-type">Set</span> &lt;MovieCatalog&gt; movieCatalogs）{ <span class="local-variable">this</span> .movi​​eCatalogs = movieCatalogs; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您的目标bean可以实现<code>org.springframework.core.如果希望按特定顺序对数组或列表中的项进行排序，请使用Ordered</code>接口或使用<code>@Order</code>或标准<code>@Priority</code>批注。否则，它们的顺序遵循容器中相应目标bean定义的注册顺序。</p>
</div>
<div class="paragraph">
<p>您可以在目标类级别和<code>@Bean</code>方法上声明<code>@Order</code>注释，可能是通过单个bean定义（在多个定义使用相同bean类的情况下）。<code>@Order</code>值可能会影响注入点的优先级，但要注意它们不会影响单例启动顺序，这是由依赖关系和<code>@DependsOn</code>声明确定的正交关注<code>@DependsOn</code> 。</p>
</div>
<div class="paragraph">
<p>注意标准的<code>javax.annotation.<code>@Bean</code>级别不提供Priority</code>注释，因为它无法在方法上声明。它的语义可以通过<code>@Order</code>值与<code>@Primary</code>在每个类型的单个bean上进行建模。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>只要预期的键类型是<code>String</code>即使是类型化的<code>Map</code>实例也可以自动装配。Map值包含所有期望类型的bean，并且键包含相应的bean名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> { <span class="directive">private</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ，MovieCatalog&gt; movieCatalogs; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs（ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ，MovieCatalog&gt; movieCatalogs）{ <span class="local-variable">this</span> .movi​​eCatalogs = movieCatalogs; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，只要零候选bean可用，自动装配就会失败。默认行为是将带注释的方法，构造函数和字段视为指示所需的依赖项。您可以在以下示例中更改此行为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Autowired</span> （required = <span class="predefined-constant">false</span> ） <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个类只能标记一个带注释的构造函数，但可以注释多个非必需的构造函数。在这种情况下，每个都被认为是候选者之一，Spring使用最贪婪的构造函数，其依赖性可以得到满足 - 也就是说，具有最多参数的构造函数。</p>
</div>
<div class="paragraph">
<p>建议使用<code>@Autowired</code>的必需属性而不是<code>@Required</code>注释。required属性表示该属性不是自动装配所必需的。如果无法自动装配，则会忽略该属性。另一方面， <code>@Required</code>更强大，因为它强制执行由容器支持的任何方式设置的属性。如果未注入任何值，则会引发相应的异常。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>或者，您可以通过Java 8的<code>java.util.表达特定依赖项的非必需特性<code>java.util.Optional</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（Optional &lt;MovieFinder&gt; movieFinder）{...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从Spring Framework 5.0开始，您还可以使用<code>@Nullable</code>注释（任何包中的任何类型注释 - 例如， <code>javax.annotation.来自JSR-305的Nullable</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（ <span class="annotation">@Nullable</span> MovieFinder movieFinder）{...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以将<code>@Autowired</code>用于众所周知的可解析依赖项的接口： <code>BeanFactory</code> ， <code>ApplicationContext</code> ， <code>Environment</code> ， <code>ResourceLoader</code> ， <code>ApplicationEventPublisher</code>和<code>MessageSource</code> 。这些接口及其扩展接口（如<code>ConfigurableApplicationContext</code>或<code>ResourcePatternResolver</code> ）将自动解析，无需特殊设置。以下示例自动装配<code>ApplicationContext</code>对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> ApplicationContext context; <span class="directive">public</span> MovieRecommender（）{} <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该<code>@Autowired</code> ， <code>@Inject</code> ， <code>@Resource</code>和<code>@Value</code>注释由Spring处理<code>BeanPostProcessor</code>实现。这意味着您无法在自己的<code>BeanPostProcessor</code>或<code>BeanFactoryPostProcessor</code>类型（如果有）中应用这些注释。必须使用XML或Spring <code>@Bean</code>方法显式地“连接”这些类型。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a> 1.9.3。使用<code>@Primary</code>微调基于注释的自动装配</h4>
<div class="paragraph">
<p>由于按类型自动装配可能会导致多个候选人，因此通常需要对选择过程有更多控制权。实现这一目标的一种方法是使用Spring的<code>@Primary</code>注释。<code>@Primary</code>表示当多个bean可以自动装配到单值依赖项时，应该优先选择特定的bean。如果候选者中只存在一个主bean，则它将成为自动装配的值。</p>
</div>
<div class="paragraph">
<p>请考虑以下配置，将<code>firstMovieCatalog</code>定义为主要<code>MovieCatalog</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MovieConfiguration</span> { <span class="annotation">@Bean</span> <strong><span class="annotation">@Primary</span></strong> <span class="directive">public</span> MovieCatalog firstMovieCatalog（）{...} <span class="annotation">@Bean</span> <span class="directive">public</span> MovieCatalog secondMovieCatalog（）{...} <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用上述配置，以下<code>MovieRecommender</code>将与<code>firstMovieCatalog</code> <code>MovieRecommender</code>自动装配：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">课</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> MovieCatalog movieCatalog; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>相应的bean定义如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="error"><strong></strong></span> <span class="error"></span> <span class="attribute-name">primary</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="error"><strong></strong></span> <span class="error"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">movieRecommender</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。MovieRecommender</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a> 1.9.4。使用限定符微调基于注释的自动装配</h4>
<div class="paragraph">
<p><code>@Primary</code>是一种有效的方法，可以在确定一个主要候选者时使用具有多个实例的类型进行自动装配。当您需要更多控制选择过程时，可以使用Spring的<code>@Qualifier</code>注释。您可以将限定符值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的bean。在最简单的情况下，这可以是一个简单的描述性值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <strong><span class="annotation">@Qualifier</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">main</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">私人</span> MovieCatalog movieCatalog; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以在各个构造函数参数或方法参数上指定<code>@Qualifier</code>注释，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="directive">private</span> MovieCatalog movieCatalog; <span class="directive">私人</span> CustomerPreferenceDao customerPreferenceDao; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> prepare（ <strong><span class="annotation">@Qualifier</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">main</span> <span class="delimiter">”</span></span> ）</strong> MovieCatalog movieCatalog，CustomerPreferenceDao customerPreferenceDao）{ <span class="local-variable">this</span> .movi​​eCatalog = movieCatalog; <span class="local-variable">这个</span> .customerPreferenceDao = customerPreferenceDao; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的bean定义。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">main</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">action</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">movieRecommender</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。MovieRecommender</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>具有<code>main</code>限定符值的bean与使用相同值限定的构造函数参数连接。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>具有<code>action</code>限定符值的bean与使用相同值限定的构造函数参数连接。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>对于回退匹配，bean名称被视为默认限定符值。因此，你可以定义与bean的<code>id</code>的<code>main</code> ，而不是嵌套预选赛元素，从而导致同样的匹配结果。但是，虽然您可以使用此约定来按名称引用特定bean，但<code>@Autowired</code>基本上是关于具有可选语义限定符的类型驱动注入。这意味着即使使用bean名称回退，限定符值在类型匹配集中也总是具有缩小的语义。它们在语义上不表示对唯一bean <code>id</code>的引用。良好的限定符值是<code>main</code>或<code>EMEA</code>或<code>persistent</code> ，表示独立于bean <code>id</code>的特定组件的特征，可以在匿名bean定义（例如前面示例中的定义）的情况下自动生成。</p>
</div>
<div class="paragraph">
<p>限定符也适用于类型集合，如前所述 - 例如， <code>Set&lt;MovieCatalog&gt;</code> 。在这种情况下，根据声明的限定符，所有匹配的bean都作为集合注入。这意味着限定符不必是唯一的。相反，它们构成过滤标准。例如，您可以使用相同的限定符值“action”定义多个<code>MovieCatalog</code> bean，所有这些bean都注入到使用<code>@Qualifier("action")</code>注释的<code>Set&lt;MovieCatalog&gt;</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在类型匹配候选项中，根据目标bean名称选择限定符值，在注入点不需要<code>@Qualifier</code>注释。如果没有其他解析指示符（例如限定符或主标记），则对于非唯一依赖性情况，Spring会将注入点名称（即字段名称或参数名称）与目标bean名称进行匹配，然后选择同名的候选人，如果有的话。</p>
</div>
<div class="paragraph">
<p>也就是说，如果您打算按名称表达注释驱动的注入，请不要主要使用<code>@Autowired</code> ，即使它能够在类型匹配候选项中通过bean名称进行选择。相反，使用JSR-250 <code>@Resource</code>注释，该注释在语义上定义为通过其唯一名称标识特定目标组件，声明的类型与匹配过程无关。<code>@Autowired</code>具有相当不同的语义：在按类型选择候选bean之后，仅在那些类型选择的候选项中考虑指定的<code>String</code>限定符值（例如，将<code>account</code>限定符与标记有相同限定符标签的bean匹配）。</p>
</div>
<div class="paragraph">
<p>对于本身定义为集合， <code>Map</code>或数组类型的bean， <code>@Resource</code>是一个很好的解决方案，通过唯一名称引用特定的集合或数组bean。也就是说，从4.3集合开始，只要元素类型信息保存在<code>@Bean</code>返回类型签名或集合继承层次结构中，您就可以通过Spring的<code>@Autowired</code>类型匹配算法匹配<code>Map</code>和数组类型。在这种情况下，您可以使用限定符值在相同类型的集合中进行选择，如上一段所述。</p>
</div>
<div class="paragraph">
<p>从4.3开始，@ <code>@Autowired</code>还会考虑自引用注入（即，引用回到当前注入的bean）。请注意，自我注入是一种后备。对其他组件的常规依赖性始终具有优先权。从这个意义上说，自我引用并不参与常规的候选人选择，因此特别是不是主要的。相反，它们总是最低优先级。在实践中，您应该仅使用自引用作为最后的手段（例如，通过bean的事务代理调用同一实例上的其他方法）。考虑在这种情况下将受影响的方法分解为单独的委托bean。或者，您可以使用<code>@Resource</code> ，它可以通过其唯一名称获取代理回到当前bean。</p>
</div>
<div class="paragraph">
<p><code>@Autowired</code>适用于字段，构造函数和多参数方法，允许在参数级别缩小限定符注释。相比之下， <code>@Resource</code>仅支持具有单个参数的字段和bean属性setter方法。因此，如果您的注入目标是构造函数或多参数方法，则应该使用限定符。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以创建自己的自定义限定符注释。为此，请定义注释并在定义中提供<code>@Qualifier</code>注释，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。FIELD， <span class="predefined-type">ElementType</span> 。PARAMETER}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <strong><span class="annotation">@Qualifier</span></strong> <span class="directive">public</span> <span class="annotation">@interface</span> Genre { <span class="predefined-type">String</span> value（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以在自动装配的字段和参数上提供自定义限定符，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">课</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <strong><span class="annotation">@Genre</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Action</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">私人</span> MovieCatalog actionCatalog; <span class="directive">私人</span> MovieCatalog喜剧目录; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setComedyCatalog（ <strong><span class="annotation">@Genre</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Comedy</span> <span class="delimiter">”</span></span> ）</strong> MovieCatalog comedyCatalog）{ <span class="local-variable">this</span> .comedyCatalog = comedyCatalog; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，您可以提供候选bean定义的信息。您可以将<code>&lt;qualifier/&gt;</code>标记添加为<code>&lt;bean/&gt;</code>标记的子元素，然后指定与自定义限定符注释匹配的<code>type</code>和<code>value</code> 。该类型与注释的完全限定类名匹配。或者，为方便起见，如果不存在冲突名称的风险，您可以使用短类名称。以下示例演示了两种方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Genre</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Action</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></strong> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。类型</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">喜剧</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></strong> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">movieRecommender</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。MovieRecommender</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#beans-classpath-scanning">类路径扫描和托管组件中</a> ，您可以看到基于注释的替代方法，即在XML中提供限定符元数据。具体来说，请参阅<a href="#beans-scanning-qualifiers">使用注释提供限定符元数据</a> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，使用没有值的注释可能就足够了。当注释用于更通用的目的并且可以跨多种不同类型的依赖项应用时，这可能很有用。例如，您可以提供可在没有Internet连接时搜索的脱机目录。首先，定义简单注释，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。FIELD， <span class="predefined-type">ElementType</span> 。PARAMETER}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Qualifier</span> <span class="directive">public</span> <span class="annotation">@interface</span> Offline {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后将注释添加到要自动装配的字段或属性中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">课</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <span class="annotation">@Offline</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">私人</span> MovieCatalog offlineCatalog; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>此行添加<code>@Offline</code>注释。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>现在bean定义只需要一个限定符<code>type</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">示例。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Offline</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>此元素指定限定符。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以定义除简单<code>value</code>属性之外或代替简单<code>value</code>属性接受命名属性的自定义限定符注释。如果随后在要自动装配的字段或参数上指定了多个属性值，则bean定义必须匹配所有此类属性值才能被视为自动装配候选。例如，请考虑以下注释定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。FIELD， <span class="predefined-type">ElementType</span> 。PARAMETER}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Qualifier</span> <span class="directive">public</span> <span class="annotation">@interface</span> MovieQualifier { <span class="predefined-type">String</span> genre（）; <span class="predefined-type">格式</span>格式（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>Format</code>是一个枚举，定义如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> <span class="predefined-type">格式</span> {VHS，DVD，BLURAY}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要自动装配的字段使用自定义限定符进行注释，并包含两个属性的值： <code>genre</code>和<code>format</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Autowired</span> <span class="annotation">@MovieQualifier</span> （格式= <span class="predefined-type">格式</span> 。VHS，genre = <span class="string"><span class="delimiter">“</span> <span class="content">Action</span> <span class="delimiter">”</span></span> ） <span class="directive">私人</span> MovieCatalog actionVhsCatalog; <span class="annotation">@Autowired</span> <span class="annotation">@MovieQualifier</span> （格式= <span class="predefined-type">格式</span> 。VHS，类型= <span class="string"><span class="delimiter">“</span> <span class="content">喜剧</span> <span class="delimiter">”</span></span> ） <span class="directive">私人</span> MovieCatalog <span class="string"><span class="content">喜剧</span></span>音乐剧目录; <span class="annotation">@Autowired</span> <span class="annotation">@MovieQualifier</span> （格式= <span class="predefined-type">格式</span> 。DVD，genre = <span class="string"><span class="delimiter">“</span> <span class="content">Action</span> <span class="delimiter">”</span></span> ） <span class="directive">私人</span> MovieCatalog actionDvdCatalog; <span class="annotation">@Autowired</span> <span class="annotation">@MovieQualifier</span> （格式= <span class="predefined-type">格式</span> 。BLURAY，genre = <span class="string"><span class="delimiter">“</span> <span class="content">喜剧</span> <span class="delimiter">”</span></span> ） <span class="directive">私人</span> MovieCatalog comedyBluRayCatalog; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，bean定义应包含匹配的限定符值。此示例还演示了您可以使用bean元属性而不是<code>&lt;qualifier/&gt;</code>元素。如果可用， <code>&lt;qualifier/&gt;</code>元素及其属性优先，但如果不存在此类限定符，则自动装配机制将回退到<code>&lt;meta/&gt;</code>标记内提供的值，如以下示例中的最后两个bean定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">MovieQualifier</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">format</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">VHS</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">genre</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Action</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ qualifier&gt;</span> <span class="comment">&lt;！ - 注入任何依赖项这个bean需要 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">MovieQualifier</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">format</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">VHS</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">genre</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Comedy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ qualifier&gt;</span> <span class="comment">&lt;！ - 注入任何依赖项这个bean需要 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;meta</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">format</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">DVD</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;meta</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">genre</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Action</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMovieCatalog</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;meta</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">format</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">BLURAY</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;meta</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">genre</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Comedy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 注入此bean所需的任何依赖项 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt; /豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a> 1.9.5。使用泛型作为自动装配限定符</h4>
<div class="paragraph">
<p>除了<code>@Qualifier</code>注释之外，您还可以使用Java泛型类型作为隐式的限定形式。例如，假设您具有以下配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> StringStore stringStore（）{ <span class="keyword">return</span> <span class="keyword">new</span> StringStore（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> IntegerStore integerStore（）{ <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设前面的bean实现了一个通用接口（即<code>Store&lt;String&gt;</code>和<code>Store&lt;Integer&gt;</code> ），您可以<code>@Autowire</code> <code>Store</code>接口，并将泛型用作限定符，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span> <span class="directive">private</span> Store &lt; <span class="predefined-type">String</span> &gt; s1; <span class="comment">// &lt;String&gt;限定符，注入stringStore bean</span> <span class="annotation">@Autowired</span> <span class="directive">private</span> Store &lt; <span class="predefined-type">Integer</span> &gt; s2; <span class="comment">// &lt;Integer&gt;限定符，注入integerStore bean</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通用限定符也适用于自动装配列表， <code>Map</code>实例和数组。以下示例自动装配通用<code>List</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//注入所有商店bean，只要它们具有&lt;Integer&gt;通用</span> <span class="comment">// Store &lt;String&gt; bean不会出现在此列表中</span> <span class="annotation">@Autowired</span> <span class="directive">private</span> <span class="predefined-type">List</span> &lt;Store &lt; <span class="predefined-type">Integer</span> &gt;&gt; s;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a> 1.9.6。使用<code>CustomAutowireConfigurer</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>是一个<code>BeanFactoryPostProcessor</code> ，它允许您注册自己的自定义限定符注释类型，即使它们没有使用Spring的<code>@Qualifier</code>注释进行注释。以下示例显示如何使用<code>CustomAutowireConfigurer</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">customAutowireConfigurer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.annotation。CustomAutowireConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customQualifierTypes</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;value&gt;</span>示例。CustomQualifier <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>AutowireCandidateResolver</code>通过以下方式确定autowire候选者：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个bean定义的<code>autowire-candidate</code>值</p>
</li>
<li>
<p><code>&lt;beans/&gt;</code>元素上可用的任何<code>default-autowire-candidates</code>模式</p>
</li>
<li>
<p>存在<code>@Qualifier</code>注释以及使用<code>CustomAutowireConfigurer</code>注册的任何自定义注释</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当多个bean有资格作为autowire候选者时，“primary”的确定如下：如果候选者中只有一个bean定义的<code>primary</code>属性设置为<code>true</code> ，则选择它。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a> 1.9.7。使用<code>@Resource</code>注入</h4>
<div class="paragraph">
<p>Spring还通过在字段或bean属性setter方法上使用JSR-250 <code>@Resource</code>注释来支持注入。这是Java EE 5和6中的常见模式（例如，在JSF 1.2托管bean或JAX-WS 2.0端点中）。Spring也支持Spring管理对象的这种模式。</p>
</div>
<div class="paragraph">
<p><code>@Resource</code>采用name属性。默认情况下，Spring将该值解释为要注入的bean名称。换句话说，它遵循按名称语义，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Resource</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">myMovieFinder</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>这行注入一个<code>@Resource</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果未明确指定名称，则默认名称是从字段名称或setter方法派生的。如果是字段，则采用字段名称。在setter方法的情况下，它采用bean属性名称。下面的例子将把名为<code>movieFinder</code>的bean注入其setter方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <strong><span class="annotation">@Resource</span></strong> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">随注释提供的名称由<code>ApplicationContext</code>解析为bean名称， <code>CommonAnnotationBeanPostProcessor</code>可以<code>CommonAnnotationBeanPostProcessor</code>该名称。如果您显式配置Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>则可以通过JNDI解析名称。但是，我们建议您依赖于默认行为并使用Spring的JNDI查找功能来保留间接级别。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在没有指定显式名称且类似于<code>@Autowired</code>的<code>@Resource</code>用法的独占情况下， <code>@Resource</code> <code>@Resource</code>找到主要类型匹配而不是特定的命名bean，并解析众所周知的可解析依赖项： <code>BeanFactory</code> ， <code>ApplicationContext</code> ， <code>ResourceLoader</code> ， <code>ApplicationEventPublisher</code>和<code>MessageSource</code>接口。</p>
</div>
<div class="paragraph">
<p>因此，在以下示例中， <code>customerPreferenceDao</code>字段首先查找名为customerPreferenceDao的bean，然后返回到<code>CustomerPreferenceDao</code>类型的主类型匹配：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieRecommender</span> { <span class="annotation">@Resource</span> <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao; <span class="annotation">@Resource</span> <span class="directive">私有</span> ApplicationContext上下文; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> MovieRecommender（）{} <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>基于已知的可解析依赖类型注入<code>context</code>字段： <code>ApplicationContext</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a> 1.9.8。使用<code>@PostConstruct</code>和<code>@PreDestroy</code></h4>
<div class="paragraph">
<p><code>CommonAnnotationBeanPostProcessor</code>不仅识别<code>@Resource</code>注释，还识别JSR-250生命周期注释。在Spring 2.5中引入，对这些注释的支持提供了<a href="#beans-factory-lifecycle-initializingbean">初始化回调</a>和<a href="#beans-factory-lifecycle-disposablebean">销毁回调中</a>描述的另一种替代<a href="#beans-factory-lifecycle-disposablebean">方法</a> 。如果<code>CommonAnnotationBeanPostProcessor</code>在Spring <code>ApplicationContext</code>注册，则在生命周期的同一点调用承载这些注释之一的方法，作为相应的Spring生命周期接口方法或显式声明的回调方法。在以下示例中，缓存在初始化时预先填充并在销毁时清除：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieLister</span> { <span class="annotation">@PostConstruct</span> <span class="directive">public</span> <span class="type">void</span> populateMovieCache（）{ <span class="comment">//在初始化时填充电影缓存...</span>} <span class="annotation">@PreDestroy</span> <span class="directive">public</span> <span class="type">void</span> clearMovieCache（）{ <span class="comment">//在销毁时清除电影缓存...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关组合各种生命周期机制的效果的详细信息，请参阅<a href="#beans-factory-lifecycle-combined-effects">组合生命周期机制</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-classpath-scanning"><a class="anchor" href="#beans-classpath-scanning"></a> 1.10。类路径扫描和托管组件</h3>
<div class="paragraph">
<p>本章中的大多数示例都使用XML来指定在Spring容器中生成每个<code>BeanDefinition</code>的配置元数据。上一节（ <a href="#beans-annotation-config">基于注释的容器配置</a> ）演示了如何通过源级注释提供大量配置元数据。但是，即使在这些示例中，“基本”bean定义也在XML文件中显式定义，而注释仅驱动依赖项注入。本节介绍通过扫描类路径隐式检测候选组件的选项。候选组件是与过滤条件匹配的类，并且具有向容器注册的相应bean定义。这消除了使用XML执行bean注册的需要。相反，您可以使用注释（例如， <code>@Component</code> ），AspectJ类型表达式或您自己的自定义筛选条件来选择哪些类具有向容器注册的bean定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring 3.0开始，Spring JavaConfig项目提供的许多功能都是核心Spring Framework的一部分。这允许您使用Java而不是使用传统的XML文件来定义bean。看看在<code>@Configuration</code> ， <code>@Bean</code> ， <code>@Import</code>和<code>@DependsOn</code>注释有关如何使用这些新功能的例子。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a> 1.10.1。<code>@Component</code>和进一步的刻板印象注释</h4>
<div class="paragraph">
<p><code>@Repository</code>注释是任何满足存储库角色或构造型（也称为数据访问对象或DAO）的类的标记。此标记的用途之一是异常的自动转换，如<a href="data-access.html#orm-exception-translation">异常转换中所述</a> 。</p>
</div>
<div class="paragraph">
<p>Spring提供了进一步的<code>@Component</code>型注释： <code>@Component</code> ， <code>@Service</code> <code>@Controller</code>和<code>@Controller</code> 。<code>@Component</code>是任何Spring管理组件的通用<code>@Component</code>型。
<code>@Repository</code> ， <code>@Service</code> <code>@Controller</code>和<code>@Controller</code>是<code>@Component</code>特殊化，用于更具体的用例（分别在持久性，服务和表示层中）。因此，您可以使用<code>@Component</code>注释组件类，但是，通过使用<code>@Repository</code> ， <code>@Service</code> <code>@Controller</code>或<code>@Controller</code>注释它们，您的类更适合通过工具处理或与方面关联。例如，这些刻板印象注释成为切入点的理想目标。<code>@Repository</code> ， <code>@Service</code> <code>@Controller</code>和<code>@Controller</code>还可以在Spring Framework的未来版本中携带其他语义。因此，如果您选择在服务层使用<code>@Component</code>或<code>@Service</code> Service， <code>@Service</code> Service显然是更好的选择。同样，如前所述，已经支持<code>@Repository</code>作为持久层中自动异常转换的标记。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a> 1.10.2。使用元注释和组合注释</h4>
<div class="paragraph">
<p>Spring提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。例如， <code>@Service</code>提到注解<a href="#beans-stereotype-annotations">早前</a>是间注释有<code>@Component</code> ，如下面的示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。TYPE） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Documented</span> <span class="annotation">@Component</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="annotation">@interface</span> Service { <span class="comment">// ....</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>Component</code>使<code>@Service</code>以与<code>@Component</code>相同的方式处理。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以组合元注释以创建“组合注释”。例如，Spring MVC的<code>@RestController</code>注释由<code>@Controller</code>和<code>@ResponseBody</code>组成。</p>
</div>
<div class="paragraph">
<p>此外，组合注释可以选择从元注释重新声明属性以允许自定义。当您只想公开元注释属性的子集时，这可能特别有用。例如，Spring的<code>@SessionScope</code>注释将范围名称硬编码为<code>session</code>但仍允许自定义<code>proxyMode</code> 。以下清单显示了<code>SessionScope</code>批注的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。TYPE， <span class="predefined-type">ElementType</span> 。方法}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Documented</span> <span class="annotation">@Scope</span> （WebApplicationContext。SCOPE_SESSION） <span class="directive">public</span> <span class="annotation">@interface</span> SessionScope { <span class="comment">/ ** * {@link Scope＃proxyMode}的别名。* &lt;p&gt;默认为{@link ScopedProxyMode＃TARGET_CLASS}。* /</span> <span class="annotation">@AliasFor</span> （annotation = Scope.class）ScopedProxyMode proxyMode（） <span class="keyword">默认为</span> ScopedProxyMode。TARGET_CLASS; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>@SessionScope</code>而不声明<code>proxyMode</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span> <strong><span class="annotation">@SessionScope</span></strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">SessionScopedService</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以覆盖<code>proxyMode</code>的值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span> <strong><span class="annotation">@SessionScope</span> （proxyMode = ScopedProxyMode。INTERFACES）</strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">SessionScopedUserService</span> <span class="directive">实现</span> UserService { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a> wiki页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a> 1.10.3。自动检测类和注册Bean定义</h4>
<div class="paragraph">
<p>Spring可以自动检测<code>BeanDefinition</code>型类，并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例。例如，以下两个类符合此类自动检测的条件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Autowired</span> <span class="directive">public</span> SimpleMovieLister（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">JpaMovieFinder</span> <span class="directive">实现</span>的MovieFinder { <span class="comment">省略掉了清晰//实现</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要自动检测这些类并注册相应的bean，您需要将<code>@ComponentScan</code>添加到<code>@Configuration</code>类，其中<code>basePackages</code>属性是这两个类的公共父包。（或者，您可以指定以逗号或分号或空格分隔的列表，其中包含每个类的父包。）</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为简洁起见，前面的示例可能使用了注释的<code>value</code>属性（即<code>@ComponentScan("org.example")</code> ）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下替代方法使用XML：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/豆类&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>&lt;context:component-scan&gt;</code>隐式启用<code>&lt;context:annotation-config&gt;</code> 。使用<code>&lt;context:component-scan&gt;</code>时，通常不需要包含<code>&lt;context:annotation-config&gt;</code>元素。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用Ant构建JAR时，请确保不要激活JAR任务的仅文件开关。此外，在某些环境中，可能不会基于安全策略公开类路径目录 - 例如，JDK 1.7.0_45及更高版本上的独立应用程序（需要在清单中设置“Trusted-Library”） - 请参阅<a href="http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">http://stackoverflow.com/ questions / 19394570 / java-jre-7u45-breaks-classloader-getresources</a> ）。</p>
</div>
<div class="paragraph">
<p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常按预期工作。但是，请确保在<code>module-info</code>描述符中导出组件类。如果您希望Spring调用类的非公共成员，请确保它们已“打开”（即，它们在<code>module-info</code>描述符中使用<code>opens</code>声明而不是<code>exports</code>声明）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此外，使用component-scan元素时，将隐式包含<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code> 。这意味着这两个组件是自动检测并连接在一起的 - 所有这些都没有在XML中提供任何bean配置元数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以通过包含值为<code>false</code>的annotation-config属性来禁用<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>的注册。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a> 1.10.4。使用过滤器自定义扫描</h4>
<div class="paragraph">
<p>默认情况下，使用<code>@Component</code> ， <code>@Repository</code> ， <code>@Service</code> <code>@Controller</code> ， <code>@Repository</code>注释的<code>@Component</code>或自身使用<code>@Component</code>注释的自定义注释是唯一检测到的候选组件。但是，您可以通过应用自定义筛选器来修改和扩展此行为。将它们添加为<code>@ComponentScan</code>注释的<code>includeFilters</code>或<code>excludeFilters</code>参数（或作为<code>component-scan</code>元素的<code>include-filter</code>或<code>exclude-filter</code>子元素）。每个filter元素都需要<code>type</code>和<code>expression</code>属性。下表介绍了筛选选项：</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表5。过滤类型</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">过滤器类型</th>
<th class="tableblock halign-left valign-top">示例表达</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释（默认）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example。SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要在目标组件中的类型级别出现的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example。SomeClass的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">目标组件可分配给（扩展或实现）的类（或接口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example ..*服务+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要由目标组件匹配的AspectJ类型表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">正则表达式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>组织\。实例\。默认。*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要由目标组件类名匹配的正则表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">习惯</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example。MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.type .自定义实现<code>org.springframework.core.type .TypeFilter</code>接口。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下示例显示忽略所有<code>@Repository</code>注释并使用“存根”存储库的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> ，includeFilters = <span class="annotation">@Filter</span> （type = FilterType。REGEX，pattern = <span class="string"><span class="delimiter">“</span> <span class="content">。*存根。* Repository</span> <span class="delimiter">“</span></span> ），excludeFilters = <span class="annotation">@Filter</span> （Repository.class）） <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了等效的XML：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：include-filter</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">regex</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">。*存根。*存储库</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;context：exclude-filter</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">”</span> <span class="content">annotation</span> <span class="delimiter">“</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.stereotype。存储库</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ context：component-scan&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以通过在注释上设置<code>useDefaultFilters=false</code>或通过提供<code>use-default-filters="false"</code>作为<code>&lt;component-scan/&gt;</code>元素的属性来禁用默认过滤器。实际上，这会禁用自动检测使用<code>@Component</code> <code>@Repository</code> ， <code>@Service</code> <code>@Component</code> ， <code>@Repository</code> ， <code>@Service</code> <code>@Controller</code>或<code>@Configuration</code>注释的<code>@Component</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a> 1.10.5。在组件中定义Bean元数据</h4>
<div class="paragraph">
<p>Spring组件还可以向容器提供bean定义元数据。您可以使用用于在<code>@Configuration</code>注释类中定义bean元数据的相同<code>@Bean</code>注释来执行此操作。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">FactoryMethodComponent</span> <span class="annotation">{@Bean</span> <span class="annotation">@Qualifier（</span> <span class="string"><span class="delimiter">“</span> <span class="content">公共</span> <span class="delimiter">”）</span></span> <span class="directive">公共</span> testBean就publicInstance（）{ <span class="keyword">返回</span> <span class="keyword">新</span> testBean这个（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“publicInstance”）;</span></span></span></span> } <span class="directive">public</span> <span class="type">void</span> doWork（）{ <span class="comment">//忽略组件方法实现</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的类是一个Spring组件，在其<code>doWork()</code>方法中具有特定于应用程序的代码。但是，它还提供了一个bean定义，它具有引用<code>publicInstance()</code>方法的工厂方法。<code>@Bean</code>批注标识工厂方法和其他bean定义属性，例如通过<code>@Qualifier</code>批注的限定符值。可以指定的其他方法级注释是<code>@Scope</code> <code>@Lazy</code> ， <code>@Scope</code> <code>@Lazy</code>和自定义限定符注释。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">除了它对组件初始化的作用外，您还可以将<code>@Lazy</code>注释放在标有<code>@Autowired</code>或<code>@Inject</code>注入点上。在这种情况下，它会导致注入惰性解析代理。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如前所述，支持自动<code>@Bean</code>字段和方法，以及对<code>@Bean</code>方法的自动<code>@Bean</code>额外支持。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">FactoryMethodComponent</span> { <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> i; <span class="annotation">@Bean</span> <span class="annotation">@Qualifier（</span> <span class="string"><span class="delimiter">“</span> <span class="content">公共</span> <span class="delimiter">”）</span></span> <span class="directive">公共</span> testBean就publicInstance（）{ <span class="keyword">返回</span> <span class="keyword">新</span> testBean这个（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“publicInstance”）;</span></span></span></span> <span class="comment">使用自定义限定符和自动装配方法参数</span> <span class="annotation">@Bean</span> <span class="directive">protected</span> TestBean protectedInstance（ <span class="annotation">@Qualifier</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">public</span> <span class="delimiter">”</span></span> ）TestBean spouse， <span class="annotation">@ Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">＃{privateInstance.age}</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> country）{TestBean tb = <span class="keyword">new</span> TestBean （ <span class="string"><span class="delimiter">“</span> <span class="content">protectedInstance</span> <span class="delimiter">”</span></span> ， <span class="integer">1</span> ）; tb.setSpouse（配偶）; tb.setCountry（国家）; <span class="keyword">返回</span> } <span class="annotation">@Bean</span> <span class="directive">private</span> TestBean privateInstance（）{ <span class="keyword">return</span> <span class="keyword">new</span> TestBean（ <span class="string"><span class="delimiter">“</span> <span class="content">privateInstance</span> <span class="delimiter">”</span></span> ，i ++）; } <span class="annotation">@Bean</span> <span class="annotation">@RequestScope</span> <span class="directive">public</span> TestBean requestScopedInstance（）{ <span class="keyword">return</span> <span class="keyword">new</span> TestBean（ <span class="string"><span class="delimiter">“</span> <span class="content">requestScopedInstance</span> <span class="delimiter">”</span></span> ， <span class="integer">3</span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例将<code>String</code>方法参数<code>country</code>自动装配到另一个名为<code>privateInstance</code> bean上的<code>age</code>属性的值。Spring Expression Language元素通过符号<code>#{ &lt;expression&gt; }</code>定义属性的值。对于<code>@Value</code>注释，表达式解析器预先配置为在解析表达式文本时查找bean名称。</p>
</div>
<div class="paragraph">
<p>从Spring Framework 4.3开始，您还可以声明一个类型为<code>InjectionPoint</code>的工厂方法参数（或其更具体的子类： <code>DependencyDescriptor</code> ）来访问触发创建当前bean的请求注入点。请注意，这仅适用于实例创建bean实例，而不适用于注入现有实例。因此，此功能对原型范围的bean最有意义。对于其他作用域，工厂方法只能看到触发在给定作用域中创建新bean实例的注入点（例如，触发创建惰性单例bean的依赖项）。在这种情况下，您可以使用提供的注入点元数据和语义关注。以下示例显示了如何使用<code>InjectionPoint</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">FactoryMethodComponent</span> <span class="annotation">{@Bean</span> <span class="annotation">@Scope（</span> <span class="string"><span class="delimiter">“</span> <span class="content">原型</span> <span class="delimiter">”）</span></span> <span class="directive">公开</span> testBean这个prototypeInstance（InjectionPoint injectionPoint）{ <span class="keyword">返回</span> <span class="keyword">新</span> testBean这个（ <span class="string"><span class="content"><span class="delimiter">“prototypeInstance</span>为</span> <span class="delimiter">”</span></span> + injectionPoint.getMember（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>常规Spring组件中的<code>@Bean</code>方法的处理方式与Spring <code>@Configuration</code>类中的对应方式不同。不同之处在于，使用CGLIB不会增强<code>@Component</code>类来拦截方法和字段的调用。CGLIB代理是调用<code>@Configuration</code>类中的<code>@Bean</code>方法中的方法或字段创建对协作对象的bean元数据引用的方法。这些方法不是使用普通的Java语义调用的，而是通过容器来提供通常的生命周期管理和Spring bean的代理，即使通过对<code>@Bean</code>方法的编程调用引用其他bean <code>@Bean</code> 。相反，在普通<code>@Component</code>类中调用<code>@Bean</code>方法中的方法或字段具有标准Java语义，不应用特殊的CGLIB处理或其他约束。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以将<code>@Bean</code>方法声明为<code>static</code> ，允许在不创建包含配置类作为实例的情况下调用它们。这在定义后处理器bean（例如，类型为<code>BeanFactoryPostProcessor</code>或<code>BeanPostProcessor</code> ）时特别有意义，因为这样的bean在容器生命周期的早期初始化，并且应避免在此时触发配置的其他部分。</p>
</div>
<div class="paragraph">
<p>由于技术限制，对静态<code>@Bean</code>方法的调用永远不会被容器截获，甚至在<code>@Configuration</code>类中也没有（如本节前面所述）：CGLIB子类化只能覆盖非静态方法。因此，直接调用另一个<code>@Bean</code>方法具有标准的Java语义，从而导致直接从工厂方法本身返回一个独立的实例。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code>方法的Java语言可见性不会立即影响Spring容器中的结果bean定义。您可以随意声明非<code>@Configuration</code>类中的工厂方法以及任何地方的静态方法。然而，常规<code>@Bean</code>的方法<code>@Configuration</code>类需要被重写的-也就是说，他们不能被声明为<code>private</code>或<code>final</code> 。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code>方法也可以在给定组件或配置类的基类上发现，也可以在组件或配置类实现的接口中声明的Java 8默认方法上发现。这使得组成复杂配置安排具有很大的灵活性，从Spring 4.2开始，甚至可以通过Java 8默认方法实现多重继承。</p>
</div>
<div class="paragraph">
<p>最后，单个类可以为同一个bean保存多个<code>@Bean</code>方法，作为根据运行时可用依赖项使用的多个工厂方法的安排。这与在其他配置方案中选择“最贪婪”构造函数或工厂方法的算法相同：在构造时选择具有最多可满足依赖项的变体，类似于容器在多个<code>@Autowired</code>构造函数之间进行选择的方式。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a> 1.10.6。命名自动检测组件</h4>
<div class="paragraph">
<p>当组件作为扫描过程的一部分自动检测时，其bean名称由该扫描程序已知的<code>BeanNameGenerator</code>策略生成。默认情况下，任何包含名称<code>value</code> Spring <code>@Component</code>型注释（ <code>@Component</code> ， <code>@Repository</code> ， <code>@Service</code> <code>@Controller</code>和<code>@Controller</code> ）都会将该名称提供给相应的bean定义。</p>
</div>
<div class="paragraph">
<p>如果此类注释不包含任何名称<code>value</code>或任何其他检测到的组件（例如自定义过滤器发现的那些组件），则默认的bean名称生成器将返回未大写的非限定类名称。例如，如果检测到以下组件类，则名称为<code>myMovieLister</code>和<code>movieFinderImpl</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">myMovieLister</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleMovieLister</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieFinderImpl</span> <span class="directive">实现</span>的MovieFinder <span class="comment">{// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您不想依赖默认的bean命名策略，则可以提供自定义bean命名策略。首先，实现<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a>接口，并确保包含默认的无参数构造函数。然后，在配置扫描程序时提供完全限定的类名，如以下示例注释和bean定义所示：</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> ，nameGenerator = MyNameGenerator.class） <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> <span class="attribute-name">name-generator</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example。MyNameGenerator</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>作为一般规则，考虑在其他组件可能对其进行显式引用时使用注释指定名称。另一方面，只要容器负责接线，自动生成的名称就足够了。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a> 1.10.7。为自动检测组件提供范围</h4>
<div class="paragraph">
<p>与一般的Spring管理组件一样，自动检测组件的默认和最常见的范围是<code>singleton</code> 。但是，有时您需要一个可由<code>@Scope</code>注释指定的不同范围。您可以在注释中提供范围的名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scope</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">prototype</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MovieFinderImpl</span> <span class="directive">实现</span> MovieFinder { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@Scope</code>注释仅在具体bean类（对于带注释的组件）或工厂方法（对于<code>@Bean</code>方法）上进行了<code>@Bean</code> 。与XML bean定义相比，没有bean定义继承的概念，类级别的继承层次结构与元数据目的无关。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关特定于Web的范围（如Spring上下文中的“request”或“session”）的详细信息，请参阅<a href="#beans-factory-scopes-other">请求，会话，应用程序和WebSocket范围</a> 。与这些范围的预构建注释一样，您也可以使用Spring的元注释方法编写自己的范围注释：例如，使用<code>@Scope("prototype")</code>元注释的自定义注释，可能还会声明自定义范围代理模式。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要为范围解析提供自定义策略而不是依赖基于注释的方法，可以实现<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a>接口。请确保包含默认的无参数构造函数。然后，您可以在配置扫描程序时提供完全限定的类名，因为以下注释和bean定义示例显示：</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> ，scopeResolver = MyScopeResolver.class） <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> <span class="attribute-name">scope-resolver</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example。MyScopeResolver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用某些非单例范围时，可能需要为范围对象生成代理。这种推理在<a href="#beans-factory-scopes-other-injection">Scoped Beans中</a>描述<a href="#beans-factory-scopes-other-injection">为依赖关系</a> 。为此，组件扫描元素上提供了scoped-proxy属性。三个可能的值是： <code>no</code> ， <code>interfaces</code>和<code>targetClass</code> 。例如，以下配置导致标准JDK动态代理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> ，scopedProxy = ScopedProxyMode。INTERFACES） <span class="directive">公共</span> <span class="type">课</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> <span class="attribute-name">scoped-proxy</span> = <span class="string"><span class="delimiter">“</span> <span class="content">interfaces</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a> 1.10.8。使用注释提供限定符元数据</h4>
<div class="paragraph">
<p>在<a href="#beans-autowired-annotation-qualifiers">使用限定符微调基于注释的自动装配中</a>讨论了<code>@Qualifier</code>注释。该部分中的示例演示了在解析自动线候选时使用<code>@Qualifier</code>注释和自定义限定符注释来提供细粒度控制。因为这些实施例是基于XML bean定义，限定符元数据是通过使用设置在候选bean定义<code>qualifier</code>或<code>meta</code>的的子元素<code>bean</code>中的XML元素。当依靠类路径扫描来自动检测组件时，您可以在候选类上为类型级注释提供限定符元数据。以下三个示例演示了此技术：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <strong><span class="annotation">@Qualifier</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Action</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ActionMovieCatalog</span> <span class="directive">实现</span> MovieCatalog { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <strong><span class="annotation">@Genre</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Action</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ActionMovieCatalog</span> <span class="directive">实现</span> MovieCatalog { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <strong><span class="annotation">@Offline</span></strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">CachingMovieCatalog</span> <span class="directive">实现</span> MovieCatalog { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与大多数基于注释的备选方案一样，请记住注释元数据绑定到类定义本身，而XML的使用允许多个相同类型的bean在其限定符元数据中提供变体，因为每个元数据都是按照 - 实例而不是每班。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a> 1.10.9。生成候选组件索引</h4>
<div class="paragraph">
<p>虽然类路径扫描非常快，但可以通过在编译时创建候选的静态列表来提高大型应用程序的启动性能。在此模式下，应用程序的所有模块都必须使用此机制，因为当<code>ApplicationContext</code>检测到此类索引时，它会自动使用它而不是扫描类路径。</p>
</div>
<div class="paragraph">
<p>要生成索引，请为包含作为组件扫描指令目标的组件的每个模块添加其他依赖项。以下示例显示了如何使用Maven执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> org.springframework <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> spring-context-indexer <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 5.1.0。RELEASE <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;optional&gt;</span> true <span class="tag">&lt;/ optional&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="tag">&lt;/ dependencies&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用Gradle执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">依赖项{compileOnly（ <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework：spring-context-indexer：5.1.0。发布</span> <span class="delimiter">“</span></span> ）}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该过程生成包含在jar文件中的<code>META-INF/spring.components</code>文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在IDE中使用此模式时，必须将<code>spring-context-indexer</code>注册为注释处理器，以确保在更新候选组件时索引是最新的。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在类路径中找到<code>META-INF/spring.components</code>时，将自动启用索引。如果索引部分可用于某些库（或用例）但无法为整个应用程序构建，则可以通过将<code>spring.index.ignore</code>设置为回退到常规类路径排列（就好像根本没有索引） <code>true</code> ，无论是作为一个系统属性或在<code>spring.properties</code>在类路径的根文件。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-standard-annotations"><a class="anchor" href="#beans-standard-annotations"></a> 1.11。使用JSR 330标准注释</h3>
<div class="paragraph">
<p>从Spring 3.0开始，Spring提供对JSR-330标准注释（依赖注入）的支持。这些注释的扫描方式与Spring注释相同。要使用它们，您需要在类路径中包含相关的jar。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您使用Maven，则<code>javax.inject</code>工件可在标准Maven存储库中找到（ <a href="http://repo1.maven.org/maven2/javax/inject/javax.inject/1/">http://repo1.maven.org/maven2/javax/inject/javax.inject/1/</a> ）。您可以将以下依赖项添加到文件pom.xml：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> javax.inject <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> javax.inject <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;/ dependency&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-inject-named"><a class="anchor" href="#beans-inject-named"></a> 1.11.1。使用<code>@Inject</code>和<code>@Named</code>依赖注入</h4>
<div class="paragraph">
<p>您可以使用<code>@javax.inject.代替<code>@Autowired</code> <code>@javax.inject.Inject</code>如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject。注入</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; <span class="directive">public</span> <span class="type">void</span> listMovies（）{ <span class="local-variable">this</span> .movi​​eFinder.findMovies（...）; ...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与<code>@Autowired</code> ，您可以在字段级别，方法级别和构造函数 - 参数级别使用<code>@Inject</code> 。此外，您可以将注入点声明为<code>Provider</code> ，允许按需访问较短范围的bean或通过<code>Provider.get()</code>调用对其他bean的延迟访问。以下示例提供了前面示例的变体：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject。注入</span> ; <span class="keyword">import</span> <span class="include">javax.inject。提供者</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> <span class="predefined-type">Provider</span> &lt;MovieFinder&gt; movieFinder; <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（ <span class="predefined-type">Provider</span> &lt;MovieFinder&gt; movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; <span class="directive">public</span> <span class="type">void</span> listMovies（）{ <span class="local-variable">this</span> .movi​​eFinder.get（）。findMovies（...）; ...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要为应注入的依赖项使用限定名称，则应使用<code>@Named</code>批注，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject。注入</span> ; <span class="keyword">import</span> <span class="include">javax.inject。命名</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（ <span class="annotation">@Named</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">main</span> <span class="delimiter">”</span></span> ）MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与<code>@Autowired</code> ，@ <code>@Inject</code>也可以与<code>java.util.一起使用<code>java.util.Optional</code>或<code>@Nullable</code> 。这在这里更适用，因为<code>@Inject</code>没有<code>required</code>属性。以下一对示例显示了如何使用<code>@Inject</code>和<code>@Nullable</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（Optional &lt;MovieFinder&gt; movieFinder）{...}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（ <span class="annotation">@Nullable</span> MovieFinder movieFinder）{...}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-named"><a class="anchor" href="#beans-named"></a> 1.11.2。<code>@Named</code>和<code>@ManagedBean</code> ： <code>@Component</code>注释的标准等价物</h4>
<div class="paragraph">
<p>您可以使用<code>@javax.inject.代替<code>@Component</code> <code>@javax.inject.Named</code>或<code>javax.annotation.ManagedBean</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject。注入</span> ; <span class="keyword">import</span> <span class="include">javax.inject。命名</span> ; <span class="annotation">@Named</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">movieListener</span> <span class="delimiter">”</span></span> ） <span class="comment">// @ManagedBean（“movieListener”）可以用作</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在不指定组件名称的情况下使用<code>@Component</code>是很常见的。
<code>@Named</code>可以以类似的方式使用，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject。注入</span> ; <span class="keyword">import</span> <span class="include">javax.inject。命名</span> ; <span class="annotation">@Named</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="annotation">@Inject</span> <span class="directive">public</span> <span class="type">void</span> setMovieFinder（MovieFinder movieFinder）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用<code>@Named</code>或<code>@ManagedBean</code> ，可以使用与使用Spring注释时完全相同的方式使用组件扫描，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">org.example</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与<code>@Component</code> ，JSR-330 <code>@Named</code>和JSR-250 <code>ManagedBean</code>注释不可组合。您应该使用Spring的构造型模型来构建自定义组件注释。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-standard-annotations-limitations"><a class="anchor" href="#beans-standard-annotations-limitations"></a> 1.11.3。JSR-330标准注释的局限性</h4>
<div class="paragraph">
<p>使用标准注释时，您应该知道某些重要功能不可用，如下表所示：</p>
</div>
<table id="annotations-comparison" class="tableblock frame-all grid-all spread">
<caption class="title">表6。Spring组件模型元素与JSR-330变体</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">弹簧</th>
<th class="tableblock halign-left valign-top">javax.inject。*</th>
<th class="tableblock halign-left valign-top">javax.inject限制/评论</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Autowired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@注入</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Inject</code>没有'required'属性。可以与Java 8的<code>Optional</code>一起使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@零件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Named / @ManagedBean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330不提供可组合模型，只是一种识别命名组件的方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Scope（ “单”）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@辛格尔顿</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330的默认范围就像Spring的<code>prototype</code> 。但是，为了使其与Spring的一般默认值保持一致，默认情况下，Spring容器中声明的JSR-330 bean是一个<code>singleton</code> 。为了使用除<code>singleton</code>之外的范围，您应该使用Spring的<code>@Scope</code>注释。 <code>javax.inject</code>还提供了<a href="http://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a>注释。然而，这个仅用于创建自己的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier / @Named</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject。Qualifier</code>只是构建自定义限定符的元注释。具体的<code>String</code>限定符（如Spring的带有值的<code>@Qualifier</code> ）可以通过<code>javax.inject.关联<code>javax.inject.Named</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有等价物</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@需要</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有等价物</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@懒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有等价物</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">的ObjectFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供商</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject。Provider</code>是Spring的<code>ObjectFactory</code>的直接替代品，只有更短的<code>get()</code>方法名称。它也可以与Spring的<code>@Autowired</code>结合使用，也可以与非注释的构造函数和setter方法结合使用。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-java"><a class="anchor" href="#beans-java"></a> 1.12。基于Java的容器配置</h3>
<div class="paragraph">
<p>本节介绍如何在Java代码中使用注释来配置Spring容器。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-java-basic-concepts">基本概念： <code>@Bean</code>和<code>@Configuration</code></a></p>
</li>
<li>
<p><a href="#beans-java-instantiating-container">使用<code>AnnotationConfigApplicationContext</code>实例化Spring容器</a></p>
</li>
<li>
<p><a href="#beans-java-bean-annotation">使用<code>@Bean</code>注释</a></p>
</li>
<li>
<p><a href="#beans-java-configuration-annotation">使用<code>@Configuration</code>注释</a></p>
</li>
<li>
<p><a href="#beans-java-composing-configuration-classes">编写基于Java的配置</a></p>
</li>
<li>
<p><a href="#beans-definition-profiles">Bean定义配置文件</a></p>
</li>
<li>
<p><a href="#beans-property-source-abstraction"><code>PropertySource</code>抽象</a></p>
</li>
<li>
<p><a href="#beans-using-propertysource">使用<code>@PropertySource</code></a></p>
</li>
<li>
<p><a href="#beans-placeholder-resolution-in-statements">占位符决议在声明中</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beans-java-basic-concepts"><a class="anchor" href="#beans-java-basic-concepts"></a> 1.12.1。基本概念： <code>@Bean</code>和<code>@Configuration</code></h4>
<div class="paragraph">
<p>Spring新的Java配置支持中的中心工件是<code>@Configuration</code> -annotated类和<code>@Bean</code> -annotated方法。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code>注释用于指示方法实例化，配置和初始化由Spring IoC容器管理的新对象。对于那些熟悉Spring的<code>&lt;beans/&gt;</code> XML配置的人来说， <code>@Bean</code>注释扮演的角色与<code>&lt;bean/&gt;</code>元素相同。您可以将<code>@Bean</code> -annotated方法与任何Spring <code>@Component</code> 。但是，它们最常用于<code>@Configuration</code> bean。</p>
</div>
<div class="paragraph">
<p>使用<code>@Configuration</code>注释类表示其主要目的是作为bean定义的源。此外， <code>@Configuration</code> <code>@Bean</code>类允许通过调用同一个类中的其他<code>@Bean</code>方法来定义bean间依赖关系。最简单的<code>@Configuration</code>类如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> MyService myService（）{ <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的<code>AppConfig</code>类等效于以下Spring <code>&lt;beans/&gt;</code> XML：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.acme.services。MyServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">完整@Configuration vs“lite”@Bean模式？</div>
<div class="paragraph">
<p>当<code>@Bean</code>方法在未使用<code>@Configuration</code>注释的类中声明时，它们被称为以“lite”模式处理。在<code>@Component</code>或甚至在普通旧类中声明的Bean方法被认为是“lite”，包含类的主要目的不同，而<code>@Bean</code>方法在那里是一种奖励。例如，服务组件可以通过在每个适用的组件类上使用额外的<code>@Bean</code>方法将管理视图公开给容器。在这种情况下， <code>@Bean</code>方法是一种通用的工厂方法机制。</p>
</div>
<div class="paragraph">
<p>与完整的<code>@Configuration</code>不同，lite <code>@Bean</code>方法不能声明bean间依赖关系。相反，它们对其包含组件的内部状态进行操作，并且可选地，对它们可能声明的参数进行操作。因此，这样的<code>@Bean</code>方法不应该调用其他<code>@Bean</code>方法。每个这样的方法实际上只是特定bean引用的工厂方法，没有任何特殊的运行时语义。这里的积极副作用是不必在运行时应用CGLIB子类，因此在类设计方面没有限制（即，包含类可能是<code>final</code> ，依此类推）。</p>
</div>
<div class="paragraph">
<p>在常见的场景中， <code>@Bean</code>方法将在<code>@Configuration</code>类中声明，确保始终使用“完整”模式，并因此将交叉方法引用重定向到容器的生命周期管理。这可以防止通过常规Java调用意外地调用相同的<code>@Bean</code>方法，这有助于减少在“精简”模式下操作时难以跟踪的细微错误。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@Bean</code>和<code>@Configuration</code>注释将在以下部分中进行深入讨论。然而，首先，我们将介绍使用基于Java的配置创建弹簧容器的各种方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-instantiating-container"><a class="anchor" href="#beans-java-instantiating-container"></a> 1.12.2。使用<code>AnnotationConfigApplicationContext</code>实例化Spring容器</h4>
<div class="paragraph">
<p>以下部分介绍了Spring的<code>AnnotationConfigApplicationContext</code> ，它是在Spring 3.0中引入的。这个多功能的<code>ApplicationContext</code>实现不仅能够接受<code>@Configuration</code>类作为输入，还能接受使用JSR-330元数据注释的普通<code>@Component</code>类和类。</p>
</div>
<div class="paragraph">
<p>当<code>@Configuration</code>类作为输入提供时， <code>@Configuration</code> <code>@Bean</code>类本身被注册为bean定义，并且类中所有声明的<code>@Bean</code>方法也被注册为bean定义。</p>
</div>
<div class="paragraph">
<p>当提供<code>@Component</code>和JSR-330类时，它们被注册为bean定义，并且假设在必要时在这些类中使用诸如<code>@Autowired</code>或<code>@Inject</code>之类的DI元数据。</p>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-contstructor"><a class="anchor" href="#beans-java-instantiating-container-contstructor"></a>简单的施工</h5>
<div class="paragraph">
<p>与实例化<code>ClassPathXmlApplicationContext</code>时Spring XML文件用作输入的方式大致相同，在实例化<code>AnnotationConfigApplicationContext</code>时可以使用<code>@Configuration</code>类作为输入。这允许完全无XML使用Spring容器，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（AppConfig.class）; MyService myService = ctx.getBean（MyService.class）; myService.doStuff（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如前所述， <code>AnnotationConfigApplicationContext</code>不仅限于使用<code>@Configuration</code>类。任何<code>@Component</code>或JSR-330带注释的类都可以作为输入提供给构造函数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（MyServiceImpl.class，Dependency1.class，Dependency2.class）; MyService myService = ctx.getBean（MyService.class）; myService.doStuff（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例假定<code>MyServiceImpl</code> ， <code>Dependency1</code>和<code>Dependency2</code>使用Spring依赖注入注释，例如<code>@Autowired</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-register"><a class="anchor" href="#beans-java-instantiating-container-register"></a>使用<code>register(Class&lt;?以编程方式构建容器<code>register(Class&lt;?&gt; ...）</code></h5>
<div class="paragraph">
<p>您可以使用no-arg构造函数实例化<code>AnnotationConfigApplicationContext</code> ，然后使用<code>register()</code>方法对其进行配置。在以编程方式构建<code>AnnotationConfigApplicationContext</code>时，此方法特别有用。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（）; ctx.register（AppConfig.class，OtherConfig.class）; ctx.register（AdditionalConfig.class）; ctx.refresh（）; MyService myService = ctx.getBean（MyService.class）; myService.doStuff（）; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-scan"><a class="anchor" href="#beans-java-instantiating-container-scan"></a>使用<code>scan(String…​)</code>启用组件<code>scan(String…​)</code></h5>
<div class="paragraph">
<p>要启用组件扫描，可以按如下方式注释<code>@Configuration</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （basePackages = <span class="string"><span class="delimiter">“</span> <span class="content">com.acme</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">AppConfig</span> {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>此注释可启用组件扫描。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有经验的Spring用户可能熟悉与Spring的<code>context:</code> namespace相同的XML声明，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.acme</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在前面的示例中，扫描<code>com.acme</code>包以查找任何<code>@Component</code> -annotated类，并将这些类注册为容器中的Spring bean定义。<code>AnnotationConfigApplicationContext</code>公开<code>scan(String…​)</code>方法以允许相同的组件扫描功能，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（）; ctx.scan（ <span class="string"><span class="delimiter">“</span> <span class="content">com.acme</span> <span class="delimiter">”</span></span> ）; ctx.refresh（）; MyService myService = ctx.getBean（MyService.class）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请记住<code>@Configuration</code>类是使用<code>@Component</code>进行<a href="#beans-meta-annotations">元注释的</a> ，因此它们是组件扫描的候选者。在前面的示例中，假设<code>AppConfig</code>在<code>com.acme</code>包（或下面的任何包）中声明，它在<code>scan()</code>调用期间被拾取。在<code>refresh()</code> ，它的所有<code>@Bean</code>方法都被处理并在容器中注册为bean定义。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-web"><a class="anchor" href="#beans-java-instantiating-container-web"></a>使用<code>AnnotationConfigWebApplicationContext</code>支持Web应用程序</h5>
<div class="paragraph">
<p>一个<code>WebApplicationContext</code>变种<code>AnnotationConfigApplicationContext</code>可与<code>AnnotationConfigWebApplicationContext</code> 。配置Spring <code>ContextLoaderListener</code> servlet侦听器，Spring MVC <code>DispatcherServlet</code> ，可以使用此实现。以下<code>web.xml</code>代码段配置典型的Spring MVC Web应用程序（请注意<code>contextClass</code> context-param和init-param的使用）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span> <span class="comment">&lt;！ - 配置ContextLoaderListener以使用AnnotationConfigWebApplicationContext而不是默认的XmlWebApplicationContext  - &gt;</span> <span class="tag">&lt;context-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextClass <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> org.springframework.web。 context.support。AnnotationConfigWebApplicationContext <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ context-param&gt;</span> <span class="comment">&lt;！ - 配置位置必须包含一个或多个以逗号或空格分隔的完全限定的@Configuration类。也可以为组件扫描指定完全限定的包 - &gt;</span> <span class="tag">&lt;context-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> com.acme。AppConfig <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ context-param&gt;</span> <span class="comment">&lt;！ - 使用ContextLoaderListener  - &gt;</span> <span class="tag">&lt;listener&gt;</span> <span class="tag">&lt;listener-class&gt;</span> org.springframework.web.context <span class="comment">，照常启动根应用程序上下文</span> 。ContextLoaderListener <span class="tag">&lt;/ listener-class&gt;</span> <span class="tag">&lt;/ listener&gt;</span> <span class="comment">&lt;！ - 像往常一样声明Spring MVC DispatcherServlet  - &gt;</span> <span class="tag">&lt;servlet&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> dispatcher <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;servlet-class&gt;</span> org.springframework.web .servlet。DispatcherServlet <span class="tag">&lt;/ servlet-class&gt;</span> <span class="comment">&lt;！ - 将DispatcherServlet配置为使用AnnotationConfigWebApplicationContext而不是默认的XmlWebApplicationContext  - &gt;</span> <span class="tag">&lt;init-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextClass <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> org.springframework。 web.context.support。AnnotationConfigWebApplicationContext <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ init-param&gt;</span> <span class="comment">&lt;！ - 同样，配置位置必须包含一个或多个逗号或空格分隔和完全限定的@Configuration类 - &gt;</span> <span class="tag">&lt;init-param&gt;</span> <span class="tag">&lt;param -name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> com.acme.web。MvcConfig <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ init-param&gt;</span> <span class="tag">&lt;/ servlet&gt;</span> <span class="comment">&lt;！ - 将/ app / *的所有请求映射到调度程序servlet  - &gt;</span> <span class="tag">&lt;servlet-mapping&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> dispatcher <span class="tag">&lt;/ servlet -name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> / app / * <span class="tag">&lt;/ url-pattern&gt;</span> <span class="tag">&lt;/ servlet-mapping&gt;</span> <span class="tag">&lt;/ web-app&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-bean-annotation"><a class="anchor" href="#beans-java-bean-annotation"></a> 1.12.3。使用<code>@Bean</code>注释</h4>
<div class="paragraph">
<p><code>@Bean</code>是方法级注释，是XML <code>&lt;bean/&gt;</code>元素的直接模拟。注释支持<code>&lt;bean/&gt;</code>提供的一些属性，例如：* <a href="#beans-factory-lifecycle-initializingbean">init-method</a> * <a href="#beans-factory-lifecycle-disposablebean">destroy-method</a> * <a href="#beans-factory-autowire">autowiring</a> * <code>name</code> 。</p>
</div>
<div class="paragraph">
<p>您可以在<code>@Configuration</code> -annotated或<code>@Component</code> -annotated类中使用<code>@Bean</code>批注。</p>
</div>
<div class="sect4">
<h5 id="beans-java-declaring-a-bean"><a class="anchor" href="#beans-java-declaring-a-bean"></a>声明一个Bean</h5>
<div class="paragraph">
<p>要声明bean，可以使用<code>@Bean</code>批注对方法进行批注。您可以使用此方法在指定为方法返回值的类型的<code>ApplicationContext</code>中注册bean定义。默认情况下，bean名称与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> TransferServiceImpl transferService（）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的配置完全等同于以下Spring XML：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">transferService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.acme。TransferServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这两个声明都在<code>ApplicationContext</code>创建了一个名为<code>transferService</code>的bean，绑定到<code>TransferServiceImpl</code>类型的对象实例，如下图所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>transferService  - &gt; com.acme。TransferServiceImpl</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用接口（或基类）返回类型声明<code>@Bean</code>方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，这会将高级类型预测的可见性限制为指定的接口类型（ <code>TransferService</code> ）。然后，只使用容器已知的完整类型（ <code>TransferServiceImpl</code> ）一次，就会实例化受影响的单例bean。非延迟单例bean根据它们的声明顺序进行实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试通过非声明类型进行匹配（例如<code>@Autowired TransferServiceImpl</code> ，它只在<code>transferService</code> bean有一个结果时解析已被实例化）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您始终通过声明的服务接口引用您的类型，则<code>@Bean</code>返回类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或可能由其实现类型引用的组件，更可能声明可能的最具体的返回类型（至少与引用您的bean的注入点所需的具体相同）。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-dependencies"><a class="anchor" href="#beans-java-dependencies"></a> Bean依赖项</h5>
<div class="paragraph">
<p><code>@Bean</code> -annotated方法可以有任意数量的参数来描述构建该bean所需的依赖项。例如，如果我们的<code>TransferService</code>需要<code>AccountRepository</code> ，我们可以使用方法参数来实现该依赖关系，如下面的示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（AccountRepository accountRepository）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl（accountRepository）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>解析机制与基于构造函数的依赖注入非常相似。<a href="#beans-constructor-injection">有关</a>详细信息，请参阅<a href="#beans-constructor-injection">相关部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-lifecycle-callbacks"><a class="anchor" href="#beans-java-lifecycle-callbacks"></a>接收生命周期回调</h5>
<div class="paragraph">
<p>使用<code>@Bean</code>批注定义的任何类都支持常规生命周期回调，并且可以使用JSR-250中的<code>@PostConstruct</code>和<code>@PreDestroy</code>注释。有关更多详细信息，请参阅<a href="#beans-postconstruct-and-predestroy-annotations">JSR-250注释</a> 。</p>
</div>
<div class="paragraph">
<p>完全支持常规的Spring <a href="#beans-factory-nature">生命周期</a>回调。如果bean实现<code>InitializingBean</code> ， <code>DisposableBean</code>或<code>Lifecycle</code> ，则它们各自的方法由容器调用。</p>
</div>
<div class="paragraph">
<p>还完全支持标准的<code>*Aware</code>接口（例如<a href="#beans-beanfactory">BeanFactoryAware</a> ， <a href="#beans-factory-aware">BeanNameAware</a> ， <a href="#context-functionality-messagesource">MessageSourceAware</a> ， <a href="#beans-factory-aware">ApplicationContextAware</a>等）。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code>注释支持指定任意初始化和销毁​​回调方法，就像<code>bean</code>元素上的Spring XML的<code>init-method</code>和<code>destroy-method</code>属性一样，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BeanOne</span> { <span class="directive">public</span> <span class="type">void</span> init（）{ <span class="comment">// initialization logic</span> }} <span class="directive">public</span> <span class="type">class</span> <span class="class">BeanTwo</span> { <span class="directive">public</span> <span class="type">void</span> cleanup（）{ <span class="comment">// destruction logic</span> }} <span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> （initMethod = <span class="string"><span class="delimiter">“</span> <span class="content">init</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> BeanOne beanOne （）{ <span class="keyword">return</span> <span class="keyword">new</span> BeanOne（）; } <span class="annotation">@Bean</span> （destroyMethod = <span class="string"><span class="delimiter">“</span> <span class="content">cleanup</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> BeanTwo beanTwo（）{ <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，使用Java配置定义的具有公共<code>close</code>或<code>shutdown</code>方法的bean会自动使用销毁回调登记。如果您有一个公共<code>close</code>或<code>shutdown</code>方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod="")</code>到bean定义中以禁用默认<code>(inferred)</code>模式。</p>
</div>
<div class="paragraph">
<p>对于使用JNDI获取的资源，您可能希望默认执行此操作，因为其生命周期在应用程序之外进行管理。特别是，请确保始终为<code>DataSource</code>执行此操作，因为已知它在Java EE应用程序服务器上存在问题。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何防止<code>DataSource</code>的自动销毁回调：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span> （destroyMethod = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（） <span class="directive">抛出</span> <span class="exception">NamingException</span> { <span class="keyword">return</span> （ <span class="predefined-type">DataSource</span> ）jndiTemplate.lookup（ <span class="string"><span class="delimiter">“</span> <span class="content">MyDS</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，使用<code>@Bean</code>方法，您通常使用编程JNDI查找，使用Spring的<code>JndiTemplate</code>或<code>JndiLocatorDelegate</code>帮助程序或直接JNDI <code>InitialContext</code>用法，但不使用<code>JndiObjectFactoryBean</code>变量（这会强制您将返回类型声明为<code>FactoryBean</code>类型而不是实际目标类型，使其更难用于其他打算在此处引用所提供资源的<code>@Bean</code>方法中的交叉引用调用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于前面注释中上面示例中的<code>BeanOne</code> ，在构造期间直接调用<code>init()</code>方法同样有效，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> BeanOne beanOne（）{BeanOne beanOne = <span class="keyword">new</span> BeanOne（）; beanOne.init（）; <span class="keyword">return</span> beanOne; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">当您直接使用Java工作时，您可以使用对象执行任何您喜欢的操作，并且不必总是依赖于容器生命周期。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-specifying-bean-scope"><a class="anchor" href="#beans-java-specifying-bean-scope"></a>指定Bean范围</h5>
<div class="paragraph">
<p>Spring包含<code>@Scope</code>注释，以便您可以指定bean的范围。</p>
</div>
<div class="sect5">
<h6 id="beans-java-available-scopes"><a class="anchor" href="#beans-java-available-scopes"></a>使用<code>@Scope</code> Annotation</h6>
<div class="paragraph">
<p>您可以指定使用<code>@Bean</code>批注定义的<code>@Bean</code>应具有特定范围。您可以使用<a href="#beans-factory-scopes">Bean Scopes</a>部分中指定的任何标准作用域。</p>
</div>
<div class="paragraph">
<p>默认范围是<code>singleton</code> ，但您可以使用<code>@Scope</code>批注覆盖它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> { <span class="annotation">@Bean</span> <strong><span class="annotation">@Scope</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">prototype</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> Encryptor <span class="annotation">encryptor</span> （）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-scoped-proxy"><a class="anchor" href="#beans-java-scoped-proxy"></a> <code>@Scope</code>和<code>scoped-proxy</code></h6>
<div class="paragraph">
<p>Spring提供了一种通过<a href="#beans-factory-scopes-other-injection">作用域代理</a>处理作用域依赖项的便捷方法。使用XML配置时创建此类代理的最简单方法是<code>&lt;aop:scoped-proxy/&gt;</code>元素。使用<code>@Scope</code>批注在Java中配置bean提供了与<code>proxyMode</code>属性的等效支持。默认为无代理（ <code>ScopedProxyMode.NO</code> ），但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>或<code>ScopedProxyMode.INTERFACES</code> 。</p>
</div>
<div class="paragraph">
<p>如果使用Java将XML参考文档（请参阅<a href="#beans-factory-scopes-other-injection">作用域代理</a> ）的作用域代理示例移植到我们的<code>@Bean</code> ，它类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//作为代理</span> <span class="directive">公开</span> <span class="comment">的HTTP会话范围的bean</span> <span class="annotation">@Bean</span> <strong><span class="annotation">@SessionScope</span></strong> <span class="directive">public</span> UserPreferences userPreferences（）{ <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> Service userService（）{UserService service = <span class="keyword">new</span> SimpleUserService（）; <span class="comment">//对代理的userPreferences bean的引用</span> service.setUserPreferences（userPreferences（））; <span class="keyword">退货</span>服务; }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-customizing-bean-naming"><a class="anchor" href="#beans-java-customizing-bean-naming"></a>自定义Bean命名</h5>
<div class="paragraph">
<p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。但是，可以使用<code>name</code>属性覆盖此功能，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">myThing</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Thing thing（）{ <span class="keyword">return</span> <span class="keyword">new</span> Thing（）; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-aliasing"><a class="anchor" href="#beans-java-bean-aliasing"></a> Bean Aliasing</h5>
<div class="paragraph">
<p>正如<a href="#beans-beanname">Naming Beans中</a>所讨论的，有时需要为单个bean提供多个名称，也称为bean别名。<code>@Bean</code>批注的<code>name</code>属性<code>@Bean</code>接受String数组。以下示例显示如何为bean设置多个别名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> （name = { <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">subsystemA-dataSource</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">subsystemB-dataSource</span> <span class="delimiter">”</span></span> }） <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="comment">//实例化，配置并返回DataSource bean ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-description"><a class="anchor" href="#beans-java-bean-description"></a> Bean描述</h5>
<div class="paragraph">
<p>有时，提供更详细的bean文本描述会很有帮助。当bean被暴露（可能通过JMX）用于监视目的时，这可能特别有用。</p>
</div>
<div class="paragraph">
<p>要向<code>@Bean</code>添加描述，可以使用<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a>批注，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <strong><span class="annotation">@Description</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">提供bean的基本示例</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> Thing thing（）{ <span class="keyword">return</span> <span class="keyword">new</span> Thing（）; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-configuration-annotation"><a class="anchor" href="#beans-java-configuration-annotation"></a> 1.12.4。使用<code>@Configuration</code>注释</h4>
<div class="paragraph">
<p><code>@Configuration</code>是一个类级注释，指示对象是bean定义的源。<code>@Configuration</code>类通过公共<code>@Bean</code>注释方法声明bean。在<code>@Configuration</code>类上调用<code>@Bean</code>方法也可用于定义bean间依赖项。有关一般介绍，请参阅<a href="#beans-java-basic-concepts">基本概念： <code>@Bean</code>和<code>@Configuration</code></a> 。</p>
</div>
<div class="sect4">
<h5 id="beans-java-injecting-dependencies"><a class="anchor" href="#beans-java-injecting-dependencies"></a>注入bean间依赖关系</h5>
<div class="paragraph">
<p>当bean彼此依赖时，表达该依赖关系就像让一个bean方法调用另一个bean一样简单，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> BeanOne beanOne（）{ <span class="keyword">return</span> <span class="keyword">new</span> BeanOne（beanTwo（））; } <span class="annotation">@Bean</span> <span class="directive">public</span> BeanTwo beanTwo（）{ <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例， <code>beanOne</code>接收参考到<code>beanTwo</code>通过构造器注入。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这种声明bean间依赖关系的方法只有在<code>@Configuration</code>类中声明<code>@Bean</code>方法时才<code>@Bean</code> 。您不能使用普通的<code>@Component</code>类声明bean间依赖关系。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-method-injection"><a class="anchor" href="#beans-java-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>如前所述， <a href="#beans-factory-method-injection">查找方法注入</a>是一项很少使用的高级功能。在单例范围的bean依赖于原型范围的bean的情况下，它很有用。将Java用于此类配置提供了实现此模式的自然方法。以下示例显示了如何使用查找方法注入：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> { <span class="directive">public</span> <span class="predefined-type">Object</span> process（ <span class="predefined-type">Object</span> commandState）{ <span class="comment">//获取相应命令接口的新实例</span>命令command = createCommand（）; <span class="comment">//在（希望是全新的）命令实例</span> command.setState（commandState） <span class="comment">上设置状态</span> ; <span class="keyword">return</span> command.execute（）; } <span class="comment">//好吧......但是这个方法的实现在哪里？</span>
    <span class="directive">protected</span> <span class="directive">abstract</span>命令createCommand（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过使用Java配置，您可以创建<code>CommandManager</code>的子类，其中抽象的<code>createCommand()</code>方法被覆盖，以便查找新的（原型）命令对象。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span> <span class="annotation">@Scope</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">prototype</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> AsyncCommand asyncCommand（）{AsyncCommand command = <span class="keyword">new</span> AsyncCommand（）; <span class="comment">//根据需要</span> <span class="keyword">返回</span>命令<span class="comment">注入依赖项</span> ; } <span class="annotation">@Bean</span> <span class="directive">public</span> CommandManager commandManager（）{ <span class="comment">//使用command（）返回新的匿名CommandManager实现</span> <span class="comment">//返回一个新的原型Command对象</span> <span class="keyword">返回</span> <span class="keyword">new</span> CommandManager（）{ <span class="directive">protected</span>命令createCommand（）{ <span class="keyword">return</span> asyncCommand（）; }}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-further-information-java-config"><a class="anchor" href="#beans-java-further-information-java-config"></a>有关基于Java的配置如何在内部工作的更多信息</h5>
<div class="paragraph">
<p>请考虑以下示例，该示例显示了被调用两次的<code>@Bean</code>注释方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> ClientService clientService1（）{ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl（）; clientService.setClientDao（clientDao（））; <span class="keyword">return</span> clientService; } <span class="annotation">@Bean</span> <span class="directive">public</span> ClientService clientService2（）{ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl（）; clientService.setClientDao（clientDao（））; <span class="keyword">return</span> clientService; } <span class="annotation">@Bean</span> <span class="directive">public</span> ClientDao clientDao（）{ <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>clientDao()</code>已被调用一次<code>clientService1()</code>一次在<code>clientService2()</code>由于此方法创建了<code>ClientDaoImpl</code>的新实例并将其返回，因此通常希望有两个实例（每个服务一个）。这肯定会有问题：在Spring中，实例化的bean默认具有<code>singleton</code>范围。这就是魔术所带来的：所有<code>@Configuration</code>类在启动时都使用<code>CGLIB</code>进行子类化。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器是否有任何缓存（作用域）bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring 3.2开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code>下重新打包并直接包含在spring-core JAR中。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">根据bean的范围，行为可能会有所不同。我们在这里谈论单身人士。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于CGLIB在启动时动态添加功能，因此存在一些限制。特别是，配置类不能是最终的。但是，从4.3开始，配置类允许使用任何构造函数，包括使用<code>@Autowired</code>或单个非默认构造函数声明进行默认注入。</p>
</div>
<div class="paragraph">
<p>如果您希望避免任何CGLIB强加的限制，请考虑在非<code>@Configuration</code>类上声明您的<code>@Bean</code>方法（例如，在普通的<code>@Component</code>类上）。然后不会拦截<code>@Bean</code>方法之间的跨方法调用，因此您必须在构造函数或方法级别专门依赖依赖项注入。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-composing-configuration-classes"><a class="anchor" href="#beans-java-composing-configuration-classes"></a> 1.12.5。编写基于Java的配置</h4>
<div class="paragraph">
<p>Spring的基于Java的配置功能允许您撰写注释，这可以降低配置的复杂性。</p>
</div>
<div class="sect4">
<h5 id="beans-java-using-import"><a class="anchor" href="#beans-java-using-import"></a>使用<code>@Import</code> Annotation</h5>
<div class="paragraph">
<p>就像在Spring XML文件中使用<code>&lt;import/&gt;</code>元素来帮助模块化配置一样， <code>@Import</code> <code>@Bean</code>注释允许从另一个配置类加载<code>@Bean</code>定义，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigA</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> A a（）{ <span class="keyword">return</span> <span class="keyword">new</span> A（）; }} <span class="annotation">@Configuration</span> <span class="annotation">@Import（ConfigA.class）</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ConfigB</span> <span class="annotation">{@Bean</span> <span class="directive">公共</span> B B（）{ <span class="keyword">返回</span> <span class="keyword">新</span> B（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，在实例化上下文时，不需要同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code> ，只需要显式提供<code>ConfigB</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（ConfigB.class）; <span class="comment">//现在豆A和B都可用了......</span>A = ctx.getBean（A.class）; B b = ctx.getBean（B.class）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的<code>@Configuration</code>类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring Framework 4.2开始， <code>@Import</code>还支持引用常规组件类，类似于<code>AnnotationConfigApplicationContext.register</code>方法。如果要避免组件扫描，这一点特别有用，可以使用一些配置类作为明确定义所有组件的入口点。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="beans-java-injecting-imported-beans"><a class="anchor" href="#beans-java-injecting-imported-beans"></a>在导入的<code>@Bean</code>定义上注入依赖<code>@Bean</code></h6>
<div class="paragraph">
<p>前面的例子有效，但很简单。在大多数实际情况中，bean跨配置类彼此依赖。使用XML时，这不是问题，因为不涉及编译器，您可以声明<code>ref="someBean"</code>并信任Spring在容器初始化期间解决它。使用<code>@Configuration</code>类时，Java编译器会对配置模型施加约束，因为对其他bean的引用必须是有效的Java语法。</p>
</div>
<div class="paragraph">
<p>幸运的是，解决这个问题很简单。正如<a href="#beans-java-dependencies">我们已经讨论过的</a> ， <code>@Bean</code>方法可以有任意数量的参数来描述bean的依赖关系。考虑以下更多真实场景​​，其中包含几个<code>@Configuration</code>类，每个类都取决于其他类中声明的bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（AccountRepository accountRepository）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl（accountRepository）; <span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> AccountRepository accountRepository（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository（dataSource）; <span class="annotation">@Configuration</span> <span class="annotation">@Import</span> （{ServiceConfig.class，RepositoryConfig.class}） <span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="comment">// return new DataSource</span> }} <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（SystemTestConfig.class）; <span class="comment">//一切都在配置类之间连接......</span>TransferService transferService = ctx.getBean（TransferService.class）; transferService.transfer（ <span class="float">100.00</span> ， <span class="string"><span class="delimiter">“</span> <span class="content">A123</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">C456</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还有另一种方法可以达到相同的效果。请记住， <code>@Configuration</code>类最终只是容器中的另一个bean：这意味着它们可以利用<code>@Autowired</code>和<code>@Value</code>注入以及与任何其他bean相同的其他功能。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保以这种方式注入的依赖项只是最简单的。<code>@Configuration</code>类在上下文初始化期间很早就被处理，并且强制以这种方式注入依赖项可能会导致意外的早期初始化。尽可能采用基于参数的注入，如前面的示例所示。</p>
</div>
<div class="paragraph">
<p>另外，要特别注意通过<code>@Bean</code> <code>BeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>定义。这些通常应该声明为<code>static @Bean</code>方法，而不是触发其包含配置类的实例化。否则，@ <code>@Autowired</code>和<code>@Value</code>不能在配置类本身上工作，因为它过早地被创建为bean实例。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示了如何将一个bean自动连接到另一个bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> AccountRepository accountRepository; <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl（accountRepository）; <span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">RepositoryConfig</span> { <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">DataSource</span> dataSource; <span class="annotation">@Autowired</span> <span class="directive">public</span> RepositoryConfig（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .dataSource = dataSource; } <span class="annotation">@Bean</span> <span class="directive">public</span> AccountRepository accountRepository（）{ <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository（dataSource）; <span class="annotation">@Configuration</span> <span class="annotation">@Import</span> （{ServiceConfig.class，RepositoryConfig.class}） <span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="comment">// return new DataSource</span> }} <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（SystemTestConfig.class）; <span class="comment">//一切都在配置类之间连接......</span>TransferService transferService = ctx.getBean（TransferService.class）; transferService.transfer（ <span class="float">100.00</span> ， <span class="string"><span class="delimiter">“</span> <span class="content">A123</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">C456</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">仅在Spring Framework 4.3中支持<code>@Configuration</code>类中的构造函数注入。另请注意，如果目标bean仅定义了一个构造函数，则无需指定<code>@Autowired</code> 。在前面的示例中， <code>RepositoryConfig</code>构造函数中不需要<code>@Autowired</code> 。
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-injecting-imported-beans-fq"></a>完全符合条件的进口豆类，便于导航</div>
<div class="content">
<div class="paragraph">
<p>在前面的场景中，使用<code>@Autowired</code>可以很好地工作并提供所需的模块化，但确定声明自动装配的bean定义的确切位置仍然有些模棱两可。例如，作为查看<code>ServiceConfig</code>的开发人员，您如何确切地知道<code>@Autowired AccountRepository</code> bean的声明位置？它在代码中并不明确，这可能就好了。请记住， <a href="https://spring.io/tools/sts">Spring Tool Suite</a>提供的工具可以呈现图表，显示所有内容的连线方式，这可能就是您所需要的。此外，您的Java IDE可以轻松找到<code>AccountRepository</code>类型的所有声明和用法，并快速显示返回该类型的<code>@Bean</code>方法的位置。</p>
</div>
<div class="paragraph">
<p>如果这种歧义不可接受并且您希望从IDE中从一个<code>@Configuration</code>类直接导航到另一个<code>@Configuration</code>类，请考虑自动装配配置类本身。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> RepositoryConfig repositoryConfig; <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（）{ <span class="comment">//将配置类导航到@Bean方法！</span>
        <span class="keyword">返回</span> <span class="keyword">new</span> TransferServiceImpl（repositoryConfig.accountRepository（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的情况中，定义<code>AccountRepository</code>是完全明确的。但是， <code>ServiceConfig</code>现在与<code>RepositoryConfig</code>紧密耦合。这是权衡。通过使用基于接口的或基于类的抽象<code>@Configuration</code>类，可以在某种程度上减轻这种紧密耦合。请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> RepositoryConfig repositoryConfig; <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl（repositoryConfig.accountRepository（））; <span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">接口</span> <span class="class">RepositoryConfig</span> { <span class="annotation">@Bean</span> AccountRepository accountRepository（）; } <span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultRepositoryConfig</span> <span class="directive">实现</span> RepositoryConfig { <span class="annotation">@Bean</span> <span class="directive">public</span> AccountRepository accountRepository（）{ <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository（...）; <span class="annotation">@Configuration</span> <span class="annotation">@Import</span> （{ServiceConfig.class，DefaultRepositoryConfig.class}） <span class="comment">//导入具体配置！</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="comment">// return DataSource</span> }} <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（SystemTestConfig.class）; TransferService transferService = ctx.getBean（TransferService.class）; transferService.transfer（ <span class="float">100.00</span> ， <span class="string"><span class="delimiter">“</span> <span class="content">A123</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">C456</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在， <code>ServiceConfig</code>与具体的<code>DefaultRepositoryConfig</code>松散耦合，内置的IDE工具仍然很有用：您可以轻松获得<code>RepositoryConfig</code>实现的类型层次结构。通过这种方式，导航<code>@Configuration</code>类及其依赖项与导航基于接口的代码的常规过程没有什么不同。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要影响某些bean的启动创建顺序，可以考虑将其中一些声明为<code>@Lazy</code> （用于在首次访问时创建而不是在启动时）或<code>@DependsOn</code>某些其他bean（确保在创建之前创建特定的其他bean）当前的bean，超出后者的直接依赖性所暗示的）。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-conditional"><a class="anchor" href="#beans-java-conditional"></a>有条件地包含<code>@Configuration</code>类或<code>@Bean</code>方法</h5>
<div class="paragraph">
<p>基于某些任意系统状态，有条件地启用或禁用完整的<code>@Configuration</code>类甚至单独的<code>@Bean</code>方法通常很有用。一个常见的例子是，只有在Spring <code>Environment</code>启用了特定的配置文件时才使用<code>@Profile</code>注释来激活bean（有关详细<a href="#beans-definition-profiles">信息</a> ，请参阅<a href="#beans-definition-profiles">Bean定义配置文件</a> ）。</p>
</div>
<div class="paragraph">
<p><code>@Profile</code>注释实际上是通过使用更灵活的注释<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a> 。<code>@Conditional</code>批注指示特定的<code>org.springframework.context.annotation.在注册<code>@Bean</code>之前应该参考的Condition</code>实现。</p>
</div>
<div class="paragraph">
<p><code>Condition</code>接口的实现提供了一个返回<code>true</code>或<code>false</code>的<code>matches(…​)</code>方法。例如，以下清单显示了用于<code>@Profile</code>的实际<code>Condition</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span> <span class="directive">公共</span> <span class="type">布尔</span>匹配（ConditionContext context，AnnotatedTypeMetadata metadata）{ <span class="keyword">if</span> （context.getEnvironment（）！= <span class="predefined-constant">null</span> ）{ <span class="comment">//读取@Profile注释属性</span> MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; attrs = metadata.getAllAnnotationAttributes（Profile.class.getName（））; <span class="keyword">如果</span> （attrs！= <span class="predefined-constant">null</span> ）{ <span class="keyword">for</span> （ <span class="predefined-type">Object</span> value：attrs.get（ <span class="string"><span class="delimiter">“</span> <span class="content">value</span> <span class="delimiter">”</span></span> ））{ <span class="keyword">if</span> （context.getEnvironment（）。acceptsProfiles（（（ <span class="predefined-type">String</span> <span class="type">[]</span> ）value）））{ <span class="keyword">return</span> <span class="predefined-constant">true</span> ; <span class="keyword">返回</span> <span class="predefined-constant">false</span> ; <span class="keyword">返回</span> <span class="predefined-constant">true</span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-combining"><a class="anchor" href="#beans-java-combining"></a>结合Java和XML配置</h5>
<div class="paragraph">
<p>Spring的<code>@Configuration</code>类支持并非旨在成为Spring XML的100％完全替代品。某些工具（如Spring XML命名空间）仍然是配置容器的理想方法。在XML方便或必要的情况下，您可以选择：通过使用例如<code>ClassPathXmlApplicationContext</code>以“以XML为中心”的方式实例化容器，或者通过使用<code>AnnotationConfigApplicationContext</code>以“以Java为中心”的方式实例化它。 <code>@ImportResource</code>注释，根据需要导入XML。</p>
</div>
<div class="sect5">
<h6 id="beans-java-combining-xml-centric"><a class="anchor" href="#beans-java-combining-xml-centric"></a>以XML为中心使用<code>@Configuration</code>类</h6>
<div class="paragraph">
<p>最好从XML引导Spring容器，并以ad-hoc方式包含<code>@Configuration</code>类。例如，在使用Spring XML的大型现有代码库中，可以根据需要更轻松地创建<code>@Configuration</code>类，并将其包含在现有XML文件中。在本节的后面部分，我们将介绍在这种“以XML为中心”的情况下使用<code>@Configuration</code>类的选项。</p>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-declare-as-bean"></a>将<code>@Configuration</code>类声明为普通的Spring <code>&lt;bean/&gt;</code>元素</div>
<div class="content">
<div class="paragraph">
<p>请记住， <code>@Configuration</code>类最终是容器中的bean定义。在本系列示例中，我们创建一个名为<code>AppConfig</code>的<code>@Configuration</code>类，并将其作为<code>&lt;bean/&gt;</code>定义包含在<code>system-test-config.xml</code>中。由于<code>&lt;context:annotation-config/&gt;</code>已打开，容器会识别<code>@Configuration</code>批注并正确处理<code>AppConfig</code>声明的<code>@Bean</code>方法。</p>
</div>
<div class="paragraph">
<p>以下示例显示了Java中的普通配置类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> <span class="predefined-type">DataSource</span> dataSource; <span class="annotation">@Bean</span> <span class="directive">public</span> AccountRepository accountRepository（）{ <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository（dataSource）; } <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（）{ <span class="keyword">return</span> <span class="keyword">new</span> TransferService（accountRepository（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了示例<code>system-test-config.xml</code>文件的一部分：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 启用注释处理，例如@Autowired和@Configuration  - &gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;context：property-placeholder</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/com/acme/jdbc.properties</span> <span class="delimiter">”</span></span> <span class="tag">/ &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.acme。AppConfig</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jdbc.datasource。DriverManagerDataSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">password</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了可能的<code>jdbc.properties</code>文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>jdbc.url = jdbc：hsqldb：hsql：// localhost / xdb jdbc.username = sa jdbc.password =</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/com/acme/system-test-config.xml</span> <span class="delimiter">”</span></span> ）; TransferService transferService = ctx.getBean（TransferService.class）; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在<code>system-test-config.xml</code>文件中， <code>AppConfig</code> <code>&lt;bean/&gt;</code>不声明<code>id</code>元素。虽然这样做是可以接受的，但是没有必要，因为没有其他bean引用它，并且不太可能通过名称从容器中明确地获取它。类似地， <code>DataSource</code> bean只是按类型自动装配，因此不严格要求显式的bean <code>id</code> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-component-scan"></a>使用&lt;context：component-scan /&gt;来获取<code>@Configuration</code>类</div>
<div class="content">
<div class="paragraph">
<p>由于<code>@Configuration</code>是使用<code>@Component</code>元注释的，因此<code>@Configuration</code> -annotated类自动成为组件扫描的候选者。使用与前一个示例中描述的相同的方案，我们可以重新定义<code>system-test-config.xml</code>以利用组件扫描。请注意，在这种情况下，我们不需要显式声明<code>&lt;context:annotation-config/&gt;</code> ，因为<code>&lt;context:component-scan/&gt;</code>启用相同的功能。</p>
</div>
<div class="paragraph">
<p>以下示例显示了已修改的<code>system-test-config.xml</code>文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 选择并将AppConfig注册为bean定义 - &gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.acme</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;context：property-placeholder</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/ com / acme / jdbc.properties</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jdbc.datasource。DriverManagerDataSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">password</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-combining-java-centric"><a class="anchor" href="#beans-java-combining-java-centric"></a> <code>@Configuration</code>类为中心在<code>@ImportResource</code>使用XML</h6>
<div class="paragraph">
<p>在<code>@Configuration</code>类是配置容器的主要机制的应用程序中，仍然可能需要使用至少一些XML。在这些场景中，您可以使用<code>@ImportResource</code>并根据需要定义尽可能多的XML。这样做可以实现“以Java为中心”的方法来配置容器并将XML保持在最低限度。以下示例（包括配置类，定义bean的XML文件，属性文件和<code>main</code>类）显示了如何使用<code>@ImportResource</code>批注来实现根据需要使用XML的“以Java为中心”的配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ImportResource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/com/acme/properties-config.xml</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">”</span></span> ） <span class="directive">private</span> <span class="predefined-type">String</span> url; <span class="annotation">@Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> ） <span class="directive">私有</span> <span class="predefined-type">字符串</span>用户名; <span class="annotation">@Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> ） <span class="directive">私有</span> <span class="predefined-type">字符串</span>密码; <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource（url，username，password）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">properties-config.xml <span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：property-placeholder</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/com/acme/jdbc.properties</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.properties jdbc.url = jdbc：hsqldb：hsql：// localhost / xdb jdbc.username = sa jdbc.password =</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（AppConfig.class）; TransferService transferService = ctx.getBean（TransferService.class）; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-environment"><a class="anchor" href="#beans-environment"></a> 1.13。环境抽象</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/env/Environment.html"><code>Environment</code></a>接口是集成在容器中的抽象，它模拟了应用程序环境的两个关键方面： <a href="#beans-definition-profiles">配置文件</a>和<a href="#beans-property-source-abstraction">属性</a> 。</p>
</div>
<div class="paragraph">
<p>配置文件是仅在给定配置文件处于活动状态时才向容器注册的Bean定义的命名逻辑组。可以将Bean分配给配置文件，无论是以XML还是使用注释定义。与配置文件相关的<code>Environment</code>对象的作用是确定哪些配置文件（如果有）当前处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。</p>
</div>
<div class="paragraph">
<p>属性在几乎所有应用程序中都发挥着重要作用，可能源自各种源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc <code>Properties</code>对象， <code>Map</code>对象等。与属性相关的<code>Environment</code>对象的作用是为用户提供方便的服务接口，用于配置属性源和从中解析属性。</p>
</div>
<div class="sect3">
<h4 id="beans-definition-profiles"><a class="anchor" href="#beans-definition-profiles"></a> 1.13.1。Bean定义配置文件</h4>
<div class="paragraph">
<p>Bean定义配置文件在核心容器中提供了一种机制，允许在不同环境中注册不同的bean。“环境”这个词对不同的用户来说意味着不同的东西，这个功能可以帮助解决许多用例，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在QA或生产环境中，针对开发中的内存数据源而不是从JNDI查找相同的数据源。</p>
</li>
<li>
<p>仅在将应用程序部署到性能环境时注册监视基础结构。</p>
</li>
<li>
<p>为客户A和客户B部署注册bean的自定义实施。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑需要<code>DataSource</code>的实际应用程序中的第一个用例。在测试环境中，配置可能类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。setType（EmbeddedDatabaseType。HSQL）.addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">my-</span></span> schema.sql <span class="string"><span class="delimiter">”</span></span> ）。addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">my-test-data.sql</span> <span class="delimiter">”</span></span> ）。 <span class="string"><span class="content">build</span></span> （）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑如何将此应用程序部署到QA或生产环境中，假设应用程序的数据源已注册到生产应用程序服务器的JNDI目录。我们的<code>dataSource</code> bean现在看起来如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span> （destroyMethod = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span> （）; <span class="keyword">return</span> （ <span class="predefined-type">DataSource</span> ）ctx.lookup（ <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>问题是如何根据当前环境在使用这两种变体之间切换。随着时间的推移，Spring用户已经设计了许多方法来完成这项工作，通常依赖于系统环境变量和包含<code>${placeholder}</code>标记的XML <code>&lt;import/&gt;</code>语句的组合，这些标记根据值解析为正确的配置文件路径一个环境变量。Bean定义配置文件是核心容器功能，可为此问题提供解决方案。</p>
</div>
<div class="paragraph">
<p>如果我们概括了前面特定于环境的bean定义示例中显示的用例，我们最终需要在某些上下文中注册某些bean定义，而在其他上下文中则不需要。您可以说您希望在情境A中注册特定的bean定义配置文件，在情况B中注册不同的配置文件。我们首先更新配置以反映此需求。</p>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-java"><a class="anchor" href="#beans-definition-profiles-java"></a>使用<code>@Profile</code></h5>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a>注释允许您指示当一个或多个指定的配置文件处于活动状态时，组件符合注册条件。使用前面的示例，我们可以重写<code>dataSource</code>配置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <strong><span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">development</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">StandaloneDataConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。setType（EmbeddedDatabaseType。HSQL）.addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql /</span></span> schema.sql <span class="string"><span class="delimiter">”</span></span> ）。addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / test-data.sql</span> <span class="delimiter">”</span></span> ）。 <span class="string"><span class="content">build</span></span> （）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <strong><span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> <span class="type">class</span> <span class="class">JndiDataConfig</span> { <span class="annotation">@Bean</span> （destroyMethod = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span> （）; <span class="keyword">return</span> （ <span class="predefined-type">DataSource</span> ）ctx.lookup（ <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如前所述，使用<code>@Bean</code>方法，您通常选择使用Spring的<code>JndiTemplate</code> / <code>JndiLocatorDelegate</code>帮助程序或前面显示的直接JNDI <code>InitialContext</code>用法，而不是<code>JndiObjectFactoryBean</code>变量，这会强制您将返回类型声明为<code>FactoryBean</code>类型。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>配置文件字符串可以包含简单的配置文件名称（例如， <code>production</code> ）或配置文件表达式。概要表达式允许表达更复杂的概要逻辑（例如， <code>production &amp; us-east</code> ）。配置文件表达式支持以下运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>!</code> ：配置文件的逻辑“不”</p>
</li>
<li>
<p><code>&amp;</code> ：配置文件的逻辑“和”</p>
</li>
<li>
<p>`|`_配置文件的逻辑“或”</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">你不能混合<code>&amp;</code>和<code>|</code>不使用括号的运算符。例如， <code>production &amp; us-east | eu-central</code>不是一个有效的表达。它必须表示为<code>production &amp; (us-east | eu-central)</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以将<code>@Profile</code>用作<a href="#beans-meta-annotations">元注释</a> ，以创建自定义组合注释。以下示例定义了一个自定义<code>@Production</code>批注，您可以将其用作<code>@Profile("production")</code>替代品：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。TYPE） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <strong><span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> <span class="annotation">@interface</span> Production {}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果一个<code>@Configuration</code>类标有<code>@Profile</code> ，所有的<code>@Bean</code>方法和<code>@Import</code>与该类相关联的注释被旁路，除非一个或多个指定的简档是活动的。如果使用<code>@Profile({"p1", "p2"})</code>标记<code>@Component</code>或<code>@Configuration</code>类，则除非已激活配置文件“p1”或“p2”，否则不会注册或处理该类。如果给定的配置文件以NOT运算符（ <code>!</code> ）作为前缀，则仅在配置文件未激活时才注册带注释的元素。例如，给定<code>@Profile({"p1", "!p2"})</code> ，如果配置文件”p1“处于活动状态或配置文件”p2“未激活，则会发生注册。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Profile</code>也可以在方法级别声明，以仅包含配置类的一个特定bean（例如，对于特定bean的替代变体），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">的AppConfig</span> <span class="annotation">{@Bean（</span> <span class="string"><span class="delimiter">“</span> <span class="content">数据源</span> <span class="delimiter"><span class="annotation">”）@profile（</span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">发展</span> <span class="delimiter">”）</span></span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="predefined-type">DataSource</span> standaloneDataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。setType（EmbeddedDatabaseType。HSQL）.addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql /</span></span> schema.sql <span class="string"><span class="delimiter">”</span></span> ）。addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / test-data.sql</span> <span class="delimiter">”</span></span> ）。 <span class="string"><span class="content">build</span></span> （）; } <span class="annotation">@Bean</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> ）@ <span class="annotation">Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">public</span> <span class="predefined-type">DataSource</span> jndiDataSource（） <span class="directive">抛出</span> <span class="exception">Exception</span> { <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span> （）; <span class="keyword">return</span> （ <span class="predefined-type">DataSource</span> ）ctx.lookup（ <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>standaloneDataSource</code>方法仅在<code>development</code>概要文件中可用。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>jndiDataSource</code>方法仅在<code>production</code>配置文件中可用。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于<code>@Bean</code>方法的<code>@Profile</code> ，可能会应用一个特殊的场景：对于相同Java方法名称的重载<code>@Bean</code>方法（类似于构造函数重载），需要在所有重载方法上一致地声明<code>@Profile</code>条件。如果条件不一致，则只有重载方法中第一个声明的条件才重要。因此，@ <code>@Profile</code>不能用于选择具有特定参数签名的重载方法。同一个bean的所有工厂方法之间的分辨率遵循Spring的构造函数解析算法在创建时。</p>
</div>
<div class="paragraph">
<p>如果要定义具有不同配置文件条件的备用Bean，请使用不同的Java方法名称，使用<code>@Bean</code> name属性指向相同的bean名称，如上例所示。如果参数签名都是相同的（例如，所有变体都具有no-arg工厂方法），这是首先在有效的Java类中表示这种排列的唯一方法（因为只有一个特定名称和参数签名的方法）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-xml"><a class="anchor" href="#beans-definition-profiles-xml"></a> XML Bean定义配置文件</h5>
<div class="paragraph">
<p>XML对应物是<code>&lt;beans&gt;</code>元素的<code>profile</code>属性。我们之前的示例配置可以在两个XML文件中重写，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">development</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：jdbc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/jdbc</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">...</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;JDBC：嵌入式数据库</span> <span class="attribute-name">ID</span> <span class="string"><span class="delimiter">=”</span> <span class="content">数据源</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;JDBC：脚本</span> <span class="attribute-name">位置</span> <span class="string"><span class="delimiter">=”</span> <span class="content">类路径：COM /银行/配置/sql/schema.sql</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：com / bank / config / sql / test-data.sql</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：embedded-database&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：jee</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/jee</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">...</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;JEE：JNDI的查找</span> <span class="attribute-name">ID</span> <span class="string"><span class="delimiter">=”</span> <span class="content">数据源</span></span> <span class="attribute-name"><span class="string"><span class="delimiter">“JNDI</span></span>名称</span> <span class="string"><span class="delimiter">=”</span> <span class="content">java的：comp / env的/ JDBC /数据源</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以避免在同一文件中使用split和nest <code>&lt;beans/&gt;</code>元素，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：jdbc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / jdbc</span> <span class="delimiter">“</span></span> <span class="attribute-name">xmlns：jee</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/jee</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">...</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 其他bean定义 - &gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">development</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：embedded-database</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / schema.sql</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath： com / bank / config / sql / test-data.sql</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：embedded-database&gt;</span> <span class="tag">&lt;/ beans&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">”</span> <span class="content">production</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>spring-bean.xsd</code>已被约束为仅允许这些元素作为文件中的最后一个元素。这应该有助于提供灵活性，而不会在XML文件中引起混乱。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>XML对应方不支持前面描述的配置文件表达式。但是，有可能通过使用<code>!</code>来否定一个配置文件<code>!</code> 运营商。也可以通过嵌套配置文件来应用逻辑“和”，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：jdbc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / jdbc</span> <span class="delimiter">“</span></span> <span class="attribute-name">xmlns：jee</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/jee</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">...</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 其他bean定义 - &gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">us-east</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span> <span class="tag">&lt;/豆&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果<code>production</code>和<code>us-east</code>配置文件都处于活动状态，则会公开<code>dataSource</code> bean。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-enable"><a class="anchor" href="#beans-definition-profiles-enable"></a>激活个人资料</h5>
<div class="paragraph">
<p>现在我们已经更新了配置，我们仍然需要指示Spring哪个配置文件处于活动状态。如果我们现在开始我们的示例应用程序，我们会看到抛出<code>NoSuchBeanDefinitionException</code> ，因为容器找不到名为<code>dataSource</code>的Spring bean。</p>
</div>
<div class="paragraph">
<p>激活配置文件可以通过多种方式完成，但最直接的方法是以编程方式对可通过<code>ApplicationContext</code>提供的<code>Environment</code> API进行操作。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext（）; ctx.getEnvironment（）。setActiveProfiles（ <span class="string"><span class="delimiter">“</span> <span class="content">development</span> <span class="delimiter">”</span></span> ）; ctx.register（SomeConfig.class，StandaloneDataConfig.class，JndiDataConfig.class）; ctx.refresh（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，您还可以通过<code>spring.profiles.active</code>属性声明性地激活配置文件，该属性可以通过系统环境变量，JVM系统属性， <code>web.xml</code> servlet上下文参数或甚至作为JNDI中的条目来指定（请参阅<a href="#beans-property-source-abstraction"><code>PropertySource</code> Abstraction）</a> ）。在集成测试中，可以使用<code>spring-test</code>模块中的<code>@ActiveProfiles</code>批注声明活动配置文件（请参阅<a href="testing.html#testcontext-ctx-management-env-profiles">使用环境配置文件的上下文配置</a> ）。</p>
</div>
<div class="paragraph">
<p>请注意，配置文件不是“任何 - 或”命题。您可以一次激活多个配置文件。编程方式，也可以提供多个配置文件名称到<code>setActiveProfiles()</code>方法，它接受<code>String…​</code>可变参数。以下示例激活多个配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ctx.getEnvironment（）。setActiveProfiles（ <span class="string"><span class="delimiter">“</span> <span class="content">profile1</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">profile2</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>声明性地， <code>spring.profiles.active</code>可以接受以逗号分隔的概要文件名列表，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">-Dspring.profiles.active = <span class="string"><span class="delimiter">“</span> <span class="content">profile1，profile2</span> <span class="delimiter">”</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-default"><a class="anchor" href="#beans-definition-profiles-default"></a>默认配置文件</h5>
<div class="paragraph">
<p>默认配置文件表示默认启用的配置文件。请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <strong><span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">default</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultDataConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。setType（EmbeddedDatabaseType。HSQL）.addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / schema.sql</span> <span class="delimiter">”</span></span> ）。build（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有激活配置文件，则创建<code>dataSource</code> 。您可以将此视为一种为一个或多个bean提供默认定义的方法。如果启用了任何配置文件，则默认配置文件不适用。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>Environment</code>上的<code>setDefaultProfiles()</code>或声明性地使用<code>spring.profiles.default</code>属性更改默认配置文件的名称。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-property-source-abstraction"><a class="anchor" href="#beans-property-source-abstraction"></a> 1.13.2。<code>PropertySource</code>抽象</h4>
<div class="paragraph">
<p>Spring的<code>Environment</code>抽象通过可配置的属性源层次结构提供搜索操作。请考虑以下列表：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext（）;环境env = ctx.getEnvironment（）; <span class="type">boolean</span> containsMyProperty = env.containsProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">my-property</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span> <span class="content">我的环境是否包含'my-property'属性？</span><span class="delimiter">“</span></span> + containsMyProperty）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的代码片段中，我们看到了一种向Spring询问<code>my-property</code>属性是否为当前环境定义的高级方法。要回答此问题， <code>Environment</code>对象将对一组<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a>对象执行搜索。<code>PropertySource</code>是对任何键值对源的简单抽象，Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a>配置有两个PropertySource对象 - 一个表示JVM系统属性集（ <code>System.getProperties()</code> ），另一个表示系统环境变量集（ <code>System.getenv()</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这些默认属性源存在于<code>StandardEnvironment</code> ，以便在独立应用程序中使用。<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a>填充了其他默认属性源，包括servlet配置和servlet上下文参数。它可以选择启用<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a> 。有关详细信息，请参阅Javadoc。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>具体地说，当您使用<code>StandardEnvironment</code> ，如果在运行时存在<code>my-property</code>系统属性或<code>my-propertyi</code>环境变量，则对<code>env.containsProperty("my-property")</code>的调用将返回true。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量。所以，如果<code>my-property</code>属性恰好在这两个地方，在通话过程中进行设置<code>env.getProperty("my-property")</code>则返回系统属性值“胜”和。请注意，属性值未合并，而是由前面的条目完全覆盖。</p>
</div>
<div class="paragraph">
<p>对于常见的<code>StandardServletEnvironment</code> ，完整层次结构如下，最高优先级条目位于顶部：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ServletConfig参数（如果适用 - 例如，在<code>DispatcherServlet</code>上下文的情况下）</p>
</li>
<li>
<p>ServletContext参数（web.xml context-param条目）</p>
</li>
<li>
<p>JNDI环境变量（ <code>java:comp/env/</code> entries）</p>
</li>
<li>
<p>JVM系统属性（ <code>-D</code>命令行参数）</p>
</li>
<li>
<p>JVM系统环境（操作系统环境变量）</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最重要的是，整个机制是可配置的。您可能希望将自定义的属性源集成到此搜索中。为此，请实现并实例化您自己的<code>PropertySource</code> ，并将其添加到当前<code>Environment</code>的<code>PropertySources</code>集合中。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext（）; MutablePropertySources sources = ctx.getEnvironment（）。getPropertySources（）; sources.addFirst（ <span class="keyword">new</span> MyPropertySource（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中， <code>MyPropertySource</code>在搜索中添加了最高优先级。如果它包含<code>my-property</code>属性，则会检测并返回该属性，以支持任何其他<code>PropertySource</code>的任何<code>my-property</code>属性。<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a> API公开了许多方法，允许精确操作属性源集。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-using-propertysource"><a class="anchor" href="#beans-using-propertysource"></a> 1.13.3。使用<code>@PropertySource</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>注释提供了一种方便的声明式机制，用于向Spring的<code>Environment</code>添加<code>PropertySource</code> 。</p>
</div>
<div class="paragraph">
<p>给定一个名为<code>app.properties</code>的文件，其中包含键值对<code>testbean.name=myTestBean</code> ，以下<code>@Configuration</code>类使用<code>@PropertySource</code> ，以便调用<code>testBean.getName()</code>返回<code>myTestBean</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <strong><span class="annotation">@PropertySource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/com/myco/app.properties</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Autowired</span> Environment env; <span class="annotation">@Bean</span> <span class="directive">public</span> TestBean testBean（）{TestBean testBean = <span class="keyword">new</span> TestBean（）; testBean.setName（env.getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">testbean.name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">return</span> testBean; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@PropertySource</code>资源位置中存在的任何<code>${…​}</code>占位符将根据已针对环境注册的属性源集合进行解析，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@PropertySource（</span> <span class="string"><span class="delimiter">“</span> <span class="content">类路径：/ COM / $ {my.placeholder：缺省的/路径} <span class="delimiter">/app.properties”）</span></span></span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">的AppConfig</span> <span class="annotation">{@Autowired</span>环境Env; <span class="annotation">@Bean</span> <span class="directive">public</span> TestBean testBean（）{TestBean testBean = <span class="keyword">new</span> TestBean（）; testBean.setName（env.getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">testbean.name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">return</span> testBean; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设<code>my.placeholder</code>存在于已注册的其中一个属性源中（例如，系统属性或环境变量），则占位符将解析为相应的值。如果不是，则<code>default/path</code>用作默认值。如果未指定缺省值且无法解析属性，则抛出<code>IllegalArgumentException</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">根据Java 8惯例，@ <code>@PropertySource</code>注释是可重复的。但是，所有这些<code>@PropertySource</code>注释都需要在同一级别声明，可以直接在配置类上声明，也可以在同一自定义注释中作为元注释声明。不建议混合直接注释和元注释，因为直接注释有效地覆盖了元注释。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-placeholder-resolution-in-statements"><a class="anchor" href="#beans-placeholder-resolution-in-statements"></a> 1.13.4。占位符决议在声明中</h4>
<div class="paragraph">
<p>从历史上看，元素中占位符的值只能针对JVM系统属性或环境变量进行解析。这已不再是这种情况。因为<code>Environment</code>抽象集成在整个容器中，所以很容易通过它来路由占位符的解析。这意味着您可以以任何您喜欢的方式配置解析过程。您可以更改搜索系统属性和环境变量的优先级，或完全删除它们。您也可以根据需要将自己的属性源添加到混合中。</p>
</div>
<div class="paragraph">
<p>具体而言，只要在<code>Environment</code>可用，无论<code>customer</code>属性在何处定义，以下语句都可以工作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;import</span> <span class="attribute-name">resource</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com / bank / service / $ {customer} -config.xml</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-load-time-weaver"><a class="anchor" href="#context-load-time-weaver"></a> 1.14。注册<code>LoadTimeWeaver</code></h3>
<div class="paragraph">
<p>Spring使用<code>LoadTimeWeaver</code>在类加载到Java虚拟机（JVM）时动态转换类。</p>
</div>
<div class="paragraph">
<p>要启用加载时编织，可以将<code>@EnableLoadTimeWeaving</code>添加到<code>@Configuration</code>类之一，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableLoadTimeWeaving</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，对于XML配置，您可以使用<code>context:load-time-weaver</code>元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;context：load-time-weaver</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦已配置<code>ApplicationContext</code> ，即内的任何豆<code>ApplicationContext</code>可以实现<code>LoadTimeWeaverAware</code> ，从而接收到所述负载时织入实例的引用。这与<a href="data-access.html#orm-jpa">Spring的JPA支持</a>结合使用特别有用，其中JPA类转换可能需要加载时编织。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html"><code>LocalContainerEntityManagerFactoryBean</code> Javadoc</a> 。有关AspectJ加载时编织的更多信息，请参阅<a href="#aop-aj-ltw">Spring Framework中使用AspectJ的加载时编织</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="context-introduction"><a class="anchor" href="#context-introduction"></a> 1.15。<code>ApplicationContext</code>附加功能</h3>
<div class="paragraph">
<p>正如<a href="#beans">章节介绍中</a>所讨论的， <code>org.springframework.beans.factory</code>包提供了管理和操作bean的基本功能，包括以编程方式。<code>org.springframework.context</code>包添加了<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>接口，该接口扩展了<code>BeanFactory</code>接口，此外还扩展了其他接口，以更面向应用程序框架的方式提供其他功能。许多人以完全声明的方式使用<code>ApplicationContext</code> ，甚至不以编程方式创建它，而是依赖于诸如<code>ContextLoader</code>类的支持类来自动实例化<code>ApplicationContext</code>作为Java EE Web应用程序的正常启动过程的一部分。</p>
</div>
<div class="paragraph">
<p>为了以更加面向框架的样式增强<code>BeanFactory</code>功能，上下文包还提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过<code>MessageSource</code>接口访问i18n风格的消息。</p>
</li>
<li>
<p>通过<code>ResourceLoader</code>接口访问URL和文件等<code>ResourceLoader</code> 。</p>
</li>
<li>
<p>事件发布，即实现了豆<code>ApplicationListener</code>接口，通过使用的<code>ApplicationEventPublisher</code>接口。</p>
</li>
<li>
<p>加载多个（分层）上下文，通过<code>HierarchicalBeanFactory</code>接口将每个上下文集中在一个特定层（例如应用程序的Web层）上。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="context-functionality-messagesource"><a class="anchor" href="#context-functionality-messagesource"></a> 1.15.1。使用<code>MessageSource</code>国际化</h4>
<div class="paragraph">
<p><code>ApplicationContext</code>接口扩展了一个名为<code>MessageSource</code>的接口，因此提供了国际化（“i18n”）功能。Spring还提供了<code>HierarchicalMessageSource</code>接口，该接口可以分层次地解析消息。这些接口共同提供了Spring影响消息解析的基础。这些接口上定义的方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getMessage(String code, Object[] args, String default, Locale loc)</code> ：用于从<code>MessageSource</code>检索消息的基本方法。如果未找到指定区域设置的消息，则使用默认消息。传入的任何参数都使用标准库提供的<code>MessageFormat</code>功能成为替换值。</p>
</li>
<li>
<p><code>String getMessage(String code, Object[] args, Locale loc)</code> ：基本上与前一个方法相同，但有一个区别：不能指定默认消息。如果找不到该消息，则抛出<code>NoSuchMessageException</code> 。</p>
</li>
<li>
<p><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code> ：前面方法中使用的所有属性也包装在名为<code>MessageSourceResolvable</code>的类中，您可以将此方法用于此类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>加载<code>ApplicationContext</code> ，它会自动搜索上下文中定义的<code>MessageSource</code> bean。bean必须具有名称<code>messageSource</code> 。如果找到这样的bean，则对前面方法的所有调用都被委托给消息源。如果未找到任何消息源， <code>ApplicationContext</code>尝试查找包含具有相同名称的bean的父级。如果是，它将该bean用作<code>MessageSource</code> 。如果<code>ApplicationContext</code>找不到任何消息源，则会实例化一个空的<code>DelegatingMessageSource</code> ，以便能够接受对上面定义的方法的调用。</p>
</div>
<div class="paragraph">
<p>Spring提供了两个<code>MessageSource</code>实现， <code>ResourceBundleMessageSource</code>和<code>StaticMessageSource</code> 。两者都实现<code>HierarchicalMessageSource</code>以进行嵌套消息传递。<code>StaticMessageSource</code>很少使用，但提供了以编程方式向源添加消息。以下示例显示了<code>ResourceBundleMessageSource</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messageSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.context.support。ResourceBundleMessageSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">basenames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> format <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> exceptions <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> windows <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例假定您在类路径中定义了三个称为<code>format</code> ， <code>exceptions</code>和<code>windows</code>资源包。解决消息的任何请求都以JDK标准的方式处理，通过<code>ResourceBundle</code>对象解析消息。出于示例的目的，假设上述两个资源包文件的内容如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">＃</span>在format.properties消息=鳄鱼摇滚！</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> innex.properties中的<span class="error">＃</span> argument.required =需要{ <span class="integer">0</span> }参数。</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一个示例显示了执行<code>MessageSource</code>功能的程序。请记住，所有<code>ApplicationContext</code>实现也都是<code>MessageSource</code>实现，因此可以<code>MessageSource</code>转换为<code>MessageSource</code>接口。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> message = resources.getMessage（ <span class="string"><span class="delimiter">“</span> <span class="content">message</span> <span class="delimiter">”</span></span> ， <span class="predefined-constant">null</span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Default</span> <span class="delimiter">”</span></span> ， <span class="predefined-constant">null</span> ）; <span class="predefined-type">System</span> .out.println（message）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述程序产生的结果如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>鳄鱼摇滚！</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>总而言之， <code>MessageSource</code>在名为<code>beans.xml</code>的文件中定义，该文件存在于类路径的根目录中。<code>messageSource</code> bean定义通过其<code>basenames</code>属性引用许多资源包。在列表中传递给<code>basenames</code>属性的三个文件作为类路径根目录下的文件存在，分别称为<code>format.properties</code> ， <code>exceptions.properties</code>和<code>windows.properties</code> 。</p>
</div>
<div class="paragraph">
<p>下一个示例显示传递给消息查找的参数。这些参数将转换为<code>String</code>对象，并插入到查找消息中的占位符中。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 此MessageSource正在Web应用程序中使用 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messageSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.context.support。ResourceBundleMessageSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">basename</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">exceptions</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 让我们将上面的MessageSource注入此POJO  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.something。示例</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messages</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Example</span> { <span class="directive">private</span> MessageSource messages; <span class="directive">public</span> <span class="type">void</span> setMessages（MessageSource messages）{ <span class="local-variable">this</span> .messages = messages; <span class="directive">public</span> <span class="type">void</span> execute（）{ <span class="predefined-type">String</span> message = <span class="local-variable">this</span> .messages.getMessage（ <span class="string"><span class="delimiter">“</span> <span class="content">argument.required</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">userDao</span> <span class="delimiter">”</span></span> }， <span class="string"><span class="delimiter">“</span> <span class="content">Required</span> <span class="delimiter">”</span></span> ， <span class="predefined-constant">null</span> ）; <span class="predefined-type">System</span> .out.println（message）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>调用<code>execute()</code>方法得到的结果如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>userDao参数是必需的。</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>关于国际化（“i18n”），Spring的各种<code>MessageSource</code>实现遵循与标准JDK <code>ResourceBundle</code>相同的区域设置解析和回退规则。总之，和继续该示例<code>messageSource</code>先前定义的，如果你想解析British（消息<code>en-GB</code> ）的语言环境，您可以创建文件名为<code>format_en_GB.properties</code> ， <code>exceptions_en_GB.properties</code>和<code>windows_en_GB.properties</code>分别。</p>
</div>
<div class="paragraph">
<p>通常，区域设置解析由应用程序的周围环境管理。在以下示例中，手动指定解析（英国）消息的区域设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>#inception_en_GB.properties argument.required = Ebagum lad，{0}参数是必需的，我说，是必需的。</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> args）{MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> message = resources.getMessage（ <span class="string"><span class="delimiter">“</span> <span class="content">argument.required</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">userDao</span> <span class="delimiter">”</span></span> }， <span class="string"><span class="delimiter">“</span> <span class="content">Required</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Locale</span> 。英国）; <span class="predefined-type">System</span> .out.println（message）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行上述程序产生的结果如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>Ebagum小伙子，我说，'userDao'论证是必需的。</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>MessageSourceAware</code>接口获取对已定义的任何<code>MessageSource</code>的引用。在创建和配置bean时，应用程序上下文的<code>MessageSource</code>会注入实现<code>MessageSourceAware</code>接口的<code>ApplicationContext</code>中定义的任何bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">作为<code>ResourceBundleMessageSource</code>的替代，Spring提供了一个<code>ReloadableResourceBundleMessageSource</code>类。此变体支持相同的bundle文件格式，但比基于标准JDK的<code>ResourceBundleMessageSource</code>实现更灵活。特别是，它允许从任何Spring资源位置（不仅从类路径）读取文件，并支持bundle属性文件的热重新加载（同时在其间有效地缓存它们）。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html"><code>ReloadableResourceBundleMessageSource</code> Javadoc</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-events"><a class="anchor" href="#context-functionality-events"></a> 1.15.2。标准和自定义事件</h4>
<div class="paragraph">
<p><code>ApplicationContext</code>中的事件处理是通过<code>ApplicationEvent</code>类和<code>ApplicationListener</code>接口提供的。如果将实现<code>ApplicationListener</code>接口的bean部署到上下文中，则每次将<code>ApplicationEvent</code>发布到<code>ApplicationContext</code> ，都会通知该bean。从本质上讲，这是标准的Observer设计模式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring 4.2开始，事件基础结构得到了显着改进，并提供了<a href="#context-functionality-events-annotation">基于注释的模型</a>以及发布任意事件的能力（即，不一定从<code>ApplicationEvent</code>扩展的对象）。当发布这样的对象时，我们将它包装在一个事件中。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下表描述了Spring提供的标准事件：</p>
</div>
<table id="beans-ctx-events-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表7。内置事件</caption>
<colgroup>
<col style="width:30%">
<col style="width:70%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">事件</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextRefreshedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">初始化或刷新<code>ApplicationContext</code>时发布（例如，通过使用<code>ConfigurableApplicationContext</code>接口上的<code>refresh()</code>方法）。这里，“初始化”意味着加载所有bean，检测并激活后处理器bean，预先实例化单例，并且可以使用<code>ApplicationContext</code>对象。只要上下文尚未关闭，只要所选的<code>ApplicationContext</code>实际支持这种“热”刷新，就可以多次触发刷新。例如， <code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStartedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用<code>ConfigurableApplicationContext</code>接口上的<code>start()</code>方法<code>start()</code> <code>ApplicationContext</code>时发布。这里，“已启动”意味着所有<code>Lifecycle</code> bean都会收到明确的启动信号。通常，此信号用于在显式停止后重新启动Bean，但它也可用于启动尚未为自动启动配置的组件（例如，在初始化时尚未启动的组件）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStoppedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用<code>ConfigurableApplicationContext</code>接口上的<code>stop()</code>方法<code>stop()</code> <code>ApplicationContext</code>时发布。这里，“已停止”表示所有<code>Lifecycle</code> bean都会收到明确的停止信号。可以通过<code>start()</code>调用重新启动已停止的上下文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextClosedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用<code>ConfigurableApplicationContext</code>接口上的<code>close()</code>方法关闭<code>ApplicationContext</code>时发布。这里，“关闭”意味着所有单例bean都被销毁。封闭的环境达到其寿命终结。它无法刷新或重新启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个特定于Web的事件，告诉所有bean已经为HTTP请求提供服务。请求完成后发布此事件。此事件仅适用于使用Spring的<code>DispatcherServlet</code> Web应用程序。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您还可以创建和发布自己的自定义事件。以下示例显示了一个扩展Spring的<code>ApplicationEvent</code>基类的简单类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">BlackListEvent</span> <span class="directive">扩展</span> ApplicationEvent { <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> address; <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span>内容; <span class="directive">public</span> BlackListEvent（ <span class="predefined-type">Object</span> source， <span class="predefined-type">String</span> address， <span class="predefined-type">String</span> content）{ <span class="local-variable">super</span> （source）; <span class="local-variable">这个</span> .address =地址; <span class="local-variable">这个</span> .content = content; } <span class="comment">//访问器和其他方法......</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要发布自定义<code>ApplicationEvent</code> ，调用<code>publishEvent()</code>上的方法<code>ApplicationEventPublisher</code> 。通常，这是通过创建一个实现<code>ApplicationEventPublisherAware</code>并将其注册为Spring bean的类来完成的。以下示例显示了这样一个类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">EmailService</span> <span class="directive">实现</span> ApplicationEventPublisherAware { <span class="directive">private</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; blackList; <span class="directive">私有</span> ApplicationEventPublisher发布者; <span class="directive">public</span> <span class="type">void</span> setBlackList（ <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; blackList）{ <span class="local-variable">this</span> .blackList = blackList; <span class="directive">public</span> <span class="type">void</span> setApplicationEventPublisher（ApplicationEventPublisher publisher）{ <span class="local-variable">this</span> .publisher = publisher; <span class="directive">public</span> <span class="type">void</span> sendEmail（ <span class="predefined-type">String</span> address， <span class="predefined-type">String</span> content）{ <span class="keyword">if</span> （blackList.contains（address））{publisher.publishEvent（ <span class="keyword">new</span> BlackListEvent（ <span class="local-variable">this</span> ，address，content））; <span class="keyword">回归</span> ; } <span class="comment">//发送电子邮件...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在配置时，Spring容器检测到<code>EmailService</code>实现<code>ApplicationEventPublisherAware</code>并自动调用<code>setApplicationEventPublisher()</code> 。实际上，传入的参数是Spring容器本身。您正在通过其<code>ApplicationEventPublisher</code>接口与应用程序上下文进行交互。</p>
</div>
<div class="paragraph">
<p>要接收自定义<code>ApplicationEvent</code> ，您可以创建一个实现<code>ApplicationListener</code>的类并将其注册为Spring bean。以下示例显示了这样一个类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">BlackListNotifier</span> <span class="directive">实现</span> ApplicationListener &lt;BlackListEvent&gt; { <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress; <span class="directive">public</span> <span class="type">void</span> setNotificationAddress（ <span class="predefined-type">String</span> notificationAddress）{ <span class="local-variable">this</span> .notificationAddress = notificationAddress; <span class="directive">public</span> <span class="type">void</span> onApplicationEvent（BlackListEvent event）{ <span class="comment">//通过notificationAddress通知相关方......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>ApplicationListener</code>通常使用自定义事件的类型进行参数化（前面示例中为<code>BlackListEvent</code> ）。这意味着<code>onApplicationEvent()</code>方法可以保持类型安全，从而避免任何向下转换的需要。您可以根据需要注册任意数量的事件侦听器，但请注意，默认情况下，事件侦听器会同步接收事件。这意味着<code>publishEvent()</code>方法将阻塞，直到所有侦听器都已完成对事件的处理。这种同步和单线程方法的一个优点是，当侦听器接收到事件时，如果事务上下文可用，它将在发布者的事务上下文内运行。如果需要另一个事件发布策略，请参阅Javadoc for Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html"><code>ApplicationEventMulticaster</code></a>接口。</p>
</div>
<div class="paragraph">
<p>以下示例显示了用于注册和配置上述每个类的bean定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emailService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。EmailService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">blackList</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> known.spammer@example.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> known.hacker@example.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> john.doe@example .org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">blackListNotifier</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。BlackListNotifier</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">notificationAddress</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">blacklist@example.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>总而言之，当调用<code>emailService</code> bean的<code>sendEmail()</code>方法时，如果有任何应列入黑名单的电子邮件消息，则会发布<code>BlackListEvent</code>类型的自定义事件。该<code>blackListNotifier</code> bean被注册为<code>ApplicationListener</code>并接收<code>BlackListEvent</code> ，此时它可以通知有关各方。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring的事件机制是为在同一应用程序上下文中的Spring bean之间的简单通信而设计的。但是，对于更复杂的企业集成需求，单独维护的<a href="http://projects.spring.io/spring-integration/">Spring Integration</a>项目为构建基于众所周知的Spring编程模型的轻量级， <a href="http://www.enterpriseintegrationpatterns.com">面向模式</a> ，事件驱动的体系结构提供了完整的支持。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="context-functionality-events-annotation"><a class="anchor" href="#context-functionality-events-annotation"></a>基于注释的事件监听器</h5>
<div class="paragraph">
<p>从Spring 4.2开始，您可以使用<code>EventListener</code>批注在托管bean的任何公共方法上注册事件监听器。<code>BlackListNotifier</code>可以重写如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">BlackListNotifier</span> { <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress; <span class="directive">public</span> <span class="type">void</span> setNotificationAddress（ <span class="predefined-type">String</span> notificationAddress）{ <span class="local-variable">this</span> .notificationAddress = notificationAddress; } <span class="annotation">@EventListener</span> <span class="directive">public</span> <span class="type">void</span> processBlackListEvent（BlackListEvent event）{ <span class="comment">//通过notificationAddress通知相关方......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>方法签名再次声明它侦听的事件类型，但这次使用灵活的名称并且没有实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析通用参数，也可以通过泛型缩小事件类型。</p>
</div>
<div class="paragraph">
<p>如果您的方法应该监听多个事件，或者您想要根据任何参数进行定义，那么也可以在注释本身上指定事件类型。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span> （{ContextStartedEvent.class， <span class="annotation">ContextRefreshedEvent.class</span> }） <span class="directive">public</span> <span class="type">void</span> handleContextStart（）{...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还可以通过使用定义<a href="#expressions"><code>SpEL</code>表达式</a>的注释的<code>condition</code>属性来添加额外的运行时过滤，该<a href="#expressions">表达式</a>应匹配以实际调用特定事件的方法。</p>
</div>
<div class="paragraph">
<p>以下示例显示了仅当事件的<code>content</code>属性等于<code>my-event</code>才能重写我们的通知程序以进行调用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span> （condition = <span class="string"><span class="delimiter">“</span> <span class="content">＃blEvent.content =='my-event'</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> processBlackListEvent（BlackListEvent blEvent）{ <span class="comment">//通过notificationAddress通知相关方......</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每个<code>SpEL</code>表达式都针对专用上下文进行评估。下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p>
</div>
<table id="context-functionality-events-annotation-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表8。事件SpEL可用元数据</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">位置</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">事件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实际的<code>ApplicationEvent</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.event</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于调用目标的参数（作为数组）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.args [0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>参数名称</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估背景</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何方法参数的名称。如果由于某种原因，名称不可用（例如，因为没有调试信息），参数名称也可以在<code>#a&lt;#arg&gt;</code>下<code>#arg</code> ，其中<code>#arg</code>代表参数索引（从0开始） 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#blEvent</code>或<code>#a0</code> （您也可以使用<code>#p0</code>或<code>#p&lt;#arg&gt;</code>表示法作为别名）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，即使您的方法签名实际引用已发布的任意对象， <code>#root.event</code>允许您访问基础事件。</p>
</div>
<div class="paragraph">
<p>如果您需要作为处理其他事件的结果发布事件，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span> <span class="directive">public</span> ListUpdateEvent handleBlackListEvent（BlackListEvent event）{ <span class="comment">//通过notificationAddress通知相关方，</span> <span class="comment">//然后发布ListUpdateEvent ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><a href="#context-functionality-events-async">异步侦听</a>器不支持此功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这种新的方法来发布新<code>ListUpdateEvent</code>为每<code>BlackListEvent</code>通过上述方法处理。如果需要发布多个事件，则可以返回事件<code>Collection</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-async"><a class="anchor" href="#context-functionality-events-async"></a>异步监听器</h5>
<div class="paragraph">
<p>如果希望特定侦听器异步处理事件，则可以重用<a href="integration.html#scheduling-annotation-support-async">常规<code>@Async</code>支持</a> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span> <span class="annotation">@Async</span> <span class="directive">public</span> <span class="type">void</span> processBlackListEvent（BlackListEvent event）{ <span class="comment">//</span> BlackListEvent <span class="comment">在一个单独的线程中处理</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用异步事件时请注意以下限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果事件侦听器抛出<code>Exception</code> ，则不会将其传播给调用者有关详细信息，请参阅<code>AsyncUncaughtExceptionHandler</code> 。</p>
</li>
<li>
<p>此类事件监听器无法发送回复。如果您需要作为处理结果发送另一个事件，请注入<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html"><code>ApplicationEventPublisher</code></a>以手动发送事件。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-order"><a class="anchor" href="#context-functionality-events-order"></a>订购听众</h5>
<div class="paragraph">
<p>如果需要在另一个侦听器之前调用一个侦听器，则可以将<code>@Order</code>注释添加到方法声明中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span> <span class="annotation">@Order</span> （ <span class="integer">42</span> ） <span class="directive">public</span> <span class="type">void</span> processBlackListEvent（BlackListEvent event）{ <span class="comment">//通过notificationAddress通知相关方......</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-generics"><a class="anchor" href="#context-functionality-events-generics"></a>通用事件</h5>
<div class="paragraph">
<p>您还可以使用泛型来进一步定义事件的结构。考虑使用<code>EntityCreatedEvent&lt;T&gt;</code> ，其中<code>T</code>是创建的实际实体的类型。例如，您可以创建以下侦听器定义以仅接收<code>Person</code> <code>EntityCreatedEvent</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span> <span class="directive">public</span> <span class="type">void</span> onPersonCreated（EntityCreatedEvent &lt;Person&gt; event）{...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于类型擦除，仅当被触发的事件解析了事件侦听器过滤器的泛型参数（即<code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; { …​ }</code> ）时，此方法才有效。</p>
</div>
<div class="paragraph">
<p>在某些情况下，如果所有事件都遵循相同的结构（这可能是前面示例中的事件的情况），则这可能变得相当繁琐。在这种情况下，您可以实现<code>ResolvableTypeProvider</code>来指导框架超出运行时环境提供的范围。以下事件显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EntityCreatedEvent</span> &lt;T&gt; <span class="directive">extends</span> ApplicationEvent <span class="directive">实现</span> ResolvableTypeProvider { <span class="directive">public</span> EntityCreatedEvent（T entity）{ <span class="local-variable">super</span> （entity）; } <span class="annotation">@Override</span> <span class="directive">public</span> ResolvableType getResolvableType（）{ <span class="keyword">return</span> ResolvableType.forClassWithGenerics（getClass（），ResolvableType.forInstance（getSource（）））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这不仅适用于<code>ApplicationEvent</code> ，也适用于作为事件发送的任意对象。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-resources"><a class="anchor" href="#context-functionality-resources"></a> 1.15.3。方便地访问低级资源</h4>
<div class="paragraph">
<p>为了最佳地使用和理解应用程序上下文，您应该熟悉Spring的<code>Resource</code>抽象，如<a href="#resources">参考资料中所述</a> 。</p>
</div>
<div class="paragraph">
<p>应用程序上下文是<code>ResourceLoader</code> ，可用于加载<code>Resource</code>对象。<code>Resource</code>本质上是JDK <code>java.net.功能更丰富的版本<code>java.net.URL</code>类。实际上， <code>Resource</code>的实现包装了一个<code>java.net.实例<code>java.net.适当的URL</code> 。<code>Resource</code>可以透明的方式从几乎任何位置获取低级资源，包括从类路径，文件系统位置，任何可用标准URL描述的位置，以及一些其他变体。如果资源位置字符串是没有任何特殊前缀的简单路径，那么这些资源来自特定且适合于实际应用程序上下文类型。</p>
</div>
<div class="paragraph">
<p>您可以配置部署到应用程序上下文中的bean，以实现特殊的回调接口<code>ResourceLoaderAware</code> ，在初始化时自动回调，应用程序上下文本身作为<code>ResourceLoader</code>传入。您还可以公开<code>Resource</code>类型的属性，以用于访问静态资源。它们像任何其他属性一样被注入其中。您可以将这些<code>Resource</code>属性指定为简单的<code>String</code>路径，并依赖特殊的JavaBean <code>PropertyEditor</code> （由上下文自动注册），以便在部署bean时将这些文本字符串转换为实际的<code>Resource</code>对象。</p>
</div>
<div class="paragraph">
<p>提供给<code>ApplicationContext</code>构造函数的位置路径实际上是资源字符串，并且以简单的形式根据特定的上下文实现进行适当处理。例如， <code>ClassPathXmlApplicationContext</code>将简单的位置路径视为类路径位置。您还可以使用具有特殊前缀的位置路径（资源字符串）来强制从类路径或URL加载定义，而不管实际的上下文类型如何。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-create"><a class="anchor" href="#context-create"></a> 1.15.4。方便的Web应用程序的ApplicationContext实例化</h4>
<div class="paragraph">
<p>您可以使用例如<code>ContextLoader</code>以声明方式创建<code>ApplicationContext</code>实例。当然，您也可以使用其中一个<code>ApplicationContext</code>实现以编程方式创建<code>ApplicationContext</code>实例。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>ContextLoaderListener</code>注册<code>ApplicationContext</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context-param&gt;</span> <span class="tag">&lt;param-name&gt;</span> contextConfigLocation <span class="tag">&lt;/ param-name&gt;</span> <span class="tag">&lt;param-value&gt;</span> /WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml <span class="tag">&lt;/ param-value&gt;</span> <span class="tag">&lt;/ context-param&gt;</span> <span class="tag">&lt;listener&gt;</span> <span class="tag">&lt;listener-class&gt;</span> org.springframework.web.context。ContextLoaderListener <span class="tag">&lt;/ listener-class&gt;</span> <span class="tag">&lt;/ listener&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>侦听器检查<code>contextConfigLocation</code>参数。如果参数不存在，则侦听器将<code>/WEB-INF/applicationContext.xml</code>用作默认值。当参数确实存在时，侦听器使用预定义的分隔符（逗号，分号和空格）分隔<code>String</code> ，并将值用作搜索应用程序上下文的位置。还支持Ant样式的路径模式。例子是<code>/WEB-INF/*Context.xml</code> （对于名称以结尾的所有文件<code>Context.xml</code> ，并驻留在<code>WEB-INF</code>目录）和<code>/WEB-INF/**/*Context.xml</code> （所有此类<code>WEB-INF</code>任何子目录中的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-deploy-rar"><a class="anchor" href="#context-deploy-rar"></a> 1.15.5。将Spring <code>ApplicationContext</code>部署为Java EE RAR文件</h4>
<div class="paragraph">
<p>可以将Spring <code>ApplicationContext</code>部署为RAR文件，将上下文及其所有必需的bean类和库JAR封装在Java EE RAR部署单元中。这相当于引导能够访问Java EE服务器设施的独立<code>ApplicationContext</code> （仅托管在Java EE环境中）。RAR部署是部署无头WAR文件的一种更自然的替代方案 - 实际上是一个没有任何HTTP入口点的WAR文件，仅用于在Java EE环境中引导Spring <code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>RAR部署非常适用于不需要HTTP入口点但仅包含消息端点和预定作业的应用程序上下文。在这样的上下文中的Bean可以使用应用程序服务器资源，例如JTA事务管理器和JNDI绑定的JDBC <code>DataSource</code>实例和JMS <code>ConnectionFactory</code>实例，并且还可以通过Spring的标准事务管理以及JNDI和JMX支持工具向平台的JMX服务器注册。应用程序组件还可以通过Spring的<code>TaskExecutor</code>抽象与应用程序服务器的JCA <code>WorkManager</code>进行交互。</p>
</div>
<div class="paragraph">
<p>有关RAR部署中涉及的配置详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>类的Javadoc。</p>
</div>
<div class="paragraph">
<p>对于将Spring ApplicationContext简单部署为Java EE RAR文件：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将所有应用程序类打包到一个RAR文件（这是一个具有不同文件扩展名的标准JAR文件）。。将所有必需的库JAR添加到RAR存档的根目录中。。添加<code>META-INF/ra.xml</code>部署描述符（如<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html">Javadoc</a>所示）和相应的Spring XML bean定义文件（通常是`META-INF / applicationContext.xml）。</p>
</li>
<li>
<p>将生成的RAR文件放入应用程序服务器的部署目录中。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这种RAR部署单元通常是独立的。它们不会将组件暴露给外部世界，甚至不会暴露给同一应用程序的其他模块。与基于RAR的<code>ApplicationContext</code>交互通常通过与其他模块共享的JMS目标进行。例如，基于RAR的<code>ApplicationContext</code>还可以调度一些作业或对文件系统中的新文件（或类似物）作出反应。如果它需要允许来自外部的同步访问，它可以（例如）导出RMI端点，这可以由同一台机器上的其他应用程序模块使用。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beanfactory"><a class="anchor" href="#beans-beanfactory"></a> 1.16。<code>BeanFactory</code></h3>
<div class="paragraph">
<p><code>BeanFactory</code> API为Spring的IoC功能提供了基础。它的特定契约主要用于与Spring的其他部分和相关的第三方框架集成，其<code>DefaultListableBeanFactory</code>实现是更高级别<code>GenericApplicationContext</code>容器中的密钥委托。</p>
</div>
<div class="paragraph">
<p><code>BeanFactory</code>和相关接口（例如<code>BeanFactoryAware</code> ， <code>InitializingBean</code> ， <code>DisposableBean</code> ）是其他框架组件的重要集成点。通过不需要任何注释或甚至反射，它们允许容器与其组件之间的非常有效的交互。应用程序级bean可以使用相同的回调接口，但通常更喜欢通过注释或通过编程配置进行声明性依赖注入。</p>
</div>
<div class="paragraph">
<p>请注意，核心<code>BeanFactory</code> API级别及其<code>DefaultListableBeanFactory</code>实现不会对配置格式或要使用的任何组件注释做出假设。所有这些风格都通过扩展（例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code> ）进行，并作为核心元数据表示在共享<code>BeanDefinition</code>对象上运行。这是使Spring的容器如此灵活和可扩展的本质。</p>
</div>
<div class="sect3">
<h4 id="context-introduction-ctx-vs-beanfactory"><a class="anchor" href="#context-introduction-ctx-vs-beanfactory"></a> 1.16.1。<code>BeanFactory</code>或<code>ApplicationContext</code> ？</h4>
<div class="paragraph">
<p>本节介绍<code>BeanFactory</code>和<code>ApplicationContext</code>容器级别之间的差异以及对引导的影响。</p>
</div>
<div class="paragraph">
<p>您应该使用<code>ApplicationContext</code>除非您有充分的理由不这样做，使用<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的常见实现。这些是Spring用于所有常见目的的核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册bean定义和带注释的类，以及（从5.0开始）注册功能bean定义。</p>
</div>
<div class="paragraph">
<p>因为<code>ApplicationContext</code>包含<code>BeanFactory</code>所有功能，所以通常建议使用<code>BeanFactory</code> ，除了需要完全控制bean处理的场景之外。在<code>ApplicationContext</code> （例如<code>GenericApplicationContext</code>实现）中，按照约定（即通过bean名称或bean类型 - 特别是后处理器）检测到几种bean，而普通的<code>DefaultListableBeanFactory</code>对任何特殊bean都是不可知的。</p>
</div>
<div class="paragraph">
<p>对于许多扩展容器功能，例如注释处理和AOP代理， <a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code>扩展点</a>是必不可少的。如果仅使用普通的<code>DefaultListableBeanFactory</code> ，则默认情况下不会检测到并激活此类后处理器。这种情况可能令人困惑，因为您的bean配置实际上没有任何问题。相反，在这种情况下，容器需要通过其他设置完全自举。</p>
</div>
<div class="paragraph">
<p>下表列出了<code>BeanFactory</code>和<code>ApplicationContext</code>接口和实现提供的功能。</p>
</div>
<table id="context-introduction-ctx-vs-beanfactory-feature-matrix" class="tableblock frame-all grid-all spread">
<caption class="title">表9。特征矩阵</caption>
<colgroup>
<col style="width:50%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">特征</th>
<th class="tableblock halign-left valign-top"><code>Bean工厂</code></th>
<th class="tableblock halign-left valign-top"><code>的ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean实例化/布线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集成的生命周期管理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动<code>BeanPostProcessor</code>注册</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动<code>BeanFactoryPostProcessor</code>注册</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方便的<code>MessageSource</code>访问（用于内部化）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">内置<code>ApplicationEvent</code>发布机制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要使用<code>DefaultListableBeanFactory</code>显式注册bean后处理器，您需要以编程方式调用<code>addBeanPostProcessor</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory（）; <span class="comment">//使用bean定义填充工厂</span> <span class="comment">//现在注册任何所需的BeanPostProcessor实例</span> factory.addBeanPostProcessor（ <span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor（））; factory.addBeanPostProcessor（ <span class="keyword">new</span> MyBeanPostProcessor（））; <span class="comment">//现在开始使用工厂了</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要将<code>BeanFactoryPostProcessor</code>应用于普通的<code>DefaultListableBeanFactory</code> ，需要调用其<code>postProcessBeanFactory</code>方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory（）; XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader（factory）; reader.loadBeanDefinitions（ <span class="keyword">new</span> FileSystemResource（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ））; <span class="comment">//从属性文件中引入一些属性值</span> PropertyPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertyPlaceholderConfigurer（）; cfg.setLocation（ <span class="keyword">new</span> FileSystemResource（ <span class="string"><span class="delimiter">“</span> <span class="content">jdbc.properties</span> <span class="delimiter">”</span></span> ））; <span class="comment">//现在实际上做了替换</span> cfg.postProcessBeanFactory（factory）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，显式注册步骤都不方便，这就是为什么各种<code>ApplicationContext</code>变体优先于Spring支持的应用程序中的普通<code>DefaultListableBeanFactory</code> ，特别是在典型企业设置中依赖<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>实例来扩展容器功能时。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>AnnotationConfigApplicationContext</code>具有注册的所有常见注释后处理器，并且可以通过配置注释（例如<code>@EnableTransactionManagement</code>在封面下引入其他处理器。在Spring的基于注释的配置模型的抽象级别，bean后处理器的概念变成仅仅是内部容器细节。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources"><a class="anchor" href="#resources"></a> 2。资源</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍Spring如何处理资源以及如何在Spring中使用资源。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#resources-introduction">介绍</a></p>
</li>
<li>
<p><a href="#resources-resource">资源接口</a></p>
</li>
<li>
<p><a href="#resources-implementations">内置资源实现</a></p>
</li>
<li>
<p><a href="#resources-resourceloader"><code>ResourceLoader</code></a></p>
</li>
<li>
<p><a href="#resources-resourceloaderaware"><code>ResourceLoaderAware</code>接口</a></p>
</li>
<li>
<p><a href="#resources-as-dependencies">资源作为依赖关系</a></p>
</li>
<li>
<p><a href="#resources-app-ctx">应用程序上下文和资源路径</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="resources-introduction"><a class="anchor" href="#resources-introduction"></a> 2.1。介绍</h3>
<div class="paragraph">
<p>Java的标准<code>java.net.遗憾的是，各种URL前缀的URL</code>类和标准处理程序对于所有对低级资源的访问都不够充分。例如，没有标准化的<code>URL</code>实现可用于访问需要从类路径或相对于<code>ServletContext</code>获取的资源。虽然可以为专门的<code>URL</code>前缀注册新的处理程序（类似于<code>http:</code> :)等现有处理程序，但这通常非常复杂，并且<code>URL</code>接口仍缺少一些理想的功能，例如检查存在的方法被指向的资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-resource"><a class="anchor" href="#resources-resource"></a> 2.2。资源接口</h3>
<div class="paragraph">
<p>Spring的<code>Resource</code>接口旨在成为一个更有能力的接口，用于抽象对低级资源的访问。以下清单显示了<code>Resource</code>接口定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Resource</span> <span class="directive">extends</span> InputStreamSource { <span class="type">boolean</span> exists（）; <span class="type">boolean</span> isOpen（）; <span class="predefined-type">URL</span> getURL（） <span class="directive">抛出</span> <span class="exception">IOException</span> ; <span class="predefined-type">File</span> getFile（） <span class="directive">抛出</span> <span class="exception">IOException</span> ;资源createRelative（ <span class="predefined-type">String</span> relativePath） <span class="directive">抛出</span> <span class="exception">IOException</span> ; <span class="predefined-type">String</span> getFilename（）; <span class="predefined-type">String</span> getDescription（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正如<code>Resource</code>接口的定义所示，它扩展了<code>InputStreamSource</code>接口。以下清单显示了<code>InputStreamSource</code>接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InputStreamSource</span> { <span class="predefined-type">InputStream</span> getInputStream（） <span class="directive">抛出</span> <span class="exception">IOException</span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Resource</code>接口中一些最重要的方法是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInputStream()</code> ：找到并打开资源，返回一个<code>InputStream</code>以便从资源中读取。预计每次调用都会返回一个新的<code>InputStream</code> 。呼叫者有责任关闭流。</p>
</li>
<li>
<p><code>exists()</code> ：返回一个<code>boolean</code>指示此资源是否实际以物理形式存在。</p>
</li>
<li>
<p><code>isOpen()</code> ：返回一个<code>boolean</code>指示此资源是否表示具有开放流的句柄。如果为<code>true</code> ，则无法多次读取<code>InputStream</code> ，并且必须只读取一次然后关闭以避免资源泄漏。对于所有常规资源实现，返回<code>false</code> ，但<code>InputStreamResource</code>除外。</p>
</li>
<li>
<p><code>getDescription()</code> ：返回此资源的描述，用于处理资源时的错误输出。这通常是完全限定的文件名或资源的实际URL。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其他方法允许您获取表示资源的实际<code>URL</code>或<code>File</code>对象（如果底层实现兼容并支持该功能）。</p>
</div>
<div class="paragraph">
<p>当需要资源时，Spring本身广泛使用<code>Resource</code>抽象，作为许多方法签名中的参数类型。某些Spring API中的其他方法（例如各种<code>ApplicationContext</code>实现的构造函数）接受一个<code>String</code> ，该<code>String</code>以简单或简单的形式用于创建适合该上下文实现的<code>Resource</code> ，或者通过<code>String</code>路径上的特殊前缀，让调用者指定必须创建和使用特定的<code>Resource</code>实现。</p>
</div>
<div class="paragraph">
<p>尽管在Spring和Spring中使用了<code>Resource</code>接口，但实际上非常有用的是在您自己的代码中作为通用实用程序类使用，以便访问资源，即使您的代码不知道或不关心任何其他春天的一部分。虽然这会将您的代码耦合到Spring，但它实际上只将它耦合到这一小组实用程序类，这些实用程序类可以作为<code>URL</code>的更有能力的替代品，并且可以被认为等同于您将用于此目的的任何其他库。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>Resource</code>抽象不会取代功能。它尽可能地包裹它。例如， <code>UrlResource</code>包装URL并使用包装的<code>URL</code>来完成其工作。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="resources-implementations"><a class="anchor" href="#resources-implementations"></a> 2.3。内置资源实现</h3>
<div class="paragraph">
<p>Spring包括以下<code>Resource</code>实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#resources-implementations-urlresource"><code>UrlResource对象</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-classpathresource"><code>使用ClassPathResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-filesystemresource"><code>的FileSystemResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-servletcontextresource"><code>ServletContextResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-inputstreamresource"><code>的InputStreamResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-bytearrayresource"><code>使用ByteArrayResource</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="resources-implementations-urlresource"><a class="anchor" href="#resources-implementations-urlresource"></a> 2.3.1。<code>UrlResource对象</code></h4>
<div class="paragraph">
<p><code>UrlResource</code>包装了一个<code>java.net.URL</code> ，可用于访问通常可通过URL访问的任何对象，例如文件，HTTP目标，FTP目标等。所有URL都具有标准化的<code>String</code>表示，以便使用适当的标准化前缀来指示另一个URL类型。这包括<code>file:</code>用于访问文件系统路径， <code>http:</code>用于通过HTTP协议访问资源， <code>ftp:</code>用于通过FTP访问资源，以及其他。</p>
</div>
<div class="paragraph">
<p><code>UrlResource</code>由Java代码通过显式使用<code>UrlResource</code>构造函数创建，但通常在调用采用<code>String</code>参数表示路径的API方法时隐式创建。对于后一种情况，JavaBeans <code>PropertyEditor</code>最终决定要创建哪种类型的<code>Resource</code> 。如果路径字符串包含众所周知的（对于它，那就是）前缀（例如<code>classpath:</code> ，它会为该前缀创建适当的专用<code>Resource</code> 。但是，如果它无法识别前缀，则假定该字符串是标准URL字符串并创建<code>UrlResource</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-classpathresource"><a class="anchor" href="#resources-implementations-classpathresource"></a> 2.3.2。<code>使用ClassPathResource</code></h4>
<div class="paragraph">
<p>此类表示应从类路径获取的资源。它使用线程上下文类加载器，给定的类加载器或给定的类来加载资源。</p>
</div>
<div class="paragraph">
<p>此<code>Resource</code>实现支持解析为<code>java.io.File</code>如果类路径的资源存在于文件系统，但不驻留在一个罐子并没有被扩大（由servlet引擎或任何环境），以文件系统类路径的资源。为了解决这个问题，各种<code>Resource</code>实现始终支持作为<code>java.net.解析<code>java.net.URL</code> 。</p>
</div>
<div class="paragraph">
<p><code>ClassPathResource</code>是由Java代码通过显式使用<code>ClassPathResource</code>构造函数创建的，但通常在调用采用<code>String</code>参数表示路径的API方法时隐式创建。对于后一种情况，JavaBeans <code>PropertyEditor</code>在字符串路径上识别特殊前缀<code>classpath:</code> <code>ClassPathResource</code>在该情况下创建<code>ClassPathResource</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-filesystemresource"><a class="anchor" href="#resources-implementations-filesystemresource"></a> 2.3.3。<code>的FileSystemResource</code></h4>
<div class="paragraph">
<p>这是<code>java.io.的<code>Resource</code>实现。File</code>句柄。它支持作为<code>File</code>和<code>URL</code>解析。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-servletcontextresource"><a class="anchor" href="#resources-implementations-servletcontextresource"></a> 2.3.4。<code>ServletContextResource</code></h4>
<div class="paragraph">
<p>这是<code>ServletContext</code>资源的<code>Resource</code>实现，用于解释相关Web应用程序根目录中的相对路径。</p>
</div>
<div class="paragraph">
<p>它始终支持流访问和URL访问，但允许<code>java.io.仅在扩展Web应用程序存档且资源实际位于文件系统上时才进行File</code>访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）（可以想象）访问，实际上都依赖于Servlet容器。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-inputstreamresource"><a class="anchor" href="#resources-implementations-inputstreamresource"></a> 2.3.5。<code>的InputStreamResource</code></h4>
<div class="paragraph">
<p><code>InputStreamResource</code>是给定<code>InputStream</code>的<code>Resource</code>实现。仅在没有适用的特定<code>Resource</code>实现时才应使用它。特别是，在可能的情况下，更喜欢<code>ByteArrayResource</code>或任何基于文件的<code>Resource</code>实现。</p>
</div>
<div class="paragraph">
<p>与其他<code>Resource</code>实现相比，这是已打开资源的描述符。因此，它从<code>isOpen()</code>返回<code>true</code> 。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-bytearrayresource"><a class="anchor" href="#resources-implementations-bytearrayresource"></a> 2.3.6。<code>使用ByteArrayResource</code></h4>
<div class="paragraph">
<p>这是给定字节数组的<code>Resource</code>实现。它为给定的字节数组创建一个<code>ByteArrayInputStream</code> 。</p>
</div>
<div class="paragraph">
<p>它对于从任何给定的字节数组加载内容非常有用，而无需使用一次性使用的<code>InputStreamResource</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-resourceloader"><a class="anchor" href="#resources-resourceloader"></a> 2.4。<code>ResourceLoader</code></h3>
<div class="paragraph">
<p><code>ResourceLoader</code>接口旨在由可以返回（即加载） <code>Resource</code>实例的对象实现。以下清单显示了<code>ResourceLoader</code>接口定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResourceLoader</span> {Resource getResource（ <span class="predefined-type">String</span> location）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所有应用程序上下文都实现<code>ResourceLoader</code>接口。因此，可以使用所有应用程序上下文来获取<code>Resource</code>实例。</p>
</div>
<div class="paragraph">
<p>在特定应用程序上下文上调用<code>getResource()</code>并且指定的位置路径没有特定前缀时，将返回适合该特定应用程序上下文的<code>Resource</code>类型。例如，假设针对<code>ClassPathXmlApplicationContext</code>实例执行了以下代码片段：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">资源模板= ctx.getResource（ <span class="string"><span class="delimiter">“</span> <span class="content">some / resource / path / myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>针对<code>ClassPathXmlApplicationContext</code> ，该代码返回<code>ClassPathResource</code> 。如果对<code>FileSystemXmlApplicationContext</code>实例执行相同的方法，它将返回<code>FileSystemResource</code> 。对于<code>WebApplicationContext</code> ，它将返回<code>ServletContextResource</code> 。它同样会为每个上下文返回适当的对象。</p>
</div>
<div class="paragraph">
<p>因此，您可以以适合特定应用程序上下文的方式加载资源。</p>
</div>
<div class="paragraph">
<p>另一方面，您可以通过指定特殊的<code>classpath:</code>前缀来强制使用<code>ClassPathResource</code> ，而不管应用程序上下文类型如何，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">资源模板= ctx.getResource（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：some / resource / path / myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，您可以通过指定任何标准<code>java.net.来强制使用<code>UrlResource</code> <code>java.net.URL</code>前缀。以下对示例使用<code>file</code>和<code>http</code>前缀：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">资源模板= ctx.getResource（ <span class="string"><span class="delimiter">“</span> <span class="content">file：///some/resource/path/myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">资源模板= ctx.getResource（ <span class="string"><span class="delimiter">“</span> <span class="content">http://myhost.com/resource/path/myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下表总结了将<code>String</code>对象转换为<code>Resource</code>对象的策略：</p>
</div>
<table id="resources-resource-strings" class="tableblock frame-all grid-all spread">
<caption class="title">表10。资源字符串</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字首</th>
<th class="tableblock halign-left valign-top">例</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类路径：</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>类路径：COM / MYAPP / config.xml中</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从类路径加载。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件：</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="javascript:void(0);" class="bare">文件：///data/config.xml</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从文件系统加载为<code>URL</code> 。另请参见<a href="#resources-filesystemresource-caveats"><code>FileSystemResource</code>警告</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP：</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://myserver/logo.png" class="bare">HTTP：//myserver/logo.png</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为<code>URL</code>加载。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（没有）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/data/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">取决于底层的<code>ApplicationContext</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="resources-resourceloaderaware"><a class="anchor" href="#resources-resourceloaderaware"></a> 2.5。<code>ResourceLoaderAware</code>接口</h3>
<div class="paragraph">
<p><code>ResourceLoaderAware</code>接口是一个特殊的标记接口，用于标识期望与<code>ResourceLoader</code>引用一起提供的对象。以下清单显示了<code>ResourceLoaderAware</code>接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResourceLoaderAware</span> { <span class="type">void</span> setResourceLoader（ResourceLoader resourceLoader）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当类实现<code>ResourceLoaderAware</code>并部署到应用程序上下文（作为Spring管理的bean）时，它被应用程序上下文识别为<code>ResourceLoaderAware</code> 。然后，应用程序上下文调用<code>setResourceLoader(ResourceLoader)</code> ，将其自身作为参数提供（请记住，Spring中的所有应用程序上下文都实现了<code>ResourceLoader</code>接口）。</p>
</div>
<div class="paragraph">
<p>由于<code>ApplicationContext</code>是<code>ResourceLoader</code> ，因此bean还可以实现<code>ApplicationContextAware</code>接口并直接使用提供的应用程序上下文来加载资源。但是，一般情况下，如果您需要，最好使用专用的<code>ResourceLoader</code>接口。代码只能耦合到资源加载接口（可以被认为是实用程序接口）而不是整个Spring <code>ApplicationContext</code>接口。</p>
</div>
<div class="paragraph">
<p>从Spring 2.5开始，您可以依赖<code>ResourceLoader</code>自动装配作为实现<code>ResourceLoaderAware</code>接口的替代方法。“传统” <code>constructor</code>和<code>byType</code>自动<a href="#beans-factory-autowire">装配</a>模式（如<a href="#beans-factory-autowire">自动装配协作者中所述</a> ）现在能够分别为构造函数参数或setter方法参数提供<code>ResourceLoader</code>类型的依赖性。为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注释的自动装配功能。在这种情况下，只要有问题的字段，构造函数或方法带有<code>@Autowired</code>注释， <code>ResourceLoader</code>就会自动装入一个字段，构造函数参数或方法参数，这些参数需要<code>ResourceLoader</code>类型。有关更多信息，请参阅<a href="#beans-autowired-annotation">使用<code>@Autowired</code></a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-as-dependencies"><a class="anchor" href="#resources-as-dependencies"></a> 2.6。资源作为依赖关系</h3>
<div class="paragraph">
<p>如果bean本身将通过某种动态过程确定并提供资源路径，那么bean使用<code>ResourceLoader</code>接口加载资源可能是有意义的。例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。如果资源是静态的，那么完全消除<code>ResourceLoader</code>接口的使用是有意义的，让bean公开它需要的<code>Resource</code>属性，并期望将它们注入到它中。</p>
</div>
<div class="paragraph">
<p>然后注入这些属性变得微不足道的是，所有应用程序上下文都注册并使用特殊的JavaBeans <code>PropertyEditor</code> ，它可以将<code>String</code>路径转换为<code>Resource</code>对象。因此，如果<code>myBean</code>具有<code>Resource</code>类型的模板属性，则可以使用该资源的简单字符串进行配置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">template</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">some / resource / path / myTemplate.txt</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，资源路径没有前缀。因此，因为应用程序上下文本身将用作<code>ResourceLoader</code> ，所以资源本身通过<code>ClassPathResource</code> ， <code>FileSystemResource</code>或<code>ServletContextResource</code>加载，具体取决于上下文的确切类型。</p>
</div>
<div class="paragraph">
<p>如果需要强制使用特定的<code>Resource</code>类型，则可以使用前缀。以下两个示例显示如何强制<code>ClassPathResource</code>和<code>UrlResource</code> （后者用于访问文件系统文件）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">template</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：some / resource / path / myTemplate.txt</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">template</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">file：///some/resource/path/myTemplate.txt</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-app-ctx"><a class="anchor" href="#resources-app-ctx"></a> 2.7。应用程序上下文和资源路径</h3>
<div class="paragraph">
<p>本节介绍如何使用资源创建应用程序上下文，包括使用XML的快捷方式，如何使用通配符以及其他详细信息。</p>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-construction"><a class="anchor" href="#resources-app-ctx-construction"></a> 2.7.1。构建应用程序上下文</h4>
<div class="paragraph">
<p>应用程序上下文构造函数（对于特定的应用程序上下文类型）通常将字符串或字符串数​​组作为资源的位置路径，例如构成上下文定义的XML文件。</p>
</div>
<div class="paragraph">
<p>当这样的位置路径没有前缀时，从该路径构建并用于加载bean定义的特定<code>Resource</code>类型取决于并且适合于特定的应用程序上下文。例如，请考虑以下示例，该示例创建<code>ClassPathXmlApplicationContext</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">conf / appContext.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>bean定义是从类路径加载的，因为使用了<code>ClassPathResource</code> 。但是，请考虑以下示例，该示例创建<code>FileSystemXmlApplicationContext</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">conf / appContext.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，bean定义是从文件系统位置加载的（在这种情况下，相对于当前工作目录）。</p>
</div>
<div class="paragraph">
<p>请注意，在位置路径上使用特殊类路径前缀或标准URL前缀会覆盖为加载定义而创建的默认<code>Resource</code>类型。考虑下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：conf / appContext.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用<code>FileSystemXmlApplicationContext</code>从类路径加载bean定义。但是，它仍然是<code>FileSystemXmlApplicationContext</code> 。如果它随后用作<code>ResourceLoader</code> ，则任何未加前缀的路径仍被视为文件系统路径。</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-classpathxml"><a class="anchor" href="#resources-app-ctx-classpathxml"></a>构造<code>ClassPathXmlApplicationContext</code>实例 - 快捷方式</h5>
<div class="paragraph">
<p><code>ClassPathXmlApplicationContext</code>公开了许多构造函数，以便于实例化。基本思想是，您只能提供一个字符串数组，该数组只包含XML文件本身的文件名（没有前导路径信息），并且还提供一个<code>Class</code> 。然后， <code>ClassPathXmlApplicationContext</code>从提供的类派生路径信息。</p>
</div>
<div class="paragraph">
<p>请考虑以下目录布局：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>com / foo / services.xml daos.xml MessengerService.class</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何实例化由名为<code>services.xml</code>和<code>daos.xml</code> （位于类路径中）的文件中定义的bean组成的<code>ClassPathXmlApplicationContext</code>实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">services.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">daos.xml</span> <span class="delimiter">”</span></span> }，MessengerService.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关各种构造函数的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>ClassPathXmlApplicationContext</code> Javadoc</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-wildcards-in-resource-paths"><a class="anchor" href="#resources-app-ctx-wildcards-in-resource-paths"></a> 2.7.2。应用程序上下文构造函数资源路径中的通配符</h4>
<div class="paragraph">
<p>应用程序上下文构造函数值中的资源路径可以是简单路径（如前所示），每个路径都与目标<code>Resource</code>进行一对一映射，或者可以包含特殊的“classpath *：”前缀或内部Ant样式的正则表达式（使用Spring的<code>PathMatcher</code>实用程序进行匹配）。后者都是有效的通配符。</p>
</div>
<div class="paragraph">
<p>此机制的一个用途是在需要进行组件样式的应用程序组装时。所有组件都可以将上下文定义片段“发布”到一个众所周知的位置路径，并且当使用前缀为<code>classpath*:</code>的相同路径创建最终应用程序上下文时，将自动拾取所有组件片段。</p>
</div>
<div class="paragraph">
<p>请注意，此通配符特定于在应用程序上下文构造函数中使用资源路径（或直接使用<code>PathMatcher</code>实用程序类层次结构时），并在构造时解析。它与<code>Resource</code>类型本身无关。您不能使用<code>classpath*:</code>前缀来构造实际的<code>Resource</code> ，因为资源一次只指向一个资源。</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-ant-patterns-in-paths"><a class="anchor" href="#resources-app-ctx-ant-patterns-in-paths"></a>蚂蚁风格的图案</h5>
<div class="paragraph">
<p>路径位置可以包含Ant样式模式，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>/WEB-INF/*-context.xml com / mycompany / ** / applicationContext.xml文件：C：/ some / path / *  -  context.xml classpath：com / mycompany / ** / applicationContext.xml</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当路径位置包含Ant样式模式时，解析程序遵循更复杂的过程来尝试解析通配符。它为直到最后一个非通配符段的路径生成一个<code>Resource</code> ，并从中获取一个URL。如果此URL不是<code>jar:</code> URL或特定于容器的变体（例如，在WebLogic中为<code>zip:</code> <code>wsjar</code>在WebSphere中为<code>wsjar</code> ，等等）， <code>java.io.从中获取File</code>并通过遍历文件系统来解析通配符。对于jar URL，解析器要么获得<code>java.net.JarURLConnection</code>或手动解析jar URL，然后遍历jar文件的内容以解析通配符。</p>
</div>
<div class="sect5">
<h6 id="resources-app-ctx-portability"><a class="anchor" href="#resources-app-ctx-portability"></a>对可移植性的影响</h6>
<div class="paragraph">
<p>如果指定的路径已经是文件URL（隐式，因为基本<code>ResourceLoader</code>是文件系统或显式），则可以保证通配符以完全可移植的方式工作。</p>
</div>
<div class="paragraph">
<p>如果指定的路径是类路径位置，则解析程序必须通过进行<code>Classloader.getResource()</code>调用来获取最后一个非通配符路径段URL。由于这只是路径的一个节点（不是最后的文件），实际上它是未定义的（在<code>ClassLoader</code> Javadoc中），在这种情况下确切地返回了什么类型的URL。在实践中，它始终是<code>java.io.表示目录的File</code> （类路径资源解析到文件系统位置的位置）或某种类型的jar URL（此处类路径资源解析为jar位置）。尽管如此，这种操作还是存在可移植性问题。</p>
</div>
<div class="paragraph">
<p>如果为最后一个非通配符段获取了jar URL，则解析器必须能够获得<code>java.net.JarURLConnection</code>或手动解析jar URL，以便能够遍历jar的内容并解析通配符。这在大多数环境中都有效，但在其他环境中无效，我们强烈建议您在依赖它之前，在特定环境中彻底测试来自jar的资源的通配符解析。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="resources-classpath-wildcards"><a class="anchor" href="#resources-classpath-wildcards"></a> <code>classpath*:</code>前缀</h5>
<div class="paragraph">
<p>构建基于XML的应用程序上下文时，位置字符串可以使用特殊的<code>classpath*:</code>前缀，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath *：conf / appContext.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此特殊前缀指定必须获取与给定名称匹配的所有类路径资源（在内部，这主要通过调用<code>ClassLoader.getResources(…​)</code> ）然后合并以形成最终的应用程序上下文定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通配符类路径依赖于底层类加载器的<code>getResources()</code>方法。由于现在大多数应用程序服务器都提供自己的类加载器实现，因此行为可能会有所不同，尤其是在处理jar文件时。检查<code>classpath*</code>有效的简单测试是使用类加载器从类路径中的jar中加载文件： <code>getClass().getClassLoader().getResources("&lt;someFileInsideTheJar&gt;")</code> 。尝试使用具有相同名称但放在两个不同位置的文件进行此测试。如果返回了不适当的结果，请检查应用程序服务器文档以获取可能影响类加载器行为的设置。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以将<code>classpath*:</code>前缀与位置路径的其余部分中的<code>PathMatcher</code>模式组合在一起（例如， <code>classpath*:META-INF/*-beans.xml</code> ）。在这种情况下，解析策略非常简单：在最后一个非通配符路径段上使用<code>ClassLoader.getResources()</code>调用来获取类加载器层次结构中的所有匹配资源，然后从每个资源中获取相同的<code>PathMatcher</code>解析前面描述的策略用于通配符子路径。</p>
</div>
</div>
<div class="sect4">
<h5 id="resources-wildcards-in-path-other-stuff"><a class="anchor" href="#resources-wildcards-in-path-other-stuff"></a>有关通配符的其他说明</h5>
<div class="paragraph">
<p>请注意， <code>classpath*:</code>与Ant样式模式结合使用时，只能在模式启动之前与至少一个根目录可靠地工作，除非实际目标文件驻留在文件系统中。这意味着<code>classpath*:*.xml</code>可能无法从jar文件的根目录中检索文件，而只能从扩展目录的根目录中检索文件。</p>
</div>
<div class="paragraph">
<p>Spring检索类路径条目的能力来自JDK的<code>ClassLoader.getResources()</code>方法，该方法仅返回空字符串的文件系统位置（指示搜索的潜在根）。Spring也会评估<code>URLClassLoader</code>运行时配置和jar文件中的<code>java.class.path</code>清单，但这不能保证导致可移植行为。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用Ant构建JAR时，请不要激活JAR任务的仅文件开关。此外，在某些环境中，类路径目录可能不会基于安全策略公开 - 例如，JDK 1.7.0_45及更高版本上的独立应用程序（需要在清单中设置“Trusted-Library”）。请参阅<a href="http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a> ）。</p>
</div>
<div class="paragraph">
<p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常按预期工作。此处强烈建议将资源放入专用目录，避免上述搜索jar文件根级别的可移植性问题。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果要搜索的根包在多个类路径位置中可用，则不保证具有<code>classpath:</code> Ant样式模式<code>classpath:</code>资源可以找到匹配的资源。请考虑以下资源位置示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>COM / myCompany中/包1 /服务的context.xml</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑一个人可能用来尝试查找该文件的Ant风格路径：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>类路径：COM / myCompany中/ ** /服务的context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>这样的资源可能只在一个位置，但是当使用前面例子之类的路径尝试解析它时，解析器会处理<code>getResource("com/mycompany");</code>返回的（第一个）URL <code>getResource("com/mycompany");</code> 。如果此基本包节点存在于多个类加载器位置中，则实际的最终资源可能不存在。因此，在这种情况下，您应该更喜欢使用<code>classpath*:</code>使用相同的Ant样式模式，该模式搜索包含根包的所有类路径位置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-filesystemresource-caveats"><a class="anchor" href="#resources-filesystemresource-caveats"></a> 2.7.3。<code>FileSystemResource</code>警告</h4>
<div class="paragraph">
<p>一个<code>FileSystemResource</code>未连接到<code>FileSystemApplicationContext</code> （即当一个<code>FileSystemApplicationContext</code>是不实际<code>ResourceLoader</code> ），把你所期望的绝对和相对路径。相对路径相对于当前工作目录，而绝对路径相对于文件系统的根目录。</p>
</div>
<div class="paragraph">
<p>但是，出于向后兼容性（历史）的原因，当<code>FileSystemApplicationContext</code>是<code>ResourceLoader</code>时，这会发生变化。<code>FileSystemApplicationContext</code>强制所有附加的<code>FileSystemResource</code>实例将所有位置路径视为相对路径，无论它们是否以前导斜杠开头。实际上，这意味着以下示例是等效的：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">conf / context.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext（ <span class="string"><span class="delimiter">“/</span> <span class="content">conf/context.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下exmaples也是等价的（即使它们有所不同，因为一个案例是相对的而另一个案例是绝对的）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FileSystemXmlApplicationContext ctx = ...; ctx.getResource（ <span class="string"><span class="delimiter">“</span> <span class="content">some / resource / path / myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FileSystemXmlApplicationContext ctx = ...; ctx.getResource（ <span class="string"><span class="delimiter">“/</span> <span class="content">some / resources / path / myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实际上，如果需要真正的绝对文件系统路径，则应避免对<code>FileSystemResource</code>或<code>FileSystemXmlApplicationContext</code>使用绝对路径，并使用<code>file:</code> URL前缀强制使用<code>UrlResource</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//实际上下文类型无关紧要，Resource将始终为UrlResource</span> ctx.getResource（ <span class="string"><span class="delimiter">“</span> <span class="content">file：///some/resource/path/myTemplate.txt</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//强制此FileSystemXmlApplicationContext通过UrlResource</span> ApplicationContext <span class="comment">加载其定义</span> ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">file：///conf/context.xml</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation"><a class="anchor" href="#validation"></a> 3。验证，数据绑定和类型转换</h2>
<div class="sectionbody">
<div class="paragraph">
<p>将验证视为业务逻辑有利有弊，而Spring提供了一种不排除其中任何一种的验证（和数据绑定）设计。具体来说，验证不应该与Web层绑定，并且应该易于本地化，并且应该可以插入任何可用的验证器。考虑到这些问题，Spring提出了一个<code>Validator</code>接口，它在应用程序的每一层都是基本的，非常有用。</p>
</div>
<div class="paragraph">
<p>数据绑定对于让用户输入动态绑定到应用程序的域模型（或用于处理用户输入的任何对象）非常有用。Spring提供了恰当命名的<code>DataBinder</code>来做到这一点。<code>Validator</code>和<code>DataBinder</code>构成<code>validation</code>包，主要用于但不限于MVC框架。</p>
</div>
<div class="paragraph">
<p><code>BeanWrapper</code>是Spring Framework中的一个基本概念，并且在很多地方使用。但是，您可能不需要直接使用<code>BeanWrapper</code> 。但是，由于这是参考文档，我们认为可能会有一些解释。我们将在本章中解释<code>BeanWrapper</code> ，因为如果您要使用它，那么在尝试将数据绑定到对象时，您很可能会这样做。</p>
</div>
<div class="paragraph">
<p>Spring的<code>DataBinder</code>和较低级别的<code>BeanWrapper</code>都使用<code>PropertyEditorSupport</code>实现来解析和格式化属性值。<code>PropertyEditor</code>和<code>PropertyEditorSupport</code>接口是JavaBeans规范的一部分，本章也对其进行了解释。Spring 3引入了一个<code>core.convert</code>包，它提供了一个通用的类型转换工具，以及一个用于格式化UI字段值的更高级“格式”包。您可以使用这些包作为<code>PropertyEditorSupport</code>实现的更简单的替代方法。它们也在本章中讨论。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">JSR-303 / JSR-349 Bean验证</div>
<div class="paragraph">
<p>从版本4.0开始，Spring Frameworks支持Bean Validation 1.0（JSR-303）和Bean Validation 1.1（JSR-349），用于设置支持并使它们适应Spring的<code>Validator</code>接口。</p>
</div>
<div class="paragraph">
<p>应用程序可以选择全局启用Bean Validation一次，如<a href="#validation-beanvalidation">Spring Validation中所述</a> ，并专门用于所有验证需求。</p>
</div>
<div class="paragraph">
<p>应用程序还可以为每个<code>DataBinder</code>实例注册其他Spring <code>Validator</code>实例，如<a href="#validation-binder">配置<code>DataBinder</code></a> 。这可以用于在不使用注释的情况下插入验证逻辑。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="validator"><a class="anchor" href="#validator"></a> 3.1。使用Spring的Validator接口验证</h3>
<div class="paragraph">
<p>Spring具有<code>Validator</code>接口，可用于验证对象。<code>Validator</code>接口通过使用<code>Errors</code>对象来工作，以便在验证时，验证器可以向<code>Errors</code>对象报告验证失败。</p>
</div>
<div class="paragraph">
<p>考虑以下小数据对象的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="type">诠释</span>年龄; <span class="comment">//通常的吸气者和制定者......</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一个示例通过实现<code>org.springframework.validation.的以下两个方法为<code>Person</code>类提供验证行为<code>org.springframework.validation.Validator</code>界面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supports(Class)</code> ：这个<code>Validator</code>验证提供的<code>Class</code>实例吗？</p>
</li>
<li>
<p><code>validate（Object，org.springframework.validation。Errors)</code> ：验证给定对象，如果验证错误，则注册具有给定<code>Errors</code>对象的对象。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实现<code>Validator</code>非常简单，特别是当您知道Spring Framework提供的<code>ValidationUtils</code>帮助器类时。以下示例为<code>Person</code>实例实现<code>Validator</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonValidator</span> <span class="directive">实现</span> <span class="predefined-type">Validator</span> { <span class="comment">/ ** *此Validator仅验证* Person实例* /</span> <span class="directive">public</span> <span class="type">boolean</span> supports（ <span class="predefined-type">Class</span> clazz）{ <span class="keyword">return</span> Person.class.equals（clazz）; <span class="directive">public</span> <span class="type">void</span> validate（ <span class="predefined-type">Object</span> obj，Errors e）{ValidationUtils.rejectIfEmpty（e， <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">name.empty</span> <span class="delimiter">”</span></span> ）;人p =（人）obj; <span class="keyword">if</span> （p.getAge（）&lt; <span class="integer">0</span> ）{e.rejectValue（ <span class="string"><span class="delimiter">“</span> <span class="content">age</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">negativevalue</span> <span class="delimiter">”</span></span> ）; } <span class="keyword">else</span> <span class="keyword">if</span> （p.getAge（）&gt; <span class="integer">110</span> ）{e.rejectValue（ <span class="string"><span class="delimiter">“</span> <span class="content">age</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">too.darn.old</span> <span class="delimiter">”</span></span> ）; }}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ValidationUtils</code>类上的<code>static</code> <code>rejectIfEmpty(..)</code>方法用于拒绝<code>name</code>属性，如果它为<code>null</code>或空字符串。请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/validation/ValidationUtils.html"><code>ValidationUtils</code> Javadoc</a> ，了解除了前面显示的示例之外它还提供了哪些功能。</p>
</div>
<div class="paragraph">
<p>虽然可以实现一个<code>Validator</code>类来验证富对象中的每个嵌套对象，但最好将每个嵌套对象类的验证逻辑封装在自己的<code>Validator</code>实现中。“富”对象的一个​​简单示例是<code>Customer</code> ，它由两个<code>String</code>属性（第一个和第二个名称）和一个复杂的<code>Address</code>对象组成。<code>Address</code>对象可以独立于<code>Customer</code>对象使用，因此实现了不同的<code>AddressValidator</code> 。如果您希望<code>CustomerValidator</code>重用<code>AddressValidator</code>类中包含的逻辑而不诉诸复制和粘贴，则可以在<code>CustomerValidator</code>依赖注入或实例化<code>AddressValidator</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CustomerValidator</span> <span class="directive">实现</span> <span class="predefined-type">Validator</span> { <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Validator</span> addressValidator; <span class="directive">public</span> CustomerValidator（ <span class="predefined-type">Validator</span> addressValidator）{ <span class="keyword">if</span> （addressValidator == <span class="predefined-constant">null</span> ）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">提供的[Validator]是</span> <span class="delimiter">”</span></span> + <span class="string"><span class="delimiter">“</span> <span class="content">必需且不得为null。</span> <span class="delimiter">”</span></span> ）; <span class="keyword">如果</span> （！addressValidator.supports（Address.class））{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">提供的[Validator]必须</span> <span class="delimiter">”</span></span> + <span class="string"><span class="delimiter">“</span> <span class="content">支持[Address]实例的验证。</span> <span class="delimiter">”</span></span> ）; <span class="local-variable">这个</span> .addressValidator = addressValidator; } <span class="comment">/ ** *此Validator验证Customer实例，Customer的任何子类* /</span> <span class="directive">public</span> <span class="type">boolean</span>支持（ <span class="predefined-type">Class</span> clazz）{ <span class="keyword">return</span> Customer.class.isAssignableFrom（clazz）; <span class="directive">public</span> <span class="type">void</span> validate（ <span class="predefined-type">对象</span>目标，错误错误）{ValidationUtils.rejectIfEmptyOrWhitespace（errors， <span class="string"><span class="delimiter">“</span> <span class="content">firstName</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">field.required</span> <span class="delimiter">”</span></span> ）; ValidationUtils.rejectIfEmptyOrWhitespace（errors， <span class="string"><span class="delimiter">“</span> <span class="content">surname</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">field.required</span> <span class="delimiter">”</span></span> ）;客户客户=（客户）目标; <span class="keyword">try</span> {errors.pushNestedPath（ <span class="string"><span class="delimiter">“</span> <span class="content">address</span> <span class="delimiter">”</span></span> ）; ValidationUtils.invokeValidator（ <span class="local-variable">此</span> .addressValidator，customer.getAddress（），errors）; } <span class="keyword">finally</span> {errors.popNestedPath（）; }}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>验证错误将报告给传递给验证程序的<code>Errors</code>对象。对于Spring Web MVC，您可以使用<code>&lt;spring:bind/&gt;</code>标记来检查错误消息，但您也可以自己检查<code>Errors</code>对象。有关它提供的方法的更多信息可以在<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframeworkvalidation/Errors.html">Javadoc中</a>找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-conversion"><a class="anchor" href="#validation-conversion"></a> 3.2。将代码解析为错误消息</h3>
<div class="paragraph">
<p>我们介绍了数据绑定和验证。本节介绍输出与验证错误相对应的消息。在上<a href="#validator">一节中</a>显示的示例中，我们拒绝了<code>name</code>和<code>age</code>字段。如果我们想通过使用<code>MessageSource</code>输出错误消息，我们可以使用我们在拒绝字段时提供的错误代码（在这种情况下为“name”和“age”）。当你从<code>Errors</code>接口调用（直接或间接地，通过使用<code>ValidationUtils</code>类） <code>rejectValue</code>或其他一个<code>reject</code>方法时，底层实现不仅会注册你传入的代码，还会注册一些其他错误代码。<code>MessageCodesResolver</code>确定<code>Errors</code>接口注册的错误代码。默认情况下，使用<code>DefaultMessageCodesResolver</code> ，它（例如）不仅使用您提供的代码注册消息，还会注册包含您传递给reject方法的字段名称的消息。因此，如果您使用<code>rejectValue("age", "too.darn.old")</code>拒绝某个字段，除了<code>too.darn.old</code>代码之外，Spring还会注册<code>too.darn.old.age</code>和<code>too.darn.old.age.int</code> （第一个包括字段名称，第二个包括字段的类型）。这样做是为了方便在定位错误消息时帮助开发人员。</p>
</div>
<div class="paragraph">
<p>有关<code>MessageCodesResolver</code>和默认策略的更多信息可分别在<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html"><code>MessageCodesResolver</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html"><code>DefaultMessageCodesResolver</code></a>的Javadoc中找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-beans"><a class="anchor" href="#beans-beans"></a> 3.3。Bean操作和<code>BeanWrapper</code></h3>
<div class="paragraph">
<p><code>org.springframework.beans</code>包遵循JavaBeans标准。JavaBean是一个具有默认无参数构造函数的类，它遵循命名约定，其中（例如）名为<code>bingoMadness</code>的属性将具有setter方法<code>setBingoMadness(..)</code>和getter方法<code>getBingoMadness()</code> 。有关JavaBeans和规范的更多信息，请参阅<a href="http://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">javabeans</a> 。</p>
</div>
<div class="paragraph">
<p>beans包中一个非常重要的类是<code>BeanWrapper</code>接口及其相应的实现（ <code>BeanWrapperImpl</code> ）。从Javadoc引用， <code>BeanWrapper</code>提供了设置和获取属性值（单独或批量），获取属性描述符和查询属性以确定它们是可读还是可写的功能。此外， <code>BeanWrapper</code>还支持嵌套属性，从而可以将子属性的属性设置为无限深度。<code>BeanWrapper</code>还支持添加标准JavaBeans <code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code> ，而无需在目标类中支持代码。最后但同样重要的是， <code>BeanWrapper</code>支持设置索引属性。<code>BeanWrapper</code>通常不直接由应用程序代码使用，但由<code>DataBinder</code>和<code>BeanFactory</code> 。</p>
</div>
<div class="paragraph">
<p><code>BeanWrapper</code>工作方式部分由其名称表示：它包装bean以对该bean执行操作，例如设置和检索属性。</p>
</div>
<div class="sect3">
<h4 id="beans-beans-conventions"><a class="anchor" href="#beans-beans-conventions"></a> 3.3.1。设置和获取基本和嵌套属性</h4>
<div class="paragraph">
<p>设置和获取属性是通过使用<code>setPropertyValue</code> ， <code>setPropertyValues</code> ， <code>getPropertyValue</code>和<code>getPropertyValues</code>方法完成的，这两种方法都带有几个重载变体。Springs Javadoc更详细地描述了它们。JavaBeans规范具有指示对象属性的约定。下表显示了这些约定的一些示例：</p>
</div>
<table id="beans-beans-conventions-properties-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表11。属性的例子</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表达</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>名称</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示与<code>getName()</code>或<code>isName()</code>和<code>setName(..)</code>方法对应的属性<code>name</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>用户名</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示与（例如） <code>getAccount().setName()</code>或<code>getAccount().getName()</code>方法对应的属性<code>account</code>的嵌套属性<code>name</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>帐户[2]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示索引属性<code>account</code>的<em>第三个</em>元素。索引属性可以是<code>array</code> ， <code>list</code>或其他自然排序的集合。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>帐户[COMPANYNAME]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示由<code>account</code> <code>Map</code>属性的<code>COMPANYNAME</code>键索引的映射条目的值。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>（如果您不打算直接使用<code>BeanWrapper</code> ，那么下一部分对您来说并不重要。如果仅使用<code>DataBinder</code>和<code>BeanFactory</code>及其默认实现，则应跳到<a href="#beans-beans-conversion">有关<code>PropertyEditors</code></a>的<a href="#beans-beans-conversion">部分</a> 。）</p>
</div>
<div class="paragraph">
<p>以下两个示例classess使用<code>BeanWrapper</code>来获取和设置属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Company</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span>员工manageDirector; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .name; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> Employee getManagingDirector（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .managingDirector; <span class="directive">public</span> <span class="type">void</span> setManagingDirector（Employee managingDirector）{ <span class="local-variable">this</span> .managingDirector = managingDirector; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Employee</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="type">浮动</span>工资; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .name; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> <span class="type">float</span> getSalary（）{ <span class="keyword">return</span> salary; <span class="directive">public</span> <span class="type">void</span> setSalary（ <span class="type">float</span> salary）{ <span class="local-variable">this</span> .salary = salary; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下代码段显示了如何检索和操作实例化<code>Companies</code>和<code>Employees</code>某些属性的一些示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">BeanWrapper公司= <span class="keyword">新的</span> BeanWrapperImpl（ <span class="keyword">new</span> Company（））; <span class="comment">//设置公司名称..</span>company.setPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Some Company Inc.</span> <span class="delimiter">”</span></span> ）; <span class="comment">// ...也可以这样做：</span> PropertyValue value = <span class="keyword">new</span> PropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Some Company Inc.</span> <span class="delimiter">”</span></span> ）; company.setPropertyValue（值）; <span class="comment">//好吧，让我们创建导演并将其绑定到公司：</span> BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl（ <span class="keyword">new</span> Employee（））; jim.setPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Jim Stravinsky</span> <span class="delimiter">”</span></span> ）; company.setPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">managingDirector</span> <span class="delimiter">”</span></span> ，jim.getWrappedInstance（））; <span class="comment">//通过公司</span> <span class="predefined-type">Float</span> salary =（ <span class="predefined-type">Float</span> ）company.getPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">managingDirector.salary</span> <span class="delimiter">”</span></span> ） <span class="comment">检索manageDirector的工资</span> ;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-beans-conversion"><a class="anchor" href="#beans-beans-conversion"></a> 3.3.2。内置<code>PropertyEditor</code>实现</h4>
<div class="paragraph">
<p>Spring使用<code>PropertyEditor</code>的概念来实现<code>Object</code>和<code>String</code>之间的转换。以与对象本身不同的方式表示属性可能很方便。例如， <code>Date</code>可以用人类可读的方式表示（如<code>String</code> ： <code>'2007-14-09'</code> ），而我们仍然可以将人类可读的表单转换回原始日期（或者更好的是，转换任何日期以人类可读的形式输入<code>Date</code>对象）。可以通过注册<code>java.beans.类型的自定义编辑器来实现此行为<code>java.beans.PropertyEditor</code> 。在<code>BeanWrapper</code>上注册自定义编辑器，或者在特定的IoC容器中注册自定义编辑器（如前一章所述），使其了解如何将属性转换为所需类型。有关<code>PropertyEditor</code>更多信息，请参阅<a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">Oracle的<code>java.beans</code>包的Javadoc</a> 。</p>
</div>
<div class="paragraph">
<p>在Spring中使用属性编辑的几个示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过使用<code>PropertyEditor</code>实现来设置bean的<code>PropertyEditor</code> 。当你使用<code>java.lang.String</code>作为您在XML文件中声明的某个bean的属性的值，Spring（如果相应属性的setter具有<code>Class</code>参数）使用<code>ClassEditor</code>尝试将参数解析为<code>Class</code>对象。</p>
</li>
<li>
<p>在Spring的MVC框架中解析HTTP请求参数是通过使用各种<code>PropertyEditor</code>实现来完成的，您可以在<code>CommandController</code>所有子类中手动绑定它们。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring有许多内置的<code>PropertyEditor</code>实现，可以简化生活。它们都位于<code>org.springframework.beans.propertyeditors</code>包中。大多数（但不是全部，如下表所示）默认情况下由<code>BeanWrapperImpl</code> 。如果属性编辑器可以某种方式配置，您仍然可以注册自己的变体来覆盖默认变体。下表描述了Spring提供的各种<code>PropertyEditor</code>实现：</p>
</div>
<table id="beans-beans-property-editors-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表12。内置<code>PropertyEditor</code>实现</caption>
<colgroup>
<col style="width:30%">
<col style="width:70%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayPropertyEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节数组的编辑器。将字符串转换为其对应的字节表示形式。<code>BeanWrapperImpl</code>默认<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>类编辑</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解析表示类到实际类的字符串，反之亦然。找不到类时，抛出<code>IllegalArgumentException</code> 。默认情况下，由<code>BeanWrapperImpl</code>注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomBooleanEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code>属性的可自定义属性编辑器。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomCollectionEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合的属性编辑器，将任何源<code>Collection</code>转换为给定的目标<code>Collection</code>类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>和CustomDateEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.可自定义属性编辑器<code>java.util.Date</code> ，支持自定义<code>DateFormat</code> 。未默认注册。必须根据需要使用适当的格式进行用户注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomNumberEditor为</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何<code>Number</code>子类的可自定义属性编辑器，例如<code>Integer</code> ， <code>Long</code> ， <code>Float</code>或<code>Double</code> 。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将字符串解析为<code>java.io.File</code>对象。默认情况下，由<code>BeanWrapperImpl</code>注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InputStreamEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单向属性编辑器，可以获取字符串并生成（通过中间<code>ResourceEditor</code>和<code>Resource</code> ） <code>InputStream</code>以便<code>InputStream</code>属性可以直接设置为字符串。请注意，默认用法不会为您关闭<code>InputStream</code> 。默认情况下，由<code>BeanWrapperImpl</code>注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以将字符串解析为<code>Locale</code>对象，反之亦然（字符串格式为<code><em class="language">[country]</em> [variant]</code> ，与<code>Locale</code>的<code>toString()</code>方法相同）。默认情况下，由<code>BeanWrapperImpl</code>注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以将字符串解析为<code>java.util.regex.Pattern</code>对象，反之亦然。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PropertiesEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以转换字符串（使用<code>java.util.的Javadoc中定义的格式进行格式化<code>java.util.Properties</code>类）到<code>Properties</code>对象。默认情况下，由<code>BeanWrapperImpl</code>注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringTrimmerEditor一个</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修剪字符串的属性编辑器。（可选）允许将空字符串转换为<code>null</code>值。默认情况下未注册 - 必须是用户注册的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>URLEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以将URL的字符串表示形式解析为实际的<code>URL</code>对象。默认情况下，由<code>BeanWrapperImpl</code>注册。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring使用<code>java.beans.PropertyEditorManager</code>用于设置可能需要的属性编辑器的搜索路径。搜索路径还包括<code>sun.bean.editors</code> ，其中包括<code>Font</code> ， <code>Color</code>和大多数基本类型等类型的<code>PropertyEditor</code>实现。另请注意，标准JavaBeans基础结构会自动发现<code>PropertyEditor</code>类（无需显式注册），​​如果它们与它们处理的类位于同一个包中，并且与该类具有相同的名称，并附加<code>Editor</code> 。例如，可以使用以下类和包结构，这足以使<code>SomethingEditor</code>类被识别并用作<code>Something</code> -typed属性的<code>PropertyEditor</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>com chank pop Something SomethingEditor // Something类的PropertyEditor</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您也可以使用标准<code>BeanInfo</code> JavaBeans的机制在这里也描述（在一定程度上<a href="http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">在这里</a> ）。以下示例使用<code>BeanInfo</code>机制使用关联类的属性显式注册一个或多个<code>PropertyEditor</code>实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>com chank pop Something SomethingBeanInfo // Something类的BeanInfo</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所引用下面的Java源代码<code>SomethingBeanInfo</code>类相关联的<code>CustomNumberEditor</code>与<code>age</code>的财产<code>Something</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomethingBeanInfo</span> <span class="directive">extends</span> <span class="predefined-type">SimpleBeanInfo</span> { <span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span> <span class="type">[]</span> getPropertyDescriptors（）{ <span class="keyword">try</span> { <span class="directive">final</span> <span class="predefined-type">PropertyEditor</span> numberPE = <span class="keyword">new</span> CustomNumberEditor（ <span class="predefined-type">Integer</span> .class， <span class="predefined-constant">true</span> ）; <span class="predefined-type">PropertyDescriptor</span> ageDescriptor = <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">age</span> <span class="delimiter">”</span></span> ，Something.class）{ <span class="directive">public</span> <span class="predefined-type">PropertyEditor</span> createPropertyEditor（ <span class="predefined-type">Object</span> bean）{ <span class="keyword">return</span> numberPE; }; }; <span class="keyword">返回</span> <span class="keyword">新的</span> <span class="predefined-type">PropertyDescriptor</span> <span class="type">[]</span> {ageDescriptor}; } <span class="keyword">catch</span> （ <span class="exception">IntrospectionException</span> ex）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">Error</span> （ex.toString（））; }}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-beans-conversion-customeditor-registration"><a class="anchor" href="#beans-beans-conversion-customeditor-registration"></a>注册其他自定义<code>PropertyEditor</code>实现</h5>
<div class="paragraph">
<p>将bean属性设置为字符串值时，Spring IoC容器最终使用标准JavaBeans <code>PropertyEditor</code>实现将这些字符串转换为属性的复杂类型。Spring预先注册了许多自定义<code>PropertyEditor</code>实现（例如，将表示为字符串的类名转换为<code>Class</code>对象）。此外，Java的标准JavaBeans <code>PropertyEditor</code>查找机制允许对类的<code>PropertyEditor</code>进行适当的命名，并将其放置在与其提供支持的类相同的包中，以便可以自动找到它。</p>
</div>
<div class="paragraph">
<p>如果需要注册其他自定义<code>PropertyEditors</code> ，可以使用多种机制。最通常不方便或不推荐的手动方法是使用<code>ConfigurableBeanFactory</code>接口的<code>registerCustomEditor()</code>方法，假设您有<code>BeanFactory</code>引用。另一种（稍微更方便）机制是使用一个名为<code>CustomEditorConfigurer</code>的特殊bean工厂后处理器。尽管您可以将bean工厂后处理器与<code>BeanFactory</code>实现一起使用，但<code>CustomEditorConfigurer</code>具有嵌套属性设置，因此我们强烈建议您将它与<code>ApplicationContext</code>一起使用，您可以在其中以类似的方式将其部署到任何其他bean以及它可以在哪里自动检测并应用。</p>
</div>
<div class="paragraph">
<p>请注意，所有bean工厂和应用程序上下文都会自动使用许多内置属性编辑器，通过使用<code>BeanWrapper</code>来处理属性转换。<code>BeanWrapper</code>注册的标准属性编辑器列在<a href="#beans-beans-conversion">上一节中</a> 。此外， <code>ApplicationContexts</code>还会覆盖或添加其他编辑器，以适合特定应用程序上下文类型的方式处理资源查找。</p>
</div>
<div class="paragraph">
<p>标准JavaBeans <code>PropertyEditor</code>实例用于将表示为字符串的属性值转换为属性的实际复杂类型。您可以使用Bean工厂后处理器<code>CustomEditorConfigurer</code>方便地将其他<code>PropertyEditor</code>实例的支持添加到<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例，该示例定义名为<code>ExoticType</code>的用户类和另一个名为<code>DependsOnExoticType</code>类， <code>ExoticType</code>需要将<code>ExoticType</code>设置为属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包装</span> <span class="namespace">示例</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ExoticType</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">public</span> ExoticType（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> <span class="type">class</span> <span class="class">DependsOnExoticType</span> { <span class="directive">private</span> ExoticType type; <span class="directive">public</span> <span class="type">void</span> setType（ExoticType type）{ <span class="local-variable">this</span> .type = type; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正确设置后，我们希望能够将type属性指定为字符串， <code>PropertyEditor</code>将其转换为实际的<code>ExoticType</code>实例。以下bean定义显示了如何设置此关系：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sample</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。DependsOnExoticType</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">type</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">aNameForExoticType</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>PropertyEditor</code>实现可能类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//将字符串表示转换为ExoticType对象</span> <span class="keyword">包</span> <span class="namespace">示例</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExoticTypeEditor</span> <span class="directive">扩展</span> <span class="predefined-type">PropertyEditorSupport</span> { <span class="directive">public</span> <span class="type">void</span> setAsText（ <span class="predefined-type">String</span> text）{setValue（ <span class="keyword">new</span> ExoticType（text.toUpperCase（）））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，以下示例显示如何使用<code>CustomEditorConfigurer</code>向<code>ApplicationContext</code>注册新的<code>PropertyEditor</code> ，然后可以根据需要使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。CustomEditorConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customEditors</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。ExoticType</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">示例。ExoticTypeEditor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-beans-conversion-customeditor-registration-per"><a class="anchor" href="#beans-beans-conversion-customeditor-registration-per"></a>使用<code>PropertyEditorRegistrar</code></h6>
<div class="paragraph">
<p>使用Spring容器注册属性编辑器的另一种机制是创建和使用<code>PropertyEditorRegistrar</code> 。当您需要在几种不同情况下使用同一组属性编辑器时，此接口特别有用。您可以编写相应的注册商，并在每种情况下重复使用它。<code>PropertyEditorRegistrar</code>实例与名为<code>PropertyEditorRegistry</code>的接口一起工作，该接口由Spring <code>BeanWrapper</code> （和<code>DataBinder</code> ）实现。<code>PropertyEditorRegistrar</code>实例在与<code>CustomEditorConfigurer</code> （ <a href="#beans-beans-conversion-customeditor-registration">此处</a>描述）结合使用时特别方便，它公开了一个名为<code>setPropertyEditorRegistrars(..)</code>的属性。以这种方式添加到<code>CustomEditorConfigurer</code> <code>PropertyEditorRegistrar</code>实例可以轻松地与<code>DataBinder</code>和Spring MVC控制器共享。此外，它避免了在自定义编辑器上进行同步的需要： <code>PropertyEditorRegistrar</code>需要为每个bean创建尝试创建新的<code>PropertyEditor</code>实例。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何创建自己的<code>PropertyEditorRegistrar</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo.editors.spring</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">CustomPropertyEditorRegistrar</span> <span class="directive">实现</span> PropertyEditorRegistrar { <span class="directive">public</span> <span class="type">void</span> registerCustomEditors（PropertyEditorRegistry registry）{ <span class="comment">//期望新的PropertyEditor实例创建</span> registry.registerCustomEditor（ExoticType.class， <span class="keyword">new</span> ExoticTypeEditor（））; <span class="comment">//你可以在这里注册尽可能多的自定义属性编辑器......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参见<code>org.springframework.beans.support.ResourceEditorRegistrar</code>用于示例<code>PropertyEditorRegistrar</code>实现。请注意，在实现<code>registerCustomEditors(..)</code>方法时，它会创建每个属性编辑器的新实例。</p>
</div>
<div class="paragraph">
<p>下一个示例显示如何配置<code>CustomEditorConfigurer</code>并将<code>CustomPropertyEditorRegistrar</code>的实例注入其中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。CustomEditorConfigurer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">propertyEditorRegistrars</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customPropertyEditorRegistrar</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customPropertyEditorRegistrar</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo.editors 。弹簧。CustomPropertyEditorRegistrar</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后（与本章的重点有所不同，对于那些使用<a href="web.html#mvc">Spring的MVC Web框架的人来说</a> ），使用<code>PropertyEditorRegistrars</code>和数据绑定<code>Controllers</code> （如<code>SimpleFormController</code> ）可以非常方便。以下示例在<code>initBinder(..)</code>方法的实现中使用<code>PropertyEditorRegistrar</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">RegisterUserController</span> <span class="directive">extends</span> SimpleFormController { <span class="directive">private</span> <span class="directive">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar; <span class="directive">public</span> RegisterUserController（PropertyEditorRegistrar propertyEditorRegistrar）{ <span class="local-variable">this</span> .customPropertyEditorRegistrar = propertyEditorRegistrar; } <span class="directive">protected</span> <span class="type">void</span> initBinder（HttpServletRequest request，ServletRequestDataBinder binder） <span class="directive">抛出</span> <span class="exception">Exception</span> { <strong><span class="local-variable">this</span> .customPropertyEditorRegistrar.registerCustomEditors（binder）;</strong> } <span class="comment">//注册用户的其他方法</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种风格<code>PropertyEditor</code>登记导致简洁的代码（执行<code>initBinder(..)</code>是只有一条线长），并允许普通<code>PropertyEditor</code>注册代码在一个类被封装，然后之间尽可能多的共享<code>Controllers</code>根据需要。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert"><a class="anchor" href="#core-convert"></a> 3.4。弹簧类型转换</h3>
<div class="paragraph">
<p>Spring 3引入了一个<code>core.convert</code>包，它提供了一个通用的类型转换系统。系统定义了一个用于实现类型转换逻辑的SPI和一个用于在运行时执行类型转换的API。在Spring容器中，您可以使用此系统作为<code>PropertyEditor</code>实现的替代方法，将外部化的bean属性值字符串转换为必需的属性类型。您还可以在需要进行类型转换的应用程序中的任何位置使用公共API。</p>
</div>
<div class="sect3">
<h4 id="core-convert-Converter-API"><a class="anchor" href="#core-convert-Converter-API"></a> 3.4.1。转换器SPI</h4>
<div class="paragraph">
<p>用于实现类型转换逻辑的SPI简单且强类型，如以下接口定义所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">Converter</span> &lt;S，T&gt; {T convert（S source）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要创建自己的转换器，请实现<code>Converter</code>接口并将<code>S</code>参数化为要转换的类型，将<code>T</code>作为要转换的类型。如果<code>S</code>的集合或数组需要转换为<code>T</code>的数组或集合，您也可以透明地应用这样的转换器，前提是已经注册了委托数组或集合转换器（ <code>DefaultConversionService</code>默认情况下也是如此）。</p>
</div>
<div class="paragraph">
<p>对于每次<code>convert(S)</code>调用，源参数保证不为null。如果转换失败，您的<code>Converter</code>可能会抛出任何未经检查的异常。具体来说，它应抛出<code>IllegalArgumentException</code>以报告无效的源值。请注意确保您的<code>Converter</code>实现是线程安全的。</p>
</div>
<div class="paragraph">
<p>为方便起见， <code>core.convert.support</code>包中提供了几个转换器实现。这些包括从字符串到数字和其他常见类型的转换器。以下清单显示了<code>StringToInteger</code>类，它是典型的<code>Converter</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.support</span> ; <span class="directive">final</span> <span class="type">类</span> <span class="class">StringToInteger</span> <span class="directive">实现</span> Converter &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Integer</span> &gt; { <span class="directive">public</span> <span class="predefined-type">Integer</span> convert（ <span class="predefined-type">String</span> source）{ <span class="keyword">return</span> <span class="predefined-type">Integer</span> .valueOf（source）; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConverterFactory-SPI"><a class="anchor" href="#core-convert-ConverterFactory-SPI"></a> 3.4.2。使用<code>ConverterFactory</code></h4>
<div class="paragraph">
<p>当您需要集中整个类层次结构的转换逻辑时（例如，从String转换为java.lang时）。枚举对象），您可以实现<code>ConverterFactory</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">ConverterFactory</span> &lt;S，R&gt; {&lt;T <span class="directive">extends</span> R&gt; Converter &lt;S，T&gt; getConverter（ <span class="predefined-type">Class</span> &lt;T&gt; targetType）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>参数化S为您要转换的类型，R为定义您可以转换为的类<em>范围</em>的基本类型。然后实现getConverter（Class &lt;T&gt;），其中T是R的子类。</p>
</div>
<div class="paragraph">
<p>以<code>StringToEnum</code> <code>ConverterFactory</code>为例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.support</span> ; <span class="directive">final</span> <span class="type">类</span> <span class="class">StringToEnumConverterFactory</span> <span class="directive">实现</span> ConverterFactory &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Enum</span> &gt; { <span class="directive">public</span> &lt;T <span class="directive">extends</span> <span class="predefined-type">Enum</span> &gt; Converter &lt; <span class="predefined-type">String</span> ，T&gt; getConverter（ <span class="predefined-type">Class</span> &lt;T&gt; targetType）{ <span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter（targetType）; <span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">StringToEnumConverter</span> &lt;T <span class="directive">extends</span> <span class="predefined-type">Enum</span> &gt; <span class="directive">implements</span> Converter &lt; <span class="predefined-type">String</span> ，T&gt; { <span class="directive">private</span> <span class="predefined-type">Class</span> &lt;T&gt; enumType; <span class="directive">public</span> StringToEnumConverter（ <span class="predefined-type">Class</span> &lt;T&gt; enumType）{ <span class="local-variable">this</span> .enumType = enumType; <span class="directive">public</span> T convert（ <span class="predefined-type">String</span> source）{ <span class="keyword">return</span> （T） <span class="predefined-type">Enum</span> .valueOf（ <span class="local-variable">this</span> .enumType，source.trim（））; }}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-GenericConverter-SPI"><a class="anchor" href="#core-convert-GenericConverter-SPI"></a> 3.4.3。使用<code>GenericConverter</code></h4>
<div class="paragraph">
<p>当您需要复杂的<code>Converter</code>实现时，请考虑使用<code>GenericConverter</code>接口。<code>GenericConverter</code>比<code>Converter</code>更灵活但不太强类型的签名，支持在多种源和目标类型之间进行转换。此外， <code>GenericConverter</code>提供了在实现转换逻辑时可以使用的源和目标字段上下文。这样的上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。以下清单显示了<code>GenericConverter</code>的接口定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">GenericConverter</span> { <span class="directive">public</span> <span class="predefined-type">Set</span> &lt;ConvertiblePair&gt; getConvertibleTypes（）; <span class="predefined-type">对象</span>转换（ <span class="predefined-type">Object</span> source，TypeDescriptor sourceType，TypeDescriptor targetType）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要实现<code>GenericConverter</code> ，请让<code>getConvertibleTypes()</code>返回支持的源→目标类型对。然后实现<code>convert(Object, TypeDescriptor, TypeDescriptor)</code>以包含转换逻辑。源<code>TypeDescriptor</code>提供对保存正在转换的值的源字段的访问。目标<code>TypeDescriptor</code>提供对要设置转换值的目标字段的访问。</p>
</div>
<div class="paragraph">
<p><code>GenericConverter</code>一个很好的例子是在Java数组和集合之间进行转换的转换器。这样的<code>ArrayToCollectionConverter</code>内省声明目标集合类型的字段，以解析集合的元素类型。这样，在目标字段上设置集合之前，可以将源数组中的每个元素转换为集合元素类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">因为<code>GenericConverter</code>是一个更复杂的SPI接口，所以只有在需要时才应该使用它。喜欢<code>Converter</code>或<code>ConverterFactory</code>以满足基本的类型转换需求。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="core-convert-ConditionalGenericConverter-SPI"><a class="anchor" href="#core-convert-ConditionalGenericConverter-SPI"></a>使用<code>ConditionalGenericConverter</code></h5>
<div class="paragraph">
<p>有时，只有在特定条件成立时才需要<code>Converter</code>运行。例如，您可能只想在目标字段上存在特定注释时才运行<code>Converter</code> ，或者只有在目标类上定义了特定方法（例如<code>static valueOf</code>方法）时才需要运行<code>Converter</code> 。
<code>ConditionalGenericConverter</code>是<code>GenericConverter</code>和<code>ConditionalConverter</code>接口的联合，允许您定义此类自定义匹配条件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ConditionalConverter</span> { <span class="type">boolean</span> matches（TypeDescriptor sourceType，TypeDescriptor targetType）; <span class="directive">公共</span> <span class="type">接口</span> <span class="class">ConditionalGenericConverter</span> <span class="directive">扩展了</span> GenericConverter，ConditionalConverter {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ConditionalGenericConverter</code>一个很好的例子是<code>EntityConverter</code> ，它在持久实体标识符和实体引用之间进行转换。仅当目标实体类型声明静态查找程序方法（例如， <code>findAccount(Long)</code> ）时，此类<code>EntityConverter</code>可能匹配。您可以在<code>matches(TypeDescriptor, TypeDescriptor)</code>的实现<code>matches(TypeDescriptor, TypeDescriptor)</code>执行这样的finder方法检查。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConversionService-API"><a class="anchor" href="#core-convert-ConversionService-API"></a> 3.4.4。<code>ConversionService</code> API</h4>
<div class="paragraph">
<p><code>ConversionService</code>定义了一个统一的API，用于在运行时执行类型转换逻辑。转换器通常在以下Facade接口后面执行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.core.convert</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">ConversionService</span> { <span class="type">boolean</span> canConvert（ <span class="predefined-type">Class</span> &lt;？&gt; sourceType， <span class="predefined-type">Class</span> &lt;？&gt; targetType）; &lt;T&gt; T convert（ <span class="predefined-type">对象</span>源， <span class="predefined-type">Class</span> &lt;T&gt; targetType）; <span class="type">boolean</span> canConvert（TypeDescriptor sourceType，TypeDescriptor targetType）; <span class="predefined-type">对象</span>转换（ <span class="predefined-type">Object</span> source，TypeDescriptor sourceType，TypeDescriptor targetType）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>大多数<code>ConversionService</code>实现还实现了<code>ConverterRegistry</code> ，它提供了一个用于注册转换器的SPI。在内部， <code>ConversionService</code>实现委托其注册的转换器执行类型转换逻辑。</p>
</div>
<div class="paragraph">
<p><code>core.convert.support</code>包中提供了强大的<code>ConversionService</code>实现。<code>GenericConversionService</code>是适用于大多数环境的通用实现。<code>ConversionServiceFactory</code>提供了一个方便的工厂，用于创建常见的<code>ConversionService</code>配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-Spring-config"><a class="anchor" href="#core-convert-Spring-config"></a> 3.4.5。配置<code>ConversionService</code></h4>
<div class="paragraph">
<p><code>ConversionService</code>是一个无状态对象，旨在在应用程序启动时实例化，然后在多个线程之间共享。在Spring应用程序中，通常为每个Spring容器（或<code>ApplicationContext</code> ）配置<code>ConversionService</code>实例。当需要框架执行类型转换时，Spring会选择<code>ConversionService</code>并使用它。您还可以将此<code>ConversionService</code>注入任何bean并直接调用它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果没有向Spring注册<code>ConversionService</code> ，则使用基于<code>PropertyEditor</code>的原始系统。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用Spring注册默认的<code>ConversionService</code> ，请添加以下bean定义，其<code>id</code>为<code>conversionService</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">conversionService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.context.support。ConversionServiceFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认的<code>ConversionService</code>可以在字符串，数字，枚举，集合，映射和其他常见类型之间进行转换。要使用您自己的自定义转换器补充或覆盖默认转换器，请设置<code>converters</code>属性。属性值可以实现任何<code>Converter</code> ， <code>ConverterFactory</code>或<code>GenericConverter</code>接口。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">conversionService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.context.support。ConversionServiceFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">converters</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。MyCustomConverter</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在Spring MVC应用程序中使用<code>ConversionService</code>也很常见。请参阅Spring MVC章节中的<a href="web.html#mvc-config-conversion">转换和格式化</a> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望在转换期间应用格式。有关使用<code>FormattingConversionServiceFactoryBean</code>详细信息，请参阅<a href="#format-FormatterRegistry-SPI"><code>FormatterRegistry</code> SPI</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-programmatic-usage"><a class="anchor" href="#core-convert-programmatic-usage"></a> 3.4.6。以编程方式使用<code>ConversionService</code></h4>
<div class="paragraph">
<p>要以编程方式使用<code>ConversionService</code>实例，您可以像对任何其他bean一样注入对它的引用。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> { <span class="annotation">@Autowired</span> <span class="directive">public</span> MyService（ConversionService conversionService）{ <span class="local-variable">this</span> .conversionService = conversionService; <span class="directive">public</span> <span class="type">void</span> doIt（）{ <span class="local-variable">this</span> .conversionService.convert（...）}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于大多数用例，您可以使用指定<code>targetType</code>的<code>convert</code>方法，但它不适用于更复杂的类型，例如参数化元素的集合。例如，如果要以编程方式将<code>List</code> of <code>Integer</code>转换为<code>String</code> <code>List</code> ，则需要提供源和目标类型的正式定义。</p>
</div>
<div class="paragraph">
<p>幸运的是， <code>TypeDescriptor</code>提供了各种选项，使得这样做非常简单，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService（）; <span class="predefined-type">列表</span> &lt; <span class="predefined-type">整数</span> &gt;输入= ....cs.convert（input，TypeDescriptor.forObject（input）， <span class="comment">// List &lt;Integer&gt;类型描述符</span> TypeDescriptor.collection（ <span class="predefined-type">List</span> .class，TypeDescriptor.valueOf（ <span class="predefined-type">String</span> .class）））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>DefaultConversionService</code>自动注册适合大多数环境的转换器。这包括集合转换器，标量转换器和基本的<code>Object</code> to- <code>String</code>转换器。您可以使用<code>DefaultConversionService</code>类上的静态<code>addDefaultConverters</code>方法向任何<code>ConverterRegistry</code>注册相同的转换<code>ConverterRegistry</code> 。</p>
</div>
<div class="paragraph">
<p>值类型转换器重新用于数组和集合，所以没有必要创建一个特定的转换器从转换<code>Collection</code>的<code>S</code>到<code>Collection</code>的<code>T</code> ，假设标准收集处理是适当的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format"><a class="anchor" href="#format"></a> 3.5。Spring Field格式</h3>
<div class="paragraph">
<p>如前一节所述， <a href="#core-convert"><code>core.convert</code></a>是一种通用类型转换系统。它提供统一的<code>ConversionService</code> API以及强类型<code>Converter</code> SPI，用于实现从一种类型到另一种类型的转换逻辑。Spring容器使用此系统绑定bean属性值。此外，Spring Expression Language（SpEL）和<code>DataBinder</code>使用此系统绑定字段值。例如，当SpEL需要强制<code>Short</code> to a <code>Long</code>来完成<code>expression.setValue(Object bean, Object value)</code>尝试时， <code>core.convert</code>系统会执行强制。</p>
</div>
<div class="paragraph">
<p>现在考虑典型客户端环境的类型转换要求，例如Web或桌面应用程序。在这样的环境中，您通常从<code>String</code>转换为支持客户端回发过程，以及返回<code>String</code>以支持视图呈现过程。此外，您经常需要本地化<code>String</code>值。更通用的<code>core.convert</code> <code>Converter</code> SPI不直接解决此类格式化要求。为了直接解决这些问题，Spring 3引入了一个方便的<code>Formatter</code> SPI，为客户端环境提供了一个简单而强大的<code>PropertyEditor</code>实现替代方案。</p>
</div>
<div class="paragraph">
<p>通常，当您需要实现通用类型转换逻辑时，可以使用<code>Converter</code> SPI  - 例如，用于在<code>java.util.之间进行转换<code>java.util.Date</code>和<code>java.lang.Long</code> 。在客户端环境（例如Web应用程序）中工作时，可以使用<code>Formatter</code> SPI，并且需要解析和打印本地化的字段值。<code>ConversionService</code>为两个SPI提供统一的类型转换API。</p>
</div>
<div class="sect3">
<h4 id="format-Formatter-SPI"><a class="anchor" href="#format-Formatter-SPI"></a> 3.5.1。<code>Formatter</code> SPI</h4>
<div class="paragraph">
<p>用于实现字段格式化逻辑的<code>Formatter</code> SPI简单且强类型化。以下清单显示了<code>Formatter</code>接口定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">Formatter</span> &lt;T&gt; <span class="directive">扩展</span> Printer &lt;T&gt;， <span class="predefined-type">Parser</span> &lt;T&gt; {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Formatter</code>扩展了<code>Printer</code>和<code>Parser</code>构建块接口。以下清单显示了这两个接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Printer</span> &lt;T&gt; { <span class="predefined-type">String</span> print（T fieldValue， <span class="predefined-type">Locale</span> locale）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.text。ParseException</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">Parser</span> &lt;T&gt; {T parse（ <span class="predefined-type">String</span> clientValue， <span class="predefined-type">Locale</span> locale） <span class="directive">抛出</span> <span class="exception">ParseException</span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要创建自己的<code>Formatter</code> ，请实现前面显示的<code>Formatter</code>接口。将<code>T</code>调整为您希望格式化的对象类型 - 例如， <code>java.util.Date</code> 。实现<code>print()</code>操作以打印<code>T</code>的实例以在客户端区域设置中显示。实现<code>parse()</code>操作以从客户端语言环境返回的格式化表示中解析<code>T</code>的实例。如果解析尝试失败，您的<code>Formatter</code>应抛出<code>ParseException</code>或<code>IllegalArgumentException</code> 。请注意确保您的<code>Formatter</code>实现是线程安全的。</p>
</div>
<div class="paragraph">
<p><code>format</code>子包提供了几个<code>Formatter</code>实现，以方便使用。<code>number</code>包提供<code>NumberStyleFormatter</code> ， <code>CurrencyStyleFormatter</code>和<code>PercentStyleFormatter</code>来格式化<code>java.lang.使用<code>java.text. Number</code>对象<code>java.text.NumberFormat</code> 。<code>datetime</code>包提供了一个<code>DateFormatter</code>来格式化<code>java.util.使用<code>java.text. Date</code>对象<code>java.text.DateFormat</code> 。<code>datetime.joda</code>包基于<a href="http://joda-time.sourceforge.net">Joda-Time库</a>提供全面的日期时间格式支持。</p>
</div>
<div class="paragraph">
<p>以下<code>DateFormatter</code>是<code>Formatter</code>实现的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format.datetime</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">DateFormatter</span> <span class="directive">实现</span> <span class="predefined-type">Formatter</span> &lt; <span class="predefined-type">Date</span> &gt; { <span class="directive">private</span> <span class="predefined-type">String</span> pattern; <span class="directive">public</span> <span class="predefined-type">DateFormatter</span> （ <span class="predefined-type">String</span> pattern）{ <span class="local-variable">this</span> .pattern = pattern; <span class="directive">public</span> <span class="predefined-type">String</span> print（ <span class="predefined-type">Date</span> date， <span class="predefined-type">Locale</span> locale）{ <span class="keyword">if</span> （date == <span class="predefined-constant">null</span> ）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ; } <span class="keyword">return</span> getDateFormat（locale）.format（date）; <span class="directive">public</span> <span class="predefined-type">Date</span> parse（ <span class="predefined-type">String</span> formatted， <span class="predefined-type">Locale</span> locale） <span class="directive">throws</span> <span class="exception">ParseException</span> { <span class="keyword">if</span> （formatted.length（）== <span class="integer">0</span> ）{ <span class="keyword">return</span> <span class="predefined-constant">null</span> ; } <span class="keyword">return</span> getDateFormat（locale）.parse（formatted）; } <span class="directive">protected</span> <span class="predefined-type">DateFormat</span> getDateFormat（ <span class="predefined-type">Locale</span> locale）{ <span class="predefined-type">DateFormat</span> dateFormat = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span> （ <span class="local-variable">this</span> .pattern，locale）; dateFormat.setLenient（ <span class="predefined-constant">false</span> ）; <span class="keyword">return</span> dateFormat; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring团队欢迎社区驱动的<code>Formatter</code>贡献，请<a href="https://jira.spring.io/browse/SPR">参阅jira.spring.io</a>进行贡献。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-CustomFormatAnnotations"><a class="anchor" href="#format-CustomFormatAnnotations"></a> 3.5.2。注释驱动的格式</h4>
<div class="paragraph">
<p>可以按字段类型或注释配置字段格式。要将注释绑定到<code>Formatter</code> ，请实现<code>AnnotationFormatterFactory</code> 。以下清单显示了<code>AnnotationFormatterFactory</code>接口的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotationFormatterFactory</span> &lt;A <span class="directive">extends</span> <span class="predefined-type">Annotation&gt;</span> { <span class="predefined-type">Set</span> &lt; <span class="predefined-type">Class</span> &lt;？&gt;&gt; getFieldTypes（）;打印机&lt;？&gt; getPrinter（一个注释， <span class="predefined-type">Class</span> &lt;？&gt; fieldType）; <span class="predefined-type">解析器</span> &lt;？&gt; getParser（A注释， <span class="predefined-type">Class</span> &lt;？&gt; fieldType）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>创建实现：。参数化A是要与格式化逻辑关联的字段<code>annotationType</code> - 例如<code>org.springframework.format.annotation.DateTimeFormat</code> 。。<code>getFieldTypes()</code>返回可以使用注释的字段类型。。让<code>getPrinter()</code>返回一个<code>Printer</code>来打印带注释字段的值。。让<code>getParser()</code>返回一个<code>Parser</code>来解析带注释字段的<code>clientValue</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例<code>AnnotationFormatterFactory</code>实现将<code>@NumberFormat</code>注释绑定到格式化程序，以指定数字样式或模式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">NumberFormatAnnotationFormatterFactory</span> <span class="directive">实现</span> AnnotationFormatterFactory &lt; <span class="predefined-type">NumberFormat</span> &gt; { <span class="directive">public</span> <span class="predefined-type">Set</span> &lt; <span class="predefined-type">Class</span> &lt;？&gt;&gt; getFieldTypes（）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span> &lt; <span class="predefined-type">Class</span> &lt;？&gt;&gt;（asList（ <span class="keyword">new</span> <span class="predefined-type">Class</span> &lt;？&gt; <span class="type">[]</span> { <span class="predefined-type">Short</span> .class， <span class="predefined-type">Integer</span> .class， <span class="predefined-type">Long</span> .class， <span class="predefined-type">Float</span> .class， <span class="predefined-type">Double</span> .class， <span class="predefined-type">BigDecimal</span> .class， <span class="predefined-type">BigInteger</span> .class}））; <span class="directive">public</span> Printer &lt; <span class="predefined-type">Number</span> &gt; getPrinter（ <span class="predefined-type">NumberFormat</span> annotation， <span class="predefined-type">Class</span> &lt;？&gt; fieldType）{ <span class="keyword">return</span> configureFormatterFrom（annotation，fieldType）; <span class="directive">public</span> <span class="predefined-type">Parser</span> &lt; <span class="predefined-type">Number</span> &gt; getParser（ <span class="predefined-type">NumberFormat</span> annotation， <span class="predefined-type">Class</span> &lt;？&gt; fieldType）{ <span class="keyword">return</span> configureFormatterFrom（annotation，fieldType）; } <span class="directive">private</span> <span class="predefined-type">Formatter</span> &lt; <span class="predefined-type">Number</span> &gt; configureFormatterFrom（ <span class="predefined-type">NumberFormat</span> annotation， <span class="predefined-type">Class</span> &lt;？&gt; fieldType）{ <span class="keyword">if</span> （！）annotation.pattern（）。isEmpty（））{ <span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter（annotation.pattern（））; } <span class="keyword">else</span> { <span class="predefined-type">Style</span> style = annotation.style（）; <span class="keyword">if</span> （style == <span class="predefined-type">Style</span> 。PERCENT）{ <span class="keyword">return</span> <span class="keyword">new</span> PercentStyleFormatter（）; } <span class="keyword">else</span> <span class="keyword">if</span> （style == <span class="predefined-type">Style</span> 。CURRENCY）{ <span class="keyword">return</span> <span class="keyword">new</span> CurrencyStyleFormatter（）; } <span class="keyword">else</span> { <span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter（）; }}}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要触发格式化，可以使用@NumberFormat注释字段，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> { <span class="annotation">@NumberFormat</span> （style = <span class="predefined-type">Style</span> 。CURRENCY） <span class="directive">私有</span> <span class="predefined-type">BigDecimal</span>十进制; }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="format-annotations-api"><a class="anchor" href="#format-annotations-api"></a>格式注释API</h5>
<div class="paragraph">
<p><code>org.springframework.format.annotation</code>包中存在可移植格式注释API。您可以使用<code>@NumberFormat</code>格式化java.lang。数字字段和<code>@DateTimeFormat</code>格式化<code>java.util.Date</code> ， <code>java.util.Calendar</code> ， <code>java.util.Long</code>或Joda-Time字段。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@DateTimeFormat</code>格式化<code>java.util.Date</code>为ISO日期（YYYY-MM-DD）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> { <span class="annotation">@DateTimeFormat</span> （iso = ISO.DATE） <span class="directive">private</span> <span class="predefined-type">date</span> date; }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistry-SPI"><a class="anchor" href="#format-FormatterRegistry-SPI"></a> 3.5.3。<code>FormatterRegistry</code> SPI</h4>
<div class="paragraph">
<p><code>FormatterRegistry</code>是一个用于注册格式化程序和转换器的SPI。
<code>FormattingConversionService</code>是<code>FormatterRegistry</code>一个实现，适用于大多数环境。您可以使用<code>FormattingConversionServiceFactoryBean</code>以编程方式或声明性地将此实现配置为Spring bean。因为此实现还实现了<code>ConversionService</code> ，所以您可以直接将其配置为与Spring的<code>DataBinder</code>和Spring Expression Language（SpEL）一起使用。</p>
</div>
<div class="paragraph">
<p>以下清单显示了<code>FormatterRegistry</code> SPI：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">FormatterRegistry</span> <span class="directive">扩展</span> ConverterRegistry { <span class="type">void</span> addFormatterForFieldType（ <span class="predefined-type">Class</span> &lt;？&gt; fieldType，Printer &lt;？&gt;打印机， <span class="predefined-type">解析器</span> &lt;？&gt;解析器）; <span class="type">void</span> addFormatterForFieldType（ <span class="predefined-type">Class</span> &lt;？&gt; fieldType， <span class="predefined-type">Formatter</span> &lt;？&gt; formatter）; <span class="type">void</span> addFormatterForFieldType（ <span class="predefined-type">Formatter</span> &lt;？&gt; formatter）; <span class="type">void</span> addFormatterForAnnotation（AnnotationFormatterFactory &lt;？，？&gt;工厂）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上面的清单所示，您可以按字段类型或注释注册格式化程序。</p>
</div>
<div class="paragraph">
<p><code>FormatterRegistry</code> SPI允许您集中配置格式规则，而不是在控制器之间复制此类配置。例如，您可能希望强制所有日期字段以特定方式格式化，或者具有特定注释的字段以特定方式格式化。使用共享的<code>FormatterRegistry</code> ，您可以定义一次这些规则，并在需要格式化时应用它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistrar-SPI"><a class="anchor" href="#format-FormatterRegistrar-SPI"></a> 3.5.4。<code>FormatterRegistrar</code> SPI</h4>
<div class="paragraph">
<p><code>FormatterRegistrar</code>是一个SPI，用于通过FormatterRegistry注册格式化程序和转换器。以下清单显示了其接口定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">FormatterRegistrar</span> { <span class="type">void</span> registerFormatters（FormatterRegistry registry）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在为给定格式类别注册多个相关转换器和格式化程序时， <code>FormatterRegistrar</code>非常有用，例如日期格式。它在声明性注册不足的情况下也很有用 - 例如，当格式化程序需要在与其自己的<code>&lt;T&gt;</code>不同的特定字段类型下编制索引时，或者在注册<code>Printer</code> / <code>Parser</code>对时。下一节提供有关转换器和格式化程序注册的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-configuring-formatting-mvc"><a class="anchor" href="#format-configuring-formatting-mvc"></a> 3.5.5。在Spring MVC中配置格式化</h4>
<div class="paragraph">
<p>请参阅Spring MVC章节中的<a href="web.html#mvc-config-conversion">转换和格式化</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-configuring-formatting-globaldatetimeformat"><a class="anchor" href="#format-configuring-formatting-globaldatetimeformat"></a> 3.6。配置全局日期和时间格式</h3>
<div class="paragraph">
<p>默认情况下，使用<code>DateFormat.从字符串转换未使用<code>@DateTimeFormat</code>注释的日期和时间字段<code>DateFormat.SHORT</code>风格。如果您愿意，可以通过定义自己的全局格式来更改此设置。</p>
</div>
<div class="paragraph">
<p>为此，您需要确保Spring不会注册默认格式化程序。相反，您应该手动注册所有格式化程序。使用<code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>或<code>org.springframework.format.datetime.DateFormatterRegistrar</code>类，取决于您是否使用Joda-Time库。</p>
</div>
<div class="paragraph">
<p>例如，以下Java配置注册全局<code>yyyyMMdd</code>格式（此示例不依赖于Joda-Time库）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> FormattingConversionService conversionService（）{ <span class="comment">//使用DefaultFormattingConversionService但不注册默认值</span> DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService（ <span class="predefined-constant">false</span> ）; <span class="comment">//确保仍然支持@NumberFormat</span> conversionService.addFormatterForFieldAnnotation（ <span class="keyword">new</span> NumberFormatAnnotationFormatterFactory（））; <span class="comment">//使用特定的全局格式注册日期转换</span> DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar（）; registrar.setFormatter（ <span class="keyword">new</span> <span class="predefined-type">DateFormatter</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyyMMdd</span> <span class="delimiter">”</span></span> ））; registrar.registerFormatters（conversionService）; <span class="keyword">return</span> conversionService; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您更喜欢基于XML的配置，则可以使用<code>FormattingConversionServiceFactoryBean</code> 。以下示例显示了如何执行此操作（这次使用Joda Time）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span> <span class="error">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">conversionService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.format.support。FormattingConversionServiceFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">registerDefaultFormatters</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">false</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">formatters</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.format.number。NumberFormatAnnotationFormatterFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">formatterRegistrars</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.format.datetime.joda。JodaTimeFormatterRegistrar</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dateFormatter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.format.datetime.joda。DateTimeFormatterFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pattern</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yyyyMMdd</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Joda-Time提供单独的不同类型来表示<code>date</code> ， <code>time</code>和<code>date-time</code>值。的<code>dateFormatter</code> ， <code>timeFormatter</code> ，和<code>dateTimeFormatter</code>所述的性质<code>JodaTimeFormatterRegistrar</code>应当用来配置不同的格式为每种类型。<code>DateTimeFormatterFactoryBean</code>提供了一种创建格式化程序的便捷方法。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用Spring MVC，请记住明确配置使用的转换服务。对于基于Java的<code>@Configuration</code> ，这意味着扩展<code>WebMvcConfigurationSupport</code>类并覆盖<code>mvcConversionService()</code>方法。对于XML，您应该使用<code>mvc:annotation-driven</code>元素的<code>conversion-service</code>属性。有关详细信息，请参阅<a href="web.html#mvc-config-conversion">转换和格式</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation"><a class="anchor" href="#validation-beanvalidation"></a> 3.7。弹簧验证</h3>
<div class="paragraph">
<p>Spring 3为其验证支持引入了几项增强功能。首先，完全支持JSR-303 Bean Validation API。其次，当以编程方式使用时，Spring的<code>DataBinder</code>可以验证对象以及绑定它们。第三，Spring MVC支持声明性地验证<code>@Controller</code>输入。</p>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-overview"><a class="anchor" href="#validation-beanvalidation-overview"></a> 3.7.1。JSR-303 Bean Validation API概述</h4>
<div class="paragraph">
<p>JSR-303标准化了Java平台的验证约束声明和元数据。通过使用此API，您可以使用声明性验证约束来注释域模型属性，并且运行时会强制执行它们。您可以使用许多内置约束。您还可以定义自己的自定义约束。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例，该示例显示了具有两个属性的简单<code>PersonForm</code>模型：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonForm</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="type">诠释</span>年龄; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>JSR-303允许您为这些属性定义声明性验证约束，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonForm</span> { <span class="annotation">@NotNull</span> <span class="annotation">@Size</span> （max = <span class="integer">64</span> ） <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="annotation">@Min</span> （ <span class="integer">0</span> ） <span class="directive">private</span> <span class="type">int</span> age; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当JSR-303 Validator验证此类的实例时，将强制执行这些约束。</p>
</div>
<div class="paragraph">
<p>有关JSR-303和JSR-349的一般信息，请参阅<a href="http://beanvalidation.org/">Bean Validation网站</a> 。有关默认参考实现的特定功能的信息，请参阅<a href="https://www.hibernate.org/412.html">Hibernate Validator</a>文档。要学习如何将bean验证提供程序设置为Spring bean，请继续阅读。</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring"><a class="anchor" href="#validation-beanvalidation-spring"></a> 3.7.2。配置Bean验证提供程序</h4>
<div class="paragraph">
<p>Spring提供对Bean Validation API的完全支持。这包括方便地支持将JSR-303或JSR-349 Bean Validation提供程序作为Spring bean引导。这允许您注入<code>javax.validation.ValidatorFactory</code>或<code>javax.validation.Validator</code>在您的应用程序中需要Validator</code>地方。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>LocalValidatorFactoryBean</code>将默认Validator配置为Spring bean，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">validator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.validation.beanvalidation。LocalValidatorFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面示例中的基本配置通过使用其默认引导机制触发bean验证以进行初始化。JSR-303或JSR-349提供程序（例如Hibernate Validator）应该存在于类路径中并自动检测。</p>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-inject"><a class="anchor" href="#validation-beanvalidation-spring-inject"></a>注入验证器</h5>
<div class="paragraph">
<p><code>LocalValidatorFactoryBean</code>实现了两个<code>javax.validation.ValidatorFactory</code>和<code>javax.validation.Validator</code> ，以及Spring的<code>org.springframework.validation.Validator</code> 。您可以将这些接口中的任何一个引用注入到需要调用验证逻辑的bean中。</p>
</div>
<div class="paragraph">
<p>您可以注入对<code>javax.validation.的引用<code>javax.validation.Validator</code>如果您更喜欢直接使用Bean Validation API，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.validation。验证者</span> ; <span class="annotation">@Service</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> <span class="predefined-type">Validator</span> validator;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以注入<code>org.springframework.validation.的引用<code>org.springframework.validation.Validator</code>如果您的bean需要Spring Validation API，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.validation。验证者</span> ; <span class="annotation">@Service</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> <span class="predefined-type">Validator</span> validator; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-constraints"><a class="anchor" href="#validation-beanvalidation-spring-constraints"></a>配置自定义约束</h5>
<div class="paragraph">
<p>每个bean验证约束由两部分组成：*声明约束及其可配置属性的<code>@Constraint</code>注释。* <code>javax.validation.的实现<code>javax.validation.ConstraintValidator</code>接口，用于实现约束的行为。</p>
</div>
<div class="paragraph">
<p>要将声明与实现相关联，每个<code>@Constraint</code>注释都引用相应的<code>ConstraintValidator</code>实现类。在运行时， <code>ConstraintValidatorFactory</code>在域模型中遇到约束注释时实例化引用的实现。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>LocalValidatorFactoryBean</code>配置一个<code>SpringConstraintValidatorFactory</code> ，它使用Spring创建<code>ConstraintValidator</code>实例。这使得自定义<code>ConstraintValidators</code>可以像任何其他Spring bean一样受益于依赖注入。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个自定义的<code>@Constraint</code>声明，后跟一个使用Spring进行依赖项注入的关联<code>ConstraintValidator</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。方法， <span class="predefined-type">ElementType</span> 。FIELD}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Constraint</span> （validatedBy = MyConstraintValidator.class） <span class="directive">public</span> <span class="annotation">@interface</span> MyConstraint {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.validation。ConstraintValidator</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyConstraintValidator</span> <span class="directive">实现</span> ConstraintValidator { <span class="annotation">@Autowired</span> ; <span class="directive">私人</span> Foo aDependency; ...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如前面的示例所示， <code>ConstraintValidator</code>实现可以将其依赖项<code>@Autowired</code>与任何其他Spring bean一样。</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-method"><a class="anchor" href="#validation-beanvalidation-spring-method"></a>弹簧驱动的方法验证</h5>
<div class="paragraph">
<p>您可以通过<code>MethodValidationPostProcessor</code> bean定义将Bean Validation 1.1支持的方法验证功能（以及作为自定义扩展，也可以通过Hibernate Validator 4.3）集成到Spring上下文中，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.validation.beanvalidation。MethodValidationPostProcessor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要获得Spring驱动的方法验证资格，所有目标类都需要使用Spring的<code>@Validated</code>注释进行注释。（或者，您也可以声明要使用的验证组。）有关使用Hibernate Validator和Bean Validation 1.1提供程序的设置详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html"><code>MethodValidationPostProcessor</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-other"><a class="anchor" href="#validation-beanvalidation-spring-other"></a>其他配置选项</h5>
<div class="paragraph">
<p>对于大多数情况，默认的<code>LocalValidatorFactoryBean</code>配置就足够了。从消息插值到遍历解析，各种Bean Validation构造有许多配置选项。有关这些选项的更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html"><code>LocalValidatorFactoryBean</code> Javadoc</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validation-binder"><a class="anchor" href="#validation-binder"></a> 3.7.3。配置<code>DataBinder</code></h4>
<div class="paragraph">
<p>从Spring 3开始，您可以使用<code>Validator</code>配置<code>DataBinder</code>实例。配置完成后，您可以通过调用<code>binder.validate()</code>来调用<code>Validator</code> 。任何验证<code>Errors</code>自动添加到活页夹的<code>BindingResult</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何在绑定到目标对象后以编程方式使用<code>DataBinder</code>来调用验证逻辑：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Foo target = <span class="keyword">new</span> Foo（）; DataBinder binder = <span class="keyword">new</span> DataBinder（target）; binder.setValidator（ <span class="keyword">new</span> FooValidator（））; <span class="comment">//绑定到目标对象</span> binder.bind（propertyValues）; <span class="comment">//验证目标对象</span> binder.validate（）; <span class="comment">//获取包含任何验证错误的</span> BindingResult BindingResult results = binder.getBindingResult（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以通过<code>dataBinder.addValidators</code>和<code>dataBinder.replaceValidators</code>配置具有多个<code>Validator</code>实例的<code>DataBinder</code> 。将全局配置的bean验证与在DataBinder实例上本地配置的Spring <code>Validator</code>组合时，这非常有用。请参阅<a href="#validation-mvc-configuring">[validation-mvc-configurations]</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-mvc"><a class="anchor" href="#validation-mvc"></a> 3.7.4。Spring MVC 3验证</h4>
<div class="paragraph">
<p>请参阅Spring MVC章节中的<a href="web.html#mvc-config-validation">验证</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions"><a class="anchor" href="#expressions"></a> 4。春季表达语言（SpEL）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Expression Language（简称“SpEL”）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了其他功能，最着名的是方法调用和基本字符串模板功能。</p>
</div>
<div class="paragraph">
<p>虽然有几种其他Java表达式语言可用--OGNL，MVEL和JBoss EL，仅举几例 - 创建Spring表达式语言是为了向Spring社区提供一种支持良好的表达式语言，可以在所有产品中使用。春季组合。其语言特性受Spring组合项目要求的驱动，包括基于Eclipse的Spring Tool Suite中代码完成支持的工具要求。也就是说，SpEL基于技术无关的API，可以在需要时集成其他表达式语言实现。</p>
</div>
<div class="paragraph">
<p>虽然SpEL是Spring组合中表达式评估的基础，但它并不直接与Spring绑定，可以单独使用。要自包含，本章中的许多示例都使用SpEL，就像它是一种独立的表达式语言一样。这需要创建一些引导基础结构类，例如解析器。大多数Spring用户不需要处理这种基础结构，而只能编写用于评估的表达式字符串。这种典型用法的一个示例是将SpEL集成到创建基于XML或基于注释的bean定义中，如<a href="#expressions-beandef">表达式支持中</a>所示， <a href="#expressions-beandef">用于定义bean定义</a> 。</p>
</div>
<div class="paragraph">
<p>本章介绍表达式语言的功能，API及其语言语法。在一些地方， <code>Inventor</code>和<code>Society</code>类被用作表达式评估的目标对象。这些类声明和用于填充它们的数据列在本章末尾。</p>
</div>
<div class="paragraph">
<p>表达式语言支持以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>文字表达</p>
</li>
<li>
<p>布尔和关系运算符</p>
</li>
<li>
<p>常用表达</p>
</li>
<li>
<p>类表达式</p>
</li>
<li>
<p>访问属性，数组，列表和映射</p>
</li>
<li>
<p>方法调用</p>
</li>
<li>
<p>关系运算符</p>
</li>
<li>
<p>分配</p>
</li>
<li>
<p>调用构造函数</p>
</li>
<li>
<p>Bean引用</p>
</li>
<li>
<p>阵列构造</p>
</li>
<li>
<p>内联列表</p>
</li>
<li>
<p>内联地图</p>
</li>
<li>
<p>三元运算符</p>
</li>
<li>
<p>变量</p>
</li>
<li>
<p>用户定义的函数</p>
</li>
<li>
<p>收集投影</p>
</li>
<li>
<p>收藏品选择</p>
</li>
<li>
<p>模板化的表达</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="expressions-evaluation"><a class="anchor" href="#expressions-evaluation"></a> 4.1。评估</h3>
<div class="paragraph">
<p>本节介绍SpEL接口及其表达式语言的简单使用。完整的语言参考可以在<a href="#expressions-language-ref">语言参考中</a>找到。</p>
</div>
<div class="paragraph">
<p>以下代码介绍了用于评估文字字符串表达式<code>Hello World</code>的SpEL API。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="predefined-type">表达式</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'Hello World'</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="predefined-type">String</span> message =（ <span class="predefined-type">String</span> ）exp.getValue（）;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>消息变量的值为<code>'Hello World'</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您最有可能使用的SpEL类和接口位于<code>org.springframework.expression</code>包及其子包中，例如<code>spel.support</code> 。</p>
</div>
<div class="paragraph">
<p><code>ExpressionParser</code>接口负责解析表达式字符串。在前面的示例中，表达式字符串是由周围的单引号表示的字符串文字。<code>Expression</code>接口负责评估先前定义的表达式字符串。分别调用<code>parser.parseExpression</code>和<code>exp.getValue</code>时，可抛出的两个异常<code>ParseException</code>和<code>EvaluationException</code> 。</p>
</div>
<div class="paragraph">
<p>SpEL支持广泛的功能，例如调用方法，访问属性和调用构造函数。</p>
</div>
<div class="paragraph">
<p>在下面的方法调用示例中，我们在字符串文字上调用<code>concat</code>方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="predefined-type">表达式</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'Hello World'.concat（'!!'）</span> <span class="delimiter">“</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="predefined-type">String</span> message =（ <span class="predefined-type">String</span> ）exp.getValue（）;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>message</code>的价值现在是'Hello World！”。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下调用JavaBean属性的示例调用<code>String</code>属性<code>Bytes</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="comment">//调用'getBytes（）'</span> <span class="predefined-type">表达式</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'Hello World'.bytes</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">byte</span> <span class="type">[]</span> bytes =（ <span class="type">byte</span> <span class="type">[]</span> ）exp.getValue（）;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>该行将文字转换为字节数组。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>SpEL还通过使用标准点表示法（例如<code>prop1.prop2.prop3</code> ）和属性值的设置来支持嵌套属性。也可以访问公共字段。以下示例显示如何使用点表示法来获取文字的长度：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="comment">//调用'getBytes（）。length'</span> <span class="predefined-type">表达式</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'Hello World'.bytes.length</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">int</span> length =（ <span class="predefined-type">Integer</span> ）exp.getValue（）;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>'Hello World'.bytes.length</code>给出了文字的长度。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>可以调用String的构造函数而不是使用字符串文字，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="predefined-type">表达式</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">new String（'hello world'）。toUpperCase（）</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="predefined-type">String</span> message = exp.getValue（ <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从文字构造一个新的<code>String</code>并使其成为大写。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意泛型方法的使用： <code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code> 。使用此方法无需将表达式的值强制转换为所需的结果类型。如果无法将值强制转换为类型<code>T</code>或使用已注册的类型转换器转换，则抛出<code>EvaluationException</code> 。</p>
</div>
<div class="paragraph">
<p>SpEL的更常见用法是提供针对特定对象实例（称为根对象）计算的表达式字符串。以下示例显示如何从<code>Inventor</code>类的实例检索<code>name</code>属性或创建布尔条件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//创建并设置日历</span> <span class="predefined-type">GregorianCalendar</span> c = <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span> （）; <span class="integer">c.set（1856年</span> <span class="integer"><span class="integer">，7，9）;</span></span> <span class="comment">//构造函数参数是name，birthday和nationality。</span>发明人特斯拉= <span class="keyword">新</span>发明家（ <span class="string"><span class="delimiter">“</span> <span class="content">Nikola Tesla</span> <span class="delimiter">”</span></span> ，c.getTime（）， <span class="string"><span class="delimiter">“</span> <span class="content">塞尔维亚人</span> <span class="delimiter">”</span></span> ）; ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="predefined-type">表达式</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="predefined-type">String</span> name =（ <span class="predefined-type">String</span> ）exp.getValue（tesla）; <span class="comment">// name ==“Nikola Tesla”</span> exp = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">name =='Nikola Tesla'</span> <span class="delimiter">”</span></span> ）; <span class="type">boolean</span> result = exp.getValue（tesla， <span class="predefined-type">Boolean</span> .class）; <span class="comment">// result == true</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>将<code>name</code>解析为表达式。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-evaluation-context"><a class="anchor" href="#expressions-evaluation-context"></a> 4.1.1。了解<code>EvaluationContext</code></h4>
<div class="paragraph">
<p>在评估表达式以解析属性，方法或字段以及帮助执行类型转换时，将使用<code>EvaluationContext</code>接口。Spring提供了两种实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SimpleEvaluationContext</code> ：为不需要SpEL语言语法的完整范围的表达式类别公开必要的SpEL语言特性和配置选项的子集，并且应该进行有意义的限制。示例包括但不限于数据绑定表达式和基于属性的过滤器。</p>
</li>
<li>
<p><code>StandardEvaluationContext</code> ：公开全套SpEL语言功能和配置选项。您可以使用它来指定默认根对象并配置每个可用的与评估相关的策略。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SimpleEvaluationContext</code>旨在仅支持SpEL语言语法的子集。它排除了Java类型引用，构造函数和bean引用。它还要求您明确选择表达式中属性和方法的支持级别。默认情况下， <code>create()</code>静态工厂方法仅启用对属性的读访问权限。您还可以获取构建器以配置所需的确切支持级别，定位以下一个或多个组合：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅限自定义<code>PropertyAccessor</code> （无反射）</p>
</li>
<li>
<p>只读访问的数据绑定属性</p>
</li>
<li>
<p>读写的数据绑定属性</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="expressions-type-conversion"><a class="anchor" href="#expressions-type-conversion"></a>类型转换</h5>
<div class="paragraph">
<p>默认情况下，SpEL使用Spring核心中提供的转换服务（ <code>org.springframework.core.convert.ConversionService</code> ）。此转换服务附带了许多用于常见转换的内置转换器，但也是完全可扩展的，因此您可以在类型之间添加自定义转换。此外，它具有泛型意识。这意味着，当您在表达式中使用泛型类型时，SpEL会尝试转换以保持其遇到的任何对象的类型正确性。</p>
</div>
<div class="paragraph">
<p>这在实践中意味着什么？假设使用<code>setValue()</code>赋值用于设置<code>List</code>属性。该属性的类型实际上是<code>List&lt;Boolean&gt;</code> 。SpEL识别列表中的元素在放入其中之前需要转换为<code>Boolean</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Simple</span> { <span class="directive">public</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">Boolean</span> &gt; booleanList = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> &lt; <span class="predefined-type">Boolean</span> &gt;（）;简单simple = <span class="keyword">new</span> Simple（）; simple.booleanList.add（ <span class="predefined-constant">true</span> ）; EvaluationContext context = SimpleEvaluationContext（）。forReadOnlyDataBinding（）。build（）; <span class="comment">// false在这里作为字符串传递。SpEL和转换服务</span> <span class="comment">//正确识别它需要是一个布尔值并将其转换为</span> parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">booleanList [0]</span> <span class="delimiter">”</span></span> ）。setValue（context，simple， <span class="string"><span class="delimiter">“</span> <span class="content">false</span> <span class="delimiter">”</span></span> ）; <span class="comment">// b是false</span> <span class="predefined-type">Boolean</span> b = simple.booleanList.get（ <span class="integer">0</span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-parser-configuration"><a class="anchor" href="#expressions-parser-configuration"></a> 4.1.2。分析器配置</h4>
<div class="paragraph">
<p>可以使用解析器配置对象（ <code>org.springframework.expression.spel.配置SpEL表达式解析器<code>org.springframework.expression.spel.SpelParserConfiguration</code> ）。配置对象控制某些表达式组件的行为。例如，如果索引到数组或集合，并且指定索引处的元素为<code>null</code> ，则可以自动创建该元素。当使用由一系列属性引用组成的表达式时，这很有用。如果索引到数组或列表并指定超出数组或列表当前大小末尾的索引，则可以自动增大数组或列表以适应该索引。以下示例演示如何自动增长列表：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Demo</span> { <span class="directive">public</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; list; } <span class="comment">//启用：</span> <span class="comment">//  - 自动空引用初始化</span> <span class="comment">//  - 自动收集增长</span> SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration（ <span class="predefined-constant">true</span> ， <span class="predefined-constant">true</span> ）; ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（config）; <span class="predefined-type">表达式</span>表达式= parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">list [3]</span> <span class="delimiter">”</span></span> ）;演示demo = <span class="keyword">new</span> Demo（）; <span class="predefined-type">Object</span> o = expression.getValue（demo）; <span class="comment">// demo.list现在将是4个条目的真实集合</span> <span class="comment">//每个条目都是一个新的空字符串</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-spel-compilation"><a class="anchor" href="#expressions-spel-compilation"></a> 4.1.3。SpEL编译</h4>
<div class="paragraph">
<p>Spring Framework 4.1包含一个基本的表达式编译器。表达式通常被解释，在评估期间提供了很多动态灵活性，但是没有提供最佳性能。对于偶尔的表达式使用，这很好，但是，当其他组件（如Spring Integration）使用时，性能可能非常重要，并且不需要动态。</p>
</div>
<div class="paragraph">
<p>SpEL编译器旨在满足此需求。在评估期间，编译器生成一个真实的Java类，它体现了表达式行为，并使用它来实现更快的表达式评估。由于缺少表达式类型，编译器使用在执行编译时对表达式的解释评估期间收集的信息。例如，它不完全从表达式中知道属性引用的类型，但是，在第一次解释评估期间，它会发现它是什么。当然，如果各种表达元素的类型随时间变化，那么基于此信息的编译可能会导致麻烦。因此，编译最适合于在重复评估时类型信息不会改变的表达式。</p>
</div>
<div class="paragraph">
<p>请考虑以下基本表达式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>someArray [0] .someProperty.someOtherProperty &lt;0.1</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为前面的表达式涉及数组访问，某些属性取消引用和数字操作，所以性能增益非常明显。在50000次迭代的微基准测试示例中，使用解释器进行评估需要75ms，使用表达式的编译版本只需要3ms。</p>
</div>
<div class="sect4">
<h5 id="expressions-compiler-configuration"><a class="anchor" href="#expressions-compiler-configuration"></a>编译器配置</h5>
<div class="paragraph">
<p>默认情况下，编译器未打开，但您可以通过两种不同的方式打开它。您可以使用解析器配置过程（ <a href="#expressions-parser-configuration">前面讨论过</a> ）或在将SpEL用法嵌入到另一个组件中时使用系统属性来打开它。本节讨论这两个选项。</p>
</div>
<div class="paragraph">
<p>编译器可以以三种模式之一运行，这些模式在<code>org.springframework.expression.spel.中捕获<code>org.springframework.expression.spel.SpelCompilerMode</code>枚举。模式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OFF</code> （默认值）：编译器已关闭。</p>
</li>
<li>
<p><code>IMMEDIATE</code> ：在立即模式下，表达式尽快编译。这通常是在第一次解释评估之后。如果编译的表达式失败（通常是由于类型更改，如前所述），表达式求值的调用者会收到异常。</p>
</li>
<li>
<p><code>MIXED</code> ：在混合模式下，表达式随着时间的推移在解释和编译模式之间静默切换。经过一定数量的解释运行后，它们会切换到编译形式，如果编译后的表单出现问题（如类型更改，如前所述），表达式会自动再次切换回解释形式。稍后，它可能会生成另一个编译的表单并切换到它。基本上，用户进入<code>IMMEDIATE</code>模式的例外是在内部处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>存在<code>IMMEDIATE</code>模式，因为<code>MIXED</code>模式可能会导致具有副作用的表达式出现问题。如果编译后的表达式在部分成功后爆炸，则可能已经完成了影响系统状态的事情。如果发生这种情况，调用者可能不希望它以解释模式静默重新运行，因为表达式的一部分可能正在运行两次。</p>
</div>
<div class="paragraph">
<p>选择模式后，使用<code>SpelParserConfiguration</code>配置解析器。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration（SpelCompilerMode。IMMEDIATE， <span class="local-variable">这个</span> .getClass（）。getClassLoader（））; SpelExpressionParser解析器= <span class="keyword">新的</span> SpelExpressionParser（config）; <span class="predefined-type">Expression</span> expr = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">payload</span> <span class="delimiter">”</span></span> ）; MyMessage message = <span class="keyword">new</span> MyMessage（）; <span class="predefined-type">Object</span> payload = expr.getValue（message）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>指定编译器模式时，还可以指定类加载器（允许传递null）。编译表达式在任何提供的子类加载器中定义。重要的是要确保，如果指定了类加载器，它可以看到表达式评估过程中涉及的所有类型。如果未指定类加载器，则使用默认类加载器（通常是表达式求值期间运行的线程的上下文类加载器）。</p>
</div>
<div class="paragraph">
<p>配置编译器的第二种方法是在SpEL嵌入到某个其他组件中时使用，并且可能无法通过配置对象对其进行配置。在这些情况下，可以使用系统属性。您可以设置<code>spring.expression.compiler.mode</code>属性设置为一个<code>SpelCompilerMode</code>枚举值（ <code>off</code> ， <code>immediate</code>或<code>mixed</code> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-compiler-limitations"><a class="anchor" href="#expressions-compiler-limitations"></a>编译器限制</h5>
<div class="paragraph">
<p>自Spring Framework 4.1以来，基本的编译框架已经到位。但是，该框架尚不支持编译各种表达式。最初的重点是可能在性能关键环境中使用的常用表达式。目前无法编译以下类型的表达式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>涉及转让的表达</p>
</li>
<li>
<p>表达式依赖于转换服务</p>
</li>
<li>
<p>表达式使用自定义解析器或访问器</p>
</li>
<li>
<p>使用选择或投影的表达式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将来可以编写更多类型的表达式。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-beandef"><a class="anchor" href="#expressions-beandef"></a> 4.2。Bean定义中的表达式</h3>
<div class="paragraph">
<p>您可以将SpEL表达式与基于XML或基于注释的配置元数据一起用于定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法都是<code>#{ &lt;expression string&gt; }</code> 。</p>
</div>
<div class="sect3">
<h4 id="expressions-beandef-xml-based"><a class="anchor" href="#expressions-beandef-xml-based"></a> 4.2.1。XML配置</h4>
<div class="paragraph">
<p>可以使用表达式设置属性或构造函数参数值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">numberGuess</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.spring.samples。NumberGuess</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">randomNumber</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{T（java.lang。数学）.random（）* 100.0}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 其他属性 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>systemProperties</code>变量是预定义的，因此您可以在表达式中使用它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">taxCalculator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.spring.samples。TaxCalculator</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultLocale</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{systemProperties ['user.region']}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 其他属性 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您不必在此上下文中使用<code>#</code>符号为预定义变量添加前缀。</p>
</div>
<div class="paragraph">
<p>您还可以按名称引用其他bean属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">numberGuess</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.spring.samples。NumberGuess</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">randomNumber</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{T（java.lang。数学）.random（）* 100.0}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 其他属性 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">shapeGuess</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.spring.samples。ShapeGuess</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">initialShapeSeed</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{numberGuess.randomNumber}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 其他属性 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-beandef-annotation-based"><a class="anchor" href="#expressions-beandef-annotation-based"></a> 4.2.2。注释配置</h4>
<div class="paragraph">
<p>要指定默认值，可以在字段，方法和方法或构造函数参数上放置<code>@Value</code>注释。</p>
</div>
<div class="paragraph">
<p>以下示例设置字段变量的默认值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">FieldValueTestBean</span> <span class="annotation">@Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">＃{</span></span> <span class="annotation">systemProperties</span> <span class="string"><span class="content">['user.region']}</span> <span class="delimiter">”</span></span> ） <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale; <span class="directive">public</span> <span class="type">void</span> setDefaultLocale（ <span class="predefined-type">String</span> defaultLocale）{ <span class="local-variable">this</span> .defaultLocale = defaultLocale; <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultLocale（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .defaultLocale; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了等效但在属性setter方法上：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">PropertyValueTestBean</span> <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale; <span class="annotation">@Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">＃{</span></span> <span class="annotation">systemProperties</span> <span class="string"><span class="content">['user.region']}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> setDefaultLocale（ <span class="predefined-type">String</span> defaultLocale）{ <span class="local-variable">this</span> .defaultLocale = defaultLocale; <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultLocale（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .defaultLocale; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>自动化方法和构造函数也可以使用<code>@Value</code>注释，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> { <span class="directive">private</span> MovieFinder movieFinder; <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> configure（MovieFinder movieFinder， <span class="annotation">@ Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">＃{</span></span> <span class="annotation">systemProperties</span> <span class="string"><span class="content">['user.region']}</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> defaultLocale）{ <span class="local-variable">this</span> .movi​​eFinder = movieFinder; <span class="local-variable">这个</span> .defaultLocale = defaultLocale; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> { <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale; <span class="directive">私人</span> CustomerPreferenceDao customerPreferenceDao; <span class="annotation">@Autowired</span> <span class="directive">public</span> MovieRecommender（CustomerPreferenceDao customerPreferenceDao， <span class="annotation">@ Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">＃{</span></span> <span class="annotation">systemProperties</span> <span class="string"><span class="content">['user.country']}</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> defaultLocale）{ <span class="local-variable">this</span> .customerPreferenceDao = customerPreferenceDao; <span class="local-variable">这个</span> .defaultLocale = defaultLocale; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-language-ref"><a class="anchor" href="#expressions-language-ref"></a> 4.3。语言参考</h3>
<div class="paragraph">
<p>本节介绍Spring表达式语言的工作原理。它涵盖以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#expressions-ref-literal">文字表达</a></p>
</li>
<li>
<p><a href="#expressions-properties-arrays">属性，数组，列表，地图和索引器</a></p>
</li>
<li>
<p><a href="#expressions-inline-lists">内联列表</a></p>
</li>
<li>
<p><a href="#expressions-inline-maps">内联地图</a></p>
</li>
<li>
<p><a href="#expressions-array-construction">数组构造</a></p>
</li>
<li>
<p><a href="#expressions-methods">方法</a></p>
</li>
<li>
<p><a href="#expressions-operators">运营商</a></p>
</li>
<li>
<p><a href="#expressions-types">类型</a></p>
</li>
<li>
<p><a href="#expressions-constructors">构造函数</a></p>
</li>
<li>
<p><a href="#expressions-ref-variables">变量</a></p>
</li>
<li>
<p><a href="#expressions-ref-functions">功能</a></p>
</li>
<li>
<p><a href="#expressions-bean-references">Bean参考</a></p>
</li>
<li>
<p><a href="#expressions-operator-ternary">三元运算符（If-Then-Else）</a></p>
</li>
<li>
<p><a href="#expressions-operator-elvis">猫王运营商</a></p>
</li>
<li>
<p><a href="#expressions-operator-safe-navigation">安全导航操作员</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="expressions-ref-literal"><a class="anchor" href="#expressions-ref-literal"></a> 4.3.1。文字表达</h4>
<div class="paragraph">
<p>支持的文字表达式的类型是字符串，数值（int，real，hex），boolean和null。字符串由单引号分隔。要在字符串中放置单引号，请使用两个单引号字符。</p>
</div>
<div class="paragraph">
<p>以下清单显示了文字的简单用法。通常，它们不是像这样单独使用，而是作为更复杂表达式的一部分使用 - 例如，在逻辑比较运算符的一侧使用文字。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="comment">// evals to“Hello World”</span> <span class="predefined-type">String</span> helloWorld =（ <span class="predefined-type">String</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'Hello World'</span> <span class="delimiter">”</span></span> ）。getValue（）; <span class="type">double</span> avogadrosNumber =（ <span class="predefined-type">Double</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">6.0221415E + 23</span> <span class="delimiter">”</span></span> ）。getValue（）; <span class="comment">// evals to 2147483647</span> <span class="type">int</span> maxValue =（ <span class="predefined-type">Integer</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">0x7FFFFFFF</span> <span class="delimiter">”</span></span> ）。getValue（）; <span class="type">boolean</span> trueValue =（ <span class="predefined-type">Boolean</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> ）。getValue（）; <span class="predefined-type">Object</span> nullValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">null</span> <span class="delimiter">”</span></span> ）。getValue（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>数字支持使用负号，指数表示法和小数点。默认情况下，使用Double.parseDouble（）解析实数。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-properties-arrays"><a class="anchor" href="#expressions-properties-arrays"></a> 4.3.2。属性，数组，列表，地图和索引器</h4>
<div class="paragraph">
<p>使用属性引用进行导航很容易。为此，请使用句点指示嵌套属性值。<code>Inventor</code>类（ <code>pupin</code>和<code>tesla</code>的实例填充<a href="#expressions-example-classes">了示例</a>部分中<a href="#expressions-example-classes">使用</a>的<a href="#expressions-example-classes">类中</a>列出的数据。为了“向下”导航并获得特斯拉的出生年份和Pupin的出生城市，我们使用以下表达式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evals to 1856</span> <span class="type">int</span> year =（ <span class="predefined-type">Integer</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Birthdate。年+ 1900</span> <span class="delimiter">“</span></span> ）。getValue（context）; <span class="predefined-type">String</span> city =（ <span class="predefined-type">String</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">placeOfBirth。City</span> <span class="delimiter">“</span></span> ）。getValue（context）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>属性名称的第一个字母允许不区分大小写。数组和列表的内容是使用方括号表示法获得的，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding（）。build（）; <span class="comment">// Inventions数组</span> <span class="comment">//求值为“Induction motor”</span> <span class="predefined-type">字符串</span>发明= parser.parseExpression（ <span class="string"><span class="delimiter">“</span></span> inventions <span class="string"><span class="content">[3]</span> <span class="delimiter">”</span></span> ）。getValue（context，tesla， <span class="predefined-type">String</span> .class）; <span class="comment">//成员列表</span> <span class="comment">//评估为“Nikola Tesla”</span> <span class="predefined-type">字符串</span>名称= parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">成员[0]。名称</span> <span class="delimiter">“</span></span> ）。getValue（context，ieee， <span class="predefined-type">String</span> .class）; <span class="comment">//列表和数组导航</span> <span class="comment">//评估为”无线通信“</span> <span class="predefined-type">字符串</span>发明= parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">成员[0]。Inventions [6]</span> <span class="delimiter">“</span></span> ）。getValue（context，ieee， <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过指定括号内的文字键值来获取映射的内容。在以下示例中，因为<code>Officers</code>映射的键是字符串，我们可以指定字符串文字：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//官员字典</span>发明人pupin = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">官员['总统']</span> <span class="delimiter">”</span></span> ）。getValue（societyContext，Inventor.class）; <span class="comment">//评估为“Idvor”</span> <span class="predefined-type">String</span> city = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Officers ['president']。出生地。City</span> <span class="delimiter">“</span></span> ）。getValue（societyContext， <span class="predefined-type">String</span> .class）; <span class="comment">//设置值</span> parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">Officers ['advisors'] [0]。出生地。国家</span> <span class="delimiter">“</span></span> ）。setValue（societyContext， <span class="string"><span class="delimiter">”</span> <span class="content">Croatia</span> <span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-lists"><a class="anchor" href="#expressions-inline-lists"></a> 4.3.3。内联列表</h4>
<div class="paragraph">
<p>您可以使用<code>{}</code>表示法直接在表达式中表达列表。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//求值为包含四个数字的Java列表</span> <span class="predefined-type">List</span> numbers =（ <span class="predefined-type">List</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">{1,2,3,4}</span> <span class="delimiter">”</span></span> ）。getValue（context）; <span class="predefined-type">List</span> listOfLists =（ <span class="predefined-type">List</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">{{'a'，'b'}，{'x'，'y'}}</span> <span class="delimiter">”</span></span> ）。getValue（context）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>{}</code>本身就是一个空列表。出于性能原因，如果列表本身完全由固定文字组成，则会创建一个常量列表来表示表达式（而不是在每个评估上构建新列表）。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-maps"><a class="anchor" href="#expressions-inline-maps"></a> 4.3.4。内联地图</h4>
<div class="paragraph">
<p>您还可以使用<code>{key:value}</code>表示法直接在表达式中表达地图。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//计算到包含两个条目的Java映射</span> <span class="predefined-type">Map</span> inventorInfo =（ <span class="predefined-type">Map</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">{name：'Nikola'，dob：'10 -July-1856'}</span> <span class="delimiter">”</span></span> ）。getValue（context）; <span class="predefined-type">map</span> mapOfMaps =（ <span class="predefined-type">Map</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">{name：{first：'Nikola'，last：'Tesla'}，dob：{day：10，month：'July'，year：1856}}</span> <span class="delimiter">”。</span></span> ）。getValue （上下文）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>{:}</code>本身就是一张空地图。出于性能原因，如果地图本身由固定文字或其他嵌套常量结构（列表或地图）组成，则会创建一个常量地图来表示表达式（而不是在每次评估时构建新地图）。引用地图键是可选的。上面的示例不使用带引号的键。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-array-construction"><a class="anchor" href="#expressions-array-construction"></a> 4.3.5。数组构造</h4>
<div class="paragraph">
<p>您可以使用熟悉的Java语法构建数组，可选择提供初始化程序以在构造时填充数组。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> <span class="type">[]</span> numbers1 =（ <span class="type">int</span> <span class="type">[]</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">new int [4]</span> <span class="delimiter">”</span></span> ）。getValue（context）; <span class="comment">//带初始化程序的数组</span> <span class="type">int</span> <span class="type">[]</span> numbers2 =（ <span class="type">int</span> <span class="type">[]</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">new int [] {1,2,3}</span> <span class="delimiter">”</span></span> ）。getValue（context）; <span class="comment">//多维数组</span> <span class="type">int</span> <span class="type">[]</span> <span class="type">[]</span> numbers3 =（ <span class="type">int</span> <span class="type">[]</span> <span class="type">[]</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">new int [4] [5]</span> <span class="delimiter">”</span></span> ）。getValue（context）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在构造多维数组时，当前无法提供初始化程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-methods"><a class="anchor" href="#expressions-methods"></a> 4.3.6。方法</h4>
<div class="paragraph">
<p>您可以使用典型的Java编程语法调用方法。您还可以在文字上调用方法。还支持变量参数。以下示例显示了如何调用方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// string literal，求值为“bc”</span> <span class="predefined-type">String</span> bc = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'abc'.substring（1,3）</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">String</span> .class）; <span class="comment">//求值为true</span> <span class="type">boolean</span> isMember = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">isMember（'Mihajlo Pupin'）</span> <span class="delimiter">”</span></span> ）。getValue（societyContext， <span class="predefined-type">Boolean</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operators"><a class="anchor" href="#expressions-operators"></a> 4.3.7。运营商</h4>
<div class="paragraph">
<p>Spring Expression Language支持以下类型的运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#expressions-operators-relational">关系运算符</a></p>
</li>
<li>
<p><a href="#expressions-operators-logical">逻辑运算符</a></p>
</li>
<li>
<p><a href="#expressions-operators-mathematical">数学运算符</a></p>
</li>
<li>
<p><a href="#expressions-assignment">作业运营商</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="expressions-operators-relational"><a class="anchor" href="#expressions-operators-relational"></a>关系运算符</h5>
<div class="paragraph">
<p>使用标准运算符表示法支持关系运算符（等于，不等于，小于，小于或等于，大于，等于或等于）。以下清单显示了一些运算符示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//求值为true</span> <span class="type">布尔值</span> trueValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">2 == 2</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//求值为false</span> <span class="type">boolean</span> falseValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">2 &lt;-5.0</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//计算结果为true</span> <span class="type">布尔值</span> trueValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'black'&lt;'block'</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>大于和小于<code>null</code>比较遵循一个简单的规则： <code>null</code>被视为<code>null</code> （不是零）。因此，任何其他值始终大于<code>null</code> （ <code>X &gt; null</code>始终为<code>true</code> ），并且其他任何值都不会小于任何值（ <code>X &lt; null</code>始终为<code>false</code> ）。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢数字比较，请避免基于数字的<code>null</code>比较，以支持与零进行比较（例如， <code>X &gt; 0</code>或<code>X &lt; 0</code> ）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除了标准的关系运算符之外，SpEL还支持基于<code>instanceof</code>和正则表达式的<code>matches</code>运算符。以下列表显示了两者的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//求值为false</span> <span class="type">boolean</span> falseValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'</span></span> xyz'instanceof <span class="string"><span class="content">T（Integer）</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//求值为true</span> <span class="type">布尔值</span> trueValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'5.00'匹配'^  - ？</span><span class="char">\\</span> <span class="content">d +（</span> <span class="char">\\</span> <span class="content">。</span> <span class="char">\\</span> <span class="content">d {2}）？$'</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//求值为false</span> <span class="type">布尔值</span> falseValue = parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">'5.0067'匹配'^  - ？</span><span class="char">\\</span> <span class="content">d +（</span> <span class="char">\\</span> <span class="content">。</span> <span class="char">\\</span> <span class="content">d {2}）？$'</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">小心原始类型，因为它们立即被装箱到包装类型，因此<code>1 instanceof T(int)</code>求值为<code>false</code>而<code>1 instanceof T(Integer)</code>求值为<code>true</code> ，如预期的那样。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个符号运算符也可以指定为纯字母等价运算符。这避免了所使用的符号对于嵌入表达式的文档类型具有特殊含义的问题（例如在XML文档中）。文本等价物是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lt</code> （ <code>&lt;</code> ）</p>
</li>
<li>
<p><code>gt</code> （ <code>&gt;</code> ）</p>
</li>
<li>
<p><code>le</code> （ <code>&lt;=</code> ）</p>
</li>
<li>
<p><code>ge</code> （ <code>&gt;=</code> ）</p>
</li>
<li>
<p><code>eq</code> （ <code>==</code> ）</p>
</li>
<li>
<p><code>ne</code> （ <code>!=</code> ）</p>
</li>
<li>
<p><code>div</code> （ <code>/</code> ）</p>
</li>
<li>
<p><code>mod</code> （ <code>%</code> ）</p>
</li>
<li>
<p><code>not</code> （ <code>!</code> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有文本运算符都不区分大小写。</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-logical"><a class="anchor" href="#expressions-operators-logical"></a>逻辑运算符</h5>
<div class="paragraph">
<p>SpEL支持以下逻辑运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>和</code></p>
</li>
<li>
<p><code>要么</code></p>
</li>
<li>
<p><code>不</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示如何使用逻辑运算符</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//  -  AND  -</span> <span class="comment">//求值为false</span> <span class="type">boolean</span> falseValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">true and false</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//评估为true</span> <span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">“</span> <span class="content">isMember（'Nikola Tesla'）and isMember（'Mihajlo Pupin'）</span> <span class="delimiter">”</span></span> ; <span class="type">boolean</span> trueValue = parser.parseExpression（expression）.getValue（societyContext， <span class="predefined-type">Boolean</span> .class）; <span class="comment">//  -  OR  -</span> <span class="comment">//求值为true</span> <span class="type">布尔值</span> trueValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">true或false</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//评估为true</span> <span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">“</span> <span class="content">isMember（'Nikola Tesla'）或isMember（'Albert Einstein'）</span> <span class="delimiter">”</span></span> ; <span class="type">boolean</span> trueValue = parser.parseExpression（expression）.getValue（societyContext， <span class="predefined-type">Boolean</span> .class）; <span class="comment">//  -  NOT  -</span> <span class="comment">//计算结果为false</span> <span class="type">布尔值</span> falseValue = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">！true</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）; <span class="comment">//  -  AND AND NOT  -</span> <span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">”</span> <span class="content">isMember（'Nikola Tesla'）and！isMember（'Mihajlo Pupin'）</span> <span class="delimiter">“</span></span> ; <span class="type">boolean</span> falseValue = parser.parseExpression（expression）.getValue（societyContext， <span class="predefined-type">Boolean</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-mathematical"><a class="anchor" href="#expressions-operators-mathematical"></a>数学运算符</h5>
<div class="paragraph">
<p>您可以在数字和字符串上使用加法运算符。您只能对数字使用减法，乘法和除法运算符。您还可以使用模数（％）和指数幂（^）运算符。强制执行标准运算符优先级。以下示例显示了正在使用的数学运算符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Addition</span> <span class="type">int</span> two = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">1 + 1</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// 2</span> <span class="predefined-type">String</span> testString = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">'test'+''+'string'</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">String</span> .class）; <span class="comment">//'test string'</span> <span class="comment">//减法</span> <span class="type">int</span> 4 = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">1  -  -3</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// 4</span> <span class="type">double</span> d = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">1000.00  -  1e4</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Double</span> .class）; <span class="comment">// -9000</span> <span class="comment">//乘法</span> <span class="type">int</span> six = parser.parseExpression（ <span class="string"><span class="delimiter">“ -</span> <span class="content">2 * -3</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// 6</span> <span class="type">double</span> twentyFour = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">2.0 * 3e0 * 4</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Double</span> .class）; <span class="comment">// 24.0</span> <span class="comment">// Division</span> <span class="type">int</span> minusTwo = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">6 / -3</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// -2</span> <span class="type">double</span> one = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">8.0 / 4e0 / 2</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Double</span> .class）; <span class="comment">// 1.0</span> <span class="comment">// Modulus</span> <span class="type">int</span> three = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">7％4</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// 3</span> <span class="type">int</span> one = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">8/5％2</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// 1</span> <span class="comment">//运算符优先级</span> <span class="type">int</span> minusTwentyOne = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">1 + 2-3 * 8</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">Integer</span> .class）; <span class="comment">// -21</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-assignment"><a class="anchor" href="#expressions-assignment"></a>作业运营商</h5>
<div class="paragraph">
<p>要设置属性，请使用赋值运算符（ <code>=</code> ）。这通常在调用<code>setValue</code>但也可以在调用<code>getValue</code> 。以下清单显示了使用赋值运算符的两种方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor inventor = <span class="keyword">new</span> Inventor（）; EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding（）。build（）; parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Name</span> <span class="delimiter">”</span></span> ）。setValue（context，inventor， <span class="string"><span class="delimiter">“</span> <span class="content">Aleksandar Seovic</span> <span class="delimiter">”</span></span> ）; <span class="comment">//或者</span> <span class="predefined-type">字符串</span> aleks = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Name ='Aleksandar Seovic'</span> <span class="delimiter">”</span></span> ）。getValue（context，inventor， <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-types"><a class="anchor" href="#expressions-types"></a> 4.3.8。类型</h4>
<div class="paragraph">
<p>您可以使用特殊的<code>T</code>运算符来指定<code>java.lang.的实例<code>java.lang.Class</code> （类型）。通过使用此运算符也可以调用静态方法。<code>StandardEvaluationContext</code>使用<code>TypeLocator</code>查找类型， <code>StandardTypeLocator</code> （可以替换）是在了解<code>java.lang</code>包的基础上构建的。这意味着对<code>java.lang</code>类型的<code>T()</code>引用不需要完全限定，但所有其他类型引用必须是。以下示例显示如何使用<code>T</code>运算符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">class</span> dateClass = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">T（java.util。Date）</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">Class</span> .class）; <span class="predefined-type">Class</span> stringClass = parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">T（String）</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">Class</span> .class）; <span class="type">boolean</span> trueValue = parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">T（java.math。的RoundingMode）。CEILING &lt;T（java.math。的RoundingMode）。FLOOR</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">Boolean</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-constructors"><a class="anchor" href="#expressions-constructors"></a> 4.3.9。构造函数</h4>
<div class="paragraph">
<p>您可以使用<code>new</code>运算符调用构造函数。除了基本类型（ <code>int</code> ， <code>float</code>等）和String之外，您应该使用全限定类名。以下示例显示如何使用<code>new</code>运算符来调用构造函数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor einstein = p.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">new org.spring.samples.spel.inventor。Inventor（'Albert Einstein'，'German'）</span> <span class="delimiter">“</span></span> ）。getValue（Inventor.class）; <span class="comment">//在List</span> p.parseExpression的<span class="comment">add方法中创建新的Inventor实例</span> （ <span class="string"><span class="delimiter">”</span> <span class="content">members.add（new org.spring.samples.spel。发明者。发明家（'阿尔伯特爱因斯坦'，'德国'））</span> <span class="delimiter">“</span></span> ）。getValue（societyContext）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-variables"><a class="anchor" href="#expressions-ref-variables"></a> 4.3.10。变量</h4>
<div class="paragraph">
<p>您可以使用<code>#variableName</code>语法在表达式中引用变量。通过在<code>EvaluationContext</code>实现上使用<code>setVariable</code>方法设置变量。以下示例显示如何使用变量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">发明人特斯拉= <span class="keyword">新</span>发明家（ <span class="string"><span class="delimiter">“</span> <span class="content">尼古拉特斯拉</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">塞尔维亚人</span> <span class="delimiter">”</span></span> ）; EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding（）。build（）; context.setVariable（ <span class="string"><span class="delimiter">“</span> <span class="content">newName</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Mike Tesla</span> <span class="delimiter">”</span></span> ）; parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Name = #newName</span> <span class="delimiter">”</span></span> ）。getValue（context，tesla）; <span class="predefined-type">System</span> .out.println（tesla.getName（）） <span class="comment">//“Mike Tesla”</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-this-root"><a class="anchor" href="#expressions-this-root"></a> <code>#this</code>和<code>#root</code>变量</h5>
<div class="paragraph">
<p>始终定义<code>#this</code>变量并引用当前评估对象（解析非限定引用）。始终定义<code>#root</code>变量并引用根上下文对象。虽然<code>#this</code>可能会随着表达式的组件的评估而变化，但<code>#root</code>始终引用根。以下示例显示了如何使用<code>#this</code>和<code>#root</code>变量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//创建一个整数数组</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">Integer</span> &gt; primes = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> &lt; <span class="predefined-type">Integer</span> &gt;（）; primes.addAll（ <span class="predefined-type">阵列</span> <span class="integer"><span class="integer"><span class="integer"><span class="integer"><span class="integer"><span class="integer"><span class="integer">.asList（2，3，5，7，11，13，17））;</span></span></span></span></span></span></span> <span class="comment">//创建解析器并将变量'primes'设置为整数数组</span> ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess（）; context.setVariable（ <span class="string"><span class="delimiter">“</span> <span class="content">primes</span> <span class="delimiter">”</span></span> ，primes）; <span class="comment">//列表中的所有素数&gt; 10（使用选择？{...}）</span>
<span class="comment">//求值为[</span> 11,13,17 <span class="comment">]</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">Integer</span> &gt; primesGreaterThanTen =（ <span class="predefined-type">List</span> &lt; <span class="predefined-type">Integer</span> &gt;）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">＃prames。？[#this&gt; 10]</span> <span class="delimiter">“</span></span> ）。getValue（context）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-functions"><a class="anchor" href="#expressions-ref-functions"></a> 4.3.11。功能</h4>
<div class="paragraph">
<p>您可以通过注册可在表达式字符串中调用的用户定义函数来扩展SpEL。该功能通过<code>EvaluationContext</code>注册。以下示例显示如何注册用户定义的函数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">方法</span>方法= ...; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding（）。build（）; context.setVariable（ <span class="string"><span class="delimiter">“</span> <span class="content">myFunction</span> <span class="delimiter">”</span></span> ，method）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，请考虑以下实用程序方法来反转字符串：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">StringUtils</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> reverseString（ <span class="predefined-type">String</span> input）{ <span class="predefined-type">StringBuilder</span> backwards = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span> （input.length（））; <span class="keyword">for</span> （ <span class="type">int</span> i = <span class="integer">0</span> ; i &lt;input.length（）; i ++）backwards.append（input.charAt（input.length（） - <span class="integer">1</span> -  i））; } <span class="keyword">return</span> backwards.toString（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以注册并使用上述方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding（）。build（）; context.setVariable（ <span class="string"><span class="delimiter">“</span> <span class="content">reverseString</span> <span class="delimiter">”</span></span> ，StringUtils.class.getDeclaredMethod（ <span class="string"><span class="delimiter">“</span> <span class="content">reverseString</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">String</span> .class））; <span class="predefined-type">String</span> helloWorldReversed = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">#reverseString（'hello'）</span> <span class="delimiter">”</span></span> ）。getValue（context， <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-bean-references"><a class="anchor" href="#expressions-bean-references"></a> 4.3.12。Bean参考</h4>
<div class="paragraph">
<p>如果已使用bean解析器配置了评估上下文，则可以使用<code>@</code>符号从表达式中查找bean。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext（）; context.setBeanResolver（ <span class="keyword">new</span> MyBeanResolver（））; <span class="comment">//在评估期间，这将最终在MyBeanResolver上调用resolve（context，“something”）</span> <span class="predefined-type">Object</span> bean = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">@ something</span> <span class="delimiter">”</span></span> ）。getValue（context）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要访问工厂bean本身，您应该在bean名称前加上<code>&amp;</code>符号。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext（）; context.setBeanResolver（ <span class="keyword">new</span> MyBeanResolver（））; <span class="comment">//这将最终在评估期间在MyBeanResolver上调用resolve（context，“＆foo”）</span> <span class="predefined-type">Object</span> bean = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">＆foo</span> <span class="delimiter">”</span></span> ）。getValue（context）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-ternary"><a class="anchor" href="#expressions-operator-ternary"></a> 4.3.13。三元运算符（If-Then-Else）</h4>
<div class="paragraph">
<p>您可以使用三元运算符在表达式中执行if-then-else条件逻辑。以下清单显示了一个最小的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> falseString = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">false？'trueExp'：'falseExp'</span> <span class="delimiter">“</span></span> ）。getValue（ <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，布尔值<code>false</code>会返回字符串值<code>'falseExp'</code> 。一个更现实的例子如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Name</span> <span class="delimiter">”</span></span> ）。setValue（societyContext， <span class="string"><span class="delimiter">“</span> <span class="content">IEEE</span> <span class="delimiter">”</span></span> ）; societyContext.setVariable（ <span class="string"><span class="delimiter">“</span> <span class="content">queryName</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Nikola Tesla</span> <span class="delimiter">”</span></span> ）; expression = <span class="string"><span class="delimiter">“</span> <span class="content">isMember（#queryName）？#queryName +“是的一个成员<span class="string"><span class="delimiter"><span class="delimiter">”“+”</span></span></span></span></span> <span class="string"><span class="content">+名称+“社会”：#queryName +“不是成员” +名称+“社会<span class="delimiter">”“;</span></span></span> <span class="predefined-type">字符串</span> queryResultString = parser.parseExpression（表达式）.getValue （societyContext， <span class="predefined-type">String</span> .class）; <span class="comment">// queryResultString =“Nikola Tesla是IEEE Society的成员”</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关三元运算符的更短语法，请参阅Elvis运算符的下一节。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-elvis"><a class="anchor" href="#expressions-operator-elvis"></a> 4.3.14。猫王运营商</h4>
<div class="paragraph">
<p>Elvis运算符是三元运算符语法的缩写，用于<a href="http://www.groovy-lang.org/operators.html#_elvis_operator">Groovy</a>语言。使用三元运算符语法，您通常必须重复两次变量，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="predefined-type">String</span> name = <span class="string"><span class="delimiter">“</span> <span class="content">Elvis Presley</span> <span class="delimiter">”</span></span> ; <span class="predefined-type">String</span> displayName =（名字！= <span class="predefined-constant">null</span> ？名称： <span class="string"><span class="delimiter">“</span> <span class="content">未知</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>相反，您可以使用Elvis运算符（以与Elvis的发型相似的名称命名）。以下示例显示如何使用Elvis运算符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; <span class="predefined-type">String</span> name = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">name？：'Unknown'</span> <span class="delimiter">”</span></span> ）。getValue（ <span class="predefined-type">String</span> .class）; <span class="predefined-type">System</span> .out.println（name）; <span class="comment">//'未知'</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下列表是一个更复杂的例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding（）。build（）;发明人特斯拉= <span class="keyword">新</span>发明家（ <span class="string"><span class="delimiter">“</span> <span class="content">尼古拉特斯拉</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">塞尔维亚人</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> name = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Name？：'Elvis Presley'</span> <span class="delimiter">”</span></span> ）。getValue（context，tesla， <span class="predefined-type">String</span> .class）; <span class="predefined-type">System</span> .out.println（name）; <span class="comment">// Nikola Tesla</span> tesla.setName（ <span class="predefined-constant">null</span> ）; name = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Name？：'Elvis Presley'</span> <span class="delimiter">”</span></span> ）。getValue（context，tesla， <span class="predefined-type">String</span> .class）; <span class="predefined-type">System</span> .out.println（name）; <span class="comment">// 埃尔维斯·普雷斯利</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用Elvis运算符在表达式中应用默认值。下面的示例演示了如何在<code>@Value</code>表达式中使用Elvis运算符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Value</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">＃{systemProperties ['pop3.port']？：25}</span> <span class="delimiter">”</span></span> ）</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果已定义，则将注入系统属性<code>pop3.port</code>否则注入25。</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-safe-navigation"><a class="anchor" href="#expressions-operator-safe-navigation"></a> 4.3.15。安全导航操作员</h4>
<div class="paragraph">
<p>安全导航操作符用于避免<code>NullPointerException</code>并且来自<a href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator">Groovy</a>语言。通常，在引用对象时，可能需要在访问对象的方法或属性之前验证它是否为null。为避免这种情况，安全导航操作符返回null而不是抛出异常。以下示例显示如何使用安全导航操作符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser（）; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding（）。build（）;发明人特斯拉= <span class="keyword">新</span>发明家（ <span class="string"><span class="delimiter">“</span> <span class="content">尼古拉特斯拉</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">塞尔维亚人</span> <span class="delimiter">”</span></span> ）; tesla.setPlaceOfBirth（ <span class="keyword">new</span> PlaceOfBirth（ <span class="string"><span class="delimiter">“</span> <span class="content">Smiljan</span> <span class="delimiter">”</span></span> ））; <span class="predefined-type">String</span> city = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">PlaceOfBirth？。City</span> <span class="delimiter">“</span></span> ）。getValue（context，tesla， <span class="predefined-type">String</span> .class）; <span class="predefined-type">System</span> .out.println（city）; <span class="comment">// Smiljan</span> tesla.setPlaceOfBirth（ <span class="predefined-constant">null</span> ）; city = parser.parseExpression（ <span class="string"><span class="delimiter">”</span> <span class="content">PlaceOfBirth？。City</span> <span class="delimiter">“</span></span> ）。getValue（context，tesla， <span class="predefined-type">String</span> .class）; <span class="predefined-type">System</span> .out.println（city）; <span class="comment">// null  - 不会抛出NullPointerException !!!</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-selection"><a class="anchor" href="#expressions-collection-selection"></a> 4.3.16。收藏选择</h4>
<div class="paragraph">
<p>Selection是一种功能强大的表达式语言功能，允许您通过从其条目中进行选择将源集合转换为另一个集合。</p>
</div>
<div class="paragraph">
<p>选择使用的语法为<code>.?[selectionExpression]</code>。它过滤集合并返回包含原始元素子集的新集合。例如，选择让我们可以轻松获得塞尔维亚发明家的列表，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">列表</span> &lt;Inventor&gt; list =（ <span class="predefined-type">List</span> &lt;Inventor&gt;）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Members。？[国籍=='塞尔维亚语']</span> <span class="delimiter">“</span></span> ）。getValue（societyContext）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以在列表和地图上进行选择。对于列表，将针对每个单独的列表元素评估选择标准。针对地图，针对每个地图条目（Java类型<code>Map.对象）评估选择标准<code>Map.Entry</code> ）。每个映射条目都可以将其键和值作为选项中使用的属性进行访问。</p>
</div>
<div class="paragraph">
<p>以下表达式返回一个新映射，该映射由原始映射中条目值小于27的那些元素组成：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">映射</span> newMap = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">map。？[value &lt;27]</span> <span class="delimiter">“</span></span> ）。getValue（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了返回所有选定元素外，您还可以只检索第一个或最后一个值。要获得与选择匹配的第一个条目，语法为<code>.^[selectionExpression]</code> 。要获得最后一个匹配选择，语法为<code>.$[selectionExpression]</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-projection"><a class="anchor" href="#expressions-collection-projection"></a> 4.3.17。收集投影</h4>
<div class="paragraph">
<p>投影允许集合驱动子表达式的评估，结果是新集合。投影的语法是<code>.![projectionExpression]</code>。例如，假设我们有一个发明者列表，但想要他们出生的城市列表。实际上，我们想要为发明人列表中的每个条目评估“placeOfBirth.city”。以下示例使用投影来执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//返回['Smiljan'，'Idvor']</span> <span class="predefined-type">列出</span> placesOfBirth =（ <span class="predefined-type">List</span> ）parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">Members。！[[placeOfBirth.city]</span> <span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用地图来驱动投影，在这种情况下，投影表达式将根据地图中的每个条目进行评估（表示为Java <code>Map.Entry</code> ）。跨地图投影的结果是一个列表，其中包含对每个地图条目的投影表达式的评估。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-templating"><a class="anchor" href="#expressions-templating"></a> 4.3.18。表达模板</h4>
<div class="paragraph">
<p>表达式模板允许将文本文本与一个或多个评估块混合。每个评估块都使用您可以定义的前缀和后缀字符分隔。一个常见的选择是使用<code>#{ }</code>作为分隔符，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">字符串</span> randomPhrase = parser.parseExpression（ <span class="string"><span class="delimiter">“</span> <span class="content">随机数是＃{T（java.lang。Math）.random（）}</span> <span class="delimiter">“</span></span> ， <span class="keyword">new</span> TemplateParserContext（））。getValue（ <span class="predefined-type">String</span> .class）; <span class="comment">//求值为”随机数为0.7038186818312008“</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过将文本文本<code>'random number is '</code>与评估<code>#{ }</code>分隔符内表达式的结果（在这种情况下，调用<code>random()</code>方法的结果<code>random()</code>连接来评估字符串。<code>parseExpression()</code>方法的第二个参数是<code>ParserContext</code>类型。<code>ParserContext</code>接口用于影响表达式的解析方式，以支持表达式模板功能。<code>TemplateParserContext</code>的定义如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TemplateParserContext</span> <span class="directive">实现</span> ParserContext { <span class="directive">public</span> <span class="predefined-type">String</span> getExpressionPrefix（）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">＃{</span> <span class="delimiter">”</span></span> ; <span class="directive">public</span> <span class="predefined-type">String</span> getExpressionSuffix（）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">}</span> <span class="delimiter">”</span></span> ; <span class="directive">public</span> <span class="type">boolean</span> isTemplate（）{ <span class="keyword">return</span> <span class="predefined-constant">true</span> ; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-example-classes"><a class="anchor" href="#expressions-example-classes"></a> 4.4。示例中使用的类</h3>
<div class="paragraph">
<p>本节列出了本章示例中使用的类。</p>
</div>
<div class="exampleblock">
<div class="title">例1。Inventor.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span> ; <span class="keyword">import</span> <span class="include">java.util。日期</span> ; <span class="keyword">import</span> <span class="include">java.util。GregorianCalendar</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Inventor</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="predefined-type">弦乐</span>国籍; <span class="directive">private</span> <span class="predefined-type">String</span> <span class="type">[]</span>发明; <span class="directive">私人</span> <span class="predefined-type">日期</span>出生日期; <span class="directive">私人</span> PlaceOfBirth placeOfBirth; <span class="directive">public</span> Inventor（ <span class="predefined-type">String</span> name， <span class="predefined-type">String</span> nationality）{ <span class="predefined-type">GregorianCalendar</span> c = <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span> （）; <span class="local-variable">这个</span> .name =名字; <span class="local-variable">这个</span> .nationality =国籍; <span class="local-variable">这个</span> .birthdate = c.getTime（）; <span class="directive">public</span> Inventor（ <span class="predefined-type">String</span> name， <span class="predefined-type">Date</span> birthdate， <span class="predefined-type">String</span> nationality）{ <span class="local-variable">this</span> .name = name; <span class="local-variable">这个</span> .nationality =国籍; <span class="local-variable">这个</span> .birthdate = birthdate; <span class="directive">public</span> Inventor（）{} <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> name; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> <span class="predefined-type">String</span> getNationality（）{ <span class="keyword">return</span> nationality; <span class="directive">public</span> <span class="type">void</span> setNationality（ <span class="predefined-type">String</span> nationality）{ <span class="local-variable">this</span> .nationality = nationality; } <span class="directive">公共</span> <span class="predefined-type">日期</span> getBirthdate（）{ <span class="keyword">回报</span>的出生日期; <span class="directive">public</span> <span class="type">void</span> setBirthdate（ <span class="predefined-type">Date</span> birthdate）{ <span class="local-variable">this</span> .birthdate = birthdate; <span class="directive">public</span> PlaceOfBirth getPlaceOfBirth（）{ <span class="keyword">return</span> placeOfBirth; } <span class="directive">public</span> <span class="type">void</span> setPlaceOfBirth（PlaceOfBirth placeOfBirth）{ <span class="local-variable">this</span> .placeOfBirth = placeOfBirth; <span class="directive">public</span> <span class="type">void</span> setInventions（ <span class="predefined-type">String</span> <span class="type">[]</span> inventions）{ <span class="local-variable">this</span> .inventions = inventions; <span class="directive">public</span> <span class="predefined-type">String</span> <span class="type">[]</span> getInventions（）{ <span class="keyword">return</span> inventions; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例2。PlaceOfBirth.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">PlaceOfBirth</span> { <span class="directive">private</span> <span class="predefined-type">String</span> city; <span class="directive">私人</span> <span class="predefined-type">字符串</span>国家; <span class="directive">public</span> PlaceOfBirth（ <span class="predefined-type">String</span> city）{ <span class="local-variable">this</span> .city = city; <span class="directive">public</span> PlaceOfBirth（ <span class="predefined-type">String</span> city， <span class="predefined-type">String</span> country）{ <span class="local-variable">this</span> （city）; <span class="local-variable">这个</span> .country = country; <span class="directive">public</span> <span class="predefined-type">String</span> getCity（）{ <span class="keyword">return</span> city; <span class="directive">public</span> <span class="type">void</span> setCity（ <span class="predefined-type">String</span> s）{ <span class="local-variable">this</span> .city = s; <span class="directive">public</span> <span class="predefined-type">String</span> getCountry（）{ <span class="keyword">return</span> country; <span class="directive">public</span> <span class="type">void</span> setCountry（ <span class="predefined-type">String</span> country）{ <span class="local-variable">this</span> .country = country; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例3。Society.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span> ; <span class="keyword">import</span> <span class="include">java.util</span> 。*; <span class="directive">公共</span> <span class="type">阶级</span> <span class="class">社会</span> { <span class="directive">私人</span> <span class="predefined-type">字符串</span>名称; <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> Advisors = <span class="string"><span class="delimiter">“</span> <span class="content">顾问</span> <span class="delimiter">”</span></span> ; <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> President = <span class="string"><span class="delimiter">“</span> <span class="content">总统</span> <span class="delimiter">”</span></span> ; <span class="directive">private</span> <span class="predefined-type">List</span> &lt;Inventor&gt; members = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> &lt;Inventor&gt;（）; <span class="directive">私人</span> <span class="predefined-type">地图</span>官员= <span class="keyword">新</span> <span class="predefined-type">HashMap</span> （）; <span class="directive">public</span> <span class="predefined-type">List</span> getMembers（）{ <span class="keyword">return</span> members; <span class="directive">public</span> <span class="predefined-type">map</span> getOfficers（）{ <span class="keyword">return</span> officer; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> name; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> <span class="type">boolean</span> isMember（ <span class="predefined-type">String</span> name）{ <span class="keyword">for</span> （Inventor inventor：members）{ <span class="keyword">if</span> （inventor.getName（）。equals（name））{ <span class="keyword">return</span> <span class="predefined-constant">true</span> ; <span class="keyword">返回</span> <span class="predefined-constant">false</span> ; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop"><a class="anchor" href="#aop"></a> 5。面向方面的Spring编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>面向方面编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象编程（OOP）。OOP中模块化的关键单元是类，而在AOP中，模块化单元是方面。方面实现了跨越多种类型和对象的关注点（例如事务管理）的模块化。（这些担忧在AOP文献中通常被称为“横切”问题。）</p>
</div>
<div class="paragraph">
<p>Spring的一个关键组件是AOP框架。虽然Spring IoC容器不依赖于AOP（意味着如果您不想使用AOP，则不需要使用AOP），AOP补充了Spring IoC，以提供非常强大的中间件解决方案。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Spring 2.0+ AOP</div>
<div class="paragraph">
<p>Spring 2.0引入了一种更简单，更强大的方法来编写自定义方面，使用<a href="#aop-schema">基于模式的方法</a>或<a href="#aop-ataspectj">@AspectJ注释样式</a> 。这两种样式都提供完全类型的建议和使用AspectJ切入点语言，同时仍然使用Spring AOP进行编织。</p>
</div>
<div class="paragraph">
<p>本章讨论Spring 2.0+模式和基于@ AspectJ的AOP支持。<a href="#aop-api">下一章</a>将讨论较低级别的AOP支持，如Spring 1.2应用程序中常见的那样。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>AOP在Spring Framework中用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供声明性企业服务，尤其是作为EJB声明性服务的替代品。最重要的此类服务是<a href="#transaction-declarative">声明式事务管理</a> 。</p>
</li>
<li>
<p>让用户实现自定义方面，补充他们使用AOP的OOP。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您只对通用声明性服务或其他预先打包的声明性中间件服务（如池）感兴趣，则无需直接使用Spring AOP，并且可以跳过本章的大部分内容。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="aop-introduction-defn"><a class="anchor" href="#aop-introduction-defn"></a> 5.1。AOP概念</h3>
<div class="paragraph">
<p>让我们从定义一些中心AOP概念和术语开始。这些术语不是特定于Spring的。不幸的是，AOP术语不是特别直观。但是，如果Spring使用自己的术语，那将更加令人困惑。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方面：跨越多个类别的关注点的模块化。事务管理是企业Java应用程序中横切关注点的一个很好的例子。在Spring AOP中，方面是通过使用常规类（ <a href="#aop-schema">基于模式的方法</a> ）或使用<code>@Aspect</code>注释（ <a href="#aop-ataspectj">@AspectJ样式</a> ）注释的常规类来实现的。</p>
</li>
<li>
<p>加入点：程序执行期间的一个点，例如执行方法或处理异常。在Spring AOP中，连接点始终表示方法执行。</p>
</li>
<li>
<p>建议：某个方面在特定连接点采取的操作。不同类型的建议包括“周围”，“之前”和“之后”建议。（建议类型将在后面讨论。）许多AOP框架（包括Spring）将建议建模为拦截器，并在连接点周围维护一系列拦截器。</p>
</li>
<li>
<p>切入点：匹配连接点的谓词。建议与切入点表达式相关联，并在切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。由切入点表达式匹配的连接点的概念是AOP的核心，而Spring默认使用AspectJ切入点表达式语言。</p>
</li>
<li>
<p>简介：代表类型声明其他方法或字段。Spring AOP允许您向任何建议的对象引入新接口（和相应的实现）。例如，您可以使用简介使bean实现<code>IsModified</code>接口，以简化缓存。（引言在AspectJ社区中称为类型间声明。）</p>
</li>
<li>
<p>目标对象：由一个或多个方面建议的对象。也称为“建议对象”。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。</p>
</li>
<li>
<p>AOP代理：由AOP框架创建的对象，用于实现方面契约（建议方法执行等）。在Spring Framework中，AOP代理是JDK动态代理或CGLIB代理。</p>
</li>
<li>
<p>编织：将方面与其他应用程序类型或对象链接以创建建议对象。这可以在编译时（例如使用AspectJ编译器），加载时间或在运行时完成。与其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring AOP包含以下类型的建议：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>建议之前：在连接点之前运行但无法阻止执行流程进入连接点的建议（除非它引发异常）。</p>
</li>
<li>
<p>返回建议后：在连接点正常完成后运行的建议（例如，如果方法返回而不抛出异常）。</p>
</li>
<li>
<p>抛出建议后：如果方法通过抛出异常退出，则执行建议。</p>
</li>
<li>
<p>在（最终）建议之后：无论连接点退出的方式（正常或异常返回），都要执行建议。</p>
</li>
<li>
<p>围绕建议：围绕连接点的建议，例如方法调用。这是最有力的建议。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>围绕建议是最一般的建议。由于Spring AOP（如AspectJ）提供了全方位的建议类型，因此我们建议您使用可以实现所需行为的最不强大的建议类型。例如，如果您只需要使用方法的返回值更新缓存，那么最好在实现返回后的建议而不是周围的建议，尽管周围的建议可以完成同样的事情。使用最具体的建议类型可以提供更简单的编程模型，减少错误的可能性。例如，您不需要在用于around建议的<code>JoinPoint</code>上调用<code>proceed()</code>方法，因此，您无法调用它。</p>
</div>
<div class="paragraph">
<p>在Spring 2.0中，所有通知参数都是静态类型的，因此您可以使用相应类型的通知参数（例如，方法执行的返回值的类型）而不是<code>Object</code>数组。</p>
</div>
<div class="paragraph">
<p>由切入点匹配的连接点的概念是AOP的关键，它将其与仅提供拦截的旧技术区分开来。切入点使得建议可以独立于面向对象的层次结构进行定向。例如，您可以将一个提供声明式事务管理的建议应用于跨多个对象（例如服务层中的所有业务操作）的一组方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-introduction-spring-defn"><a class="anchor" href="#aop-introduction-spring-defn"></a> 5.2。Spring AOP功能和目标</h3>
<div class="paragraph">
<p>Spring AOP是用纯Java实现的。不需要特殊的编译过程。Spring AOP不需要控制类加载器层次结构，因此适合在servlet容器或应用程序服务器中使用。</p>
</div>
<div class="paragraph">
<p>Spring AOP目前仅支持方法执行连接点（建议在Spring bean上执行方法）。虽然可以在不破坏核心Spring AOP API的情况下添加对字段拦截的支持，但未实现字段拦截。如果您需要建议字段访问和更新连接点，请考虑使用AspectJ等语言。</p>
</div>
<div class="paragraph">
<p>Spring AOP的AOP方法与大多数其他AOP框架的方法不同。目的不是提供最完整的AOP实现（尽管Spring AOP非常强大）。相反，目标是在AOP实现和Spring IoC之间提供紧密集成，以帮助解决企业应用程序中的常见问题。</p>
</div>
<div class="paragraph">
<p>因此，例如，Spring Framework的AOP功能通常与Spring IoC容器一起使用。通过使用普通bean定义语法来配置方面（尽管这允许强大的“自动代理”功能）。这是与其他AOP实现的重要区别。使用Spring AOP无法轻松或高效地完成某些操作，例如建议非常细粒度的对象（通常是域对象）。在这种情况下，AspectJ是最佳选择。但是，我们的经验是，Spring AOP为适合AOP的企业Java应用程序中的大多数问题提供了出色的解决方案。</p>
</div>
<div class="paragraph">
<p>Spring AOP从未努力与AspectJ竞争，以提供全面的AOP解决方案。我们相信，基于代理的框架（如Spring AOP）和完整的框架（如AspectJ）都很有价值，而且它们是互补的，而不是竞争。Spring将Spring AOP和IoC与AspectJ无缝集成，以在一致的基于Spring的应用程序架构中实现AOP的所有使用。此集成不会影响Spring AOP API或AOP Alliance API。 Spring AOP仍然向后兼容。有关Spring AOP API的讨论，请参阅<a href="#aop-api">以下章节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring框架的核心原则之一是非侵入性。这是一个想法，您不应该被迫在您的业务或域模型中引入特定于框架的类和接口。但是，在某些地方，Spring Framework确实为您提供了将Spring Framework特定的依赖项引入代码库的选项。为您提供此类选项的基本原理是，在某些情况下，以这种方式阅读或编写某些特定功能可能更容易。但是，Spring Framework（几乎）总是为您提供选择：您可以自由决定哪种选项最适合您的特定用例或场景。</p>
</div>
<div class="paragraph">
<p>与本章相关的一个选择是选择哪种AOP框架（以及哪种AOP样式）。您可以选择AspectJ，Spring AOP或两者。您还可以选择@AspectJ注释样式方法或Spring XML配置样式方法。本章首先选择引入@ AspectJ风格的方法，这一事实不应被视为Spring团队倾向于采用Spring XML配置风格的@AspectJ注释风格方法。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#aop-choosing">选择要使用的AOP声明样式</a> ，以更全面地讨论每种样式的“为什么和如何进行”。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-introduction-proxies"><a class="anchor" href="#aop-introduction-proxies"></a> 5.3。AOP代理</h3>
<div class="paragraph">
<p>Spring AOP默认使用AOP代理的标准JDK动态代理。这使得任何接口（或接口集）都可以被代理。</p>
</div>
<div class="paragraph">
<p>Spring AOP也可以使用CGLIB代理。这是代理类而不是接口所必需的。默认情况下，如果业务对象未实现接口，则使用CGLIB。由于优化的做法是编程接口而不是类，业务类通常实现一个或多个业务接口。可以<a href="#aop-proxying">强制使用CGLIB</a> ，在那些需要建议未在接口上声明的方法或需要将代理对象作为具体类型传递给方法的情况下（希望很少见）。</p>
</div>
<div class="paragraph">
<p>掌握Spring AOP是基于代理的这一事实非常重要。请参阅<a href="#aop-understanding-aop-proxies">了解AOP代理</a> ，以全面了解此实现细节的实际含义。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj"><a class="anchor" href="#aop-ataspectj"></a> 5.4。@AspectJ支持</h3>
<div class="paragraph">
<p>@AspectJ指的是将方面声明为使用注释注释的常规Java类的样式。作为AspectJ 5版本的一部分， <a href="http://www.eclipse.org/aspectj">AspectJ项目</a>引入了@AspectJ样式。Spring使用AspectJ提供的库来解释与AspectJ 5相同的注释，用于切入点解析和匹配。但是，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ编译器或weaver。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用AspectJ编译器和weaver可以使用完整的AspectJ语言，并在<a href="#aop-using-aspectj">使用AspectJ和Spring Applications中进行</a>了讨论。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-aspectj-support"><a class="anchor" href="#aop-aspectj-support"></a> 5.4.1。启用@AspectJ支持</h4>
<div class="paragraph">
<p>要在Spring配置中使用@AspectJ方面，您需要启用Spring支持，以根据@AspectJ方面配置Spring AOP，并根据这些方面是否建议自动代理bean。通过自动代理，我们的意思是，如果Spring确定bean被一个或多个方面建议，它会自动为该bean生成一个代理来拦截方法调用，并确保根据需要执行建议。</p>
</div>
<div class="paragraph">
<p>可以使用XML或Java样式配置启用@AspectJ支持。在任何一种情况下，您还需要确保AspectJ的<code>aspectjweaver.jar</code>库位于应用程序的类路径中（版本1.8或更高版本）。此库可在AspectJ分发的<code>lib</code>目录中或Maven Central存储库中找到。</p>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-java"><a class="anchor" href="#aop-enable-aspectj-java"></a>使用Java配置启用@AspectJ支持</h5>
<div class="paragraph">
<p>要使用Java <code>@Configuration</code>启用@AspectJ支持，请添加<code>@EnableAspectJAutoProxy</code>注释，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableAspectJAutoProxy</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-xml"><a class="anchor" href="#aop-enable-aspectj-xml"></a>使用XML配置启用@AspectJ支持</h5>
<div class="paragraph">
<p>要使用基于XML的配置启用@AspectJ支持，请使用<code>aop:aspectj-autoproxy</code>元素，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspectj-autoproxy</span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这假设您使用<a href="#xsd-schemas">基于XML架构的配置中</a>描述的架构支持。有关如何在<code>aop</code>命名空间中导入标记，请参阅<a href="#xsd-schemas-aop">AOP架构</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-at-aspectj"><a class="anchor" href="#aop-at-aspectj"></a> 5.4.2。声明一个方面</h4>
<div class="paragraph">
<p>在启用了@AspectJ支持的情况下，在应用程序上下文中定义的任何bean都具有@AspectJ方面的类（具有<code>@Aspect</code>注释），S​​pring会自动检测并用于配置Spring AOP。接下来的两个示例显示了非常有用的方面所需的最小定义。</p>
</div>
<div class="paragraph">
<p>这两个示例中的第一个示例在应用程序上下文中显示了一个常规bean定义，该定义指向具有<code>@Aspect</code>批注的bean类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myAspect</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.xyz。NotVeryUsefulAspect</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 在这里配置方面的属性 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这两个示例中的第二个显示了<code>NotVeryUsefulAspect</code>类定义，该定义使用<code>org.aspectj.lang.annotation.Aspect</code>注释;</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.xyz</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">NotVeryUsefulAspect</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>方面（使用<code>@Aspect</code>注释的类）可以包含方法和字段，与任何其他类相同。它们还可以包含切入点，建议和引入（类型间）声明。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">通过组件扫描自动检测方面</div>您可以在Spring XML配置中将方面类注册为常规bean，或者通过类路径扫描自动检测它们 - 与任何其他Spring管理的bean相同。但是，请注意<code>@Aspect</code>注释不足以在类路径中进行自动检测。为此，您需要添加一个单独的<code>@Component</code>注释（或者，根据Spring的组件扫描程序的规则，可以使用符合条件的自定义构造型注释）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">与其他方面的方面建议？</div>在Spring AOP中，方面本身不能成为其他方面建议的目标。类上的<code>@Aspect</code>注释将其标记为方面，因此将其从自动代理中排除。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts"><a class="anchor" href="#aop-pointcuts"></a> 5.4.3。声明切入点</h4>
<div class="paragraph">
<p>切入点确定感兴趣的连接点，从而使我们能够控制建议何时执行。Spring AOP仅支持Spring bean的方法执行连接点，因此您可以将切入点视为匹配Spring bean上方法的执行。切入点声明有两个部分：一个包含名称和任何参数的签名以及一个切入点表达式，它确切地确定了我们感兴趣的方法执行。在AOP的@AspectJ注释样式中，切入点签名由常规方法定义提供，切入点表达式通过使用<code>@Pointcut</code>注释指示（用作切入点签名的方法必须具有<code>void</code>返回类型）。</p>
</div>
<div class="paragraph">
<p>一个示例可以帮助区分切入点签名和切入点表达式。以下示例定义名为<code>anyOldTransfer</code>的切入点，该切入点与名为<code>transfer</code>的任何方法的执行相匹配：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">execution（* transfer（..））</span> <span class="delimiter">”</span></span> ） <span class="comment">//切入点表达式</span> <span class="directive">private</span> <span class="type">void</span> anyOldTransfer（）{} <span class="comment">//切入点签名</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>形成<code>@Pointcut</code>注释值的切入点表达式是常规的AspectJ 5切入点表达式。有关AspectJ的切入点语言的完整讨论，请参阅<a href="http://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ编程指南</a> （以及，对于扩展， <a href="http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5开发人员的笔记本</a> ）或AspectJ上的一本书（例如<em>Eclipse AspectJ</em> ，Colyer等人，或<em>AspectJ in Action）</em> ，作者：Ramnivas Laddad）。</p>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-designators"><a class="anchor" href="#aop-pointcuts-designators"></a>支持的切入点指示符</h5>
<div class="paragraph">
<p>Spring AOP支持以下AspectJ切入点指示符（PCD）用于切入点表达式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>execution</code> ：用于匹配方法执行连接点。这是使用Spring AOP时使用的主要切入点指示符。</p>
</li>
<li>
<p><code>within</code> ：限制匹配某些类型中的连接点（使用Spring AOP时在匹配类型中声明的方法的执行）。</p>
</li>
<li>
<p><code>this</code> ：限制匹配连接点（使用Spring AOP时执行方法），其中bean引用（Spring AOP代理）是给定类型的实例。</p>
</li>
<li>
<p><code>target</code> ：限制与连接点的匹配（使用Spring AOP时执行方法），其中目标对象（被代理的应用程序对象）是给定类型的实例。</p>
</li>
<li>
<p><code>args</code> ：限制与连接点的匹配（使用Spring AOP时执行方法），其中参数是给定类型的实例。</p>
</li>
<li>
<p><code>@target</code> ：限制与连接点的匹配（使用Spring AOP时执行方法），其中执行对象的类具有给定类型的注释。</p>
</li>
<li>
<p><code>@args</code> ：限制与连接点的匹配（使用Spring AOP时执行方法），其中传递的实际参数的运行时类型具有给定类型的注释。</p>
</li>
<li>
<p><code>@within</code> ：限制匹配到具有给定注释的类型中的连接点（使用Spring AOP时在具有给定注释的类型中声明的方法的执行）。</p>
</li>
<li>
<p><code>@annotation</code> ：限制连接点的匹配，其中连接点的主题（在Spring AOP中执行的方法）具有给定的注释。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">其他切入点类型</div>
<div class="paragraph">
<p>完整的AspectJ切入点语言支持未在Spring支持额外的切入点指示符： <code>call</code> ， <code>get</code> ， <code>set</code> ， <code>preinitialization</code> ， <code>staticinitialization</code> ， <code>initialization</code> ， <code>handler</code> ， <code>adviceexecution</code> ， <code>withincode</code> ， <code>cflow</code> ， <code>cflowbelow</code> ， <code>if</code> ， <code>@this</code>和<code>@withincode</code> 。在Spring AOP解释的切入点表达式中使用这些切入点指示符会导致抛出<code>IllegalArgumentException</code> 。</p>
</div>
<div class="paragraph">
<p>Spring AOP支持的切入点指示符集可以在将来的版本中进行扩展，以支持更多的AspectJ切入点指示符。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>由于Spring AOP仅限制与方法执行连接点的匹配，因此前面对切入点指示符的讨论给出了比在AspectJ编程指南中找到的更窄的定义。此外，AspectJ本身具有基于类型的语义，并且在执行连接点， <code>this</code>和<code>target</code>引用相同的对象：执行该方法的对象。Spring AOP是一个基于代理的系统，它区分代理对象本身（绑定<code>this</code> ）和代理后面的目标对象（绑定到<code>target</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于Spring的AOP框架基于代理的特性，根据定义，目标对象内的调用不会被截获。对于JDK代理，只能拦截代理上的公共接口方法调用。使用CGLIB，代理上的公共和受保护方法调用被截获（如果需要，甚至是包可见的方法）。但是，通过代理进行的常见交互应始终通过公共签名进行设计。</p>
</div>
<div class="paragraph">
<p>请注意，切入点定义通常与任何截获的方法匹配。如果切入点严格意义上是公开的，即使在通过代理进行潜在非公共交互的CGLIB代理方案中，也需要相应地定义切入点。</p>
</div>
<div class="paragraph">
<p>如果您的拦截需要包括目标类中的方法调用甚至构造函数，请考虑使用Spring驱动的<a href="#aop-aj-ltw">本机AspectJ编织</a>而不是Spring的基于代理的AOP框架。这构成了具有不同特征的不同AOP使用模式，因此在做出决定之前一定要熟悉编织。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring AOP还支持另一个名为<code>bean</code> PCD。此PCD允许您将连接点的匹配限制为特定的命名Spring bean或一组命名的Spring bean（使用通配符时）。<code>bean</code> PCD具有以下形式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">豆（idOrNameOfBean）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>idOrNameOfBean</code>标记可以是任何Spring bean的名称。提供了使用<code>*</code>字符的有限通配符支持，因此，如果为Spring bean建立了一些命名约定，则可以编写<code>bean</code> PCD表达式来选择它们。与其他切入点指示符的情况一样， <code>bean</code> PCD可以与<code>&amp;&amp;</code> （和）， <code>||</code> （或），和<code>!</code> （否定）运营商。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>bean</code> PCD仅在Spring AOP中受支持，而在本机AspectJ编织中不受支持。它是AspectJ定义的标准PCD的Spring特定扩展，因此不适用于<code>@Aspect</code>模型中声明的方面。</p>
</div>
<div class="paragraph">
<p><code>bean</code> PCD在实例级别（基于Spring bean名称概念）而不是仅在类型级别（基于编织的AOP受限）上运行。基于实例的切入点指示符是Spring基于代理的AOP框架的一种特殊功能，它与Spring bean工厂紧密集成，通过名称可以自然而直接地识别特定的bean。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-combining"><a class="anchor" href="#aop-pointcuts-combining"></a>结合Pointcut表达式</h5>
<div class="paragraph">
<p>您可以使用<code>&amp;&amp;,</code> <code>||</code>组合切入点表达式而且<code>!</code> 。您还可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">execution（public * *（..））</span> <span class="delimiter">”</span></span> <span class="directive">private</span> <span class="type">void</span> anyPublicOperation（）{} <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">within（com.xyz.someapp.trading .. *）</span> <span class="delimiter">”</span></span> ） <span class="directive">private</span> <span class="type">void</span> inTrading（）{} <i class="conum" data-value="2"></i> <b>（2）</b> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">anyPublicOperation（）&amp;&amp; inTrading（）</span> <span class="delimiter">”</span></span> ） <span class="directive">private</span> <span class="type">void</span> tradingOperation（）{} <i class="conum" data-value="3"></i> <b>（3）</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>如果方法执行连接点表示任何公共方法的执行，则<code>anyPublicOperation</code>匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果方法执行在交易模块中，则<code>inTrading</code>匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果方法执行表示交易模块中的任何公共方法，则<code>tradingOperation</code>匹配。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如前所示，最好从较小的命名组件构建更复杂的切入点表达式。当按名称引用切入点时，将应用常规Java可见性规则（您可以看到相同类型的私有切入点，层次结构中的受保护切入点，任何位置的公共切入点等）。可见性不会影响切入点匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-common-pointcuts"><a class="anchor" href="#aop-common-pointcuts"></a>共享公共切入点定义</h5>
<div class="paragraph">
<p>在使用企业应用程序时，开发人员通常希望从几个方面引用应用程序的模块和特定的操作集。我们建议定义一个“SystemArchitecture”方面，为此目的捕获常见的切入点表达式。这样的方面通常类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.xyz.someapp</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。切入点</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SystemArchitecture</span> { <span class="comment">/ ** *如果方法是在com.xyz.someapp.web包中的类型或其下的任何子包*中定义的，则连接点位于Web层中。* /</span> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">within（com.xyz.someapp.web .. *）</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> inWebLayer（）{} <span class="comment">/ ** *如果方法是在类型中定义的，则连接点在服务层中com.xyz.someapp.service包或其下的任何子包*。* /</span> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">within（com.xyz.someapp.service .. *）</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> inServiceLayer（）{} <span class="comment">/ ** *如果在类型中定义了*，则连接点位于数据访问层中在com.xyz.someapp.dao包或其下的任何子包*。* /</span> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">within（com.xyz.someapp.dao .. *）</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> inDataAccessLayer（）{} <span class="comment">/ ** *业务服务是在service *接口上定义的任何方法的执行。该定义假定接口放在*“service”包中，并且实现类型在子包中。* *如果按功能区域对服务接口进行分组（例如，*包com.xyz.someapp.abc.service和com.xyz.someapp.def.service），则*切入点表达式“execution（* com.xyz。 someapp..service。*。*（..））“*可以代替使用。* *或者，您可以使用'bean'* PCD编写表达式，如“bean（* Service）”。（这假设您以一致的方式命名了您的Spring服务bean。）* /</span> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.someapp..service。*。*（..））</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> businessService（）{} <span class="comment">/ ** *数据访问操作是在* dao接口上定义的任何方法的执行。该定义假定接口放在*“dao”包中，并且实现类型在子包中。* /</span> <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.someapp.dao。*。*（..））</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> dataAccessOperation（）{}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在需要切入点表达式的任何位置引用此类方面中定义的切入点。例如，要使服务层具有事务性，您可以编写以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">pointcut</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.someapp。SystemArchitecture.businessService（）</span> <span class="delimiter">“</span></span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tx-advice</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tx-advice</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">*</span> <span class="delimiter">“</span></span> <span class="attribute-name">propagation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">REQUIRED</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>&lt;aop:config&gt;</code>和<code>&lt;aop:advisor&gt;</code>元素在<a href="#aop-schema">[aop-schema]</a>中讨论。<a href="data-access.html#transaction">事务管理</a>中讨论了<a href="data-access.html#transaction">事务</a>元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-examples"><a class="anchor" href="#aop-pointcuts-examples"></a>例子</h5>
<div class="paragraph">
<p>Spring AOP用户可能最常使用<code>execution</code>切入点指示符。执行表达式的格式如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">执行（改性剂图案？ret-type-pattern声明型模式？name-pattern（param-pattern） <span class="directive">throws</span> -pattern？）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除返回类型模式（前面代码片段中的<code>ret-type-pattern</code> ），名称模式和参数模式之外的所有部分都是可选的。返回类型模式确定方法的返回类型必须是什么才能匹配连接点。
<code>*</code>最常用作返回类型模式。它匹配任何返回类型。仅当方法返回给定类型时，完全限定类型名称才匹配。名称模式与方法名称匹配。您可以使用<code>*</code>通配符作为名称模式的全部或部分。如果指定声明类型模式，请包含尾随<code>.</code>将它加入名称模式组件。参数模式稍微复杂一些:( <code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任何数量（零个或多个）参数。<code>(*)</code>模式匹配采用任何类型的一个参数的方法。
<code>(*,String)</code>匹配一个带两个参数的方法。第一个可以是任何类型，而第二个必须是<code>String</code> 。有关更多信息，请参阅AspectJ编程指南的<a href="http://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义</a>部分。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一些常见的切入点表达式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>执行任何公共方法：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">执行（ <span class="directive">公共</span> * *（..））</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>执行名称以<code>set</code>开头的任何方法：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">执行（* set *（..））</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>执行<code>AccountService</code>接口定义的任何方法：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">执行（* com.xyz.service。帐户服务。*（..））</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>执行<code>service</code>包中定义的任何方法：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">执行（* com.xyz.service。*。*（..））</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>执行服务包或其子包中定义的任何方法：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">执行（* com.xyz.service ..*。*（..））</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>服务包中的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">内（com.xyz.service。*）</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>服务包或其子包中的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">内（com.xyz.service ..*）</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>代理实现<code>AccountService</code>接口的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">这个</span> （com.xyz.service。帐户服务）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">'this'更常用于绑定形式。请参阅有关如何在建议体中提供代理对象的<a href="#aop-advice">声明建议</a>部分。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>目标对象实现<code>AccountService</code>接口的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">目标（com.xyz.service。帐户服务）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">'target'更常用于绑定形式。有关如何在建议体中提供目标对象的信息，请参阅<a href="#aop-advice">声明建议</a>部分。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>采用单个参数的任何连接点（仅在Spring AOP中执行的方法）以及在运行时传递的参数是<code>Serializable</code> ：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ARGS（java.io。序列化）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">'args'更常用于绑定形式。请参阅<a href="#aop-advice">声明建议</a>部分，了解如何在建议体中提供方法参数。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请注意，此示例中给出的切入点与<code>execution(* *(java.io.不同<code>execution(* *(java.io.Serializable))</code> 。如果在运行时传递的参数是<code>Serializable</code> ，则args版本匹配，如果方法签名声明了<code>Serializable</code>类型的单个参数，则执行版本匹配。</p>
</div>
</li>
<li>
<p>目标对象具有<code>@Transactional</code>注释的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@target</span> （org.springframework.transaction.annotation。事务）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以在绑定表单中使用“@target”。有关如何在建议体中提供注释对象的信息，请参阅“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>任何连接点（仅在Spring AOP中执行方法），其中目标对象的声明类型具有<code>@Transactional</code>注释：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@within</span> （org.springframework.transaction.annotation。事务）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以在绑定表单中使用“@within”。有关如何在建议体中提供注释对象的信息，请参阅“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>任何连接点（仅在Spring AOP中执行的方法），其中执行方法具有<code>@Transactional</code>注释：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@annotation</span> （org.springframework.transaction.annotation。事务）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以在绑定表单中使用“@annotation”。有关如何在建议体中提供注释对象的信息，请参阅“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>任何连接点（仅在Spring AOP中执行的方法），它接受一个参数，并且传递的参数的运行时类型具有<code>@Classified</code>注释：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@args</span> （com.xyz.security。分类）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以在绑定表单中使用“@args”。请参阅“ <a href="#aop-advice">声明建议”</a>部分，了解如何在建议体中提供注释对象。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>名为<code>tradeService</code>的Spring bean上的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">豆（tradeService）</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Spring bean上的任何连接点（仅在Spring AOP中执行方法），其名称与通配符表达式<code>*Service</code>匹配：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">豆（*服务）</code></pre>
</div>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="writing-good-pointcuts"><a class="anchor" href="#writing-good-pointcuts"></a>写好切入点</h5>
<div class="paragraph">
<p>在编译期间，AspectJ处理切入点以优化匹配性能。检查代码并确定每个连接点是否（静态地或动态地）匹配给定切入点是一个代价高昂的过程。（动态匹配意味着无法通过静态分析完全确定匹配，并且在代码中放置测试以确定代码运行时是否存在实际匹配）。在第一次遇到切入点声明时，AspectJ会将其重写为匹配过程的最佳形式。这是什么意思？基本上，切入点在DNF（析取范式）中重写，并且切入点的组件被排序，以便首先检查那些评估更便宜的组件。这意味着您不必担心了解各种切入点指示符的性能，并且可以在切入点声明中以任何顺序提供它们。</p>
</div>
<div class="paragraph">
<p>但是，AspectJ只能使用它所说的内容。为了获得最佳的匹配性能，您应该考虑他们想要实现的目标，并在定义中尽可能缩小匹配的搜索空间。现有的指示符自然分为三组：kinded，scoping和contextual：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kinded指示符选择一种特定的连接点： <code>execution</code> ， <code>get</code> ， <code>set</code> ， <code>call</code>和<code>handler</code> 。</p>
</li>
<li>
<p>作用域代号选择一组（可能是多种）感兴趣的连接点： <code>within</code>和<code>withincode</code></p>
</li>
<li>
<p>上下文指示符基于上下文匹配（并且可选地绑定）： <code>this</code> ， <code>target</code>和<code>@annotation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个写得很好的切入点应该至少包括前两种类型（kinded和scoping）。您可以根据连接点上下文包含上下文指示符以进行匹配，或者绑定该上下文以在建议中使用。由于额外的处理和分析，仅提供一个kinded指示符或仅提供上下文指示符，但可能会影响编织性能（使用的时间和内存）。范围界定指示符非常快速匹配，使用它们意味着AspectJ可以非常快速地解除不应该进一步处理的连接点组。如果可能的话，一个好的切入点应始终包括一个。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice"><a class="anchor" href="#aop-advice"></a> 5.4.4。宣布建议</h4>
<div class="paragraph">
<p>建议与切入点表达式相关联，并在切入点匹配的方法执行之前，之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是在适当位置声明的切入点表达式。</p>
</div>
<div class="sect4">
<h5 id="aop-advice-before"><a class="anchor" href="#aop-advice-before"></a>在建议之前</h5>
<div class="paragraph">
<p>您可以使用<code>@Before</code>注释在方面中的建议之前声明：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。之前</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">BeforeExample</span> { <span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doAccessCheck（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们使用就地切入点表达式，我们可以重写前面的示例，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。之前</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">BeforeExample</span> { <span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.dao。）*。*（..））</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doAccessCheck（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-returning"><a class="anchor" href="#aop-advice-after-returning"></a>返回建议后</h5>
<div class="paragraph">
<p>返回建议后，匹配的方法执行正常返回。您可以使用<code>@AfterReturning</code>注释声明它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。经过回归</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AfterReturningExample</span> { <span class="annotation">@AfterReturning</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doAccessCheck（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以在同一方面拥有多个建议声明（以及其他成员）。我们在这些例子中只展示了一个建议声明，以集中每个声明的效果。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有时，您需要在建议体中访问返回的实际值。您可以使用绑定返回值的<code>@AfterReturning</code>形式来获取该访问权限，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。经过回归</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AfterReturningExample</span> { <span class="annotation">@AfterReturning</span> （pointcut = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）</span> <span class="delimiter">“</span></span> ，returns = <span class="string"><span class="delimiter">”</span> <span class="content">retVal</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doAccessCheck（ <span class="predefined-type">Object</span> retVal）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>returning</code>属性中使用的名称必须与advice方法中的参数名称相对应。当方法执行返回时，返回值作为相应的参数值传递给advice方法。<code>returning</code>子句还将匹配仅限于那些返回指定类型值的方法执行（在本例中为<code>Object</code> ，它匹配任何返回值）。</p>
</div>
<div class="paragraph">
<p>请注意，在返回建议后使用时，无法返回完全不同的参考。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-throwing"><a class="anchor" href="#aop-advice-after-throwing"></a>投掷建议后</h5>
<div class="paragraph">
<p>抛出建议运行时，匹配的方法执行通过抛出异常退出。您可以使用<code>@AfterThrowing</code>注释声明它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。之后</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AfterThrowingExample</span> { <span class="annotation">@AfterThrowing</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doRecoveryActions（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通常，您希望建议仅在抛出给定类型的异常时运行，并且您还经常需要访问建议体中的抛出异常。您可以使用<code>throwing</code>属性来限制匹配（如果需要，请使用<code>Throwable</code>作为异常类型），并将抛出的异常绑定到advice参数。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。之后</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AfterThrowingExample</span> { <span class="annotation">@AfterThrowing</span> （pointcut = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）</span> <span class="delimiter">“</span></span> ，throwing = <span class="string"><span class="delimiter">”</span> <span class="content">ex</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doRecoveryActions（DataAccessException ex）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>throwing</code>属性中使用的名称必须与advice方法中的参数名称相对应。当通过抛出异常退出方法时，异常将作为相应的参数值传递给advice方法。甲<code>throwing</code>子句也限制了只能匹配到抛出指定类型的异常（那些方法执行<code>DataAccessException</code> ，在这种情况下）。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-finally"><a class="anchor" href="#aop-advice-after-finally"></a>之后（最后）建议</h5>
<div class="paragraph">
<p>在匹配的方法执行退出之后（最终）建议运行之后。它是使用<code>@After</code>注释<code>@After</code> 。在建议之后必须准备好处理正常和异常返回条件。它通常用于释放资源和类似目的。以下示例显示了在finally建议之后如何使用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。之后</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AfterFinallyExample</span> { <span class="annotation">@After</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> doReleaseLock（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-around-advice"><a class="anchor" href="#aop-ataspectj-around-advice"></a>围绕建议</h5>
<div class="paragraph">
<p>最后一种建议是建议。周围的建议围绕匹配方法的执行运行。它有机会在方法执行之前和之后完成工作，并确定何时，如何，甚至方法实际上都可以执行。如果您需要以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态，则通常会使用around建议。始终使用符合您要求的最不强大的建议形式（即，如果在建议之前，请不要使用建议）。</p>
</div>
<div class="paragraph">
<p>使用<code>@Around</code>注释声明around建议。advice方法的第一个参数必须是<code>ProceedingJoinPoint</code>类型。在通知的主体内，在<code>ProceedingJoinPoint</code>上调用<code>proceed()</code>会导致执行基础方法。<code>proceed</code>方法也可以传入<code>Object[]</code> 。数组中的值在进行时用作方法执行的参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的行为<code>proceed</code>时，与被称为<code>Object[]</code>比的行为有点不同<code>proceed</code>环绕通知通过AspectJ编译器。对于使用传统AspectJ语言编写的周围建议，传递给<code>proceed</code>的参数数量必须与传递给around建议的参数数量（不是底层连接点所采用的参数数量）相匹配，并且传递给的值继续给定的参数位置取代了值绑定到的实体的连接点的原始值（如果现在没有意义，请不要担心）。Spring采用的方法更简单，并且更好地匹配其基于代理的仅执行语义。如果编译为Spring编写的@AspectJ方面并使用AspectJ编译器和weaver <code>proceed</code>使用参数，则只需要注意这种差异。有一种方法可以编写在Spring AOP和AspectJ上100％兼容的方面，这将在<a href="#aop-ataspectj-advice-params">下面的建议参数部分中</a>讨论。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何使用around建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。周围</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang。ProceedingJoinPoint</span> ; <span class="annotation">@Aspect</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AroundExample</span> <span class="annotation"><span class="string"><span class="delimiter"><span class="content">{@Around（“com.xyz.myapp。</span></span>SystemArchitecture.businessService（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="predefined-type">Object</span> doBasicProfiling（ProceedingJoinPoint pjp） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="comment">// start</span> stopwatch <span class="predefined-type">Object</span> retVal = pjp.proceed（）; <span class="comment">// stop</span> stopwatch <span class="keyword">return</span> retVal;}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>around通知返回的值是方法调用者看到的返回值。例如，一个简单的缓存方面可以从缓存中返回一个值<code>proceed()</code>如果有的话<code>proceed()</code>如果没有则调用<code>proceed()</code> 。请注意， <code>proceed</code>可调用一次，许多次，或者根本就是环绕通知的体内。所有这些都是合法的。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params"><a class="anchor" href="#aop-ataspectj-advice-params"></a>建议参数</h5>
<div class="paragraph">
<p>Spring提供完全类型的建议，这意味着您在通知签名中声明了所需的参数（正如我们之前看到的返回和抛出示例），而不是始终使用<code>Object[]</code>数组。我们将在本节后面的内容中了解如何使建议主体可以使用参数和其他上下文值。首先，我们来看看如何编写通用建议，以便了解建议目前建议的方法。</p>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-the-joinpoint"><a class="anchor" href="#aop-ataspectj-advice-params-the-joinpoint"></a>访问当前<code>JoinPoint</code></h6>
<div class="paragraph">
<p>任何通知方法都可以声明<code>org.aspectj.lang.类型的参数作为其第一个参数<code>org.aspectj.lang.JoinPoint</code> （请注意，需要提供建议来声明<code>ProceedingJoinPoint</code>类型的第一个参数，它是<code>JoinPoint</code>的子类。<code>JoinPoint</code>接口提供了许多有用的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getArgs()</code> ：返回方法参数。</p>
</li>
<li>
<p><code>getThis()</code> ：返回代理对象。</p>
</li>
<li>
<p><code>getTarget()</code> ：返回目标对象。</p>
</li>
<li>
<p><code>getSignature()</code> ：返回正在建议的方法的描述。</p>
</li>
<li>
<p><code>toString()</code> ：打印建议方法的有用描述。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html">Javadoc</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-passing"><a class="anchor" href="#aop-ataspectj-advice-params-passing"></a>将参数传递给建议</h6>
<div class="paragraph">
<p>我们已经看到了如何绑定返回的值或异常值（在返回之后和抛出建议之后使用）。要使参数值可用于建议体，您可以使用<code>args</code>的绑定形式。如果在args表达式中使用参数名称代替类型名称，则在调用通知时，相应参数的值将作为参数值传递。一个例子应该使这更清楚。假设您要建议执行以<code>Account</code>对象作为第一个参数的DAO操作，并且您需要访问建议体中的帐户。你可以写下面的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）&amp;&amp; args（account，..）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> validateAccount（Account account）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>切入点表达式的<code>args(account,..)</code>部分有两个目的。首先，它将匹配仅限于那些方法至少接受一个参数的方法执行，而传递给该参数的参数是<code>Account</code>的实例。其次，它通过<code>account</code>参数使实际的<code>Account</code>对象可用于建议。</p>
</div>
<div class="paragraph">
<p>另一种编写方法是声明一个切入点，它在匹配连接点时“提供” <code>Account</code>对象值，然后从建议中引用指定的切入点。这看起来如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.dataAccessOperation（）&amp;&amp; args（account，..）</span> <span class="delimiter">“</span></span> ） <span class="directive">private</span> <span class="type">void</span> accountDataAccessOperation（Account account）{} <span class="annotation">@ Before</span> （ <span class="string"><span class="delimiter">”</span> <span class="content">accountDataAccessOperation（account）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> validateAccount（Account account）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅AspectJ编程指南。</p>
</div>
<div class="paragraph">
<p>代理对象（ <code>this</code> ），目标对象（ <code>target</code> ），和说明（ <code>@within</code> ， <code>@target</code> ， <code>@annotation</code>和<code>@args</code> ）都可以以类似的方式结合。接下来的两个示例显示如何匹配带有<code>@Auditable</code>注释的注释方法的执行并提取审计代码：</p>
</div>
<div class="paragraph">
<p>这两个示例中的第一个显示了<code>@Auditable</code>注释的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。方法） <span class="directive">public</span> <span class="annotation">@interface</span> Auditable {AuditCode value（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这两个示例中的第二个显示了与<code>@Auditable</code>方法的执行相匹配的建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.lib。Pointcuts.anyPublicMethod（）&amp;&amp; @ annotation（auditable）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> audit（Auditable auditable）{AuditCode code = auditable.value（）; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-generics"><a class="anchor" href="#aop-ataspectj-advice-params-generics"></a>建议参数和泛型</h6>
<div class="paragraph">
<p>Spring AOP可以处理类声明和方法参数中使用的泛型。假设您有一个如下所示的泛型类型：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Sample</span> &lt;T&gt; { <span class="type">void</span> sampleGenericMethod（T param）; <span class="type">void</span> sampleGenericCollectionMethod（ <span class="predefined-type">Collection</span> &lt;T&gt; param）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过在要拦截方法的参数类型中键入advice参数，将方法类型的拦截限制为某些参数类型：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">执行（* ..Sample + .sampleGenericMethod（*））&amp;&amp; args（param）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> beforeSampleMethod（MyType param）{ <span class="comment">// Advice implementation</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此方法不适用于通用集合。因此，您无法按如下方式定义切入点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">执行（* ..Sample + .sampleGenericCollectionMethod（*））&amp;&amp; args（param）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> beforeSampleMethod（ <span class="predefined-type">Collection</span> &lt;MyType&gt; param）{ <span class="comment">// Advice implementation</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了使这项工作，我们必须检查集合的每个元素，这是不合理的，因为我们也无法决定如何一般地处理<code>null</code>值。要实现与此类似的功能，您必须输入<code>Collection&lt;?&gt;</code>并手动检查元素的类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-names"><a class="anchor" href="#aop-ataspectj-advice-params-names"></a>确定参数名称</h6>
<div class="paragraph">
<p>通知调用中的参数绑定依赖于切入点表达式中使用的匹配名称与通知和切入点方法签名中声明的参数名称。参数名称不能通过Java反射获得，因此Spring AOP使用以下策略来确定参数名称：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果用户已明确指定参数名称，则使用指定的参数名称。通知和切入点注释都有一个可选的<code>argNames</code>属性，您可以使用该属性指定带注释的方法的参数名称。这些参数名称在运行时可用。以下示例显示如何使用<code>argNames</code>属性：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span> （value = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.lib。Pointcuts.anyPublicMethod（）&amp;&amp; target（bean）&amp;&amp; @annotation（auditable）</span> <span class="delimiter">“</span></span> ，argNames = <span class="string"><span class="delimiter">”</span> <span class="content">bean，</span></span> auditable</span></span> <span class="string"><span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> audit（ <span class="predefined-type">Object</span> bean，Auditable auditable）{AuditCode code = auditable.value（）; <span class="comment">// .. 。使用代码和bean</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果第一个参数是<code>JoinPoint</code> ， <code>ProceedingJoinPoint</code>或<code>JoinPoint.StaticPart</code>类型，您可以从<code>argNames</code>属性的值中省略参数的名称。例如，如果修改前面的建议以接收连接点对象，则<code>argNames</code>属性不需要包含它：</p>
</div>
<div class="paragraph">
<p>==== [源，JAVA，缩进= 0]</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Before（值=“com.xyz.lib。Pointcuts.anyPublicMethod（）&amp;&amp; target（bean）&amp;&amp; @annotation（auditable）“，argNames =”bean，auditable“）public void audit（JoinPoint jp，Object bean，Auditable auditable）{AuditCode code = auditable.value（）; / / ...使用代码，bean和jp}</pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>+对<code>JoinPoint</code> ， <code>ProceedingJoinPoint</code>和<code>JoinPoint.的第一个参数进行特殊处理<code>JoinPoint.StaticPart</code>类型对于不收集任何其他连接点上下文的建议实例特别方便。在这种情况下，您可以省略<code>argNames</code>属性。例如，以下建议无需声明<code>argNames</code>属性：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.lib。Pointcuts.anyPublicMethod（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> audit（JoinPoint jp）{ <span class="comment">// ...使用jp</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>使用<code>'argNames'</code>属性有点笨拙，所以如果没有指定<code>'argNames'</code>属性，Spring AOP会查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要已使用调试信息（至少为<code>'-g:vars'</code> ）编译类，就会显示此信息。使用此标志进行编译的后果是：（1）您的代码稍微容易理解（逆向工程），（2）类文件大小略大（通常无关紧要），（3）优化删除未使用的本地您的编译器不会应用变量。换句话说，通过使用此标志构建，您应该不会遇到任何困难。</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果即使没有调试信息，AspectJ编译器（ajc）也编译了@AspectJ方面，则无需添加<code>argNames</code>属性，因为编译器会保留所需的信息。
</td>
</tr>
</table>
</div>
</li>
<li>
<p>如果代码编译时没有必要的调试信息，Spring AOP会尝试推断绑定变量与参数的配对（例如，如果只有一个变量绑定在切入点表达式中，并且advice方法只接受一个参数，那么配对很明显）。如果给定可用信息，变量的绑定是不<code>AmbiguousBindingException</code>则抛出<code>AmbiguousBindingException</code> 。</p>
</li>
<li>
<p>如果上述所有策略都失败，则抛出<code>IllegalArgumentException</code> 。</p>
</li>
</ul>
</div>
<div id="aop-ataspectj-advice-proceeding-with-the-call" class="paragraph">
<p>=====继续参数</p>
</div>
<div class="paragraph">
<p>我们之前评论过，我们将描述如何使用在Spring AOP和AspectJ中一致工作的参数编写一个<code>proceed</code>调用。解决方案是确保建议签名按顺序绑定每个方法参数。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">执行（列表&lt;帐户&gt;查找*（..））&amp;&amp;</span> <span class="delimiter">”</span></span> + <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.inDataAccessLayer（）&amp;&amp;</span> <span class="delimiter">“</span></span> + <span class="string"><span class="delimiter">”</span> <span class="content">args（accountHolderNamePattern）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="predefined-type">Object</span> preProcessQueryPattern（ProceedingJoinPoint pjp， <span class="predefined-type">String</span> accountHolderNamePattern） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="predefined-type">String</span> newPattern = preProcess（accountHolderNamePattern）; <span class="keyword">return</span> pjp.proceed（ <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {newPattern}）; }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>在许多情况下，无论如何都要执行此绑定（如前面的示例所示）。</p>
</div>
<div id="aop-ataspectj-advice-ordering" class="paragraph">
<p>====建议订购</p>
</div>
<div class="paragraph">
<p>当多条建议都想在同一个连接点运行时会发生什么？Spring AOP遵循与AspectJ相同的优先级规则来确定建议执行的顺序。最高优先级的建议首先“在路上”（因此，给定两条之前的建议，优先级最高的建议首先运行）。从连接点“出路”，最高优先级建议最后运行（因此，给出两条后建议，具有最高优先级的建议将运行第二）。</p>
</div>
<div class="paragraph">
<p>当在不同方面定义的两条建议都需要在同一个连接点运行时，除非另行指定，否则执行顺序是未定义的。您可以通过指定优先级来控制执行顺序。这是通过实现<code>org.springframework.core.以正常的Spring方式完成的<code>org.springframework.core.方面类中的Ordered</code>接口或使用<code>Order</code>注释对其进行注释。给定两个方面，从<code>Ordered.getValue()</code> （或注释值）返回较低值的方面具有较高的优先级。</p>
</div>
<div class="paragraph">
<p>当在同一方面定义的两条建议都需要在同一个连接点运行时，排序是未定义的（因为没有办法通过反射为javac编译的类检索声明顺序）。考虑将这些建议方法折叠到每个方面类中每个连接点的一个建议方法中，或者将这些建议重构为可以在方面级别订购的单独方面类。</p>
</div>
<div id="aop-introductions" class="paragraph">
<p>===介绍</p>
</div>
<div class="paragraph">
<p>简介（在AspectJ中称为类型间声明）使方面能够声明建议对象实现给定接口，并代表这些对象提供该接口的实现。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@DeclareParents</code>注释进行介绍。此批注用于声明匹配类型具有新父级（因此名称）。例如，给定名为<code>UsageTracked</code>的接口和名为<code>DefaultUsageTracked</code>接口的实现，以下方面声明服务接口的所有实现者也实现<code>UsageTracked</code>接口（例如，通过JMX公开统计信息）：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">UsageTracking</span> { <span class="annotation">@DeclareParents</span> （value = <span class="string"><span class="delimiter">“</span> <span class="content">com.xzy.myapp.service。* +</span> <span class="delimiter">”</span></span> ，defaultImpl = DefaultUsageTracked.class） <span class="directive">public</span> <span class="directive">static</span> UsageTracked mixin; <span class="annotation">@Before</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.businessService（）&amp;&amp; this（usageTracked）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> recordUsage（UsageTracked usageTracked）{usageTracked.incrementUseCount（）;}}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>要实现的接口由注释字段的类型确定。<code>@DeclareParents</code>注释的<code>value</code>属性是AspectJ类型模式。任何匹配类型的bean都实现<code>UsageTracked</code>接口。请注意，在前面示例的before advice中，service bean可以直接用作<code>UsageTracked</code>接口的<code>UsageTracked</code> 。如果以编程方式访问bean，您将编写以下内容：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UsageTracked usageTracked =（UsageTracked）context.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">myService</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="aop-instantiation-models" class="paragraph">
<p>===方面实例化模型</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是一个高级主题。如果您刚刚开始使用AOP，您可以安全地跳过它直到稍后。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，应用程序上下文中的每个方面都有一个实例。AspectJ将其称为单例实例化模型。可以使用备用生命周期定义方面。Spring支持AspectJ的<code>perthis</code>和<code>pertarget</code>实例化模型（目前不支持<code>percflow, percflowbelow,</code>和<code>pertypewithin</code> ）。</p>
</div>
<div class="paragraph">
<p>你可以声明<code>perthis</code>通过指定方面<code>perthis</code>在第<code>@Aspect</code>注解。请考虑以下示例：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">perthis（com.xyz.myapp。SystemArchitecture.businessService（））</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">MyAspect</span> { <span class="directive">private</span> <span class="type">int</span> someState; <span class="annotation">@Before</span> （com.xyz.myapp。SystemArchitecture.businessService（）） <span class="directive">public</span> <span class="type">void</span> recordServiceUsage（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>在前面的示例中， <code>'perthis'</code>子句的作用是为执行业务服务的每个唯一服务对象创建一个方面实例（每个唯一对象在由切入点表达式匹配的连接点处绑定到'this'）。方法实例是在第一次在服务对象上调用方法时创建的。当服务对象超出范围时，该方面超出范围。在创建方面实例之前，其中没有任何建议执行。一旦创建了方面实例，在其中声明的通知就会在匹配的连接点处执行，但仅在服务对象与此方面关联的服务对象时执行。有关<code>per</code>子句的更多信息，请参阅AspectJ编程指南。</p>
</div>
<div class="paragraph">
<p><code>pertarget</code>实例化模型的工作方式与<code>perthis</code>完全相同，但它为匹配的连接点处的每个唯一目标对象创建一个方面实例。</p>
</div>
<div id="aop-ataspectj-example" class="paragraph">
<p>===一个AOP示例</p>
</div>
<div class="paragraph">
<p>现在您已经了解了所有组成部分的工作原理，我们可以将它们放在一起做一些有用的事情。</p>
</div>
<div class="paragraph">
<p>由于并发问题（例如，死锁失败者），业务服务的执行有时会失败。如果重试该操作，则可能在下次尝试时成功。对于适合在这种情况下重试的业务服务（不需要返回给用户进行冲突解决的幂等操作），我们希望透明地重试操作以避免客户端看到<code>PessimisticLockingFailureException</code> 。这是一个明确跨越服务层中的多个服务的要求，因此是通过一个方面实现的理想选择。</p>
</div>
<div class="paragraph">
<p>因为我们想要重试操作，所以我们需要使用around建议，以便我们可以多次调用<code>proceed</code> 。以下清单显示了基本方面的实现：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ConcurrentOperationExecutor</span> <span class="directive">实现</span> Ordered { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DEFAULT_MAX_RETRIES = <span class="integer">2</span> ; <span class="directive">private</span> <span class="type">int</span> maxRetries = DEFAULT_MAX_RETRIES; <span class="directive">private</span> <span class="type">int</span> order = <span class="integer">1</span> ; <span class="directive">public</span> <span class="type">void</span> setMaxRetries（ <span class="type">int</span> maxRetries）{ <span class="local-variable">this</span> .maxRetries = maxRetries; <span class="directive">public</span> <span class="type">int</span> getOrder（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .order; <span class="directive">public</span> <span class="type">void</span> setOrder（ <span class="type">int</span> order）{ <span class="local-variable">this</span> .order = order; } <span class="annotation">@Around</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.businessService（）</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation（ProceedingJoinPoint pjp） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="type">int</span> numAttempts = <span class="integer">0</span> ; PessimisticLockingFailureException lockFailureException; <span class="keyword">do</span> {numAttempts ++; <span class="keyword">try</span> { <span class="keyword">return</span> pjp.proceed（）;} <span class="keyword">catch</span> （PessimisticLockingFailureException ex）{lockFailureException = ex;} } <span class="keyword">while</span> （numAttempts &lt;= <span class="local-variable">this</span> .maxRetries）; <span class="keyword">throw</span> lockFailureException;}}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>请注意，该方面实现了<code>Ordered</code>接口，以便我们可以将方面的优先级设置为高于事务通知（我们每次重试时都需要一个新的事务）。<code>maxRetries</code>和<code>order</code>属性都由Spring配置。主要操作发生在<code>doConcurrentOperation</code>周围的建议中。请注意，目前，我们将重试逻辑应用于每个<code>businessService()</code> 。我们尝试继续，如果我们失败了<code>PessimisticLockingFailureException</code> ，我们再试一次，除非我们已经用尽所有的重试尝试。</p>
</div>
<div class="paragraph">
<p>相应的Spring配置如下：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspectj-autoproxy</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">concurrentOperationExecutor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp.service.impl。ConcurrentOperationExecutor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">maxRetries</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">3</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">order</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>为了优化方面以便它只重试幂等操作，我们可以定义以下<code>Idempotent</code>注释：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="directive">public</span> <span class="annotation">@interface</span> Idempotent { <span class="comment">// marker annotation</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>然后，我们可以使用注释来注释服务操作的实现。对方面进行更改以仅重试幂等操作涉及改进切入点表达式，以便只有<code>@Idempotent</code>操作匹配，如下所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.businessService（）&amp;&amp;</span> <span class="delimiter">“</span></span> + <span class="string"><span class="delimiter">”</span> <span class="content">@ annotation（com.xyz.myapp.service。幂等）</span> <span class="delimiter">“</span></span> ） <span class="directive">公共</span> <span class="predefined-type">对象</span> doConcurrentOperation（ProceedingJoinPoint pjp） <span class="directive">抛出</span> <span class="predefined-type">Throwable</span> {...}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="aop-schema" class="paragraph">
<p>==基于模式的AOP支持</p>
</div>
<div class="paragraph">
<p>如果您更喜欢基于XML的格式，Spring还支持使用新的<code>aop</code>命名空间标记定义方面。支持与使用@AspectJ样式时完全相同的切入点表达式和建议种类。因此，在本节中，我们将重点放在新语法上，并将读者引用到上一节（ <a href="#aop-ataspectj">@AspectJ支持</a> ）中的讨论，以了解编写切入点表达式和建议参数的绑定。</p>
</div>
<div class="paragraph">
<p>要使用本节中描述的aop命名空间标记，您需要导入<code>spring-aop</code>模式，如<a href="#xsd-schemas">基于XML模式的配置中所述</a> 。有关如何在<code>aop</code>命名空间中导入标记，请参阅<a href="#xsd-schemas-aop">AOP架构</a> 。</p>
</div>
<div class="paragraph">
<p>在Spring配置中，所有aspect和advisor元素必须放在<code>&lt;aop:config&gt;</code>元素中（在应用程序上下文配置中可以有多个<code>&lt;aop:config&gt;</code>元素）。<code>&lt;aop:config&gt;</code>元素可以包含切入点，顾问程序和方面元素（请注意，这些元素必须按此顺序声明）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content"><code>&lt;aop:config&gt;</code>配置样式大量使用了Spring的<a href="#aop-autoproxy">自动代理</a>机制。如果您已经通过使用<code>BeanNameAutoProxyCreator</code>或类似的东西使用显式自动代理，这可能会导致问题（例如建议不被编织）。建议的使用模式是仅使用<code>&lt;aop:config&gt;</code>样式或仅使用<code>AutoProxyCreator</code>样式，并且永远不要混用它们。
</td>
</tr>
</table>
</div>
<div id="aop-schema-declaring-an-aspect" class="paragraph">
<p>===声明一个方面</p>
</div>
<div class="paragraph">
<p>使用模式支持时，方面是在Spring应用程序上下文中定义为bean的常规Java对象。状态和行为在对象的字段和方法中捕获，切入点和建议信息在XML中捕获。</p>
</div>
<div class="paragraph">
<p>您可以使用&lt;aop：aspect&gt;元素声明方面，并使用<code>ref</code>属性引用支持bean，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myAspect</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> ...
    <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> ...
<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>支持方面的bean（在这种情况下是<code>aBean</code> ）当然可以像任何其他Spring bean一样配置和依赖注入。</p>
</div>
<div id="aop-schema-pointcuts" class="paragraph">
<p>===声明切入点</p>
</div>
<div class="paragraph">
<p>您可以在<code>&lt;aop:config&gt;</code>元素中声明一个命名切入点，让切入点定义在多个方面和顾问之间共享。</p>
</div>
<div class="paragraph">
<p>表示服务层中任何业务服务执行的切入点可以定义如下：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessService</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.service。*。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>请注意，切入点表达式本身使用与<a href="#aop-ataspectj">@AspectJ支持中</a>描述的相同的AspectJ切入点表达式语言。如果使用基于模式的声明样式，则可以引用切入点表达式中类型（@Aspects）中定义的命名切入点。定义上述切入点的另一种方法如下：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessService</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp。SystemArchitecture.businessService（）</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>假设您具有<a href="#aop-common-pointcuts">共享公共切入点定义中</a>所述的<code>SystemArchitecture</code>方面。</p>
</div>
<div class="paragraph">
<p>然后在方面内声明切入点与声明顶级切入点非常相似，如下例所示：</p>
</div>
<div class="paragraph">
<p>===</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myAspect</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessService</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.service。*。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> ......

    <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与@AspectJ方面大致相同，使用基于模式的定义样式声明的切入点可以收集连接点上下文。例如，以下切入点<code>this</code>对象收集为连接点上下文并将其传递给建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myAspect</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessService</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.service。*。*（..））</span> <span class="entity">＆amp;</span> <span class="entity">＆安培;</span> <span class="content">这个（服务）</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：在</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessService</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">monitor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;之前</span> ......

    <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>必须通过包含匹配名称的参数来声明建议以接收收集的连接点上下文，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> monitor（ <span class="predefined-type">对象</span>服务）{...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>组合切入点子表达式时， <code>&amp;&amp;</code>在XML文档中很难处理，因此您可以使用<code>and</code> ， <code>or</code> ，而<code>not</code>关键字来代替<code>&amp;&amp;</code> ， <code>||</code> ，和<code>!</code> ， 分别。例如，以前的切入点可以更好地编写如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;AOP：配置&gt;</span> <span class="tag">&lt;AOP：方面</span> <span class="attribute-name">ID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“myAspect”</span></span></span></span> <span class="attribute-name">REF</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“aBean”&gt;</span></span></span></span></span> <span class="tag">&lt;AOP：切入点</span> <span class="attribute-name">ID</span> = <span class="string"><span class="content"><span class="delimiter">“businessService</span>的</span> <span class="delimiter">”</span></span> <span class="attribute-name">表达</span> <span class="string"><span class="delimiter">=“</span> <span class="content">执行<strong>（。*</strong> com.xyz.myapp.service（..）） <strong>和</strong>这个（服务）</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：在</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessService</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">monitor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;之前</span> ......
    <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，以这种方式定义的切入点由其XML <code>id</code>引用，不能用作命名切入点来形成复合切入点。因此，基于模式的定义样式中的命名切入点支持比@AspectJ样式提供的更有限。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice"><a class="anchor" href="#aop-schema-advice"></a> 5.4.5。宣布建议</h4>
<div class="paragraph">
<p>基于模式的AOP支持使用与@AspectJ样式相同的五种建议，并且它们具有完全相同的语义。</p>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-before"><a class="anchor" href="#aop-schema-advice-before"></a>在建议之前</h5>
<div class="paragraph">
<p>在匹配的方法执行之前运行建议之前。它通过使用&lt;aop：before&gt;元素在<code>&lt;aop:aspect&gt;</code>声明，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">beforeExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：before</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataAccessOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">doAccessCheck</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里， <code>dataAccessOperation</code>是在顶部（ <code>&lt;aop:config&gt;</code> ）级别定义的切入点的<code>id</code> 。要改为内联<code>pointcut-ref</code> ，请使用<code>pointcut</code>属性替换<code>pointcut-ref</code>属性，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">beforeExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：before</span> <span class="attribute-name">pointcut</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.dao。*。*（..））</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">doAccessCheck</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正如我们在讨论@AspectJ样式时所提到的，使用命名切入点可以显着提高代码的可读性。</p>
</div>
<div class="paragraph">
<p><code>method</code>属性标识提供建议正文的方法（ <code>doAccessCheck</code> ）。必须为包含建议的aspect元素引用的bean定义此方法。在执行数据访问操作（由切入点表达式匹配的方法执行连接点）之前，将调用方面bean上的<code>doAccessCheck</code>方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-returning"><a class="anchor" href="#aop-schema-advice-after-returning"></a>返回建议后</h5>
<div class="paragraph">
<p>在匹配的方法执行正常完成后返回通知运行。它在<code>&lt;aop:aspect&gt;</code>中以与advice之前相同的方式声明。以下示例显示了如何声明它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">afterReturningExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：after-</span> <span class="string"><span class="content">returns</span></span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataAccessOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">doAccessCheck</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与@AspectJ样式一样，您可以在建议体内获取返回值。为此，请使用returns属性指定应将返回值传递到的参数的名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;AOP：方面</span> <span class="attribute-name">ID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“afterReturningExample”</span></span></span></span> <span class="attribute-name">REF</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“aBean”&gt;</span></span></span></span></span> <span class="tag">&lt;AOP：后返回</span> <span class="attribute-name">切入点-REF</span> = <span class="string"><span class="content"><span class="delimiter">“dataAccessOperation</span>操作</span> <span class="delimiter">”</span></span> <span class="attribute-name">返回</span> = <span class="string"><span class="content"><span class="delimiter">“retVal</span>的</span> <span class="delimiter">”</span></span> <span class="attribute-name">方法</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“doAccessCheck”/&gt;</span></span></span></span></span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>doAccessCheck</code>方法必须声明一个名为<code>retVal</code>的参数。此参数的类型以与<code>@AfterReturning</code>所述相同的方式约束匹配。例如，您可以按如下方式取消方法签名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> doAccessCheck（ <span class="predefined-type">Object</span> retVal）{...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-throwing"><a class="anchor" href="#aop-schema-advice-after-throwing"></a>投掷建议后</h5>
<div class="paragraph">
<p>抛出建议执行时，匹配的方法执行通过抛出异常退出。它通过使用after-throwing元素在<code>&lt;aop:aspect&gt;</code>声明，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">afterThrowingExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：after-throwing</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataAccessOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">doRecoveryActions</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与@AspectJ样式一样，您可以在建议体内获得抛出的异常。为此，请使用throwing属性指定应将异常传递到的参数的名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">afterThrowingExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：after-throwing</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataAccessOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">throwing</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataAccessEx</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">doRecoveryActions</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>doRecoveryActions</code>方法必须声明一个名为<code>dataAccessEx</code>的参数。此参数的类型以与<code>@AfterThrowing</code>相同的方式约束匹配。例如，方法签名可以声明如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> doRecoveryActions（DataAccessException dataAccessEx）{...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-finally"><a class="anchor" href="#aop-schema-advice-after-finally"></a>之后（最后）建议</h5>
<div class="paragraph">
<p>在（最终）建议运行之后，无论匹配的方法执行如何退出。您可以使用<code>after</code>元素声明它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">afterFinallyExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：after</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataAccessOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">doReleaseLock</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-around"><a class="anchor" href="#aop-schema-advice-around"></a>围绕建议</h5>
<div class="paragraph">
<p>最后一种建议是建议。周围的建议围绕匹配的方法执行运行。它有机会在方法执行之前和之后完成工作，并确定何时，如何，甚至方法实际上都可以执行。around建议通常用于以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态。始终使用符合您要求的最不强大的建议形式。如果在建议可以完成工作之前，请不要使用周围的建议。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>aop:around</code>元素声明周围的建议。advice方法的第一个参数必须是<code>ProceedingJoinPoint</code>类型。在通知的主体内，在<code>ProceedingJoinPoint</code>上调用<code>proceed()</code>会导致执行基础方法。也可以使用<code>Object[]</code>调用<code>proceed</code>方法。数组中的值在进行时用作方法执行的参数。有关调用<code>proceed</code>使用<code>Object[]</code>说明，请参阅“ <a href="#aop-ataspectj-around-advice">周围建议</a> <code>Object[]</code> 。以下示例显示如何在XML中声明建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aroundExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">aBean</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：around</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessService</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">doBasicProfiling</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> ...

<span class="tag">&lt;/ AOP：方面&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>doBasicProfiling</code>通知的实现可以与@AspectJ示例中的完全相同（当然，减去注释），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> doBasicProfiling（ProceedingJoinPoint pjp） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="comment">// start</span> stopwatch <span class="predefined-type">Object</span> retVal = pjp.proceed（）; <span class="comment">//停止秒表</span> <span class="keyword">返回</span> retVal; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-params"><a class="anchor" href="#aop-schema-params"></a>建议参数</h5>
<div class="paragraph">
<p>基于模式的声明样式支持完全类型化的建议，其方式与对@AspectJ支持的描述相同 - 通过名称匹配切入点参数与建议方法参数。有关详细信息，请参阅<a href="#aop-ataspectj-advice-params">建议参数</a>如果您希望显式指定通知方法的参数名称（不依赖于前面描述的检测策略），可以使用advice元素的<code>arg-names</code>属性来实现，该属性的处理方式与<code>argNames</code>属性相同。在建议注释中（如<a href="#aop-ataspectj-advice-params-names">确定参数名称中所述</a> ）。以下示例显示如何在XML中指定参数名称：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：before</span> <span class="attribute-name">pointcut</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.lib。Pointcuts.anyPublicMethod（）和@annotation（auditable）</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">audit</span> <span class="delimiter">“</span></span> <span class="attribute-name">arg-names</span> = <span class="string"><span class="delimiter">”</span> <span class="content">auditable</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>arg-names</code>属性接受以逗号分隔的参数名称列表。</p>
</div>
<div class="paragraph">
<p>以下稍微涉及的基于XSD的方法示例显示了一些与一些强类型参数一起使用的建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">xyservice</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">PersonService</span> {Person getPerson（ <span class="predefined-type">String</span> personName， <span class="type">int</span> age）; <span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultFooService</span> <span class="directive">实现</span> FooService { <span class="directive">public</span> Person getPerson（ <span class="predefined-type">String</span> name， <span class="type">int</span> age）{ <span class="keyword">return</span> <span class="keyword">new</span> Person（name，age）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来是方面。请注意， <code>profile(..)</code>方法接受许多强类型参数，第一个参数恰好是用于继续方法调用的连接点。此参数的存在表示<code>profile(..)</code>将用作<code>around</code>建议，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">xy</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang。ProceedingJoinPoint</span> ; <span class="keyword">import</span> <span class="include">org.springframework.util。秒表</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleProfiler</span> { <span class="directive">public</span> <span class="predefined-type">Object</span> profile（ProceedingJoinPoint call， <span class="predefined-type">String</span> name， <span class="type">int</span> age） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {StopWatch clock = <span class="keyword">new</span> StopWatch（ <span class="string"><span class="delimiter">“</span> <span class="content">profiling for”</span> <span class="delimiter">“</span></span> + name + <span class="string"><span class="delimiter">”</span> <span class="content">'和'</span> <span class="delimiter">“</span></span> + age + <span class="string"><span class="delimiter">”</span> <span class="content">'</span> <span class="delimiter">“</span></span> ）; <span class="keyword">try</span> {clock.start（call.toShortString（））; <span class="keyword">return</span> call.proceed（）; } <span class="keyword">finally</span> {clock.stop（）; <span class="predefined-type">System</span> .out.println（clock.prettyPrint（））; }}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，以下示例XML配置会影响特定连接点的前一个建议的执行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这是将由Spring的AOP基础设施代理的对象 - &gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">personService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyservice。DefaultPersonService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 这是实际的建议本身 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profiler</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xySimpleProfiler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profiler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">theExecutionOfSomePersonServiceMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">”</span> <span class="content">execution（* xyservice。PersonService.getPerson（String，int））</span> <span class="content">和args（name，age）</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：around</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">theExecutionOfSomePersonServiceMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profile</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt; /豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请考虑以下驱动程序脚本：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.beans.factory。BeanFactory</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="keyword">导入</span> <span class="include">xyservice。PersonService</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> {BeanFactory ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">x / y / plain.xml</span> <span class="delimiter">”</span></span> ）; PersonService person =（PersonService）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">personService</span> <span class="delimiter">”</span></span> ）; person.getPerson（ <span class="string"><span class="delimiter">“</span> <span class="content">Pengo</span> <span class="delimiter">”</span></span> ， <span class="integer">12</span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用这样的Boot类，我们将获得类似于标准输出上的folloiwng的输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>StopWatch'Pengo'和'12''的分析：运行时间（毫秒）= 0 ------------------------------ ----------- ms％任务名称----------------------------------- ------ 00000？执行（的getFoo）</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ordering"><a class="anchor" href="#aop-ordering"></a>建议订购</h5>
<div class="paragraph">
<p>当多个建议需要在同一个连接点（执行方法）执行时，排序规则如<a href="#aop-ataspectj-advice-ordering">[aop-ataspectj-advice-ordering]中所述</a> 。方面之间的优先级是通过将<code>Order</code>注释添加到支持方面的bean或通过让bean实现<code>Ordered</code>接口来确定的。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-introductions"><a class="anchor" href="#aop-schema-introductions"></a> 5.4.6。简介</h4>
<div class="paragraph">
<p>介绍（在AspectJ中称为类型间声明）让方面声明建议对象实现给定接口并代表这些对象提供该接口的实现。</p>
</div>
<div class="paragraph">
<p>您可以在<code>aop:aspect</code>使用<code>aop:declare-parents</code>元素进行介绍。您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有新父级（因此名称）。例如，给定名为<code>UsageTracked</code>的接口和名为<code>DefaultUsageTracked</code>接口的实现，以下方面声明服务接口的所有实现者也实现<code>UsageTracked</code>接口。（例如，为了通过JMX公开统计信息。）</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">usageTrackerAspect</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">usageTracking</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：declare-parents</span> <span class="attribute-name">types-matching</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xzy.myapp.service。* +</span> <span class="delimiter">”</span></span> <span class="attribute-name">implement-interface</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp.service。跟踪。UsageTracked</span> <span class="delimiter">“</span></span> <span class="attribute-name">default-impl</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.xyz.myapp.service.tracking。DefaultUsageTracked</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：before</span> <span class="attribute-name">pointcut</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.xyz.myapp。SystemArchitecture.businessService（）</span> <span class="content">和this（usageTracked）</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">recordUsage</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：aspect&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，支持<code>usageTracking</code> bean的类将包含以下方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> recordUsage（UsageTracked usageTracked）{usageTracked.incrementUseCount（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要实现的接口由<code>implement-interface</code>属性确定。<code>types-matching</code>属性的值是AspectJ类型模式。任何匹配类型的bean都实现<code>UsageTracked</code>接口。请注意，在前面示例的before advice中，service bean可以直接用作<code>UsageTracked</code>接口的<code>UsageTracked</code> 。要以编程方式访问bean，您可以编写以下代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UsageTracked usageTracked =（UsageTracked）context.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">myService</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-instatiation-models"><a class="anchor" href="#aop-schema-instatiation-models"></a> 5.4.7。Aspect实例化模型</h4>
<div class="paragraph">
<p>模式定义方面唯一受支持的实例化模型是单例模型。在将来的版本中可能支持其他实例化模型。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advisors"><a class="anchor" href="#aop-schema-advisors"></a> 5.4.8。顾问</h4>
<div class="paragraph">
<p>“顾问”的概念来自Spring中定义的AOP支持，并且在AspectJ中没有直接的等价物。顾问就像一个小小的独立方面，只有一条建议。建议本身由bean表示，并且必须实现<a href="#aop-api-advice-types">Spring</a>中的<a href="#aop-api-advice-types">建议类型中</a>描述的建议接口<a href="#aop-api-advice-types">之一</a> 。顾问可以利用AspectJ切入点表达式。</p>
</div>
<div class="paragraph">
<p>Spring使用<code>&lt;aop:advisor&gt;</code>元素支持顾问程序概念。您最常见的是它与事务性建议一起使用，它在Spring中也有自己的命名空间支持。以下示例显示了一个顾问：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessService</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.service。*。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessService</span> <span class="delimiter">“</span></span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tx-advice</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tx-advice</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt; tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="attribute-name">propagation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">REQUIRED</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了前面示例中使用的<code>pointcut-ref</code>属性之外，您还可以使用<code>pointcut</code>属性来内联定义切入点表达式。</p>
</div>
<div class="paragraph">
<p>要定义顾问程序的优先级以便建议可以参与排序，请使用<code>order</code>属性来定义顾问程序的<code>Ordered</code>值。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-example"><a class="anchor" href="#aop-schema-example"></a> 5.4.9。AOP架构示例</h4>
<div class="paragraph">
<p>本节说明了如何使用模式支持重写<a href="#aop-ataspectj-example">[aop-ataspectj-example]中</a>的并发锁定失败重试示例。</p>
</div>
<div class="paragraph">
<p>由于并发问题（例如，死锁失败者），业务服务的执行有时会失败。如果重试该操作，则可能在下次尝试时成功。对于适合在这种情况下重试的业务服务（不需要返回给用户进行冲突解决的幂等操作），我们希望透明地重试操作以避免客户端看到<code>PessimisticLockingFailureException</code> 。这是一个明确跨越服务层中的多个服务的要求，因此是通过一个方面实现的理想选择。</p>
</div>
<div class="paragraph">
<p>因为我们想要重试操作，所以我们需要使用around建议，以便我们可以多次调用<code>proceed</code> 。以下清单显示了基本方面实现（使用模式支持的常规Java类）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ConcurrentOperationExecutor</span> <span class="directive">实现</span> Ordered { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DEFAULT_MAX_RETRIES = <span class="integer">2</span> ; <span class="directive">private</span> <span class="type">int</span> maxRetries = DEFAULT_MAX_RETRIES; <span class="directive">private</span> <span class="type">int</span> order = <span class="integer">1</span> ; <span class="directive">public</span> <span class="type">void</span> setMaxRetries（ <span class="type">int</span> maxRetries）{ <span class="local-variable">this</span> .maxRetries = maxRetries; <span class="directive">public</span> <span class="type">int</span> getOrder（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .order; <span class="directive">public</span> <span class="type">void</span> setOrder（ <span class="type">int</span> order）{ <span class="local-variable">this</span> .order = order; <span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation（ProceedingJoinPoint pjp） <span class="directive">抛出</span> <span class="predefined-type">Throwable</span> { <span class="type">int</span> numAttempts = <span class="integer">0</span> ; PessimisticLockingFailureException lockFailureException; <span class="keyword">做</span> {numAttempts ++; <span class="keyword">try</span> { <span class="keyword">return</span> pjp.proceed（）; } <span class="keyword">catch</span> （PessimisticLockingFailureException ex）{lockFailureException = ex; <span class="keyword">while</span> （numAttempts &lt;= <span class="local-variable">this</span> .maxRetries）; <span class="keyword">throw</span> lockFailureException; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，该方面实现了<code>Ordered</code>接口，以便我们可以将方面的优先级设置为高于事务通知（我们每次重试时都需要一个新的事务）。<code>maxRetries</code>和<code>order</code>属性都由Spring配置。主要操作发生在<code>doConcurrentOperation</code> around advice方法中。我们试着继续。如果我们使用<code>PessimisticLockingFailureException</code>失败，我们会再次尝试，除非我们已经用尽所有重试尝试。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此类与@AspectJ示例中使用的类相同，但删除了注释。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>相应的Spring配置如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">concurrentOperationRetry</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">concurrentOperationExecutor</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">idempotentOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.service。*。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：around</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">idempotentOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">doConcurrentOperation</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">concurrentOperationExecutor</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com .xyz.myapp.service.impl。ConcurrentOperationExecutor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">maxRetries</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">3</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">order</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，在当时，我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入<code>Idempotent</code>注释并使用注释来注释服务操作的实现来优化方面，使其仅重试真正的幂等操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="directive">public</span> <span class="annotation">@interface</span> Idempotent { <span class="comment">// marker annotation</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对方面进行更改以仅重试幂等操作涉及改进切入点表达式，以便只有<code>@Idempotent</code>操作匹配，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">idempotentOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* com.xyz.myapp.service。*。*（..））和</span> <span class="content">@annotation（com.xyz.myapp.service。幂等）</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-choosing"><a class="anchor" href="#aop-choosing"></a> 5.5。选择要使用的AOP声明样式</h3>
<div class="paragraph">
<p>一旦确定某个方面是实现给定需求的最佳方法，您如何决定使用Spring AOP或AspectJ以及Aspect语言（代码）样式，@ AspectJ注释样式还是Spring XML样式？这些决策受到许多因素的影响，包括应用程序要求，开发工具和团队对AOP的熟悉程度。</p>
</div>
<div class="sect3">
<h4 id="aop-spring-or-aspectj"><a class="anchor" href="#aop-spring-or-aspectj"></a> 5.5.1。Spring AOP还是Full AspectJ？</h4>
<div class="paragraph">
<p>使用最简单的方法。Spring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器/ weaver。如果您只需要建议在Spring bean上执行操作，那么Spring AOP是正确的选择。如果需要建议不由Spring容器管理的对象（例如域对象），则需要使用AspectJ。如果您希望建议除简单方法执行之外的连接点（例如，字段获取或设置连接点等），则还需要使用AspectJ。</p>
</div>
<div class="paragraph">
<p>使用AspectJ时，您可以选择AspectJ语言语法（也称为“代码样式”）或@AspectJ注释样式。显然，如果您不使用Java 5+，则可以选择：使用代码样式。如果方面在您的设计中发挥重要作用，并且您能够使用Eclipse的<a href="http://www.eclipse.org/ajdt/">AspectJ开发工具（AJDT）</a>插件，则AspectJ语言语法是首选选项。它更清晰，更简单，因为该语言是专门为写作方面而设计的。如果您不使用Eclipse或只有几个方面在您的应用程序中不起主要作用，您可能需要考虑使用@AspectJ样式，在IDE中坚持使用常规Java编译，并添加一个方面编织阶段到你的构建脚本。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-or-xml"><a class="anchor" href="#aop-ataspectj-or-xml"></a> 5.5.2。@AspectJ或Spring for AOP的XML？</h4>
<div class="paragraph">
<p>如果您选择使用Spring AOP，则可以选择@AspectJ或XML样式。需要考虑各种权衡。</p>
</div>
<div class="paragraph">
<p>XML样式可能是现有Spring用户最熟悉的，并且由真正的POJO支持。当使用AOP作为配置企业服务的工具时，XML可能是一个不错的选择（一个好的测试是你是否认为切入点表达式是你可能想要独立改变的配置的一部分）。使用XML样式，从您的配置可以更清楚地了解系统中存在哪些方面。</p>
</div>
<div class="paragraph">
<p>XML风格有两个缺点。首先，它没有完全封装它在一个地方解决的要求的实现。DRY原则规定，系统中的任何知识都应该有单一，明确，权威的表示。使用XML样式时，有关如何实现需求的知识将分支到支持bean类的声明和配置文件中的XML。使用@AspectJ样式时，此信息封装在单个模块中：方面。其次，XML样式在它所表达的内容方面比@AspectJ样式稍微受限：仅支持“单例”方面实例化模型，并且不可能组合在XML中声明的命名切入点。例如，在@AspectJ样式中，您可以编写如下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span> （execution（* get *（））） <span class="directive">public</span> <span class="type">void</span> propertyAccess（）{} <span class="annotation">@Pointcut</span> （execution（org.xyz。账户+ *（..））
<span class="directive">public</span> <span class="type">void</span> operationReturningAnAccount（）{} <span class="annotation">@ Pointcut</span> （propertyAccess（）&amp;&amp; operationReturningAnAccount（）） <span class="directive">public</span> <span class="type">void</span> accountPropertyAccess（）{}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在XML样式中，我可以声明前两个切入点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">propertyAccess</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* get *（））</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">operationReturningAnAccount</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（org.xyz。账户+ *（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>XML方法的缺点是您无法通过组合这些定义来定义<code>accountPropertyAccess</code>切入点。</p>
</div>
<div class="paragraph">
<p>@AspectJ样式支持额外的实例化模型和更丰富的切入点组合。它具有将方面保持为模块化单元的优点。它还具有以下优点：Spring AOP和AspectJ都可以理解（并因此消耗）@AspectJ方面。因此，如果您以后决定需要AspectJ的功能来实现其他要求，则可以轻松迁移到基于AspectJ的方法。总而言之，只要您的方面不仅仅是简单的企业服务配置，Spring团队更喜欢@AspectJ风格。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-mixing-styles"><a class="anchor" href="#aop-mixing-styles"></a> 5.6。混合方面类型</h3>
<div class="paragraph">
<p>通过使用自动代理支持，模式定义的<code>&lt;aop:aspect&gt;</code>方面， <code>&lt;aop:advisor&gt;</code>声明的顾问程序，甚至是使用Spring 1.2样式定义的代理和拦截器，完全可以混合@AspectJ样式方面。组态。所有这些都是通过使用相同的底层支持机制实现的，并且可以毫无困难地共存。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-proxying"><a class="anchor" href="#aop-proxying"></a> 5.7。代理机制</h3>
<div class="paragraph">
<p>Spring AOP使用JDK动态代理或CGLIB为给定目标对象创建代理。（只要有选择，JDK动态代理就是首选）。</p>
</div>
<div class="paragraph">
<p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。目标类型实现的所有接口都是代理的。如果目标对象未实现任何接口，则会创建CGLIB代理。</p>
</div>
<div class="paragraph">
<p>如果要强制使用CGLIB代理（例如，代理为目标对象定义的每个方法，而不仅仅是那些由其接口实现的方法），您可以这样做。但是，您应该考虑以下问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无法建议<code>final</code>方法，因为它们无法被覆盖。</p>
</li>
<li>
<p>从Spring 3.2开始，不再需要将CGLIB添加到项目类路径中，因为CGLIB类在<code>org.springframework</code>下重新打包并直接包含在spring-core JAR中。这意味着基于CGLIB的代理支持“正常工作”，与JDK动态代理始终具有相同的方式。</p>
</li>
<li>
<p>从Spring 4.0开始，代理对象的构造函数不再被调用两次，因为CGLIB代理实例是通过Objenesis创建的。只有当您的JVM不允许构造函数绕过时，您才可能看到来自Spring的AOP支持的双重调用和相应的调试日志条目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要强制使用CGLIB代理，请将<code>&lt;aop:config&gt;</code>元素的<code>proxy-target-class</code>属性的值设置为true，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config</span> <span class="attribute-name">proxy-target-class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 此处定义的其他bean ...  - &gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在使用@AspectJ自动代理支持时强制CGLIB代理，请将<code>&lt;aop:aspectj-autoproxy&gt;</code>元素的<code>proxy-target-class</code>属性设置为<code>true</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspectj-autoproxy</span> <span class="attribute-name">proxy-target-class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>多个<code>&lt;aop:config/&gt;</code>部分在运行时折叠为单个统一自动代理创建器，它应用指定的任何<code>&lt;aop:config/&gt;</code>部分（通常来自不同的XML bean定义文件）的<em>最强</em>代理设置。这也适用于<code>&lt;tx:annotation-driven/&gt;</code>和<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素。</p>
</div>
<div class="paragraph">
<p>为了清楚起见，使用<code>proxy-target-class="true"</code>上<code>&lt;tx:annotation-driven/&gt;</code> <code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>&lt;aop:config/&gt;</code>元素强制<em>所有三个</em>使用CGLIB代理<em>他们</em></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-understanding-aop-proxies"><a class="anchor" href="#aop-understanding-aop-proxies"></a> 5.7.1。了解AOP代理</h4>
<div class="paragraph">
<p>Spring AOP是基于代理的。在编写自己的方面或使用Spring Framework提供的任何基于Spring AOP的方面之前，掌握最后一个语句实际意味着什么的语义是非常重要的。</p>
</div>
<div class="paragraph">
<p>首先考虑一下你有一个普通的，无代理的，没有特别关于它的直接对象引用的场景，如下面的代码片段所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SimplePojo</span> <span class="directive">实现</span> Pojo { <span class="directive">public</span> <span class="type">void</span> foo（）{ <span class="comment">//下一个方法调用是对'this'引用的直接调用</span> <span class="local-variable">this</span> .bar（）; } <span class="directive">public</span> <span class="type">void</span> bar（）{ <span class="comment">//一些逻辑......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-plain-pojo-call.png" alt="aop proxy plain pojo call">
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{Pojo pojo = <span class="keyword">new</span> SimplePojo（）; <span class="comment">//这是对'pojo'引用</span> pojo.foo（） <span class="comment">的直接方法调用</span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当客户端代码具有的引用是代理时，事情会稍微改变。请考虑以下图表和代码段：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-call.png" alt="aop代理电话">
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ProxyFactory factory = <span class="keyword">new</span> ProxyFactory（ <span class="keyword">new</span> SimplePojo（））; factory.addInterface（Pojo.class）; factory.addAdvice（ <span class="keyword">new</span> RetryAdvice（））; Pojo pojo =（Pojo）factory.getProxy（）; <span class="comment">//这是代理上的方法调用！</span>pojo.foo（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里要理解的关键是<code>Main</code>类的<code>main(..)</code>方法中的客户端代码具有对代理的引用。这意味着对该对象引用的方法调用是对代理的调用。因此，代理可以委托给与该特定方法调用相关的所有拦截器（通知）。但是，一旦调用最终到达目标对象（在这种情况下为<code>SimplePojo</code> ，引用），将调用它可能在其自身上进行的任何方法调用，例如<code>this.bar()</code>或<code>this.foo()</code> ，将被调用反对<code>this</code>参考，而不是代理。这具有重要意义。这意味着自我调用不会导致与方法调用相关的建议有机会执行。</p>
</div>
<div class="paragraph">
<p>好的，那要做些什么呢？最好的方法（术语“最好”，这里使用的松散）是重构代码，以便不会发生自我调用。这确实需要您做一些工作，但这是最好的，最少侵入性的方法。下一个方法是绝对可怕的，我们毫不犹豫地指出它，正是因为它是如此可怕。您可以（对我们来说很痛苦）将类中的逻辑完全绑定到Spring AOP，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SimplePojo</span> <span class="directive">实现</span> Pojo { <span class="directive">public</span> <span class="type">void</span> foo（）{ <span class="comment">//这个有效，但是...... gah！</span>（（Pojo）AopContext.currentProxy（））。bar（）; } <span class="directive">public</span> <span class="type">void</span> bar（）{ <span class="comment">//一些逻辑......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这完全将您的代码耦合到Spring AOP，它使类本身意识到它正在AOP上下文中使用，它在AOP面前飞行。在创建代理时，还需要一些其他配置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ProxyFactory factory = <span class="keyword">new</span> ProxyFactory（ <span class="keyword">new</span> SimplePojo（））; factory.adddInterface（Pojo.class）; factory.addAdvice（ <span class="keyword">new</span> RetryAdvice（））; factory.setExposeProxy（ <span class="predefined-constant">true</span> ）; Pojo pojo =（Pojo）factory.getProxy（）; <span class="comment">//这是代理上的方法调用！</span>pojo.foo（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，必须注意的是AspectJ没有这种自我调用问题，因为它不是基于代理的AOP框架。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-aspectj-programmatic"><a class="anchor" href="#aop-aspectj-programmatic"></a> 5.8。程序化创建@AspectJ代理</h3>
<div class="paragraph">
<p>除了使用<code>&lt;aop:config&gt;</code>或<code>&lt;aop:aspectj-autoproxy&gt;</code>在配置中声明方面之外，还可以以编程方式创建建议目标对象的代理。有关Spring的AOP API的完整详细信息，请参阅<a href="#aop-api">下一章</a> 。在这里，我们希望关注使用@AspectJ方面自动创建代理的能力。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code>类，用于为一个或多个@AspectJ方面建议的目标对象创建代理。此类的基本用法非常简单，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//创建一个可以为给定目标对象生成代理的</span>工厂AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory（targetObject）; <span class="comment">//添加一个方面，该类必须是@AspectJ方面</span> <span class="comment">//你可以根据需要多次调用它来使用不同的方面</span> factory.addAspect（ <span class="predefined-type">SecurityManager</span> .class）; <span class="comment">//你也可以添加现有的方面实例，提供的对象的类型必须是@AspectJ方面的</span>工厂.addAspect（usageTracker）; <span class="comment">//现在获取代理对象...</span>MyInterfaceType proxy = factory.getProxy（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html">Javadoc</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-using-aspectj"><a class="anchor" href="#aop-using-aspectj"></a> 5.9。在Spring应用程序中使用AspectJ</h3>
<div class="paragraph">
<p>到目前为止，我们在本章中介绍的所有内容都是纯粹的Spring AOP。在本节中，我们将介绍如何使用AspectJ compileror weaver而不是Spring AOP，或者除了Spring AOP之外，如果您的需求超出Spring AOP提供的功能。</p>
</div>
<div class="paragraph">
<p>Spring附带了一个小的AspectJ方面库，它可以作为<code>spring-aspects.jar</code>在您的发行版中独立使用。您需要将其添加到类路径中才能使用其中的方面。<a href="#aop-atconfigurable">使用AspectJ向依赖项使用Spring</a>和<a href="#aop-ajlib-other">其他Spring方面</a> <a href="#aop-atconfigurable">注入域对象</a> <a href="#aop-ajlib-other">AspectJ</a>讨论了此库的内容以及如何使用它。<a href="#aop-aj-configure">使用Spring IoC配置AspectJ方面</a>讨论如何依赖注入使用AspectJ编译器编织的AspectJ方面。最后， <a href="#aop-aj-ltw">Spring Framework</a>中使用AspectJ的加载时编织为使用AspectJ的Spring应用程序提供了加载时编织的介绍。</p>
</div>
<div class="sect3">
<h4 id="aop-atconfigurable"><a class="anchor" href="#aop-atconfigurable"></a> 5.9.1。使用AspectJ依赖于使用Spring注入域对象</h4>
<div class="paragraph">
<p>Spring容器实例化并配置在应用程序上下文中定义的bean。在给定包含要应用的配置的bean定义的名称的情况下，还可以要求bean工厂配置预先存在的对象。
<code>spring-aspects.jar</code>包含一个注释驱动的方面，利用此功能允许依赖注入任何对象。该支持旨在用于在任何容器控制之外创建的对象。域对象通常属于此类别，因为它们通常使用<code>new</code>运算符或ORM工具以编程方式创建，这是数据库查询的结果。</p>
</div>
<div class="paragraph">
<p><code>@Configurable</code>注释标记一个类符合Spring驱动配置的条件。在最简单的情况下，您可以纯粹使用它作为标记注释，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.xyz.myapp.domain</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation。可配置</span> ; <span class="annotation">@Configurable</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">Account</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当以这种方式用作标记接口时，Spring通过使用与完全限定类型名称（） <code>com.xyz.myapp.domain.同名的bean定义（通常为prototype-scoped）来配置带注释类型的新实例（在本例中为<code>Account</code> ）。 <code>com.xyz.myapp.domain.Account</code> ）。由于bean的默认名称是其类型的完全限定名称，因此声明原型定义的便捷方法是省略<code>id</code>属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.myapp.domain。帐户</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fundsTransferService</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fundsTransferService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要显式指定要使用的原型bean定义的名称，可以直接在注释中执行此操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.xyz.myapp.domain</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation。可配置</span> ; <span class="annotation">@Configurable</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">帐户</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring现在查找名为<code>account</code>的bean定义，并将其用作配置新<code>Account</code>实例的定义。</p>
</div>
<div class="paragraph">
<p>您还可以使用自动装配来避免必须指定专用的bean定义。要让Spring应用自动<code>autowire</code> ，请使用<code>@Configurable</code>批注的<code>autowire</code>属性。您可以指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或<code>@Configurable(autowire=Autowire.BY_NAME</code>分别按类型或名称进行自动装配。作为替代方案，从Spring 2.5开始，最好通过在字段或方法级别使用<code>@Autowired</code>或<code>@Inject</code>为<code>@Configurable</code> bean指定显式的，注释驱动的依赖注入（有关更多详细信息，请参阅<a href="#beans-annotation-config">基于注释的容器配置</a> ） 。</p>
</div>
<div class="paragraph">
<p>最后，您可以使用<code>dependencyCheck</code>属性为新创建和配置的对象中的对象引用启用Spring依赖项检查（例如， <code>@Configurable(autowire=Autowire. Configurable <code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code> ）。如果此属性设置为<code>true</code> ，则Spring在配置后验证是否已设置所有属性（不是基元或集合）。</p>
</div>
<div class="paragraph">
<p>请注意，使用注释本身不会做任何事情。<code>spring-aspects.jar</code>中的<code>AnnotationBeanConfigurerAspect</code>作用于注释的存在。本质上，方面说，“在从使用<code>@Configurable</code>注释的类型的新对象的初始化返回之后，根据注释的属性使用Spring配置新创建的对象”。在此上下文中，“初始化”是指新实例化的对象（例如，使用<code>new</code>运算符实例<code>Serializable</code>对象）以及正在进行反<code>Serializable</code>对象（例如，通过<a href="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">readResolve（）</a> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>上段中的一个关键短语是“实质上”。对于大多数情况，“从新对象初始化返回后”的确切语义很好。在此上下文中，“初始化之后”意味着在构造对象之后注入依赖项。这意味着依赖项不可用于类的构造函数体。如果希望在构造函数体执行之前注入依赖项，从而可以在构造函数体中使用，则需要在<code>@Configurable</code>声明中定义它，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configurable</span> （preConstruction = <span class="predefined-constant">true</span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<a href="http://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ编程指南的</a> <a href="http://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">本附录</a>中找到有关AspectJ <a href="http://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">中</a>各种切入点类型的语言语义的更多信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为此，必须使用AspectJ编织器编写带注释的类型。您可以使用构建时Ant或Maven任务来执行此操作（例如，参见<a href="http://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ开发环境指南</a> ）或加载时编织（请参阅<a href="#aop-aj-ltw">Spring Framework中使用AspectJ进行加载时编织</a> ）。<code>AnnotationBeanConfigurerAspect</code>本身需要由Spring配置（以获取对用于配置新对象的bean工厂的引用）。如果使用基于Java的配置，则可以将<code>@EnableSpringConfigured</code>添加到任何<code>@Configuration</code>类，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableSpringConfigured</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您更喜欢基于XML的配置，则Spring <a href="#xsd-schemas-context"><code>context</code>命名空间</a>定义了一个方便的<code>context:spring-configured</code>元素，您可以按如下方式使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context：spring-configured</span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在配置方面之前创建的<code>@Configurable</code>对象的实例会导致向调试日志发出消息，并且不会发生对象的配置。一个示例可能是Spring配置中的bean，它在Spring初始化时创建域对象。在这种情况下，您可以使用<code>depends-on</code> bean属性手动指定bean依赖于配置方面。以下示例显示了如何使用<code>depends-on</code>属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xzy.myapp.service。MyService</span> <span class="delimiter">“</span></span> <span class="attribute-name">depends-on</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans.factory.aspectj。AnnotationBeanConfigurerAspect</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不要通过bean配置器方面激活<code>@Configurable</code>处理，除非你真的想在运行时依赖它的语义。特别是，请确保不要对使用容器注册为常规Spring bean的bean类使用<code>@Configurable</code> 。这样做会导致双重初始化，一次通过容器，一次通过方面。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="aop-configurable-testing"><a class="anchor" href="#aop-configurable-testing"></a>单元测试<code>@Configurable</code> Objects</h5>
<div class="paragraph">
<p><code>@Configurable</code>支持的目标之一是启用域对象的独立单元测试，而不会遇到与硬编码查找相关的困难。如果AspectJ没有<code>@Configurable</code>类型，则注释在单元测试期间没有影响。您可以在测试对象中设置模拟或存根属性引用，并照常进行。如果AspectJ <code>@Configurable</code>类型，您仍然可以正常地在容器外部进行单元测试，但每次构造一个<code>@Configurable</code>对象时都会看到一条警告消息，表明它尚未由Spring配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-configurable-container"><a class="anchor" href="#aop-configurable-container"></a>使用多个应用程序上下文</h5>
<div class="paragraph">
<p>用于实现<code>@Configurable</code>支持的<code>AnnotationBeanConfigurerAspect</code>是AspectJ单例方面。单例方面的范围与<code>static</code>成员的范围相同：每个类加载器有一个方面实例，用于定义类型。这意味着，如果在同一个类加载器层次结构中定义多个应用程序上下文，则需要考虑在哪里定义<code>@EnableSpringConfigured</code> bean以及将<code>spring-aspects.jar</code>放在类路径上的位置。</p>
</div>
<div class="paragraph">
<p>考虑一个典型的Spring Web应用程序配置，它具有共享的父应用程序上下文，它定义了公共业务服务，支持这些服务所需的一切，以及每个servlet的一个子应用程序上下文（包含特定于该servlet的定义）。所有这些上下文共存于同一个类加载器层次结构中，因此<code>AnnotationBeanConfigurerAspect</code>只能包含对其中一个的引用。在这种情况下，我们建议在共享（父）应用程序上下文中定义<code>@EnableSpringConfigured</code> bean。这定义了您可能希望注入域对象的服务。结果是，您无法使用@Configurable机制（可能不是您想要执行的操作）来配置域对象，并引用对子（特定于servlet的）上下文中定义的bean。</p>
</div>
<div class="paragraph">
<p>在同一容器中部署多个Web应用程序时，请确保每个Web应用程序使用自己的类加载器加载<code>spring-aspects.jar</code>的类型（例如，将<code>spring-aspects.jar</code>放在<code>'WEB-INF/lib'</code> ）。如果<code>spring-aspects.jar</code>仅添加到容器范围的类路径中（因此由共享父类加载器加载），则所有Web应用程序共享相同的方面实例（可能不是您想要的）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ajlib-other"><a class="anchor" href="#aop-ajlib-other"></a> 5.9.2。AspectJ的其他Spring方面</h4>
<div class="paragraph">
<p>除了<code>@Configurable</code>方面， <code>spring-aspects.jar</code>包含一个AspectJ方面，您可以使用它来为使用<code>@Transactional</code>注释注释的类型和方法驱动Spring的事务管理。这主要适用于希望在Spring容器之外使用Spring Framework的事务支持的用户。</p>
</div>
<div class="paragraph">
<p>解释<code>@Transactional</code>注释的方面是<code>AnnotationTransactionAspect</code> 。使用此方面时，必须注释实现类（或该类中的方法或两者），而不是类实现的接口（如果有）。AspectJ遵循Java的规则，即接口上的注释不会被继承。</p>
</div>
<div class="paragraph">
<p>类上的<code>@Transactional</code>注释指定了在类中执行任何公共操作的默认事务语义。</p>
</div>
<div class="paragraph">
<p>类中方法的<code>@Transactional</code>注释会覆盖类注释（如果存在）给出的默认事务语义。可以注释任何可见性的方法，包括私有方法。直接注释非公共方法是获得执行此类方法的事务划分的唯一方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring Framework 4.2开始， <code>spring-aspects</code>提供了类似的方面，为标准的<code>javax.transaction.提供了完全相同的功能<code>javax.transaction.Transactional</code>注释。检查<code>JtaAnnotationTransactionAspect</code>以获取更多详细信息。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于想要使用Spring配置和事务管理支持但不想（或不能）使用注释的AspectJ程序员， <code>spring-aspects.jar</code>还包含可以扩展以提供自己的切入点定义的<code>abstract</code>方面。有关更多信息，请参阅<code>AbstractBeanConfigurerAspect</code>和<code>AbstractTransactionAspect</code>方面的源代码。作为示例，以下摘录显示了如何编写方面来配置域模型中定义的所有对象实例，方法是使用与完全限定类名匹配的原型bean定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect DomainObjectConfiguration <span class="directive">扩展</span> AbstractBeanConfigurerAspect { <span class="directive">public</span> DomainObjectConfiguration（）{setBeanWiringInfoResolver（ <span class="keyword">new</span> ClassNameBeanWiringInfoResolver（））; } <span class="comment">//创建一个新bean（域模型中的任何对象）</span> <span class="directive">protected</span> pointcut beanCreation（ <span class="predefined-type">Object</span> beanInstance）：initialization（ <span class="keyword">new</span> （..））&amp;&amp; SystemArchitecture.inDomainModel（）&amp;&amp; <span class="local-variable">this</span> （beanInstance）; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-configure"><a class="anchor" href="#aop-aj-configure"></a> 5.9.3。使用Spring IoC配置AspectJ方面</h4>
<div class="paragraph">
<p>当您在Spring应用程序中使用AspectJ方面时，很自然地希望并期望能够使用Spring配置这些方面。AspectJ运行时本身负责方面创建，并且通过Spring配置AspectJ创建方面的方法取决于方面使用的AspectJ实例化模型（ <code>per-xxx</code>子句）。</p>
</div>
<div class="paragraph">
<p>AspectJ的大多数方面都是单例方面。这些方面的配置很容易。您可以创建一个正常引用方面类型的bean定义，并包含<code>factory-method="aspectOf"</code> bean属性。这可以确保Spring通过询问AspectJ来获取方面实例，而不是尝试创建实例本身。以下示例显示如何使用<code>factory-method="aspectOf"</code>属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">profiler</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.xyz.profiler。Profiler</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">aspectOf</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">profilingStrategy</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jamonProfilingStrategy</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>请注意<code>factory-method="aspectOf"</code>属性</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>非单身方面更难配置。但是，可以通过创建原型bean定义并使用<code>spring-aspects.jar</code>的<code>@Configurable</code>支持来配置方面实例（一旦它们具有由AspectJ运行时创建的bean）。</p>
</div>
<div class="paragraph">
<p>如果您想要使用AspectJ编写一些@AspectJ方面（例如，使用域模型类型的加载时编织）和其他要与Spring AOP一起使用的@AspectJ方面，并且这些方面都在Spring中配置，您需要告诉Spring AOP @AspectJ自动代理支持，配置中定义的@AspectJ方面的确切子集应该用于自动代理。您可以通过在<code>&lt;aop:aspectj-autoproxy/&gt;</code>声明中使用一个或多个<code>&lt;include/&gt;</code>元素来完成此操作。每个<code>&lt;include/&gt;</code>元素指定一个名称模式，并且只有名称与至少一个模式匹配的bean才会用于Spring AOP自动代理配置。以下示例显示了如何使用<code>&lt;include/&gt;</code>元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：aspectj-autoproxy&gt;</span> <span class="tag">&lt;aop：include</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thisBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：include</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">thatBean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：aspectj-autoproxy&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不要被<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素的名称误导。使用它会导致创建Spring AOP代理。这里使用@AspectJ样式的方面声明，但不涉及AspectJ运行时。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw"><a class="anchor" href="#aop-aj-ltw"></a> 5.9.4。在Spring框架中使用AspectJ进行加载时编织</h4>
<div class="paragraph">
<p>加载时编织（LTW）是指在将AspectJ方面加载到Java虚拟机（JVM）中时将其编织到应用程序的类文件中的过程。本节的重点是在Spring Framework的特定上下文中配置和使用LTW。本节不是对LTW的一般性介绍。有关LTW细节的详细信息以及仅使用AspectJ配置LTW（完全不涉及Spring），请参阅<a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">AspectJ开发环境指南</a>的<a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">LTW部分</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Framework为AspectJ LTW带来的价值在于对编织过程进行更精细的控制。“Vanilla”AspectJ LTW通过使用Java（5+）代理来实现，该代理通过在启动JVM时指定VM参数来启用。因此，它是一个JVM范围的设置，在某些情况下可能很好，但通常有点过于粗糙。支持Spring的LTW允许您在基于每个<code>ClassLoader</code>基础上打开LTW，这更精细，并且在“单JVM多应用程序”环境中更有意义（例如在典型的应用程序服务器中找到的）环境）。</p>
</div>
<div class="paragraph">
<p>此外， <a href="#aop-aj-ltw-environments">在某些环境中</a> ，此支持可实现加载时编织，而无需对添加<code>-javaagent:path/to/aspectjweaver.jar</code>或（如本节后面部分所述） <code>-javaagent:path/to/org.springframework.instrument-{version}.jar</code>所需的应用程序服务器的启动脚本进行任何修改。 <code>-javaagent:path/to/org.springframework.instrument-{version}.jar</code> （以前名为<code>spring-agent.jar</code> ）。开发人员修改构成应用程序上下文的一个或多个文件以启用加载时编织，而不是依赖于通常负责部署配置的管理员，例如启动脚本。</p>
</div>
<div class="paragraph">
<p>既然销售情况已经结束，那么让我们首先介绍使用Spring的AspectJ LTW的快速示例，然后详细介绍示例中介绍的元素。有关完整示例，请参阅<a href="https://github.com/spring-projects/spring-petclinic">Petclinic示例应用程序</a> 。</p>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-first-example"><a class="anchor" href="#aop-aj-ltw-first-example"></a>第一个例子</h5>
<div class="paragraph">
<p>假设您是一名应用程序开发人员，负责诊断系统中某些性能问题的原因。我们将打开一个简单的分析方面，让我们快速获得一些性能指标，而不是打破分析工具。然后，我们可以在之后立即对该特定区域应用更精细的分析工具。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此处提供的示例使用XML配置。您还可以使用<a href="#beans-java">Java配置</a>配置和使用@AspectJ。具体来说，您可以使用<code>@EnableLoadTimeWeaving</code>批注作为<code>&lt;context:load-time-weaver/&gt;</code>的替代方法（详见<a href="#aop-aj-ltw-spring">下文</a> ）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示了分析方面，这不是花哨 - 它是一个基于时间的分析器，它使用@ AspectJ样式的方面声明：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">foo</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang。ProceedingJoinPoint</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。方面</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。周围</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation。切入点</span> ; <span class="keyword">import</span> <span class="include">org.springframework.util。秒表</span> ; <span class="keyword">import</span> <span class="include">org.springframework.core.annotation。订单</span> ; <span class="annotation">@Aspect</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ProfilingAspect</span> { <span class="annotation">@Around</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">methodsToBeProfiled（）</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">Object</span> profile（ProceedingJoinPoint pjp） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {StopWatch sw = <span class="keyword">new</span> StopWatch（getClass（）。getSimpleName（））; <span class="keyword">try</span> {sw.start（pjp.getSignature（）。getName（））; <span class="keyword">return</span> pjp.proceed（）; } <span class="keyword">finally</span> {sw.stop（）; <span class="predefined-type">System</span> .out.println（sw.prettyPrint（））; <span class="annotation">@Pointcut</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">执行（public * foo ..*。*（..））</span> <span class="delimiter">“</span></span> ） <span class="directive">public</span> <span class="type">void</span> methodsToBeProfiled（）{}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还需要创建一个<code>META-INF/aop.xml</code>文件，以通知AspectJ weaver我们想要将<code>ProfilingAspect</code>编织到我们的类中。此文件约定，即在Java类路径中存在名为<code>META-INF/aop.xml</code>的文件（或多个文件）是标准AspectJ。以下示例显示了<code>aop.xml</code>文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="doctype">&lt;！DOCTYPE aspectj PUBLIC“ -  // AspectJ // DTD // EN”“http://www.eclipse.org/aspectj/dtd/aspectj.dtd”&gt;</span> <span class="tag">&lt;aspectj&gt;</span> <span class="tag">&lt;weaver&gt;</span> <span class="comment">&lt;！ - 只编织我们的类特定</span> <span class="attribute-name">于</span> <span class="comment">应用程序的包 - &gt;</span> <span class="tag">&lt;include</span> <span class="attribute-name">within</span> = <span class="string"><span class="delimiter">“</span> <span class="content">foo。*</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ weaver&gt;</span> <span class="tag">&lt;aspects&gt;</span> <span class="comment">&lt;！ - 在这方面编织 - &gt;</span> <span class="tag">&lt;aspect</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">foo。ProfilingAspect</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aspects&gt;</span> <span class="tag">&lt;/ aspectj&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们可以继续进行配置的Spring特定部分。我们需要配置<code>LoadTimeWeaver</code> （稍后解释）。此加载时weaver是负责将一个或多个<code>META-INF/aop.xml</code>文件中的方面配置编织到应用程序的类中的基本组件。好处是它不需要很多配置（您可以指定更多选项，但稍后会对这些选项进行详细说明），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 服务对象;我们将分析它的方法 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">entitlementCalculationService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">foo。StubEntitlementCalculationService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 这会打开加载时编织 - &gt;</span> <strong><span class="tag">&lt;context：load-time-weaver</span> <span class="tag">/&gt;</span></strong> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在所有必需的工件（方面， <code>META-INF/aop.xml</code>文件和Spring配置）都已到位，我们可以使用<code>main(..)</code>方法创建以下驱动程序类，以演示LTW的运行情况：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Main</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ，Main.class）; EntitlementCalculationService entitlementCalculationService =（EntitlementCalculationService）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">entitlementCalculationService</span> <span class="delimiter">”</span></span> ）; <span class="comment">//这个方法执行</span>权利-CalculationService.calculateEntitlement（）; <span class="comment">该分析方面是“编织”的</span> 。 }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还有最后一件事要做。本节的介绍确实说可以用Spring在每个<code>ClassLoader</code>基础上选择性地打开LTW，这是事实。但是，对于此示例，我们使用Java代理（随Spring提供）来打开LTW。我们使用folloiwng命令来运行前面显示的<code>Main</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>java -javaagent：C：/projects/foo/lib/global/spring-instrument.jar foo。主要</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>-javaagent</code>是一个标志，用于指定和启用<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理程序来检测在JVM上运行的程序</a> 。 Spring Framework附带了一个代理程序<code>InstrumentationSavingAgent</code> ，它包装在<code>spring-instrument.jar</code> ，它作为前面示例中<code>-javaagent</code>参数的值提供。</p>
</div>
<div class="paragraph">
<p>执行<code>Main</code>程序的输出类似于下一个示例。（我在<code>calculateEntitlement()</code>实现中引入了一个<code>Thread.sleep(..)</code>语句，以便探查器实际捕获0毫秒以外的东西（ <code>01234</code>毫秒不是AOP引入的开销）。以下清单显示了运行探查器时得到的输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>计算权利StopWatch'ProfilingAspect'：运行时间（毫秒）= 1234 ------ ----- ------------------------- --- ms％任务名称------ ----- ---------------------------- 01234 100％calculateEntitlement</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于LTW是通过使用成熟的AspectJ实现的，因此我们不仅限于为Spring bean提供建议。<code>Main</code>的以下细微变化产生相同的结果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Main</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ，Main.class）; EntitlementCalculationService entitlementCalculationService = <span class="keyword">new</span> StubEntitlementCalculationService（）; <span class="comment">//这个方法执行</span>权利-CalculationService.calculateEntitlement（）; <span class="comment">该分析方面将被“编织”</span> 。 }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，在前面的程序中，我们如何引导Spring容器，然后在Spring的上下文之外创建一个新的<code>StubEntitlementCalculationService</code>实例。剖析建议仍在编织中。</p>
</div>
<div class="paragraph">
<p>不可否认，这个例子很简单。但是，Spring中LTW支持的基础知识已在前面的示例中引入，本节的其余部分详细说明了每个配置和使用位置背后的“原因”。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本例中使用的<code>ProfilingAspect</code>可能是基本的，但它非常有用。这是开发人员在开发期间可以使用的开发时间方面的一个很好的示例，然后可以轻松地从部署到UAT或生产中的应用程序的构建中排除。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-the-aspects"><a class="anchor" href="#aop-aj-ltw-the-aspects"></a>方面</h5>
<div class="paragraph">
<p>您在LTW中使用的方面必须是AspectJ方面。您可以使用AspectJ语言本身编写它们，也可以使用@ AspectJ样式编写方面。那么你的方面都是有效的AspectJ和Spring AOP方面。此外，编译的方面类需要在类路径上可用。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-aop_dot_xml"><a class="anchor" href="#aop-aj-ltw-aop_dot_xml"></a> 'META-INF / aop.xml文件'</h5>
<div class="paragraph">
<p>通过使用Java类路径上的一个或多个<code>META-INF/aop.xml</code>文件（直接或更常见地，在jar文件中）配置AspectJ LTW基础结构。</p>
</div>
<div class="paragraph">
<p>LTW部分<a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ参考文档中</a>详细介绍了此文件的结构和内容。因为aop.xml文件是100％AspectJ，所以我们不会在这里进一步描述。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-libraries"><a class="anchor" href="#aop-aj-ltw-libraries"></a>必需的库（JARS）</h5>
<div class="paragraph">
<p>至少，您需要以下库来使用Spring Framework对AspectJ LTW的支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-aop.jar</code> （版本2.5或更高版本，加上所有必需的依赖项）</p>
</li>
<li>
<p><code>aspectjweaver.jar</code> （版本1.6.8或更高版本）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果使用<a href="#aop-aj-ltw-environment-generic">Spring提供的代理来启用检测</a> ，则还需要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>弹簧instrument.jar</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-spring"><a class="anchor" href="#aop-aj-ltw-spring"></a>弹簧配置</h5>
<div class="paragraph">
<p>Spring的LTW支持的关键组件是<code>LoadTimeWeaver</code>接口（在<code>org.springframework.instrument.classloading</code>包中），以及随Spring发行版一起提供的众多实现。<code>LoadTimeWeaver</code>负责添加一个或多个<code>java.lang.instrument.ClassFileTransformers</code>在运行时运行到<code>ClassLoader</code> ，它为各种有趣的应用程序打开了大门，其中一个恰好是方面的LTW。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您不熟悉运行时类文件转换的概念，请在继续之前查看<code>java.lang.instrument</code>包的Javadoc API文档。虽然该文档并不全面，但至少可以看到关键接口和类（供您阅读本节时参考）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为特定的<code>ApplicationContext</code>配置<code>LoadTimeWeaver</code>就像添加一行一样简单。（请注意，您几乎肯定需要使用<code>ApplicationContext</code>作为Spring容器 - 通常， <code>BeanFactory</code>是不够的，因为LTW支持使用<code>BeanFactoryPostProcessors</code> 。）</p>
</div>
<div class="paragraph">
<p>要启用Spring Framework的LTW支持，您需要配置<code>LoadTimeWeaver</code> ，通常使用<code>@EnableLoadTimeWeaving</code>批注来完成，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableLoadTimeWeaving</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果您更喜欢基于XML的配置，请使用<code>&lt;context:load-time-weaver/&gt;</code>元素。请注意，元素是在<code>context</code>命名空间中定义的。以下示例显示如何使用<code>&lt;context:load-time-weaver/&gt;</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：load-time-weaver</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置会自动为您定义和注册许多LTW特定的基础结构bean，例如<code>LoadTimeWeaver</code>和<code>AspectJWeavingEnabler</code> 。默认的<code>LoadTimeWeaver</code>是<code>DefaultContextLoadTimeWeaver</code>类，它尝试装饰自动检测到的<code>LoadTimeWeaver</code> 。“自动检测”的<code>LoadTimeWeaver</code>的确切类型取决于您的运行时环境。下表总结了各种<code>LoadTimeWeaver</code>实现：</p>
</div>
<table id="aop-aj-ltw-spring-env-impls" class="tableblock frame-all grid-all spread">
<caption class="title">表13。DefaultContextLoadTimeWeaver LoadTimeWeavers</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">运行环境</th>
<th class="tableblock halign-left valign-top"><code>LoadTimeWeaver</code>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Oracle的<a href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebLogicLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Oracle的<a href="http://glassfish.dev.java.net/">GlassFish中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GlassFishLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在<a href="http://tomcat.apache.org/">Apache Tomcat中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Red Hat的<a href="http://www.jboss.org/jbossas/">JBoss AS</a>或<a href="http://www.wildfly.org/">WildFly中运行</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JBossLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在IBM的<a href="http://www-01.ibm.com/software/webservers/appserv/was/">WebSphere中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSphereLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JVM以Spring <code>InstrumentationSavingAgent</code>开头（ <code>java -javaagent:path/to/spring-instrument.jar</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InstrumentationLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">后备，期望底层的ClassLoader遵循常见的约定（例如适用于<code>TomcatInstrumentableClassLoader</code>和<a href="http://www.caucho.com/">Resin</a> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveLoadTimeWeaver</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，该表仅列出使用<code>DefaultContextLoadTimeWeaver</code>时自动检测的<code>LoadTimeWeavers</code> 。您可以准确指定要使用的<code>LoadTimeWeaver</code>实现。</p>
</div>
<div class="paragraph">
<p>要使用Java配置指定特定的<code>LoadTimeWeaver</code> ，请实现<code>LoadTimeWeavingConfigurer</code>接口并覆盖<code>getLoadTimeWeaver()</code>方法。以下示例指定<code>ReflectiveLoadTimeWeaver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableLoadTimeWeaving</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">的AppConfig</span> <span class="directive">实现</span> LoadTimeWeavingConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span>的LoadTimeWeaver getLoadTimeWeaver（）{ <span class="keyword">返回</span> <span class="keyword">新</span> ReflectiveLoadTimeWeaver（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用基于XML的配置，则可以将完全限定的类名指定为<code>&lt;context:load-time-weaver/&gt;</code>元素上的<code>weaver-class</code>属性的值。同样，以下示例指定了<code>ReflectiveLoadTimeWeaver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;context：load-time-weaver</span> <span class="attribute-name">weaver-class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.instrument。类加载。ReflectiveLoadTimeWeaver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>稍后可以使用众所周知的名称<code>loadTimeWeaver</code>从Spring容器中检索由配置定义和注册的<code>LoadTimeWeaver</code> 。请记住， <code>LoadTimeWeaver</code>仅作为Spring的LTW基础结构添加一个或多个<code>ClassFileTransformers</code>的机制存在。执行LTW的实际<code>ClassFileTransformer</code>是<code>ClassPreProcessorAgentAdapter</code> （来自<code>org.aspectj.weaver.loadtime</code>包）类。有关详细信息，请参阅<code>ClassPreProcessorAgentAdapter</code>类的类级Javadoc，因为编织实际如何实现的细节超出了本文档的范围。</p>
</div>
<div class="paragraph">
<p>剩下要讨论的配置有一个最终属性： <code>aspectjWeaving</code>属性（如果使用XML， <code>aspectjWeaving</code> <code>aspectj-weaving</code> ）。此属性控制是否启用LTW。它接受三个可能值中的一个，如果该属性不存在，则默认值为<code>autodetect</code> 。下表总结了三个可能的值：</p>
</div>
<table id="aop-aj-ltw-ltw-tag-attrs" class="tableblock frame-all grid-all spread">
<caption class="title">表14。AspectJ编织属性值</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注释值</th>
<th class="tableblock halign-left valign-top">XML值</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>启用</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>上</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ编织开启，方面在加载时编织。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>禁用</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>离</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTW已关闭。没有方面是在加载时编织的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>自动侦测</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>自动侦测</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果Spring LTW基础结构可以找到至少一个<code>META-INF/aop.xml</code>文件，那么AspectJ编织就会打开。否则，它关闭。这是默认值。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments"><a class="anchor" href="#aop-aj-ltw-environments"></a>特定于环境的配置</h5>
<div class="paragraph">
<p>最后一节包含在应用程序服务器和Web容器等环境中使用Spring的LTW支持时所需的任何其他设置和配置。</p>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environment-tomcat"><a class="anchor" href="#aop-aj-ltw-environment-tomcat"></a> Tomcat的</h6>
<div class="paragraph">
<p>从历史上看， <a href="http://tomcat.apache.org/">Apache Tomcat</a>的默认类加载器不支持类转换，这就是Spring提供满足此需求的增强实现的原因。命名为<code>TomcatInstrumentableClassLoader</code> ，加载程序适用于Tomcat 6.0及更高版本。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">不要在Tomcat 8.0及更高<code>TomcatInstrumentableClassLoader</code>上定义<code>TomcatInstrumentableClassLoader</code> 。相反，让Spring通过<code>TomcatLoadTimeWeaver</code>策略自动使用Tomcat的新本机<code>InstrumentableClassLoader</code>工具。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果仍需要使用<code>TomcatInstrumentableClassLoader</code> ，则可以为每个Web应用程序单独注册，如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将<code>org.springframework.instrument.tomcat.jar</code>复制到<code>$CATALINA_HOME/lib</code> ，其中<code>$CATALINA_HOME</code>表示Tomcat安装的根目录</p>
</li>
<li>
<p>通过编辑Web应用程序上下文文件，指示Tomcat使用自定义类加载器（而不是默认值），如以下示例所示：</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;Context</span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ myWebApp</span> <span class="delimiter">”</span></span> <span class="attribute-name">docBase</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ my / webApp / location</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;Loader</span> <span class="attribute-name">loaderClass</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.instrument.classloading.tomcat。TomcatInstrumentableClassLoader</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ Context&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Apache Tomcat 6.0+支持多个上下文位置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务器配置文件： <code>$CATALINA_HOME/conf/server.xml</code></p>
</li>
<li>
<p>默认上下文配置： <code>$CATALINA_HOME/conf/context.xml</code> ，它影响所有已部署的Web应用程序</p>
</li>
<li>
<p>每个Web应用程序配置，可以在服务器端部署在<code>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</code>也可以嵌入在<code>META-INF/context.xml</code>的Web应用程序存档中<code>META-INF/context.xml</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了提高效率，我们建议使用嵌入式每Web应用程序配置样式，因为它仅影响使用自定义类加载器的应用程序，并且不需要对服务器配置进行任何更改。有关可用上下文位置的更多详细信息，请参阅Tomcat 6.0.x <a href="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html">文档</a> 。</p>
</div>
<div class="paragraph">
<p>或者，考虑使用Spring提供的通用VM代理，在Tomcat的启动脚本中指定（在本节前面介绍过）。这使得检测可用于所有已部署的Web应用程序，无论它们恰好运行在哪个<code>ClassLoader</code>上。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"><a class="anchor" href="#aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"></a> WebLogic，WebSphere，Resin，GlassFish和JBoss</h6>
<div class="paragraph">
<p>最新版本的WebLogic Server（版本10及更高版本），IBM WebSphere Application Server（版本7及更高版本），Resin（版本3.1及更高版本）和JBoss（版本6.x或更高版本）提供了一个能够进行本地检测的<code>ClassLoader</code> 。Spring的原生LTW利用这种ClassLoader实现来实现AspectJ编织。<a href="#aop-using-aspectj">如前所述</a> ，您可以通过激活加载时编织来启用LTW。具体来说，您无需修改​​启动脚本即可添加<code>-javaagent:path/to/spring-instrument.jar</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，支持GlassFish检测的<code>ClassLoader</code>仅在其EAR环境中可用。对于GlassFish Web应用程序，请遵循<a href="#aop-aj-ltw-environment-tomcat">前面概述</a>的Tomcat设置说明。</p>
</div>
<div class="paragraph">
<p>请注意，在JBoss 6.x上，您需要禁用应用服务器扫描，以防止它在应用程序实际启动之前加载类。一个快速的解决方法是向您的工件添加一个名为<code>WEB-INF/jboss-scanning.xml</code>其中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;scanning</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">urn：jboss：scanning：1.0</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environment-generic"><a class="anchor" href="#aop-aj-ltw-environment-generic"></a>通用Java应用程序</h6>
<div class="paragraph">
<p>如果在不支持或不支持现有<code>LoadTimeWeaver</code>实现的环境中需要类检测，则JDK代理可以是唯一的解决方案。对于这种情况，Spring提供了<code>InstrumentationLoadTimeWeaver</code> ，它需要一个特定于Spring的（但非常通用的）VM代理， <code>org.springframework.instrument-{version}.jar</code> （以前称为<code>spring-agent.jar</code> ）。</p>
</div>
<div class="paragraph">
<p>要使用它，必须通过提供以下JVM选项来启动具有Spring代理的虚拟机：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>-javaagent：/path/to/org.springframework.instrument- {}版本的.jar</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，这需要修改VM启动脚本，这可能会阻止您在应用程序服务器环境中使用它（具体取决于您的操作策略）。此外，JDK代理可以检测整个VM，这可能很昂贵。</p>
</div>
<div class="paragraph">
<p>出于性能原因，我们建议您仅在目标环境（例如<a href="http://www.eclipse.org/jetty/">Jetty</a> ）没有（或不支持）专用LTW时才使用此配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-resources"><a class="anchor" href="#aop-resources"></a> 5.10。更多资源</h3>
<div class="paragraph">
<p>有关AspectJ的更多信息可以在<a href="http://www.eclipse.org/aspectj">AspectJ网站</a>上找到。</p>
</div>
<div class="paragraph">
<p><em>Eclipse AspectJ</em>由Adrian Colyer等人。人。（Addison-Wesley，2005）为AspectJ语言提供了全面的介绍和参考。</p>
</div>
<div class="paragraph">
<p><em>AspectJ in Action</em> ，第二版由Ramnivas Laddad（Manning，2009）强烈推荐。本书的重点是AspectJ，但是很多一般的AOP主题都在探索中（在某种程度上）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api"><a class="anchor" href="#aop-api"></a> 6。Spring AOP API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前一章描述了Spring使用@AspectJ和基于模式的方面定义对AOP的支持。在本章中，我们将讨论较低级别的Spring AOP API以及Spring 1.2应用程序中常用的AOP支持。对于新应用程序，我们建议使用前一章中描述的Spring 2.0及更高版本的AOP支持。但是，当您使用现有应用程序时（或者当您阅读书籍和文章时），您可能会遇到Spring 1.2风格的示例。Spring 5仍然向后兼容Spring 1.2，本章中描述的所有内容在Spring 5中都得到了完全支持。</p>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts"><a class="anchor" href="#aop-api-pointcuts"></a> 6.1。Spring中的Pointcut API</h3>
<div class="paragraph">
<p>本节描述了Spring如何处理关键的切入点概念。</p>
</div>
<div class="sect3">
<h4 id="aop-api-concepts"><a class="anchor" href="#aop-api-concepts"></a> 6.1.1。概念</h4>
<div class="paragraph">
<p>Spring的切入点模型使切入点重用独立于建议类型。您可以使用相同的切入点来定位不同的建议。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.aop.Pointcut</code>接口是中央接口，用于将建议定位到特定的类和方法。完整的界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Pointcut</span> {ClassFilter getClassFilter（）; MethodMatcher getMethodMatcher（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将<code>Pointcut</code>接口拆分为两部分允许重用类和方法匹配部分以及细粒度合成操作（例如与另一个方法匹配器执行“联合”）。</p>
</div>
<div class="paragraph">
<p><code>ClassFilter</code>接口用于将切入点限制为给定的一组目标类。如果<code>matches()</code>方法始终返回true，则匹配所有目标类。以下清单显示了<code>ClassFilter</code>接口定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ClassFilter</span> { <span class="type">boolean</span> matches（ <span class="predefined-type">Class</span> clazz）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>MethodMatcher</code>接口通常更重要。完整的界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodMatcher</span> { <span class="type">boolean</span> matches（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Class</span> targetClass）; <span class="type">boolean</span> isRuntime（）; <span class="type">boolean</span> matches（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Class</span> targetClass， <span class="predefined-type">Object</span> <span class="type">[]</span> args）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>matches(Method, Class)</code>方法用于测试此切入点是否与目标类上的给定方法匹配。可以在创建AOP代理时执行此评估，以避免需要对每个方法调用进行测试。如果双参数<code>matches</code>方法对给定方法返回<code>true</code> ，并且<code>isRuntime()</code>方法返回<code>true</code> ，则在每次方法调用时都会调用三参数匹配方法。这使得切入点可以在执行目标通知之前立即查看传递给方法调用的参数。</p>
</div>
<div class="paragraph">
<p>大多数<code>MethodMatcher</code>实现都是静态的，这意味着它们的<code>isRuntime()</code>方法返回<code>false</code> 。在这种情况下，永远不会调用三参数<code>matches</code>方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果可能，尝试使切入点成为静态，允许AOP框架在创建AOP代理时缓存切入点评估的结果。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcut-ops"><a class="anchor" href="#aop-api-pointcut-ops"></a> 6.1.2。切入点的操作</h4>
<div class="paragraph">
<p>Spring支持切入点上的操作（特别是联合和交叉）。</p>
</div>
<div class="paragraph">
<p>Union表示切入点匹配的方法。交叉表示两个切入点匹配的方法。联盟通常更有用。您可以使用<code>org.springframework.aop.support.的静态方法来编译切入点<code>org.springframework.aop.support.Pointcuts</code>类或在同一个包中使用<code>ComposablePointcut</code>类。但是，使用AspectJ切入点表达式通常是一种更简单的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-aspectj"><a class="anchor" href="#aop-api-pointcuts-aspectj"></a> 6.1.3。AspectJ表达式切入点</h4>
<div class="paragraph">
<p>从2.0开始，Spring使用的最重要的切入点类型是<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code> 。这是一个切入点，它使用AspectJ提供的库来解析AspectJ切入点表达式字符串。</p>
</div>
<div class="paragraph">
<p>有关受支持的AspectJ切入点基元的讨论，请参见<a href="#aop">上一章</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-impls"><a class="anchor" href="#aop-api-pointcuts-impls"></a> 6.1.4。便利切入点实现</h4>
<div class="paragraph">
<p>Spring提供了几种方便的切入点实现。您可以直接使用其中一些。其他的目的是在特定于应用程序的切入点中进行子类化。</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-static"><a class="anchor" href="#aop-api-pointcuts-static"></a>静态切入点</h5>
<div class="paragraph">
<p>静态切入点基于方法和目标类，不能考虑方法的参数。对于大多数用途，静态切入点足够 - 并且是最好的。当首次调用方法时，Spring只能评估一次静态切入点。之后，无需再次使用每个方法调用来评估切入点。</p>
</div>
<div class="paragraph">
<p>本节的其余部分描述了Spring中包含的一些静态切入点实现。</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-regex"><a class="anchor" href="#aop-api-pointcuts-regex"></a>正则表达式切入点</h6>
<div class="paragraph">
<p>指定静态切入点的一种显而易见的方法是正则表达式。除Spring之外的几个AOP框架使这成为可能。
<code>org.springframework.aop.support。JdkRegexpMethodPointcut</code>是一个通用的正则表达式切入点，它使用JDK中的正则表达式支持。</p>
</div>
<div class="paragraph">
<p>使用<code>JdkRegexpMethodPointcut</code>类，您可以提供模式字符串列表。如果其中任何一个匹配，则切入点评估为<code>true</code> 。（因此，结果实际上是这些切入点的结合。）</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>JdkRegexpMethodPointcut</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">settersAndAbsquatulatePointcut</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.support。JdkRegexpMethodPointcut</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">patterns</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> 。* set。* <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> 。* absquatulate <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring提供了一个名为<code>RegexpMethodPointcutAdvisor</code>的便利类，它允许我们引用一个<code>Advice</code> （记住<code>Advice</code>可以是一个拦截器，建议之前，抛出建议等）。在幕后，Spring使用了<code>JdkRegexpMethodPointcut</code> 。使用<code>RegexpMethodPointcutAdvisor</code>简化了布线，因为一个bean封装了切入点和建议，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">settersAndAbsquatulateAdvisor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.support。RegexpMethodPointcutAdvisor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">advice</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beanNameOfAopAllianceInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">patterns</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> 。* set。* <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> 。* absquatulate <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以将<code>RegexpMethodPointcutAdvisor</code>与任何<code>Advice</code>类型一起使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-attribute-driven"><a class="anchor" href="#aop-api-pointcuts-attribute-driven"></a>属性驱动的切入点</h6>
<div class="paragraph">
<p>一种重要的静态切入点是元数据驱动的切入点。这使用元数据属性的值（通常是源级元数据）。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-dynamic"><a class="anchor" href="#aop-api-pointcuts-dynamic"></a>动态切入点</h5>
<div class="paragraph">
<p>与静态切入点相比，动态切入点的评估成本更高。它们考虑了方法参数和静态信息。这意味着必须使用每个方法调用来评估它们，并且不能缓存结果，因为参数会有所不同。</p>
</div>
<div class="paragraph">
<p>主要的例子是<code>control flow</code>切入点。</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-cflow"><a class="anchor" href="#aop-api-pointcuts-cflow"></a>控制流切入点</h6>
<div class="paragraph">
<p>Spring控制流切入点在概念上类似于AspectJ <code>cflow</code>切入点，虽然功能较弱。（目前无法指定切入点在由另一个切入点匹配的连接点下方执行。）控制流切入点与当前调用堆栈匹配。例如，如果连接点是由<code>com.mycompany.web</code>包中的方法或<code>SomeCaller</code>类调用的，则可能会触发它。使用<code>org.springframework.aop.support.指定控制流切入点<code>org.springframework.aop.support.ControlFlowPointcut</code>类。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在运行时评估控制流切入点的成本远远高于其他动态切入点。在Java 1.4中，成本大约是其他动态切入点的五倍。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-superclasses"><a class="anchor" href="#aop-api-pointcuts-superclasses"></a> 6.1.5。切入点超级课程</h4>
<div class="paragraph">
<p>Spring提供了有用的切入点超类来帮助您实现自己的切入点。</p>
</div>
<div class="paragraph">
<p>因为静态切入点最有用，所以您应该将<code>StaticMethodMatcherPointcut</code>子类化。这需要只实现一个抽象方法（尽管您可以覆盖其他方法来自定义行为）。以下示例显示如何子类化<code>StaticMethodMatcherPointcut</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TestStaticPointcut</span> <span class="directive">extends</span> StaticMethodMatcherPointcut { <span class="directive">public</span> <span class="type">boolean</span> matches（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Class</span> targetClass）{ <span class="comment">//如果自定义条件匹配则返回true</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还有动态切入点的超类。</p>
</div>
<div class="paragraph">
<p>您可以在Spring 1.0 RC2及更高版本中使用任何建议类型的自定义切入点。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-custom"><a class="anchor" href="#aop-api-pointcuts-custom"></a> 6.1.6。自定义切入点</h4>
<div class="paragraph">
<p>因为Spring AOP中的切入点是Java类而不是语言功能（如在AspectJ中），所以您可以声明自定义切入点，无论是静态还是动态。Spring中的自定义切入点可以是任意复杂的。但是，如果可以，我们建议使用AspectJ切入点表达式语言。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">更高版本的Spring可能支持JAC提供的“语义切入点” - 例如，“所有改变目标对象中实例变量的方法”。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advice"><a class="anchor" href="#aop-api-advice"></a> 6.2。Spring中的建议API</h3>
<div class="paragraph">
<p>现在我们可以研究Spring AOP如何处理建议。</p>
</div>
<div class="sect3">
<h4 id="aop-api-advice-lifecycle"><a class="anchor" href="#aop-api-advice-lifecycle"></a> 6.2.1。建议生命周期</h4>
<div class="paragraph">
<p>每个建议都是一个Spring bean。建议实例可以在所有建议对象之间共享，或者对每个建议对象都是唯一的。这对应于每个类或每个实例的建议。</p>
</div>
<div class="paragraph">
<p>每类建议最常使用。它适用于通用建议，例如交易顾问。这些不依赖于代理对象的状态或添加新状态。他们只是对方法和论点采取行动。</p>
</div>
<div class="paragraph">
<p>每个实例的建议适用于介绍，以支持mixin。在这种情况下，建议将状态添加到代理对象。</p>
</div>
<div class="paragraph">
<p>Ypou可以在同一个AOP代理中混合使用共享和每个实例的建议。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-types"><a class="anchor" href="#aop-api-advice-types"></a> 6.2.2。Spring中的建议类型</h4>
<div class="paragraph">
<p>Spring提供了几种建议类型，并且可以扩展以支持任意建议类型。本节介绍基本概念和标准建议类型。</p>
</div>
<div class="sect4">
<h5 id="aop-api-advice-around"><a class="anchor" href="#aop-api-advice-around"></a>拦截建议</h5>
<div class="paragraph">
<p>Spring中最基本的建议类型是关于建议的拦截。</p>
</div>
<div class="paragraph">
<p>Spring符合AOP <code>Alliance</code>接口，可以提供使用方法拦截的建议。实现<code>MethodInterceptor</code>并实现建议的类也应该实现以下接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">MethodInterceptor</span> <span class="directive">扩展</span> Interceptor { <span class="predefined-type">Object</span> invoke（MethodInvocation invocation） <span class="directive">抛出</span> <span class="predefined-type">Throwable</span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>invoke()</code>方法的<code>MethodInvocation</code>参数公开了被调用的方法，目标连接点，AOP代理和方法的参数。<code>invoke()</code>方法应该返回调用的结果：连接点的返回值。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个简单的<code>MethodInterceptor</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">DebugInterceptor</span> <span class="directive">实现</span> MethodInterceptor { <span class="directive">public</span> <span class="predefined-type">Object</span> invoke（MethodInvocation invocation） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span> <span class="content">Before：invocation = [</span> <span class="delimiter">”</span></span> + invocation + <span class="string"><span class="delimiter">“</span> <span class="content">]</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">Object</span> rval = invocation.proceed（）; <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span> <span class="content">Invocation</span></span> returns <span class="string"><span class="delimiter">”</span></span> ）; <span class="keyword">返回</span> rval; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意对<code>MethodInvocation</code>的<code>proceed()</code>方法的调用。这沿拦截器链向下进入连接点。大多数拦截器调用此方法并返回其返回值。但是，与任何around建议一样， <code>MethodInterceptor</code>可以返回不同的值或抛出异常而不是调用proceed方法。但是，如果没有充分的理由，您不希望这样做。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>MethodInterceptor</code>实现提供与其他符合AOP Alliance标准的AOP实现的互操作性。本节其余部分讨论的其他建议类型实现了常见的AOP概念，但是采用Spring特定的方式。虽然使用最具体的建议类型有一个优势，但如果您可能希望在另一个AOP框架中运行该方面，请坚持使用<code>MethodInterceptor</code>建议。请注意，切入点目前在框架之间不可互操作，AOP联盟目前不定义切入点接口。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-before"><a class="anchor" href="#aop-api-advice-before"></a>在建议之前</h5>
<div class="paragraph">
<p>更简单的建议类型是之前的建议。这不需要<code>MethodInvocation</code>对象，因为只在进入方法之前调用它。</p>
</div>
<div class="paragraph">
<p>之前建议的主要优点是不需要调用<code>proceed()</code>方法，因此不会无意中无法继续拦截链。</p>
</div>
<div class="paragraph">
<p>以下清单显示了<code>MethodBeforeAdvice</code>接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodBeforeAdvice</span> <span class="directive">extends</span> BeforeAdvice { <span class="type">void</span> before（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args， <span class="predefined-type">Object</span> target） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（Spring的API设计允许在建议之前使用字段，尽管通常的对象适用于字段拦截，并且Spring不太可能实现它。）</p>
</div>
<div class="paragraph">
<p>请注意，返回类型为<code>void</code> 。在通知可以在连接点执行之前插入自定义行为但不能更改返回值之前。如果before advice抛出异常，则会中止拦截器链的进一步执行。异常传播回拦截器链。如果未选中它或在被调用方法的签名上，它将直接传递给客户端。否则，它由AOP代理包装在未经检查的异常中。</p>
</div>
<div class="paragraph">
<p>以下示例显示了Spring中的before建议，该建议计算所有方法调用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CountingBeforeAdvice</span> <span class="directive">实现</span> MethodBeforeAdvice { <span class="directive">private</span> <span class="type">int</span> count; <span class="directive">public</span> <span class="type">void</span> before（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args， <span class="predefined-type">Object</span> target） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {++ count; <span class="directive">public</span> <span class="type">int</span> getCount（）{ <span class="keyword">return</span> count; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">之前建议可以与任何切入点一起使用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-throws"><a class="anchor" href="#aop-api-advice-throws"></a>抛出建议</h5>
<div class="paragraph">
<p>如果连接点引发异常，则在返回连接点后调用抛出建议。Spring提供类型投掷建议。请注意，这意味着<code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。它是一个标记接口，用于标识给定对象实现一个或多个类型化throws建议方法。这些应该是以下形式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">afterThrowing（[ <span class="predefined-type">Method</span> ，args，target]，subclassOfThrowable）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>只需要最后一个参数。方法签名可以有一个或四个参数，具体取决于通知方法是否对方法和参数感兴趣。接下来的两个列表显示了作为throws建议示例的类。</p>
</div>
<div class="paragraph">
<p>如果<code>RemoteException</code> （包括子类），则调用以下建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">RemoteThrowsAdvice</span> <span class="directive">实现</span> ThrowsAdvice { <span class="directive">public</span> <span class="type">void</span> afterThrowing（ <span class="exception">RemoteException</span> ex） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="comment">//做远程异常的事情</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与前面的建议不同，下一个示例声明了四个参数，以便它可以访问被调用的方法，方法参数和目标对象。如果抛出<code>ServletException</code>则调用以下建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ServletThrowsAdviceWithArguments</span> <span class="directive">实现</span> ThrowsAdvice { <span class="directive">public</span> <span class="type">void</span> afterThrowing（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args， <span class="predefined-type">Object</span> target，ServletException ex）{ <span class="comment">//对所有参数做一些事情</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后一个示例说明了如何在处理<code>RemoteException</code>和<code>ServletException</code>的单个类中使用这两个方法。可以在单个类中组合任意数量的throws建议方法。以下清单显示了最后一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">CombinedThrowsAdvice</span> <span class="directive">实现</span> ThrowsAdvice { <span class="directive">public</span> <span class="type">void</span> afterThrowing（ <span class="exception">RemoteException</span> ex） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="comment">//做一些远程异常</span> } <span class="directive">public</span> <span class="type">void</span> afterThrowing（ <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args， <span class="predefined-type">Object</span> target，ServletException ex）{ <span class="comment">//做所有事情参数</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果throws-advice方法本身抛出异常，它将覆盖原始异常（即，它会更改抛出给用户的异常）。覆盖异常通常是RuntimeException，它与任何方法签名兼容。但是，如果throws-advice方法抛出已检查的异常，则它必须与目标方法的已声明异常匹配，因此在某种程度上与特定目标方法签名相关联。<em>不要抛出与目标方法签名不兼容的未声明的已检查异常！</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">抛出建议可以与任何切入点一起使用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-after-returning"><a class="anchor" href="#aop-api-advice-after-returning"></a>返回建议后</h5>
<div class="paragraph">
<p>在Spring中返回后的建议必须实现<code>org.springframework.aop.AfterReturningAdvice</code>接口，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">AfterReturningAdvice</span> <span class="directive">扩展</span>建议{ <span class="type">void</span> afterReturning（ <span class="predefined-type">Object</span> returnValue， <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args， <span class="predefined-type">Object</span> target） <span class="directive">抛出</span> <span class="predefined-type">Throwable</span> ; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>返回后的建议可以访问返回值（无法修改），调用的方法，方法的参数和目标。</p>
</div>
<div class="paragraph">
<p>返回通知后的以下内容计算所有未抛出异常的成功方法调用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CountingAfterReturningAdvice</span> <span class="directive">实现</span> AfterReturningAdvice { <span class="directive">private</span> <span class="type">int</span> count; <span class="directive">public</span> <span class="type">void</span> afterReturning（ <span class="predefined-type">Object</span> returnValue， <span class="predefined-type">Method</span> m， <span class="predefined-type">Object</span> <span class="type">[]</span> args， <span class="predefined-type">Object</span> target） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {++ count; <span class="directive">public</span> <span class="type">int</span> getCount（）{ <span class="keyword">return</span> count; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此建议不会更改执行路径。如果它抛出异常，则抛出拦截器链而不是返回值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">返回建议后可以使用任何切入点。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-introduction"><a class="anchor" href="#aop-api-advice-introduction"></a>简介建议</h5>
<div class="paragraph">
<p>Spring将介绍建议视为一种特殊的拦截建议。</p>
</div>
<div class="paragraph">
<p>简介需要一个<code>IntroductionAdvisor</code>和一个<code>IntroductionInterceptor</code>来实现以下接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionInterceptor</span> <span class="directive">extends</span> MethodInterceptor { <span class="type">boolean</span> implementsInterface（ <span class="predefined-type">Class</span> intf）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从AOP Alliance <code>MethodInterceptor</code>接口继承的<code>invoke()</code>方法必须实现引入。也就是说，如果调用的方法在引入的接口上，则引入拦截器负责处理方法调用 - 它不能调用<code>proceed()</code> 。</p>
</div>
<div class="paragraph">
<p>引言建议不能与任何切入点一起使用，因为它仅适用于类，而不是方法，级别。您只能在<code>IntroductionAdvisor</code>使用介绍建议，其中包含以下方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">IntroductionAdvisor</span> <span class="directive">扩展</span> Advisor，IntroductionInfo {ClassFilter getClassFilter（）; <span class="type">void</span> validateInterfaces（） <span class="directive">抛出</span> <span class="exception">IllegalArgumentException</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionInfo</span> { <span class="predefined-type">Class</span> <span class="type">[]</span> getInterfaces（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>没有<code>MethodMatcher</code> ，因此没有与介绍建议相关的<code>Pointcut</code> 。只有类过滤是合乎逻辑的。</p>
</div>
<div class="paragraph">
<p><code>getInterfaces()</code>方法返回此顾问程序引入的接口。</p>
</div>
<div class="paragraph">
<p><code>validateInterfaces()</code>方法在内部用于查看引入的接口是否可以由配置的<code>IntroductionInterceptor</code> 。</p>
</div>
<div class="paragraph">
<p>考虑Spring测试套件中的一个示例，并假设我们要将以下接口引入一个或多个对象：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lockable</span> { <span class="type">void</span> lock（）; <span class="type">void</span> unlock（）; <span class="type">boolean</span> locked（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这说明了一个混合。我们希望能够将建议对象转换为<code>Lockable</code> ，无论其类型如何，并调用锁定和解锁方法。如果我们调用<code>lock()</code>方法，我们希望所有setter方法都抛出一个<code>LockedException</code> 。因此，我们可以添加一个方面，该方面提供了使对象不可变的能力，而不需要它们知道它：AOP的一个很好的例子。</p>
</div>
<div class="paragraph">
<p>首先，我们需要一个可以完成繁重工作的<code>IntroductionInterceptor</code> 。在这种情况下，我们扩展<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>方便类。我们可以直接实现<code>IntroductionInterceptor</code> ，但使用<code>DelegatingIntroductionInterceptor</code>最适合大多数情况。</p>
</div>
<div class="paragraph">
<p><code>DelegatingIntroductionInterceptor</code>旨在委托介绍接口的实际实现，隐藏拦截的使用。您可以使用构造函数参数将委托设置为任何对象。默认委托（当使用无参数构造函数时）就是<code>this</code> 。因此，在下一个示例中，委托是<code>DelegatingIntroductionInterceptor</code>的<code>LockMixin</code>子类。给定委托（默认情况下，自身）， <code>DelegatingIntroductionInterceptor</code>实例查找委托实现的所有接口（除了<code>IntroductionInterceptor</code> ）并支持对其中任何接口的介绍。<code>LockMixin</code>类的子类可以调用<code>suppressInterface(Class intf)</code>方法来抑制不应该公开的接口。但是，无论<code>IntroductionInterceptor</code>准备支持多少接口， <code>IntroductionAdvisor</code>使用控制实际公开的接口。引入的接口隐藏了目标对同一接口的任何实现。</p>
</div>
<div class="paragraph">
<p>因此， <code>LockMixin</code>延长<code>DelegatingIntroductionInterceptor</code>并实现<code>Lockable</code>本身。超类自动选择可以支持<code>Lockable</code>引入，因此我们不需要指定。我们可以用这种方式引入任意数量的接口。</p>
</div>
<div class="paragraph">
<p>注意使用<code>locked</code>实例变量。这有效地将额外状态添加到目标对象中保存的状态。</p>
</div>
<div class="paragraph">
<p>以下示例显示了示例<code>LockMixin</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">LockMixin</span> <span class="directive">extends</span> DelegatingIntroductionInterceptor <span class="directive">实现了</span> <span class="class">Lockable</span> { <span class="directive">private</span> <span class="type">boolean</span> locked; <span class="directive">public</span> <span class="type">void</span> lock（）{ <span class="local-variable">this</span> .locked = <span class="predefined-constant">true</span> ; } <span class="directive">public</span> <span class="type">void</span> unlock（）{ <span class="local-variable">this</span> .locked = <span class="predefined-constant">false</span> ; <span class="directive">public</span> <span class="type">boolean</span> locked（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .locked; <span class="directive">public</span> <span class="predefined-type">Object</span> invoke（MethodInvocation invocation） <span class="directive">throws</span> <span class="predefined-type">Throwable</span> { <span class="keyword">if</span> （locked（）&amp;&amp; invocation.getMethod（）。getName（）。indexOf（ <span class="string"><span class="delimiter">“</span> <span class="content">set</span> <span class="delimiter">”</span></span> ）== <span class="integer">0</span> ）{ <span class="keyword">throw</span> <span class="keyword">new</span> LockedException（）; } <span class="keyword">return</span> <span class="local-variable">super</span> .invoke（invocation）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通常，您不需要覆盖<code>invoke()</code>方法。<code>DelegatingIntroductionInterceptor</code>实现（如果引入方法则调用<code>delegate</code>方法，否则向连接点前进）通常就足够了。在本例中，我们需要添加一个检查：如果处于锁定模式，则不能调用setter方法。</p>
</div>
<div class="paragraph">
<p>所需的介绍只需要保存一个不同的<code>LockMixin</code>实例并指定引入的接口（在这种情况下，只能是<code>Lockable</code> ）。一个更复杂的例子可能会引用引入拦截器（它将被定义为原型）。在这种情况下，没有与<code>LockMixin</code>相关的配置，因此我们使用<code>new</code>创建它。以下示例显示了我们的<code>LockMixinAdvisor</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">LockMixinAdvisor</span> <span class="directive">扩展了</span> DefaultIntroductionAdvisor { <span class="directive">public</span> LockMixinAdvisor（）{ <span class="local-variable">super</span> （ <span class="keyword">new</span> LockMixin（），Lockable.class）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以非常简单地应用这个顾问，因为它不需要配置。（然而，这是不可能使用<code>IntroductionInterceptor</code>没有<code>IntroductionAdvisor</code> 。）像往常一样介绍，顾问必须是每个实例，因为它是有状态的。对于每个建议的对象，我们需要一个不同的<code>LockMixinAdvisor</code>实例，因此需要<code>LockMixin</code> 。顾问包括建议对象的状态的一部分。</p>
</div>
<div class="paragraph">
<p>我们可以像在任何其他顾问中一样，通过在XML配置中使用<code>Advised.addAdvisor()</code>方法或（推荐方式）以编程方式应用此顾问程序。下面讨论的所有代理创建选项，包括“自动代理创建器”，正确处理引入和有状态混合。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advisor"><a class="anchor" href="#aop-api-advisor"></a> 6.3。Spring中的Advisor API</h3>
<div class="paragraph">
<p>在Spring中，Advisor是一个只包含与切入点表达式关联的建议对象的方面。</p>
</div>
<div class="paragraph">
<p>除了介绍的特殊情况，任何顾问都可以使用任何建议。
<code>org.springframework.aop.support。DefaultPointcutAdvisor</code>是最常用的顾问类。它可以与<code>MethodInterceptor</code> ， <code>BeforeAdvice</code>或<code>ThrowsAdvice</code> 。</p>
</div>
<div class="paragraph">
<p>可以在同一个AOP代理中混合Spring中的顾问程序和通知类型。例如，您可以在一个代理配置中使用拦截建议，抛出建议和建议之前。Spring自动创建必要的拦截链。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb"><a class="anchor" href="#aop-pfb"></a> 6.4。使用<code>ProxyFactoryBean</code>创建AOP代理</h3>
<div class="paragraph">
<p>如果你为业务对象使用Spring IoC容器（一个<code>ApplicationContext</code>或<code>BeanFactory</code> ）（你应该是！），你想使用Spring的AOP <code>FactoryBean</code>实现之一。（请记住，工厂bean引入了一个间接层，让它创建不同类型的对象。）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring AOP支持还使用工厂bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在Spring中创建AOP代理的基本方法是使用<code>org.springframework.aop.framework.ProxyFactoryBean</code> 。这样可以完全控制切入点，任何适用的建议以及它们的顺序。但是，如果您不需要这样的控制，则有更简单的选项。</p>
</div>
<div class="sect3">
<h4 id="aop-pfb-1"><a class="anchor" href="#aop-pfb-1"></a> 6.4.1。基本</h4>
<div class="paragraph">
<p>与其他Spring <code>FactoryBean</code>实现一样， <code>ProxyFactoryBean</code>引入了一个间接层。如果定义<code>ProxyFactoryBean</code>名为<code>foo</code> ，引用对象<code>foo</code>看不到<code>ProxyFactoryBean</code>实例本身，而是由执行创建的对象<code>getObject()</code>的方法<code>ProxyFactoryBean</code> 。此方法创建一个包装目标对象的AOP代理。</p>
</div>
<div class="paragraph">
<p>使用<code>ProxyFactoryBean</code>或其他IoC感知类来创建AOP代理的最重要的好处之一是IoC还可以管理建议和切入点。这是一个强大的功能，可以实现其他AOP框架难以实现的某些方法。例如，一个建议本身可以引用应用程序对象（除了目标，它应该在任何AOP框架中可用），受益于依赖注入提供的所有可插入性。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-2"><a class="anchor" href="#aop-pfb-2"></a> 6.4.2。JavaBean属性</h4>
<div class="paragraph">
<p>与Spring提供的大多数<code>FactoryBean</code>实现一样， <code>ProxyFactoryBean</code>类本身就是一个JavaBean。其属性用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定要代理的目标。</p>
</li>
<li>
<p>指定是否使用CGLIB（稍后介绍，另请参阅<a href="#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一些关键属性继承自<code>org.springframework.aop.framework.ProxyConfig</code> （Spring中所有AOP代理工厂的超类）。这些关键属性包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyTargetClass</code> ：如果要代理目标类，则为<code>true</code> ，而不是目标类的接口。如果此属性值设置为<code>true</code> ，则会创建CGLIB代理（但另请参阅<a href="#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a> ）。</p>
</li>
<li>
<p><code>optimize</code> ：控制是否将积极优化应用于通过CGLIB创建的代理。除非您完全了解相关AOP代理如何处理优化，否则您不应轻率使用此设置。目前仅用于CGLIB代理。它对JDK动态代理没有影响。</p>
</li>
<li>
<p><code>frozen</code> ：如果代理配置<code>frozen</code> ，对配置进行更改不再允许。这既可以作为轻微的优化，也可以用于在创建代理后不希望调用者能够操作代理（通过<code>Advised</code>接口）的情况。此属性的默认值为<code>false</code> ，因此允许更改（例如添加其他建议）。</p>
</li>
<li>
<p><code>exposeProxy</code> ：确定是否应在<code>ThreadLocal</code>公开当前代理，以便目标可以访问它。如果目标需要获取代理并且<code>exposeProxy</code>属性设置为<code>true</code> ，则目标可以使用<code>AopContext.currentProxy()</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ProxyFactoryBean</code>特有的其他属性包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyInterfaces</code> ： <code>String</code>接口名称的数组。如果未提供，则使用目标类的CGLIB代理（但另请参阅<a href="#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a> ）。</p>
</li>
<li>
<p><code>interceptorNames</code> ：要应用的<code>Advisor</code> ，拦截器或其他建议名称的<code>String</code>数组。以先到先得的方式订购非常重要。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。</p>
<div class="paragraph">
<p>名称是当前工厂中的bean名称，包括来自祖先工厂的bean名称。你不能在这里提到bean引用，因为这样做会导致<code>ProxyFactoryBean</code>忽略通知的单例设置。</p>
</div>
<div class="paragraph">
<p>您可以使用星号（ <code>*</code> ）附加拦截器名称。这样做会导致应用所有顾问程序bean，其名称以要应用星号之前的部分开头。您可以在<a href="#aop-global-advisors">使用“全局”顾问中</a>找到使用此功能的示例。</p>
</div>
</li>
<li>
<p>singleton：无论调用<code>getObject()</code>方法的频率如何，工厂是否应该返回单个对象。几个<code>FactoryBean</code>实现提供了这样的方法。默认值为<code>true</code> 。如果您想使用有状态建议 - 例如，对于有状态的mixins  - 使用原型建议以及单例值<code>false</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-proxy-types"><a class="anchor" href="#aop-pfb-proxy-types"></a> 6.4.3。基于JDK和CGLIB的代理</h4>
<div class="paragraph">
<p>本节作为关于<code>ProxyFactoryBean</code>如何选择为特定目标对象（将被代理）创建基于JDK的代理或基于CGLIB的代理的<code>ProxyFactoryBean</code>文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>ProxyFactoryBean</code>关于创建基于JDK或CGLIB的代理的行为在Spring的1.2.x和2.0版本之间发生了变化。现在， <code>ProxyFactoryBean</code>在自动检测接口方面表现出与<code>TransactionProxyFactoryBean</code>类相似的语义。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果要代理的目标对象的类（以下简称为目标类）未实现任何接口，则创建基于CGLIB的代理。这是最简单的方案，因为JDK代理是基于接口的，没有接口意味着甚至不可能进行JDK代理。您可以通过设置<code>interceptorNames</code>属性来插入目标bean并指定拦截器列表。请注意，即使<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性已设置为<code>false</code> ， <code>proxyTargetClass</code>创建基于CGLIB的代理。（这样做没有任何意义，最好从bean定义中删除，因为它最多是多余的，并且最糟糕的是混淆。）</p>
</div>
<div class="paragraph">
<p>如果目标类实现一个（或多个）接口，则创建的代理类型取决于<code>ProxyFactoryBean</code>的配置。</p>
</div>
<div class="paragraph">
<p>如果<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性已设置为<code>true</code> ，则会创建基于CGLIB的代理。这是有道理的，并且符合最少惊喜的原则。即使<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性已设置为一个或多个完全限定的接口名称， <code>proxyTargetClass</code>属性设置为<code>true</code>这一事实<code>proxyTargetClass</code>导致基于CGLIB的代理生效。</p>
</div>
<div class="paragraph">
<p>如果<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性已设置为一个或多个完全限定的接口名称，则会创建基于JDK的代理。创建的代理实现<code>proxyInterfaces</code>属性中指定的所有接口。如果目标类碰巧实现了比<code>proxyInterfaces</code>属性中指定的接口多得多的接口，那么这一切都很好，但返回的代理不会实现这些附加接口。</p>
</div>
<div class="paragraph">
<p>如果尚未设置<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性，但目标类确实实现了一个（或多个）接口，则<code>ProxyFactoryBean</code>自动检测目标类确实实现至少一个接口和基于JDK的代理的事实被建造。实际代理的接口是目标类实现的所有接口。实际上，这与将目标类实现的每个接口的列表提供给<code>proxyInterfaces</code>属性相同。但是，它的工作量明显减少，并且不易出现印刷错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-intf"><a class="anchor" href="#aop-api-proxying-intf"></a> 6.4.4。代理接口</h4>
<div class="paragraph">
<p>考虑一下<code>ProxyFactoryBean</code>一个简单示例。这个例子涉及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>代理的目标bean。这是示例中的<code>personTarget</code> bean定义。</p>
</li>
<li>
<p>用于提供建议的<code>Advisor</code>和<code>Interceptor</code> 。</p>
</li>
<li>
<p>AOP代理bean定义，用于指定目标对象（ <code>personTarget</code> bean），代理接口和要应用的建议。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下清单显示了该示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">personTarget</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.mycompany。PersonImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Tony</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">51</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myAdvisor</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。MyAdvisor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someProperty</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">自定义字符串属性值</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">debugInterceptor</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.interceptor。DebugInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">person</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.framework。ProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">proxyInterfaces</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。Person</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">target</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">personTarget</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptorNames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> myAdvisor <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> debugInterceptor <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt; / property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>interceptorNames</code>属性采用<code>String</code>列表，该列表包含当前工厂中拦截器或顾问程序的bean名称。您可以在返回之前，之后使用顾问程序，拦截器，并抛出建议对象。顾问的排序很重要。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可能想知道为什么列表不包含bean引用。原因是，如果<code>ProxyFactoryBean</code>的singleton属性设置为<code>false</code> ，则它必须能够返回独立的代理实例。如果任何顾问本身就是原型，则需要返回一个独立的实例，因此必须能够从工厂获得原型的实例。持有参考是不够的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>前面显示的<code>person</code> bean定义可以用来代替<code>Person</code>实现，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">人人=（人）factory.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">人</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与普通Java对象一样，同一IoC上下文中的其他bean可以表达对它的强类型依赖。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">personUser</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.mycompany。PersonUser</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">person</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">person</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此示例中的<code>PersonUser</code>类公开<code>Person</code>类型的属性。就其而言，可以透明地使用AOP代理来代替“真实”的人实现。但是，它的类将是一个动态代理类。可以将其转换为<code>Advised</code>界面（稍后讨论）。</p>
</div>
<div class="paragraph">
<p>您可以使用匿名内部bean隐藏目标和代理之间的区别。只有<code>ProxyFactoryBean</code>定义不同。该建议仅用于完整性。以下示例显示如何使用匿名内部bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myAdvisor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.mycompany。MyAdvisor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someProperty</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">自定义字符串属性值</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">debugInterceptor</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.interceptor。DebugInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">person</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.framework。ProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">proxyInterfaces</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。Person</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 使用内部bean，而不是对target的本地引用 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">target</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。PersonImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Tony</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">51</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptorNames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> myAdvisor <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> debugInterceptor <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用匿名内部bean的优点是只有一个<code>Person</code>类型的对象。如果我们想要阻止应用程序上下文的用户获取对未建议对象的引用或者需要避免Spring IoC自动装配的任何歧义，这将非常有用。可以说，还有一个优点是<code>ProxyFactoryBean</code>定义是自包含的。但是，有时能够从工厂获得未建议的目标实际上可能是一个优势（例如，在某些测试场景中）。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-class"><a class="anchor" href="#aop-api-proxying-class"></a> 6.4.5。代理类</h4>
<div class="paragraph">
<p>如果您需要代理一个类而不是一个或多个接口，该怎么办？</p>
</div>
<div class="paragraph">
<p>想象一下，在我们之前的例子中，没有<code>Person</code>接口。我们需要建议一个名为<code>Person</code>的类，它没有实现任何业务接口。在这种情况下，您可以将Spring配置为使用CGLIB代理而不是动态代理。为此，请将前面显示的<code>ProxyFactoryBean</code>上的<code>proxyTargetClass</code>属性设置为<code>true</code> 。虽然最好对接口而不是类进行编程，但在使用遗留代码时，建议不实现接口的类的能力会很有用。（一般来说，Spring不是规定性的。虽然它使应用良好实践变得容易，但它避免强制采用特定方法。）</p>
</div>
<div class="paragraph">
<p>如果您愿意，即使您有接口，也可以在任何情况下强制使用CGLIB。</p>
</div>
<div class="paragraph">
<p>CGLIB代理通过在运行时生成目标类的子类来工作。Spring配置此生成的子类以将方法调用委托给原始目标。子类用于实现Decorator模式，在通知中编织。</p>
</div>
<div class="paragraph">
<p>CGLIB代理通常应对用户透明。但是，有一些问题需要考虑：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无法建议<code>Final</code>方法，因为它们无法被覆盖。</p>
</li>
<li>
<p>无需将CGLIB添加到类路径中。从Spring 3.2开始，CGLIB被重新打包并包含在spring-core JAR中。换句话说，基于CGLIB的AOP“开箱即用”，JDK动态代理也是如此。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CGLIB代理和动态代理之间几乎没有性能差异。从Spring 1.0开始，动态代理略快一些。但是，这可能会在未来发生变化。在这种情况下，绩效不应该是决定性的考虑因素。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-global-advisors"><a class="anchor" href="#aop-global-advisors"></a> 6.4.6。使用“全球”顾问</h4>
<div class="paragraph">
<p>通过在拦截器名称后附加星号，将所有与星号前面的部分匹配的bean名称的顾问程序添加到顾问程序链中。如果您需要添加一组标准的“全局”顾问，这可以派上用场。以下示例定义了两个全局顾问程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">proxy</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.framework。ProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">target</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptorNames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> global * <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">global_debug</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.interceptor。DebugInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">global_performance</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.interceptor。PerformanceMonitorInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-concise-proxy"><a class="anchor" href="#aop-concise-proxy"></a> 6.5。简明的代理定义</h3>
<div class="paragraph">
<p>特别是在定义事务代理时，最终可能会有许多类似的代理定义。使用父bean和子bean定义以及内部bean定义可以产生更清晰，更简洁的代理定义。</p>
</div>
<div class="paragraph">
<p>首先，我们为代理创建父，模板，bean定义，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txProxyTemplate</span> <span class="delimiter">”</span></span> <span class="attribute-name">abstract</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.transaction.interceptor。TransactionProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionAttributes</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">*</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> PROPAGATION_REQUIRED <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt; /豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这从未实例化，因此它实际上可能是不完整的。然后，需要创建的每个代理都是子bean定义，它将代理的目标包装为内部bean定义，因为目标永远不会单独使用。以下示例显示了这样的子bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myService</span> <span class="delimiter">”</span></span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txProxyTemplate</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">target</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.samples。MyServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以覆盖父模板中的属性。在以下示例中，我们覆盖了事务传播设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mySpecialService</span> <span class="delimiter">”</span></span> <span class="attribute-name">parent</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txProxyTemplate</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">target</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.samples。MySpecialServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionAttributes</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">get *</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> PROPAGATION_REQUIRED，readOnly <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">find *</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> PROPAGATION_REQUIRED，readOnly <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">load *</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> PROPAGATION_REQUIRED，readOnly <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">store *</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> PROPAGATION_REQUIRED <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，在父bean示例中，我们通过将<code>abstract</code>属性设置为<code>true</code>将父bean定义显式标记为abstract， <a href="#beans-child-bean-definitions">如前所述</a> ，因此实际上可能无法实例化它。默认情况下，应用程序上下文（但不是简单的bean工厂）预先实例化所有单例。因此，重要的是（至少对于单例bean），如果您有一个（父）bean定义，您打算仅将其用作模板，并且此定义指定了一个类，则必须确保将<code>abstract</code>属性设置为<code>true</code> 。否则，应用程序上下文实际上会尝试预先实例化它。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-prog"><a class="anchor" href="#aop-prog"></a> 6.6。使用<code>ProxyFactory</code>编程方式创建AOP代理</h3>
<div class="paragraph">
<p>使用Spring以编程方式创建AOP代理很容易。这使您可以使用Spring AOP而不依赖于Spring IoC。</p>
</div>
<div class="paragraph">
<p>目标对象实现的接口将自动代理。以下清单显示了为目标对象创建代理，其中包含一个拦截器和一个顾问程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ProxyFactory factory = <span class="keyword">new</span> ProxyFactory（myBusinessInterfaceImpl）; factory.addAdvice（myMethodInterceptor）; factory.addAdvisor（myAdvisor）; MyBusinessInterface tb =（MyBusinessInterface）factory.getProxy（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一步是构造一个<code>org.springframework.aop.framework.类型的对象<code>org.springframework.aop.framework.ProxyFactory</code> 。您可以使用目标对象创建它，如前面的示例所示，或者指定要在备用构造函数中代理的接口。</p>
</div>
<div class="paragraph">
<p>您可以添加建议（使用拦截器作为专门的建议），顾问或两者，并在<code>ProxyFactory</code>的生命周期中操纵它们。如果添加<code>IntroductionInterceptionAroundAdvisor</code> ，则可以使代理实现其他接口。</p>
</div>
<div class="paragraph">
<p><code>ProxyFactory</code>上的便捷方法（继承自<code>AdvisedSupport</code> ）允许您添加其他建议类型，例如before和throws建议。
<code>AdvisedSupport</code>是<code>ProxyFactory</code>和<code>ProxyFactoryBean</code>的超类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在大多数应用程序中，将AOP代理创建与IoC框架集成是最佳实践。我们建议您通常使用AOP从Java代码外部化配置。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advised"><a class="anchor" href="#aop-api-advised"></a> 6.7。操纵建议的对象</h3>
<div class="paragraph">
<p>但是，无论您创建AOP代理，都可以使用<code>org.springframework.aop.framework.来操作它们<code>org.springframework.aop.framework.Advised</code>界面。任何AOP代理都可以转换为此接口，无论它实现哪个其他接口。该界面包括以下方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Advisor <span class="type">[]</span> getAdvisors（）; <span class="type">void</span> addAdvice（Advice advice） <span class="directive">抛出</span> AopConfigException; <span class="type">void</span> addAdvice（ <span class="type">int</span> pos，Advice advice） <span class="directive">抛出</span> AopConfigException; <span class="type">void</span> addAdvisor（Advisor顾问程序） <span class="directive">抛出</span> AopConfigException; <span class="type">void</span> addAdvisor（ <span class="type">int</span> pos，Advisor advisor） <span class="directive">抛出</span> AopConfigException; <span class="type">int</span> indexOf（顾问顾问）; <span class="type">boolean</span> removeAdvisor（Advisor顾问程序） <span class="directive">抛出</span> AopConfigException; <span class="type">void</span> removeAdvisor（ <span class="type">int</span> index） <span class="directive">抛出</span> AopConfigException; <span class="type">boolean</span> replaceAdvisor（Advisor a，Advisor b） <span class="directive">抛出</span> AopConfigException; <span class="type">boolean</span> isFrozen（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>getAdvisors()</code>方法为已添加到工厂的每个顾问程序，拦截器或其他通知类型返回一个<code>Advisor</code> 。如果添加了<code>Advisor</code> ，则此索引处返回的顾问程序是您添加的对象。如果您添加了一个拦截器或其他建议类型，Spring会将其包含在一个顾问程序中，并且切入点始终返回<code>true</code> 。因此，如果添加了一个<code>MethodInterceptor</code> ，则为此索引返回的顾问程序是一个<code>DefaultPointcutAdvisor</code> ，它返回<code>MethodInterceptor</code>和一个匹配所有类和方法的切入点。</p>
</div>
<div class="paragraph">
<p><code>addAdvisor()</code>方法可用于添加任何<code>Advisor</code> 。通常，持有切入点和建议的顾问程序是通用的<code>DefaultPointcutAdvisor</code> ，您可以将其用于任何建议或切入点（但不适用于介绍）。</p>
</div>
<div class="paragraph">
<p>默认情况下，即使创建了代理，也可以添加或删除顾问程序或拦截器。唯一的限制是无法添加或删除介绍顾问，因为工厂的现有代理不显示接口更改。（您可以从工厂获取新代理以避免此问题。）</p>
</div>
<div class="paragraph">
<p>以下示例显示将AOP代理转换为<code>Advised</code>接口并检查和操作其建议：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">建议=（建议）myObject;顾问<span class="type">[]</span>顾问= advisory.getAdvisors（）; <span class="type">int</span> oldAdvisorCount = advisors.length; <span class="predefined-type">System</span> .out.println（oldAdvisorCount + <span class="string"><span class="delimiter">“</span> <span class="content">顾问</span> <span class="delimiter">”</span></span> ）; <span class="comment">//在没有切入点的情况下添加类似拦截器的建议</span> <span class="comment">//将匹配所有代理方法</span> <span class="comment">//可以在返回或抛出之前，之后使用拦截器建议</span> advice.addAdvice（ <span class="keyword">new</span> DebugInterceptor（））; <span class="comment">//使用切入点</span> advice.addAdvisor <span class="comment">添加选择性建议</span> （ <span class="keyword">new</span> DefaultPointcutAdvisor（mySpecialPointcut，myAdvice））; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">添加了两个顾问</span> <span class="delimiter">”</span></span> ，oldAdvisorCount + <span class="integer">2</span> ，recommended.getAdvisors（）。length）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管存在合法的使用案例，但是否有必要修改生产中的业务对象的建议是值得怀疑的（没有双关语意）。但是，它在开发中非常有用（例如，在测试中）。我们有时发现能够以拦截器或其他建议的形式添加测试代码非常有用，进入我们想要测试的方法调用。 （例如，在为回滚标记事务之前，建议可以进入为该方法创建的事务内部，可能运行SQL以检查数据库是否已正确更新。）
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>根据您创建代理的方式，通常可以设置<code>frozen</code>标志。在这种情况下， <code>Advised</code> <code>isFrozen()</code>方法返回<code>true</code> ，并且在修改通过添加或去除的结果建议任何企图<code>AopConfigException</code> 。在某些情况下，冻结建议对象状态的能力很有用（例如，防止调用代码删除安全拦截器）。如果已知不需要运行时建议修改，它也可以在Spring 1.1中使用以允许积极优化。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-autoproxy"><a class="anchor" href="#aop-autoproxy"></a> 6.8。使用“自动代理”工具</h3>
<div class="paragraph">
<p>到目前为止，我们已经考虑使用<code>ProxyFactoryBean</code>或类似的工厂bean显式创建AOP代理。</p>
</div>
<div class="paragraph">
<p>Spring还允许我们使用“自动代理”bean定义，它可以自动代理选定的bean定义。这是基于Spring的“bean post processor”基础结构构建的，它可以在容器加载时修改任何bean定义。</p>
</div>
<div class="paragraph">
<p>在此模型中，您在XML bean定义文件中设置了一些特殊的bean定义，以配置自动代理基础结构。这使您可以声明符合自动代理条件的目标。你不能使用<code>ProxyFactoryBean</code> 。</p>
</div>
<div class="paragraph">
<p>有两种方法可以做到这一点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过使用引用当前上下文中特定bean的自动代理创建器。</p>
</li>
<li>
<p>自动代理创建的一个特例值得单独考虑：由源级元数据属性驱动的自动代理创建。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-choices"><a class="anchor" href="#aop-autoproxy-choices"></a> 6.8.1。自动代理Bean定义</h4>
<div class="paragraph">
<p>本节介绍<code>org.springframework.aop.framework.autoproxy</code>包提供的自动代理创建器。</p>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy"><a class="anchor" href="#aop-api-autoproxy"></a><code>BeanNameAutoProxyCreator</code></h5>
<div class="paragraph">
<p><code>BeanNameAutoProxyCreator</code>类是一个<code>BeanPostProcessor</code> ，它自动为名称与文字值或通配符匹配的bean创建AOP代理。以下示例显示如何创建<code>BeanNameAutoProxyCreator</code> bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.framework.autoproxy。BeanNameAutoProxyCreator</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beanNames</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdk *，onlyJdk</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptorNames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> myInterceptor <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean &gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与<code>ProxyFactoryBean</code> ，有一个<code>interceptorNames</code>属性而不是拦截器列表，以允许原型顾问程序的正确行为。命名为“拦截器”可以是顾问或任何建议类型。</p>
</div>
<div class="paragraph">
<p>与通常的自动代理一样，使用<code>BeanNameAutoProxyCreator</code>要点是将相同的配置一致地应用于多个对象，并且配置量最小。将声明性事务应用于多个对象是一种流行的选择。</p>
</div>
<div class="paragraph">
<p>名称匹配的Bean定义（例如前面示例中的<code>jdkMyBean</code>和<code>onlyJdk</code>是具有目标类的普通旧bean定义。<code>BeanNameAutoProxyCreator</code>自动创建AOP代理。相同的建议适用于所有匹配的bean。请注意，如果使用顾问程序（而不是前面示例中的拦截器），则切入点可能会以不同方式应用于不同的bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-default"><a class="anchor" href="#aop-api-autoproxy-default"></a><code>DefaultAdvisorAutoProxyCreator</code></h5>
<div class="paragraph">
<p><code>DefaultAdvisorAutoProxyCreator</code>是一个更通用且功能更强大的自动代理创建器。这会在当前上下文中自动应用符合条件的顾问程序，而无需在auto-proxy advisor的bean定义中包含特定的bean名称。它提供与<code>BeanNameAutoProxyCreator</code>一样的一致配置和避免重复的优点。</p>
</div>
<div class="paragraph">
<p>使用此机制涉及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定<code>DefaultAdvisorAutoProxyCreator</code> bean定义。</p>
</li>
<li>
<p>在相同或相关的上下文中指定任意数量的顾问程序。请注意，这些必须是顾问，而不是拦截器或其他建议。这是必要的，因为必须有一个切入点来评估，以检查每个建议对候选bean定义的合格性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DefaultAdvisorAutoProxyCreator</code>自动评估每个顾问程序中包含的切入点，以查看它应该应用于每个业务对象（例如示例中的<code>businessObject1</code>和<code>businessObject2</code> ）的建议（如果有）。</p>
</div>
<div class="paragraph">
<p>这意味着可以自动将任意数量的顾问程序应用于每个业务对象。如果任何顾问程序中的切入点与业务对象中的任何方法都不匹配，则不会代理该对象。随着为新业务对象添加bean定义，必要时会自动代理它们。</p>
</div>
<div class="paragraph">
<p>自动代理通常具有使调用者或依赖者无法获得未建议的对象的优点。在此<code>ApplicationContext</code>上调用<code>getBean("businessObject1")</code>将返回AOP代理，而不是目标业务对象。（前面所示的“内在豆”成语也提供了这种好处。）</p>
</div>
<div class="paragraph">
<p>以下示例创建一个<code>DefaultAdvisorAutoProxyCreator</code> bean以及本节中讨论的其他元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.framework.autoproxy。DefaultAdvisorAutoProxyCreator</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.transaction.interceptor。TransactionAttributeSourceAdvisor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionInterceptor</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customAdvisor</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。MyAdvisor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessObject1</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。BusinessObject1</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 属性省略 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessObject2</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany。BusinessObject2</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要将相同的建议一致地应用于许多业务对象，则<code>DefaultAdvisorAutoProxyCreator</code>非常有用。基础结构定义到位后，您可以添加新的业务对象，而不包括特定的代理配置。您还可以轻松地删除其他方面（例如，跟踪或性能监视方面），只需对配置进行最小的更改。</p>
</div>
<div class="paragraph">
<p><code>DefaultAdvisorAutoProxyCreator</code>提供过滤支持（通过使用命名约定，以便仅评估某些顾问程序，允许在同一工厂中使用多个，不同配置的AdvisorAutoProxyCreators）和排序。顾问可以实现<code>org.springframework.core.如果这是一个问题， Ordered</code>接口以确保正确的排序。上例中使用的<code>TransactionAttributeSourceAdvisor</code>具有可配置的订单值。默认设置是无序的。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-targetsource"><a class="anchor" href="#aop-targetsource"></a> 6.9。使用<code>TargetSource</code>实现</h3>
<div class="paragraph">
<p>Spring提供了<code>TargetSource</code>的概念，用<code>org.springframework.aop.表示<code>org.springframework.aop.TargetSource</code>接口。该接口负责返回实现连接点的“目标对象”。每次AOP代理处理方法调用时，都会要求<code>TargetSource</code>实现一个目标实例。</p>
</div>
<div class="paragraph">
<p>使用Spring AOP的开发人员通常不需要直接使用<code>TargetSource</code>实现，但这提供了支持池，热插拔和其他复杂目标的强大方法。例如，池化<code>TargetSource</code>可以通过使用池来管理实例，为每次调用返回不同的目标实例。</p>
</div>
<div class="paragraph">
<p>如果未指定<code>TargetSource</code> ，则使用默认实现来包装本地对象。每次调用都会返回相同的目标（正如您所期望的那样）。</p>
</div>
<div class="paragraph">
<p>本节的其余部分描述了Spring提供的标准目标源以及如何使用它们。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用自定义目标源时，目标通常需要是原型而不是单例bean定义。这允许Spring在需要时创建新的目标实例。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-ts-swap"><a class="anchor" href="#aop-ts-swap"></a> 6.9.1。热插拔目标源</h4>
<div class="paragraph">
<p><code>org.springframework.aop.target.存在HotSwappableTargetSource</code>以允许切换AOP代理的目标，同时让调用者保持对它的引用。</p>
</div>
<div class="paragraph">
<p>更改目标源的目标会立即生效。<code>HotSwappableTargetSource</code>是线程安全的。</p>
</div>
<div class="paragraph">
<p>您可以使用HotSwappableTargetSource上的<code>swap()</code>方法更改目标，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HotSwappableTargetSource swapper =（HotSwappableTargetSource）beanFactory.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">swapper</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">Object</span> oldTarget = swapper.swap（newTarget）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了所需的XML定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">initialTarget</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mycompany。OldTarget</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">swapper</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.target。HotSwappableTargetSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">initialTarget</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">swappable</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.framework。ProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">swapper</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的<code>swap()</code>调用更改了可交换bean的目标。持有对该bean的引用的客户端不知道该更改但立即开始命中新目标。</p>
</div>
<div class="paragraph">
<p>虽然这个例子没有添加任何建议（没有必要添加使用<code>TargetSource</code>建议），但任何<code>TargetSource</code>都可以与任意建议一起使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-pool"><a class="anchor" href="#aop-ts-pool"></a> 6.9.2。汇集目标来源</h4>
<div class="paragraph">
<p>使用池化目标源为无状态会话EJB提供了类似的编程模型，其中维护了相同实例的池，方法调用将释放池中的空闲对象。</p>
</div>
<div class="paragraph">
<p>Spring池和SLSB池之间的一个重要区别是Spring池可以应用于任何POJO。与Spring一样，此服务可以以非侵入方式应用。</p>
</div>
<div class="paragraph">
<p>Spring为Commons Pool 2.2提供了支持，它提供了一个相当有效的池实现。您需要在应用程序的类路径上使用<code>commons-pool</code> Jar才能使用此功能。您也可以将<code>org.springframework.aop.target.子类化<code>org.springframework.aop.target.AbstractPoolingTargetSource</code>支持任何其他池API。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Commons Pool 1.5+也受支持，但自Spring Framework 4.2起已弃用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下listig显示了一个示例配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">businessObjectTarget</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.mycompany。MyBusinessObject</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...属性省略<span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">poolTargetSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop.target。CommonsPool2TargetSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetBeanName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessObjectTarget</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">maxSize</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">25</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessObject</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.aop .framework。ProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">poolTargetSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptorNames</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，目标对象（前面示例中的<code>businessObjectTarget</code> ）必须是原型。这使得<code>PoolingTargetSource</code>实现可以根据<code>PoolingTargetSource</code>创建目标的新实例以扩展池。请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html"><code>AbstractPoolingTargetSource</code></a>的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">Javadoc</a>以及您希望用于获取有关其属性的信息的具体子类。 <code>maxSize</code>是最基本的，并且始终保证存在。</p>
</div>
<div class="paragraph">
<p>在这种情况下， <code>myInterceptor</code>是需要在同一IoC上下文中定义的拦截器的名称。但是，您无需指定拦截器来使用池。如果您只想要池化而没有其他建议，请不要设置<code>interceptorNames</code>属性。</p>
</div>
<div class="paragraph">
<p>您可以将Spring配置为能够将任何池化对象转换为<code>org.springframework.aop.target.PoolingConfig</code>接口，通过介绍公开有关配置和池当前大小的信息。您需要定义类似于以下内容的顾问程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">poolConfigAdvisor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。MethodInvokingFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetObject</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">poolTargetSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">getPoolingConfigMixin</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过在<code>AbstractPoolingTargetSource</code>类上调用便捷方法获得此顾问程序，因此使用<code>MethodInvokingFactoryBean</code> 。此顾问程序的名称（ <code>poolConfigAdvisor</code> ，此处）必须位于<code>ProxyFactoryBean</code>用于公开池对象的拦截器名称列表中。</p>
</div>
<div class="paragraph">
<p>演员阵容定义如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">PoolingConfig conf =（PoolingConfig）beanFactory.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">businessObject</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span> <span class="content">Max pool size is</span> <span class="delimiter">”</span></span> + conf.getMaxSize（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通常不需要池化无状态服务对象。我们不认为它应该是默认选择，因为大多数无状态对象自然是线程安全的，并且如果缓存资源，实例池是有问题的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用自动代理可以实现更简单的池化。您可以设置任何自动代理创建者使用的<code>TargetSource</code>实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-prototype"><a class="anchor" href="#aop-ts-prototype"></a> 6.9.3。原型目标来源</h4>
<div class="paragraph">
<p>设置“原型”目标源类似于设置池化<code>TargetSource</code> 。在这种情况下，将在每次方法调用时创建目标的新实例。虽然在现代JVM中创建新对象的成本并不高，但是连接新对象（满足其IoC依赖性）的成本可能更高。因此，如果没有充分的理由，就不应该使用这种方法。</p>
</div>
<div class="paragraph">
<p>为此，您可以修改前面显示的<code>poolTargetSource</code>定义，如下所示（为清晰起见，我们还更改了名称）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">prototypeTargetSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.target。PrototypeTargetSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetBeanName</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessObjectTarget</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>唯一的属性是目标bean的名称。<code>TargetSource</code>实现中使用继承来确保一致的命名。与池化目标源一样，目标bean必须是原型bean定义。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-threadlocal"><a class="anchor" href="#aop-ts-threadlocal"></a> 6.9.4。<code>ThreadLocal</code>目标源</h4>
<div class="paragraph">
<p>如果您需要为每个传入请求创建一个对象（每个线程）， <code>ThreadLocal</code>目标源很有用。<code>ThreadLocal</code>的概念提供了一个JDK范围的工具，可以在线程旁边透明地存储资源。设置<code>ThreadLocalTargetSource</code>与其他类型的目标源所解释的几乎相同，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">threadlocalTargetSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.aop.target。ThreadLocalTargetSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetBeanName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessObjectTarget</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>ThreadLocal</code>实例在多线程和多类加载器环境中错误地使用它们时会出现严重问题（可能导致内存泄漏）。您应该始终考虑将threadlocal包装在其他类中，并且永远不要直接使用<code>ThreadLocal</code>本身（在包装类中除外）。此外，您应该始终记住正确设置和取消设置（后者只需要调用<code>ThreadLocal.set(null)</code> ）线程的本地资源。在任何情况下都应该进行取消设置，因为不取消设置可能会导致出现问题。Spring的<code>ThreadLocal</code>支持为您完成此操作，应始终考虑使用<code>ThreadLocal</code>实例而不使用其他正确的处理代码。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-extensibility"><a class="anchor" href="#aop-extensibility"></a> 6.10。定义新的建议类型</h3>
<div class="paragraph">
<p>Spring AOP旨在可扩展。虽然拦截实现策略目前在内部使用，但除了围绕建议的拦截，之前，抛出建议以及返回建议之后，还可以支持任意建议类型。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.aop.framework.adapter</code>包是一个SPI包，可以在不更改核心框架的情况下添加对新自定义通知类型的支持。自定义<code>Advice</code>类型的唯一约束是它必须实现<code>org.aopalliance.aop.Advice</code>标记界面。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html"><code>org.springframework.aop.framework.adapter</code> Javadoc</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="null-safety"><a class="anchor" href="#null-safety"></a> 7。空安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>尽管Java不允许您使用其类型系统表示null安全性，但Spring Framework现在在<code>org.springframework.lang</code>包中提供以下注释，以便您声明API和字段的可空性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a> ：用于指示特定参数，返回值或字段不能为<code>null</code>注释（在<code>@NonNullApi</code>和<code>@NonNullFields</code>适用的参数和返回值上<code>@NonNullApi</code> ）。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a> ：用于指示特定参数，返回值或字段可以为<code>null</code>注释。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a> ：包级别的注释，声明非null作为参数和返回值的默认行为。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/lang/NonNullFields.html"><code>@NonNullFields</code></a> ：包级别的注释，声明非null作为字段的默认行为。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework利用这些注释，但它们也可以在任何基于Spring的Java项目中使用，以声明空安全API和可选的空安全字段。尚未支持泛型类型参数，varargs和数组元素可空性，但应在即将发布的版本中，请参阅<a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a>以获取最新信息。预计可以在Spring Framework版本之间微调可空性声明，包括次要版本。方法体内使用的类型的可为空性超出了此功能的范围。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Reactor或Spring Data等库提供使用此功能的空安全API。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="use-cases"><a class="anchor" href="#use-cases"></a> 7.1。用例</h3>
<div class="paragraph">
<p>除了提供Spring Framework API可空性的显式声明之外，IDE（例如IDEA或Eclipse）可以使用这些注释来提供与null安全相关的有用警告，以避免在运行时出现<code>NullPointerException</code> 。</p>
</div>
<div class="paragraph">
<p>它们还用于使Kotlin项目中的Spring API为null安全，因为Kotlin本身支持<a href="https://kotlinlang.org/docs/reference/null-safety.html">null安全性</a> 。<a href="languages.html#kotlin-null-safety">Kotlin支持文档</a>中提供了更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="jsr-305-meta-annotations"><a class="anchor" href="#jsr-305-meta-annotations"></a> 7.2。JSR 305元注释</h3>
<div class="paragraph">
<p>Spring注释是使用<a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>注释进行元注释的（一种休眠但广泛传播的JSR）。JSR 305元注释允许像IDEA或Kotlin这样的工具供应商以通用方式提供空安全支持，而无需对Spring注释进行硬编码支持。</p>
</div>
<div class="paragraph">
<p>没有必要也不建议在项目类路径中添加JSR 305依赖项以利用Spring null-safe API。只有在其代码库中使用空安全注释的基于Spring的库等项目才应添加带有<code>compileOnly</code> Gradle配置的<code>com.google.code.findbugs:jsr305:3.0.2</code>或Maven <code>provided</code>范围以避免编译警告。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="databuffers"><a class="anchor" href="#databuffers"></a> 8。数据缓冲区和编解码器</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>DataBuffer</code>接口定义了字节缓冲区的抽象。引入它的主要原因（而不是使用标准的<code>java.nio.相反， ByteBuffer</code>是Netty。Netty不使用<code>ByteBuffer</code> ，而是提供<code>ByteBuf</code>作为替代方案。Spring的<code>DataBuffer</code>是<code>ByteBuf</code>的简单抽象，也可以在非Netty平台上使用（即Servlet 3.1+）。</p>
</div>
<div class="sect2">
<h3 id="code-databufferfactory-code"><a class="anchor" href="#code-databufferfactory-code"></a> 8.1。<code>DataBufferFactory</code></h3>
<div class="paragraph">
<p><code>DataBufferFactory</code>提供分配新数据缓冲区以及包装现有数据的功能。<code>allocateBuffer</code>方法使用默认或给定容量分配新数据缓冲区。虽然<code>DataBuffer</code>实现按需增长和缩减，但如果知道的话，提前提供容量会更有效。<code>wrap</code>方法修饰现有的<code>ByteBuffer</code>或字节数组。包装不涉及分配。它使用<code>DataBuffer</code>实现装饰给定数据。</p>
</div>
<div class="paragraph">
<p><code>DataBufferFactory</code>有两个实现： <code>NettyDataBufferFactory</code> （用于Netty平台，如Reactor Netty）和<code>DefaultDataBufferFactory</code> （用于其他平台，如Servlet 3.1+服务器）。</p>
</div>
</div>
<div class="sect2">
<h3 id="the-code-databuffer-code-interface"><a class="anchor" href="#the-code-databuffer-code-interface"></a> 8.2。<code>DataBuffer</code>接口</h3>
<div class="paragraph">
<p><code>DataBuffer</code>接口类似于<code>ByteBuffer</code>但具有许多优点。与Netty的<code>ByteBuf</code>类似， <code>DataBuffer</code>抽象提供独立的读写位置。这与JDK的<code>ByteBuffer</code>不同，后者只显示读取和写入的一个位置，以及在两个I / O操作之间切换的单独的<code>flip()</code>操作。通常，以下不变量适用于读取位置，写入位置和容量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>0 &lt;=读取位置&lt;=写入位置&lt;=容量</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从<code>DataBuffer</code>读取字节时，读取位置将根据从缓冲区读取的数据量自动更新。类似地，当向<code>DataBuffer</code>写入字节时，写入位置会根据写入缓冲区的数据量进行更新。此外，在编写数据时， <code>DataBuffer</code>的容量会自动扩展，与<code>StringBuilder</code> ， <code>ArrayList</code>和类似类型的方式相同。</p>
</div>
<div class="paragraph">
<p>除了上面提到的读写功能外， <code>DataBuffer</code>还有一些方法可以将（切片）缓冲区视为<code>ByteBuffer</code> ， <code>InputStream</code>或<code>OutputStream</code> 。另外，它提供了确定给定字节索引的方法。</p>
</div>
<div class="paragraph">
<p>如前所述， <code>DataBufferFactory</code>有两个实现： <code>NettyDataBufferFactory</code> （用于Netty平台，如Reactor Netty）和<code>DefaultDataBufferFactory</code> （用于其他平台，如Servlet 3.1+服务器）。</p>
</div>
<div class="sect3">
<h4 id="code-pooleddatabuffer-code"><a class="anchor" href="#code-pooleddatabuffer-code"></a> 8.2.1。<code>PooledDataBuffer</code></h4>
<div class="paragraph">
<p><code>PooledDataBuffer</code>是<code>DataBuffer</code>的扩展，它添加了引用计数的方法。<code>retain</code>方法将引用计数增加1。<code>release</code>方法将计数减1，并在计数达到0时释放缓冲区的内存。这两种方法都与引用计数有关，这是我们<a href="#databuffer-reference-counting">稍后</a>解释的一种机制。</p>
</div>
<div class="paragraph">
<p>请注意， <code>DataBufferUtils</code>提供了有用的实用方法，用于释放和保留池化数据缓冲区。这些方法将普通的<code>DataBuffer</code>作为参数，但只有在传递的数据缓冲区是<code>PooledDataBuffer</code>的实例时才调用<code>retain</code>或<code>release</code> 。</p>
</div>
<div class="sect4">
<h5 id="databuffer-reference-counting"><a class="anchor" href="#databuffer-reference-counting"></a>参考计数</h5>
<div class="paragraph">
<p>引用计数不是Java中的常用技术。它在其他编程语言中更常见，例如Object C和C ++。就其本身而言，引用计数并不复杂。它主要涉及跟踪应用于对象的引用数。<code>PooledDataBuffer</code>的引用计数从1开始，通过调用<code>retain</code>递增，并通过调用<code>release</code>递减。只要缓冲区的引用计数大于0，就不会释放缓冲区。当数字减少到0时，实例被释放。实际上，这意味着缓冲区捕获的保留内存将返回到内存池，准备用于将来的分配。</p>
</div>
<div class="paragraph">
<p>通常，访问<code>DataBuffer</code>的最后一个组件负责释放它。在Spring中，有两种组件可以释放缓冲区：解码器和传输器。解码器负责将缓冲流转换为其他类型（请参阅<a href="#codecs">编解码器</a> ），并且传输负责跨网络边界发送缓冲区，通常作为HTTP消息。这意味着，如果为了将它们放入出站HTTP消息（即客户端请求或服务器端响应）而分配数据缓冲区，则不必释放它们。此规则的另一个结果是，如果您分配的数据缓冲区不会在正文中结束（例如，由于抛出的异常），您必须自己释放它们。以下代码段显示了处理抛出异常的方法时的典型<code>DataBuffer</code>使用方案：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataBufferFactory工厂= ...DataBuffer buffer = factory.allocateBuffer（）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">boolean</span> release = <span class="predefined-constant">true</span> ; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="keyword">尝试</span> {writeDataToBuffer（buffer）; <i class="conum" data-value="3"></i> <b>（3）</b> putBufferInHttpBody（缓冲区）; release = <span class="predefined-constant">false</span> ; <i class="conum" data-value="4"></i> <b>（4）</b> } <span class="keyword">finally</span> { <span class="keyword">if</span> （release）{DataBufferUtils.release（buffer）; <i class="conum" data-value="5"></i> <b>（5）</b> }} <span class="directive">private</span> <span class="type">void</span> writeDataToBuffer（ <span class="predefined-type">DataBuffer</span> buffer） <span class="directive">抛出</span> <span class="exception">IOException</span> { <i class="conum" data-value="3"></i> <b>（3）</b> ......}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>分配新缓冲区。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>布尔标志指示是否应释放分配的缓冲区。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>此示例方法将数据加载到缓冲区中。请注意，该方法可以抛出<code>IOException</code> 。因此，需要一个释放缓冲区的<code>finally</code>块。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>如果没有发生异常，我们将<code>release</code>标志切换为<code>false</code>因为缓冲区现在作为通过网络发送HTTP正文的一部分被释放。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>如果确实发生了异常，则该标志仍设置为<code>true</code> ，并在此处释放缓冲区。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="code-databufferutils-code"><a class="anchor" href="#code-databufferutils-code"></a> 8.2.2。<code>DataBufferUtils</code></h4>
<div class="paragraph">
<p><code>DataBufferUtils</code>类包含对数据缓冲区进行操作的各种实用程序方法。它包含从<code>InputStream</code>或NIO <code>Channel</code>读取<code>Flux</code> of <code>DataBuffer</code>对象的方法，以及将数据缓冲区<code>Flux</code>写入<code>OutputStream</code>或<code>Channel</code> 。
<code>DataBufferUtils</code>还公开了在纯<code>DataBuffer</code>实例上运行的<code>retain</code>和<code>release</code>方法（因此不需要转换为<code>PooledDataBuffer</code> ）。</p>
</div>
<div class="paragraph">
<p>另外， <code>DataBufferUtils</code>公开了<code>compose</code> ，它将数据缓冲区流合并为一个。例如，此方法可用于将整个HTTP主体转换为单个缓冲区（并从中转换为<code>String</code>或<code>InputStream</code> ）。在处理较旧的阻塞API时，这尤其有用。但请注意，这会将整个主体置于内存中，因此比纯流式解决方案使用更多内存。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="codecs"><a class="anchor" href="#codecs"></a> 8.3。编解码器</h3>
<div class="paragraph">
<p><code>org.springframework.core.codec</code>包中包含两个主要的抽象，用于将字节流转换为对象流，反之亦然。<code>Encoder</code>是一种策略接口，它将对象流编码为数据缓冲区的输出流。<code>Decoder</code>反过来：它将数据缓冲区流转换为对象流。注意，解码器实例需要考虑<a href="#databuffer-reference-counting">引用计数</a> 。</p>
</div>
<div class="paragraph">
<p>Spring提供了大量默认编解码器（用于转换为<code>String</code> ， <code>ByteBuffer</code>和字节数组）和支持编组库的编解码器，例如JAXB和Jackson（ <a href="https://github.com/FasterXML/jackson-core/issues/57">Jackson 2.9+支持非阻塞解析</a> ）。在Spring WebFlux的上下文中，编解码器用于将请求主体转换为<code>@RequestMapping</code>参数或将返回类型转换为发送回客户端的响应主体。默认编解码器在<code>WebFluxConfigurationSupport</code>类中配置。您可以通过在从该类继承时重写<code>configureHttpMessageCodecs</code>来更改它们。有关在WebFlux中使用编解码器的更多信息，请参阅<a href="web-reactive.html#webflux-codecs">[web-reactive #webflux-codecs]</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a> 9。附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a> 9.1。XML模式</h3>
<div class="paragraph">
<p>附录的这一部分列出了与核心容器相关的XML模式。</p>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util"><a class="anchor" href="#xsd-schemas-util"></a> 9.1.1。<code>util</code> Schema</h4>
<div class="paragraph">
<p>顾名思义， <code>util</code>标签处理常见的实用程序配置问题，例如配置集合，引用常量等。要在<code>util</code>模式中使用标记，您需要在Spring XML配置文件的顶部有以下前导码（片段中的文本引用正确的模式，以便<code>util</code>命名空间中的标记可供您使用）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：util</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/util</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-constant"><a class="anchor" href="#xsd-schemas-util-constant"></a>使用<code>&lt;util:constant/&gt;</code></h5>
<div class="paragraph">
<p>考虑以下bean定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">isolation</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.sql。连接。TRANSACTION_SERIALIZABLE</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans.factory.config。FieldRetrievingFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置使用Spring <code>FactoryBean</code>实现（ <code>FieldRetrievingFactoryBean</code> ）将bean上<code>isolation</code>属性的值设置为<code>java.sql.的值<code>java.sql.连接。TRANSACTION_SERIALIZABLE</code>常量。这一切都很好，但它很冗长，并且（不必要地）将Spring的内部管道暴露给最终用户。</p>
</div>
<div class="paragraph">
<p>以下基于XML Schema的版本更简洁，清楚地表达了开发人员的意图（“注入此常量值”），并且它读得更好：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">isolation</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;util：constant</span> <span class="attribute-name">static-field</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.sql。连接。TRANSACTION_SERIALIZABLE</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="xsd-schemas-util-frfb"><a class="anchor" href="#xsd-schemas-util-frfb"></a>从字段值设置Bean属性或构造函数参数</h6>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>是一个<code>FactoryBean</code> ，用于检索<code>static</code>或非静态字段值。它通常用于检索<code>public</code> <code>static</code> <code>final</code>常量，然后可以使用它来为另一个bean设置属性值或构造函数参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)"><code>staticField</code></a>属性公开<code>static</code>字段：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myField</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。FieldRetrievingFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">staticField</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">java.sql。连接。TRANSACTION_SERIALIZABLE</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还有一个便捷使用形式，其中<code>static</code>字段被指定为bean名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.sql。连接。TRANSACTION_SERIALIZABLE</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans.factory.config。FieldRetrievingFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这确实意味着bean <code>id</code>不再有任何选择（因此引用它的任何其他bean也必须使用这个更长的名称），但这种形式定义非常简洁，非常方便用作内部bean，因为不必为bean引用指定<code>id</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">isolation</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.sql。连接。TRANSACTION_SERIALIZABLE</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans.factory.config。FieldRetrievingFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以访问另一个bean的非静态（实例）字段，如<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>类的API文档中所述。</p>
</div>
<div class="paragraph">
<p>在Spring中，将枚举值作为属性或构造函数参数注入bean中很容易。您实际上不需要做任何事情或了解有关Spring内部的任何信息（甚至是关于诸如<code>FieldRetrievingFactoryBean</code>类的类）。以下示例枚举显示了注入枚举值的容易程度：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">javax.persistence</span> ; <span class="directive">public</span> <span class="type">enum</span> PersistenceContextType {TRANSACTION，EXTENDED}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑下面的<code>PersistenceContextType</code>类型的setter和相应的bean定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包装</span> <span class="namespace">示例</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Client</span> { <span class="directive">private</span> PersistenceContextType persistenceContextType; <span class="directive">public</span> <span class="type">void</span> setPersistenceContextType（PersistenceContextType type）{ <span class="local-variable">this</span> .persistenceContextType = type; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">示例。客户端</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">persistenceContextType</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TRANSACTION</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-property-path"><a class="anchor" href="#xsd-schemas-util-property-path"></a>使用<code>&lt;util:property-path/&gt;</code></h5>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 要通过名称引用的目标bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">spouse</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">11</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 结果为10，这是bean'testBean的属性'age'的值' - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean.age</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPathFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置使用Spring <code>FactoryBean</code>实现（ <code>PropertyPathFactoryBean</code> ）创建名为<code>testBean.age</code>的bean（类型为<code>int</code> ），其值等于<code>testBean</code> bean的<code>age</code>属性。</p>
</div>
<div class="paragraph">
<p>现在考虑以下示例，它添加了一个<code>&lt;util:property-path/&gt;</code>元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 要通过名称引用的目标bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">spouse</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">11</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 结果为10，这是bean'testBean的属性'age'的值' - &gt;</span> <span class="tag">&lt;util：property-path</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> <span class="attribute-name">path</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean.age</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>&lt;property-path/&gt;</code>元素的<code>path</code>属性的值遵循<code>beanName.beanProperty</code>的形式。在这种情况下，它会获取名为<code>testBean</code>的bean的<code>age</code>属性。该<code>age</code>属性的价值是<code>10</code> 。</p>
</div>
<div class="sect5">
<h6 id="xsd-schemas-util-property-path-dependency"><a class="anchor" href="#xsd-schemas-util-property-path-dependency"></a>使用<code>&lt;util:property-path/&gt;</code>设置Bean属性或构造函数参数</h6>
<div class="paragraph">
<p><code>PropertyPathFactoryBean</code>是一个<code>FactoryBean</code> ，用于计算给定目标对象的属性路径。目标对象可以直接指定，也可以通过bean名称指定。然后，您可以在另一个bean定义中将此值用作属性值或构造函数参数。</p>
</div>
<div class="paragraph">
<p>以下示例按名称显示了针对另一个bean使用的路径：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">//要通过名称引用的目标bean <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">person</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">spouse</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">11</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> //得到11，这是bean'人的'spouse.age'属性的值' <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theAge</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPathFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetBeanName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">person</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">propertyPath</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">spouse.age</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在以下示例中，将针对内部bean评估路径：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 结果为12，这是内部bean的属性'age'的值 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">theAge</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPathFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetObject</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.beans。TestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">12</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">propertyPath</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还有一个快捷方式表单，其中bean名称是属性路径。以下示例显示了快捷方式窗体：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 结果为10，这是bean'person'的属性'age'的值 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">person.age</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPathFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个表单确实意味着bean的名称没有选择。对它的任何引用也必须使用相同的<code>id</code> ，即路径。如果用作内部bean，则根本不需要引用它，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">age</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">person.age</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertyPathFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在实际定义中专门设置结果类型。对于大多数用例来说，这不是必需的，但它有时可能很有用。有关此功能的更多信息，请参阅Javadoc。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-properties"><a class="anchor" href="#xsd-schemas-util-properties"></a>使用<code>&lt;util:properties/&gt;</code></h5>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。具有从提供的位置加载的值的属性实例 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbcConfiguration</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。PropertiesFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">location</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：com / foo / jdbc-production.properties</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置使用Spring <code>FactoryBean</code>实现（ <code>PropertiesFactoryBean</code> ）来实例化<code>java.util.具有从提供的<a href="#resources"><code>Resource</code></a>位置加载的值的Properties</code>实例）。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>util:properties</code>元素来进行更简洁的表示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。从提供的位置加载值的属性实例 - &gt;</span> <span class="tag">&lt;util：properties</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbcConfiguration</span> <span class="delimiter">”</span></span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / foo / jdbc-production.properties</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-list"><a class="anchor" href="#xsd-schemas-util-list"></a>使用<code>&lt;util:list/&gt;</code></h5>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。列出从提供的'sourceList'加载值的实例 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。ListFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sourceList</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> pechorin@hero.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> raskolnikov@slums.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> stavrogin@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> porfiry@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置使用Spring <code>FactoryBean</code>实现（ <code>ListFactoryBean</code> ）来创建<code>java.util.List</code>实例并使用从提供的<code>sourceList</code>获取的值对其进行初始化。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>&lt;util:list/&gt;</code>元素进行更简洁的表示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。列出具有提供值的实例 - &gt;</span> <span class="tag">&lt;util：list</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">email</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> pechorin@hero.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> raskolnikov@slums.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> stavrogin @ gov。 org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> porfiry@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ util：list&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>&lt;util:list/&gt;</code>元素上的<code>list-class</code>属性显式控制实例化和填充的<code>List</code>的确切类型。例如，如果我们真的需要<code>java.util.要实例化的LinkedList</code> ，我们可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;util：list</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="attribute-name">list-class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.util。LinkedList</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> jackshaftoe@vagabond.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> eliza@thinkingmanscrumpet.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> vanhoek@pirate.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> d'Arcachon @ nemesis.org <span class="tag">&lt; / value&gt;</span> <span class="tag">&lt;/ util：list&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果未提供<code>list-class</code>属性，则容器将选择<code>List</code>实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-map"><a class="anchor" href="#xsd-schemas-util-map"></a>使用<code>&lt;util:map/&gt;</code></h5>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。使用从提供的'sourceMap'加载的值映射实例 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。MapFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sourceMap</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pechorin</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pechorin@hero.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">raskolnikov</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">raskolnikov@slums.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">stavrogin</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">stavrogin@gov.org</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">porfiry</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">porfiry@gov.org</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置使用Spring <code>FactoryBean</code>实现（ <code>MapFactoryBean</code> ）来创建<code>java.util.使用从提供的<code>'sourceMap'</code>获取的键值对初始化Map</code>实例。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>&lt;util:map/&gt;</code>元素进行更简洁的表示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。使用提供的键值对映射实例 - &gt;</span> <span class="tag">&lt;util：map</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">email</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pechorin</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pechorin@hero.org</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">raskolnikov</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">raskolnikov@slums.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">stavrogin</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">stavrogin@gov.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">porfiry</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">porfiry@gov.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ util：map&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>&lt;util:map/&gt;</code>元素上的<code>'map-class'</code>属性显式控制实例化和填充的<code>Map</code>的确切类型。例如，如果我们真的需要<code>java.util.要实例化的TreeMap</code> ，我们可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;util：map</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="attribute-name">map-class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.util。TreeMap</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pechorin</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pechorin@hero.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">raskolnikov</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">raskolnikov@slums.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">stavrogin</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">stavrogin @ gov.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">porfiry</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">porfiry@gov.org</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ util：map&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果未提供<code>'map-class'</code>属性，则容器将选择<code>Map</code>实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-set"><a class="anchor" href="#xsd-schemas-util-set"></a>使用<code>&lt;util:set/&gt;</code></h5>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。使用从提供的'sourceSet'加载的值设置实例 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.beans.factory.config。SetFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sourceSet</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;value&gt;</span> pechorin@hero.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> raskolnikov@slums.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> stavrogin@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> porfiry@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置使用Spring <code>FactoryBean</code>实现（ <code>SetFactoryBean</code> ）来创建<code>java.util.使用从提供的<code>sourceSet</code>获取的值初始化Set</code>实例。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>&lt;util:set/&gt;</code>元素进行更简洁的表示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 创建一个java.util。使用提供的值设置实例 - &gt;</span> <span class="tag">&lt;util：set</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> pechorin@hero.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> raskolnikov@slums.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> stavrogin @ gov。 org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> porfiry@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ util：set&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>&lt;util:set/&gt;</code>元素上的<code>set-class</code>属性显式控制实例化和填充的<code>Set</code>的确切类型。例如，如果我们真的需要<code>java.util.要实例化的TreeSet</code> ，我们可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;util：set</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emails</span> <span class="delimiter">”</span></span> <span class="attribute-name">set-class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.util。TreeSet</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> pechorin@hero.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> raskolnikov@slums.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> stavrogin@gov.org <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> porfiry@gov.org <span class="tag">&lt;/ value &gt;</span> <span class="tag">&lt;/ util：set&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果未提供<code>set-class</code>属性，则容器将选择<code>Set</code>实现。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-aop"><a class="anchor" href="#xsd-schemas-aop"></a> 9.1.2。<code>aop</code> Schema</h4>
<div class="paragraph">
<p><code>aop</code>标签用于配置Spring中的所有AOP，包括Spring自己的基于代理的AOP框架和Spring与AspectJ AOP框架的集成。这些标签在题为<a href="#aop">面向方面的Spring编程</a>一章中全面介绍。</p>
</div>
<div class="paragraph">
<p>为了完整性，要在<code>aop</code>模式中使用标记，您需要在Spring XML配置文件的顶部有以下前导码（片段中的文本引用正确的模式，以便<code>aop</code>命名空间中的标记为你可以得到）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：aop</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context"><a class="anchor" href="#xsd-schemas-context"></a> 9.1.3。<code>context</code>架构</h4>
<div class="paragraph">
<p><code>context</code>标记处理与管道相关的<code>ApplicationContext</code>配置 - 也就是说，通常不是对最终用户很重要的bean，而是在Spring中执行大量“grunt”工作的bean，例如<code>BeanfactoryPostProcessors</code> 。以下代码段引用了正确的架构，以便您可以使用<code>context</code>命名空间中的元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：context</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-pphc"><a class="anchor" href="#xsd-schemas-context-pphc"></a>使用<code>&lt;property-placeholder/&gt;</code></h5>
<div class="paragraph">
<p>此元素激活<code>${…​}</code>占位符的替换，这些占位符是针对指定的属性文件（作为<a href="#resources">Spring资源位置</a> ）解析的。此元素是一种便捷机制，可为您设置<a href="#beans-factory-placeholderconfigurer"><code>PropertyPlaceholderConfigurer</code></a> 。如果您需要更多地控制<code>PropertyPlaceholderConfigurer</code> ，您可以自己明确定义一个。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-ac"><a class="anchor" href="#xsd-schemas-context-ac"></a>使用<code>&lt;annotation-config/&gt;</code></h5>
<div class="paragraph">
<p>此元素激活Spring基础结构以检测bean类中的注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring的<a href="#beans-required-annotation"><code>@Required</code></a>和<a href="#beans-annotation-config"><code>@Autowired</code></a></p>
</li>
<li>
<p>JSR 250的@ <code>@PostConstruct</code> ，@ <code>@PreDestroy</code>和<code>@Resource</code> （如果有的话）</p>
</li>
<li>
<p>JPA的<code>@PersistenceContext</code>和<code>@PersistenceUnit</code> （如果可用）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>或者，您可以选择显式激活这些注释的各个<code>BeanPostProcessors</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此元素不会激活Spring的<a href="data-access.html#transaction-declarative-annotations"><code>@Transactional</code></a>注释的处理。您可以使用<a href="data-access.html#tx-decl-explained"><code>&lt;tx:annotation-driven/&gt;</code></a>元素来实现此目的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-component-scan"><a class="anchor" href="#xsd-schemas-context-component-scan"></a>使用<code>&lt;component-scan/&gt;</code></h5>
<div class="paragraph">
<p>此元素在<a href="#beans-annotation-config">基于注释的容器配置中进行了</a>详细<a href="#beans-annotation-config">说明</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-ltw"><a class="anchor" href="#xsd-schemas-context-ltw"></a>使用<code>&lt;load-time-weaver/&gt;</code></h5>
<div class="paragraph">
<p><a href="#aop-aj-ltw">在Spring Framework中使用AspectJ进行加载时编织时</a>详细介绍了此元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-sc"><a class="anchor" href="#xsd-schemas-context-sc"></a>使用<code>&lt;spring-configured/&gt;</code></h5>
<div class="paragraph">
<p>在<a href="#aop-atconfigurable">使用AspectJ依赖注入域对象与Spring中</a>详细说明了这个元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a>使用<code>&lt;mbean-export/&gt;</code></h5>
<div class="paragraph">
<p><a href="integration.html#jmx-context-mbeanexport">配置基于MBean导出的注释中</a>详细介绍了此元素。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-beans"><a class="anchor" href="#xsd-schemas-beans"></a> 9.1.4。豆类架构</h4>
<div class="paragraph">
<p>最后但并非最不重要的是，我们在<code>beans</code>模式中有元素。自框架诞生以来，这些元素一直存在于Spring中。这里没有显示<code>beans</code>模式中各种元素的示例，因为它们在<a href="#beans-factory-properties-detailed">依赖关系和配置中</a>得到了非常全面的<a href="#beans-factory-properties-detailed">介绍</a> （实际上，在整个<a href="#beans">章节中</a> ）。</p>
</div>
<div class="paragraph">
<p>请注意，您可以向<code>&lt;bean/&gt;</code> XML定义添加零个或多个键值对。如果有的话，使用这些额外的元数据完成的工作完全取决于您自己的自定义逻辑（因此，如果您按照标题为<a href="#xml-custom">XML Schema Authoring</a>的附录中所述编写自己的自定义元素，通常只能使用它。</p>
</div>
<div class="paragraph">
<p>以下示例显示了周围<code>&lt;bean/&gt;</code>上下文中的<code>&lt;meta/&gt;</code>元素（请注意，没有任何逻辑来解释它，元数据实际上是无用的）。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">foo</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyFoo</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;meta</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cacheName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">foo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Rick</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>这是示例<code>meta</code>元素</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>对于前面的示例，您可以假设有一些逻辑使用bean定义并设置一些使用提供的元数据的缓存基础结构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-custom"><a class="anchor" href="#xml-custom"></a> 9.2。XML Schema Authoring</h3>
<div id="xsd-custom-introduction" class="paragraph">
<p>从版本2.0开始，Spring提供了一种机制，用于为基本的Spring XML格式添加基于模式的扩展，以定义和配置bean。本节介绍如何编写自己的自定义XML bean定义解析器并将这些解析器集成到Spring IoC容器中。</p>
</div>
<div class="paragraph">
<p>为了便于创作使用模式感知XML编辑器的配置文件，Spring的可扩展XML配置机制基于XML Schema。如果您不熟悉Spring标准Spring发行版附带的当前XML配置扩展，则应首先阅读标题为<a href="#xsd-config">[xsd-config]</a>的附录。</p>
</div>
<div class="paragraph">
<p>要创建新的XML配置扩展：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#xsd-custom-schema">编写</a> XML模式来描述您的自定义元素。</p>
</li>
<li>
<p><a href="#xsd-custom-namespacehandler">编写</a>自定义<code>NamespaceHandler</code>实现。</p>
</li>
<li>
<p><a href="#xsd-custom-parser">代码</a>的一个或多个<code>BeanDefinitionParser</code>实现（这是真正的工作就完成了）。</p>
</li>
<li>
<p>使用Spring <a href="#xsd-custom-registration">注册</a>新工件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对于统一的示例，我们创建了一个XML扩展（一个自定义XML元素），它允许我们配置<code>SimpleDateFormat</code>类型的对象（来自<code>java.text</code>包）。完成后，我们将能够定义<code>SimpleDateFormat</code>类型的bean定义，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;myns：dateformat</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dateFormat</span> <span class="delimiter">”</span></span> <span class="attribute-name">pattern</span> = <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd HH：mm</span> <span class="delimiter">”</span></span> <span class="attribute-name">lenient</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（我们在本附录后面会包含更详细的示例。第一个简单示例的目的是引导您完成制作自定义扩展的基本步骤。）</p>
</div>
<div class="sect3">
<h4 id="xsd-custom-schema"><a class="anchor" href="#xsd-custom-schema"></a> 9.2.1。编写架构</h4>
<div class="paragraph">
<p>创建一个用于Spring的IoC容器的XML配置扩展，首先要创建一个XML Schema来描述扩展。对于我们的示例，我们使用以下模式来配置<code>SimpleDateFormat</code>对象：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  myns.xsd（包内org / springframework / samples / xml） - &gt;</span> <span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;xsd：schema</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.mycompany.com/schema/myns</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsd</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：beans</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="delimiter">“</span></span> <span class="attribute-name">的targetNamespace</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.mycompany.com/schema/myns</span> <span class="delimiter">“</span></span> <span class="attribute-name">将elementFormDefault</span> <span class="string"><span class="delimiter">=”</span> <span class="content">合格</span> <span class="delimiter"><span class="attribute-name">“attributeFormDefault</span></span></span> <span class="string"><span class="delimiter">=”</span> <span class="content">不合格</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;XSD：进口</span> <span class="attribute-name">命名空间</span> <span class="string"><span class="delimiter">=”</span> <span class="content">HTTP：// WWW .springframework.org / schema / beans</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;xsd：element</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dateformat</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;xsd：complexType&gt;</span> <span class="tag">&lt;xsd：complexContent&gt;</span> <span class="tag">&lt;xsd：extension</span> <span class="attribute-name">base</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans：identifiedType</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;xsd：attribute</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lenient</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xsd：boolean</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;xsd：attribute</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pattern</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xsd：string</span> <span class="delimiter">”</span></span> <span class="attribute-name">use</span> = <span class="string"><span class="delimiter">“</span> <span class="content">required</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ xsd：extension&gt;</span> <span class="tag">&lt;/ xsd：complexContent&gt;</span> <span class="tag">&lt;/ xsd：complexType&gt;</span> <span class="tag">&lt;/ xsd：element&gt;</span> <span class="tag">&lt;/ xsd：schema&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指示的行包含所有可识别标记的扩展名基础（意味着它们具有我们可以用作容器中的bean标识符的<code>id</code>属性）。我们可以使用此属性，因为我们导入了Spring提供的<code>beans</code>命名空间。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的模式允许我们使用<code>&lt;myns:dateformat/&gt;</code>元素直接在XML应用程序上下文文件中配置<code>SimpleDateFormat</code>对象，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;myns：dateformat</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dateFormat</span> <span class="delimiter">”</span></span> <span class="attribute-name">pattern</span> = <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd HH：mm</span> <span class="delimiter">”</span></span> <span class="attribute-name">lenient</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，在我们创建基础结构类之后，前面的XML代码段与以下XML代码段基本相同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dateFormat</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.text。SimpleDateFormat</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yyyy-HH-dd HH：mm</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">lenient</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前两个片段中的第二个在容器中创建一个bean（由名称为<code>SimpleDateFormat</code>类型的<code>dateFormat</code>标识），并设置了几个属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">基于模式的创建配置格式的方法允许与具有模式感知XML编辑器的IDE紧密集成。通过使用正确创作的架构，您可以使用自动完成功能让用户在枚举中定义的几个配置选项之间进行选择。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-namespacehandler"><a class="anchor" href="#xsd-custom-namespacehandler"></a> 9.2.2。编码<code>NamespaceHandler</code></h4>
<div class="paragraph">
<p>除了模式之外，我们需要一个<code>NamespaceHandler</code>来解析Spring在解析配置文件时遇到的这个特定命名空间的所有元素。对于此示例， <code>NamespaceHandler</code>应该负责解析<code>myns:dateformat</code>元素。</p>
</div>
<div class="paragraph">
<p><code>NamespaceHandler</code>接口有三个方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>init()</code> ：允许初始化<code>NamespaceHandler</code>并在使用处理程序之前由Spring调用。</p>
</li>
<li>
<p><code>BeanDefinition parse(Element, ParserContext)</code> ：当Spring遇到顶级元素（不嵌套在bean定义或不同的命名空间内）时调用。此方法本身可以注册bean定义，返回bean定义或两者。</p>
</li>
<li>
<p><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code> ：当Spring遇到不同命名空间的属性或嵌套元素时调用。一个或多个bean定义的装饰（例如）与<a href="#beans-factory-scopes">Spring支持</a>的<a href="#beans-factory-scopes">范围</a>一起使用。我们首先突出一个简单的例子，不使用装饰，之后我们在一个更高级的例子中展示装饰。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然您可以为整个命名空间编写自己的<code>NamespaceHandler</code> （因此提供解析命名空间中每个元素的代码），但通常情况是，Spring XML配置文件中的每个顶级XML元素都会生成一个bean定义（在我们的例子中，单个<code>&lt;myns:dateformat/&gt;</code>元素导致单个<code>SimpleDateFormat</code> bean定义）。Spring提供了许多支持此方案的便捷类。在以下示例中，我们使用<code>NamespaceHandlerSupport</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.samples.xml</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。NamespaceHandlerSupport</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">MyNamespaceHandler</span> <span class="directive">extends</span> NamespaceHandlerSupport { <span class="directive">public</span> <span class="type">void</span> init（）{ <strong>registerBeanDefinitionParser（ <span class="string"><span class="delimiter">“</span> <span class="content">dateformat</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> SimpleDateFormatBeanDefinitionParser（））;</strong> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可能会注意到此类中实际上并没有很多解析逻辑。实际上， <code>NamespaceHandlerSupport</code>类具有内置的委托概念。它支持注册任何数量的<code>BeanDefinitionParser</code>实例，当它需要解析其命名空间中的元素时，它会委托给它们。这种干净的关注分离让<code>NamespaceHandler</code>处理其命名空间中所有自定义元素的解析编排，同时委托<code>BeanDefinitionParsers</code>执行XML解析的繁琐工作。这意味着每个<code>BeanDefinitionParser</code>只包含解析单个自定义元素的逻辑，我们可以在下一步中看到。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-parser"><a class="anchor" href="#xsd-custom-parser"></a> 9.2.3。使用<code>BeanDefinitionParser</code></h4>
<div class="paragraph">
<p>如果<code>NamespaceHandler</code>遇到已映射到特定bean定义解析器的类型的XML元素（在本例中为<code>dateformat</code> ，则使用<code>BeanDefinitionParser</code> 。换句话说， <code>BeanDefinitionParser</code>负责解析模式中定义的一个不同的顶级XML元素。在解析器中，我们可以访问XML元素（以及它的子元素），以便我们可以解析自定义XML内容，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.samples.xml</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.support。BeanDefinitionBuilder</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。AbstractSingleBeanDefinitionParser</span> ; <span class="keyword">import</span> <span class="include">org.springframework.util。StringUtils</span> ; <span class="keyword">import</span> <span class="include">org.w3c.dom。元素</span> ; <span class="keyword">import</span> <span class="include">java.text。SimpleDateFormat</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleDateFormatBeanDefinitionParser</span> <span class="directive">扩展</span> AbstractSingleBeanDefinitionParser { <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">protected</span> <span class="predefined-type">class</span> getBeanClass（ <span class="predefined-type">Element</span> element）{ <span class="keyword">return</span> <span class="predefined-type">SimpleDateFormat</span> .class; <i class="conum" data-value="2"></i> <b>（2）</b> } <span class="directive">protected</span> <span class="type">void</span> doParse（ <span class="predefined-type">Element</span> element，BeanDefinitionBuilder bean）{ <span class="comment">//这将永远不会为null，因为模式明确要求提供一个值</span> <span class="predefined-type">String</span> pattern = element.getAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">pattern</span> <span class="delimiter">”</span></span> ）; bean.addConstructorArg（图案）; <span class="comment">//这是一个可选属性</span> <span class="predefined-type">String</span> lenient = element.getAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">lenient</span> <span class="delimiter">”</span></span> ）; <span class="keyword">如果</span> （StringUtils.hasText（宽松））{bean.addPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">宽松</span> <span class="delimiter">”，</span></span> <span class="predefined-type">布尔</span> .valueOf（宽松））; }}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>我们使用Spring提供的<code>AbstractSingleBeanDefinitionParser</code>来处理创建单个<code>BeanDefinition</code>的许多基本工作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们提供<code>AbstractSingleBeanDefinitionParser</code>超类，其类型是我们的单个<code>BeanDefinition</code>代表的类型。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个简单的例子中，这就是我们需要做的一切。我们的单个<code>BeanDefinition</code>的创建由<code>AbstractSingleBeanDefinitionParser</code>超类处理，bean定义的唯一标识符的提取和设置也是如此。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-registration"><a class="anchor" href="#xsd-custom-registration"></a> 9.2.4。注册处理程序和架构</h4>
<div class="paragraph">
<p>编码完成。剩下要做的就是让Spring XML解析基础架构了解我们的自定义元素。我们通过在两个专用属性文件中注册我们的自定义<code>namespaceHandler</code>和自定义XSD文件来实现。这些属性文件都放在应用程序的<code>META-INF</code>目录中，例如，可以与JAR文件中的二进制类一起分发。Spring XML解析基础结构通过使用这些特殊属性文件自动获取新扩展，其格式将在接下来的两节中详细介绍。</p>
</div>
<div class="sect4">
<h5 id="xsd-custom-registration-spring-handlers"><a class="anchor" href="#xsd-custom-registration-spring-handlers"></a>编写<code>META-INF/spring.handlers</code></h5>
<div class="paragraph">
<p>名为<code>spring.handlers</code>的属性文件包含XML Schema URI到命名空间处理程序类的映射。对于我们的示例，我们需要编写以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>HTTP \：//www.mycompany.com/schema/myns=org.springframework.samples.xml。MyNamespaceHandler</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（ <code>:</code>字符是Java属性格式的有效分隔符，因此<code>:</code> URI中的字符需要使用反斜杠进行转义。）</p>
</div>
<div class="paragraph">
<p>键值对的第一部分（键）是与自定义命名空间扩展关联的URI，需要与自定义XSD架构中指定的<code>targetNamespace</code>属性的值完全匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-custom-registration-spring-schemas"><a class="anchor" href="#xsd-custom-registration-spring-schemas"></a>写'META-INF / spring.schemas'</h5>
<div class="paragraph">
<p>名为<code>spring.schemas</code>的属性文件包含XML Schema位置（与模式声明一起使用，在XML文件中使用模式作为<code>xsi:schemaLocation</code>属性的一部分）到classpath资源的映射。需要此文件来防止Spring绝对必须使用需要Internet访问权限的默认<code>EntityResolver</code>来检索模式文件。如果在此属性文件中指定映射，Spring将在类路径中搜索模式（在本例中为<code>org.springframework.samples.xml</code>包中的<code>myns.xsd</code> ）。以下代码段显示了我们需要为自定义架构添加的行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>HTTP \：//www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（请记住<code>:</code>必须转义<code>:</code>字符。）</p>
</div>
<div class="paragraph">
<p>建议您在类路径上的<code>NamespaceHandler</code>和<code>BeanDefinitionParser</code>类旁边部署XSD文件（或多个文件）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-using"><a class="anchor" href="#xsd-custom-using"></a> 9.2.5。在Spring XML配置中使用自定义扩展</h4>
<div class="paragraph">
<p>使用自己实现的自定义扩展与使用Spring提供的“自定义”扩展之一没有什么不同。以下示例使用Spring XML配置文件中前面步骤中开发的自定义<code>&lt;dateformat/&gt;</code>元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：myns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.mycompany.com/schema/myns</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 作为顶级bean  - &gt;</span> <span class="tag">&lt;myns：dateformat</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultDateFormat</span> <span class="delimiter">“</span></span> <span class="attribute-name">pattern</span> = <span class="string"><span class="delimiter">”</span> <span class="content">yyyy-MM-dd HH：mm</span> <span class="delimiter">“</span></span> <span class="attribute-name">lenient</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jobDetailTemplate</span> <span class="delimiter">”</span></span> <span class="attribute-name">abstract</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dateFormat</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 作为内部bean  - &gt;</span> <span class="tag">&lt;myns：dateformat</span> <span class="attribute-name">pattern</span> = <span class="string"><span class="delimiter">“</span> <span class="content">HH：mm MM-dd-yyyy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>我们的自定义bean。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-meat"><a class="anchor" href="#xsd-custom-meat"></a> 9.2.6。更详细的例子</h4>
<div class="paragraph">
<p>本节介绍自定义XML扩展的一些更详细的示例。</p>
</div>
<div class="sect4">
<h5 id="xsd-custom-custom-nested"><a class="anchor" href="#xsd-custom-custom-nested"></a>在自定义元素中嵌套自定义元素</h5>
<div class="paragraph">
<p>本节中提供的示例显示了如何编写满足以下配置目标所需的各种工件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：foo</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.foo.com/schema/component</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.foo.com/schema/component http://www.foo.com/schema/component/component.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;foo：component</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bionic-family</span> <span class="delimiter">“</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Bionic-1</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;foo ：component</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Mother-1</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;foo：component</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Karate-1</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;foo：component</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Sport-1</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ foo：component&gt;</span> <span class="tag">&lt;foo：component</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Rock -1</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ foo：component&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述配置将自定义扩展嵌套在彼此之内。实际由<code>&lt;foo:component/&gt;</code>元素配置的类是<code>Component</code>类（在下一个示例中显示）。注意<code>Component</code>类如何不公开<code>components</code>属性的setter方法。这使得通过使用setter注入为<code>Component</code>类配置bean定义很困难（或者更不可能）。以下清单显示了<code>Component</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">java.util。ArrayList</span> ; <span class="keyword">import</span> <span class="include">java.util。清单</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Component</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">private</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">Component</span> &gt; components = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> &lt; <span class="predefined-type">Component</span> &gt;（）; <span class="comment">// MMM，存在用于“部件”</span> <span class="directive">公共</span> <span class="type">无效</span> addComponent（ <span class="predefined-type">色差</span>分量）{ <span class="local-variable">此</span> .components.add（组分） <span class="comment">没有setter方法</span> ; <span class="directive">public</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">Component</span> &gt; getComponents（）{ <span class="keyword">返回</span>组件; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> name; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此问题的典型解决方案是创建一个自定义<code>FactoryBean</code> ，用于公开<code>components</code>属性的setter属性。以下清单显示了这样的自定义<code>FactoryBean</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory。FactoryBean</span> ; <span class="keyword">import</span> <span class="include">java.util。清单</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">ComponentFactoryBean</span> <span class="directive">实现</span> FactoryBean &lt; <span class="predefined-type">Component</span> &gt; { <span class="directive">private</span> <span class="predefined-type">Component</span> parent; <span class="directive">私人</span> <span class="predefined-type">清单</span> &lt; <span class="predefined-type">组件</span> &gt;儿童; <span class="directive">public</span> <span class="type">void</span> setParent（ <span class="predefined-type">Component</span> parent）{ <span class="local-variable">this</span> .parent = parent; <span class="directive">public</span> <span class="type">void</span> setChildren（ <span class="predefined-type">List</span> &lt; <span class="predefined-type">Component</span> &gt; children）{ <span class="local-variable">this</span> .children = children; <span class="directive">public</span> <span class="predefined-type">Component</span> getObject（） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="keyword">if</span> （ <span class="local-variable">this</span> .children！= <span class="predefined-constant">null</span> &amp;&amp; <span class="local-variable">this</span> .children.size（）&gt; <span class="integer">0</span> ）{ <span class="keyword">for</span> （ <span class="predefined-type">Component</span> child：children）{ <span class="local-variable">this</span> .parent.addComponent（child）; <span class="keyword">返回</span> <span class="local-variable">此</span> .parent; <span class="directive">public</span> <span class="predefined-type">Class</span> &lt; <span class="predefined-type">Component</span> &gt; getObjectType（）{ <span class="keyword">return</span> <span class="predefined-type">Component</span> .class; <span class="directive">public</span> <span class="type">boolean</span> isSingleton（）{ <span class="keyword">return</span> <span class="predefined-constant">true</span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这很好用，但它向最终用户公开了很多Spring管道。我们要做的是编写一个隐藏所有Spring管道的自定义扩展。如果我们坚持<a href="#xsd-custom-introduction">前面描述的步骤</a> ，我们首先创建XSD架构来定义自定义标记的结构，如下面的清单所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”standalone =“no”？&gt;</span> <span class="tag">&lt;xsd：schema</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.foo.com/schema/component</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsd</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema</span> <span class="delimiter">”</span></span> <span class="attribute-name">targetNamespace</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www。 foo.com/schema/component</span> <span class="delimiter">“</span></span> <span class="attribute-name">将elementFormDefault</span> <span class="string"><span class="delimiter">=”</span> <span class="content">合格</span> <span class="delimiter"><span class="attribute-name">“attributeFormDefault</span></span></span> <span class="string"><span class="delimiter">=”</span> <span class="content">不合格</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;XSD：元素</span> <span class="attribute-name">名称</span> <span class="string"><span class="delimiter">=”</span> <span class="content">组件</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;XSD：复杂类型&gt;</span> <span class="tag">&lt;XSD：选择</span> <span class="attribute-name">的minOccurs</span> <span class="string"><span class="delimiter">=”</span> <span class="content">0</span></span> <span class="attribute-name"><span class="string"><span class="delimiter">“maxOccurs</span></span>的</span> <span class="string"><span class="delimiter">=”</span> <span class="content">无限</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt; xsd：element</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">component</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ xsd：choice&gt;</span> <span class="tag">&lt;xsd：attribute</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xsd：ID</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;xsd：attribute</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> <span class="attribute-name">use</span> = <span class="string"><span class="delimiter">“</span> <span class="content">required</span> <span class="delimiter">”</span></span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xsd：string</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ xsd：complexType&gt;</span> <span class="tag">&lt;/ xsd：element&gt;</span> <span class="tag">&lt;/ xsd：schema&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>再次按照<a href="#xsd-custom-introduction">前面描述的过程</a> ，我们再创建一个自定义<code>NamespaceHandler</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。NamespaceHandlerSupport</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ComponentNamespaceHandler</span> <span class="directive">extends</span> NamespaceHandlerSupport { <span class="directive">public</span> <span class="type">void</span> init（）{registerBeanDefinitionParser（ <span class="string"><span class="delimiter">“</span> <span class="content">component</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> ComponentBeanDefinitionParser（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来是自定义<code>BeanDefinitionParser</code> 。请记住，我们正在创建描述<code>ComponentFactoryBean</code> <code>BeanDefinition</code> 。以下清单显示了我们的自定义<code>BeanDefinitionParser</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.config。BeanDefinition</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.support。AbstractBeanDefinition</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.support。BeanDefinitionBuilder</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.support。ManagedList</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。AbstractBeanDefinitionParser</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。ParserContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.util.xml。DomUtils</span> ; <span class="keyword">import</span> <span class="include">org.w3c.dom。元素</span> ; <span class="keyword">import</span> <span class="include">java.util。清单</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ComponentBeanDefinitionParser</span> <span class="directive">extends</span> AbstractBeanDefinitionParser { <span class="directive">protected</span> AbstractBeanDefinition parseInternal（ <span class="predefined-type">Element</span> element，ParserContext parserContext）{ <span class="keyword">return</span> parseComponentElement（element）; <span class="directive">private</span> <span class="directive">static</span> AbstractBeanDefinition parseComponentElement（ <span class="predefined-type">Element</span> element）{BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition（ComponentFactoryBean.class）; factory.addPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">parent</span> <span class="delimiter">”</span></span> ，parseComponent（element））; <span class="predefined-type">List</span> &lt; <span class="predefined-type">Element</span> &gt; childElements = DomUtils.getChildElementsByTagName（element， <span class="string"><span class="delimiter">“</span> <span class="content">component</span> <span class="delimiter">”</span></span> ）; <span class="keyword">if</span> （childElements！= <span class="predefined-constant">null</span> &amp;&amp; childElements.size（）&gt; <span class="integer">0</span> ）{parseChildComponents（childElements，factory）; } <span class="keyword">return</span> factory.getBeanDefinition（）; <span class="directive">private</span> <span class="directive">static</span> BeanDefinition parseComponent（ <span class="predefined-type">Element</span> element）{BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition（ <span class="predefined-type">Component</span> .class）; component.addPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ，element.getAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">return</span> component.getBeanDefinition（）; <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> parseChildComponents（ <span class="predefined-type">List</span> &lt; <span class="predefined-type">Element</span> &gt; childElements，BeanDefinitionBuilder factory）{ManagedList &lt;BeanDefinition&gt; children = <span class="keyword">new</span> ManagedList &lt;BeanDefinition&gt;（childElements.size（））; <span class="keyword">for</span> （ <span class="predefined-type">Element</span> element：childElements）{children.add（parseComponentElement（element））; } factory.addPropertyValue（ <span class="string"><span class="delimiter">“</span> <span class="content">children</span> <span class="delimiter">”</span></span> ，children）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，在Spring XML基础结构中注册各种工件，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>#in'META-INF / spring.handlers'http：//www.foo.com/schema/component=com.foo。ComponentNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#in'META-INF / spring.schemas'http：//www.foo.com/schema/component/component.xsd=com/foo/component.xsd</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-custom-custom-just-attributes"><a class="anchor" href="#xsd-custom-custom-just-attributes"></a> “普通”元素的自定义属性</h5>
<div class="paragraph">
<p>编写自己的自定义解析器和相关工件并不难。但是，有时这不是正确的做法。考虑需要向现有bean定义添加元数据的场景。在这种情况下，您当然不希望编写自己的整个自定义扩展。相反，您只想在现有bean定义元素中添加其他属性。</p>
</div>
<div class="paragraph">
<p>通过另一个示例，假设您为服务对象（未知）访问集群<a href="http://jcp.org/en/jsr/detail?id=107">JCache</a>定义了bean定义，并且您希望确保在周围集群中急切地启动指定的JCache实例。以下清单显示了这样一个定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">checkingAccountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.foo。DefaultCheckingAccountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">jcache：cache-name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">checking.account</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 此处的其他依赖项...  - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以在解析<code>'jcache:cache-name'</code>属性时创建另一个<code>BeanDefinition</code> 。然后，此<code>BeanDefinition</code>为我们初始化命名的JCache。我们还可以修改<code>'checkingAccountService'</code>的现有<code>BeanDefinition</code> ，以便它依赖于这个新的JCache初始化<code>BeanDefinition</code> 。以下清单显示了我们的<code>JCacheInitializer</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">JCacheInitializer</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">public</span> JCacheInitializer（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> <span class="type">void</span> initialize（）{ <span class="comment">//许多JCache API调用来初始化命名缓存...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们可以转到自定义扩展。首先，我们需要编写描述自定义属性的XSD架构，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”standalone =“no”？&gt;</span> <span class="tag">&lt;xsd：schema</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.foo.com/schema/jcache</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsd</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema</span> <span class="delimiter">”</span></span> <span class="attribute-name">targetNamespace</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www。 foo.com/schema/jcache</span> <span class="delimiter">“</span></span> <span class="attribute-name">将elementFormDefault</span> <span class="string"><span class="delimiter">=”</span> <span class="content">合格</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;XSD：属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">高速缓存名</span> <span class="delimiter">“</span></span> <span class="attribute-name">类型</span> <span class="string"><span class="delimiter">=”</span> <span class="content">XSD：字符串</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;/ XSD：模式&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们需要创建关联的<code>NamespaceHandler</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。NamespaceHandlerSupport</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">JCacheNamespaceHandler</span> <span class="directive">扩展了</span> NamespaceHandlerSupport { <span class="directive">public</span> <span class="type">void</span> init（）{ <span class="local-variable">super</span> .registerBeanDefinitionDecoratorForAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">cache-name</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> JCacheInitializingBeanDefinitionDecorator（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们需要创建解析器。请注意，在这种情况下，因为我们要解析XML属性，所以我们编写<code>BeanDefinitionDecorator</code>而不是<code>BeanDefinitionParser</code> 。以下清单显示了我们的<code>BeanDefinitionDecorator</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.config。BeanDefinitionHolder</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.support。AbstractBeanDefinition</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.support。BeanDefinitionBuilder</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。BeanDefinitionDecorator</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.xml。ParserContext</span> ; <span class="keyword">import</span> <span class="include">org.w3c.dom。Attr</span> ; <span class="keyword">import</span> <span class="include">org.w3c.dom。节点</span> ; <span class="keyword">import</span> <span class="include">java.util。ArrayList</span> ; <span class="keyword">import</span> <span class="include">java.util。数组</span> ; <span class="keyword">import</span> <span class="include">java.util。清单</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">JCacheInitializingBeanDefinitionDecorator</span> <span class="directive">实现</span> BeanDefinitionDecorator { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> EMPTY_STRING_ARRAY = <span class="keyword">new</span> <span class="predefined-type">String</span> [ <span class="integer">0</span> ]; <span class="directive">public</span> BeanDefinitionHolder decorate（Node source，BeanDefinitionHolder holder，ParserContext ctx）{ <span class="predefined-type">String</span> initializerBeanName = registerJCacheInitializer（source，ctx）; createDependencyOnJCacheInitializer（holder，initializerBeanName）; <span class="keyword">回报</span>持有人; <span class="directive">private</span> <span class="type">void</span> createDependencyOnJCacheInitializer（BeanDefinitionHolder holder， <span class="predefined-type">String</span> initializerBeanName）{AbstractBeanDefinition definition =（（AbstractBeanDefinition）holder.getBeanDefinition（））; <span class="predefined-type">String</span> <span class="type">[]</span> dependsOn = definition.getDependsOn（）; <span class="keyword">if</span> （dependsOn == <span class="predefined-constant">null</span> ）{dependsOn = <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> {initializerBeanName}; } <span class="keyword">else</span> { <span class="predefined-type">List</span> dependencies = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> （ <span class="predefined-type">Arrays</span> .asList（dependsOn））; dependencies.add（ini​​tializerBeanName）; dependsOn =（ <span class="predefined-type">String</span> <span class="type">[]</span> ）dependencies.toArray（EMPTY_STRING_ARRAY）; } definition.setDependsOn（dependsOn）; <span class="directive">private</span> <span class="predefined-type">String</span> registerJCacheInitializer（Node source，ParserContext ctx）{ <span class="predefined-type">String</span> cacheName =（（Attr）source）.getValue（）; <span class="predefined-type">String</span> beanName = cacheName + <span class="string"><span class="delimiter">“-</span> <span class="content">initializer</span> <span class="delimiter">”</span></span> ; <span class="keyword">如果</span> （！ctx.getRegistry（）。containsBeanDefinition（beanName））{BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition（JCacheInitializer.class）; initializer.addConstructorArg（cacheName）; ctx.getRegistry（）。registerBeanDefinition（beanName，initializer.getBeanDefinition（））; } <span class="keyword">return</span> beanName; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，我们需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件来注册Spring XML基础结构中的各种工件，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>#in'META-INF / spring.handlers'http：//www.foo.com/schema/jcache=com.foo。JCacheNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#in'META-INF / spring.schemas'http：//www.foo.com/schema/jcache/jcache.xsd=com/foo/jcache.xsd</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>