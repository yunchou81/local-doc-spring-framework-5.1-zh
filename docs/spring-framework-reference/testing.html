<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8"></meta>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
<meta name="generator" content="Asciidoctor 1.5.5"></meta>
<title>测试</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="testing" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>测试</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#testing-introduction">1。弹簧测试简介</a></li>
<li><a href="#unit-testing">2。单元测试</a>
<ul class="sectlevel2">
<li><a href="#mock-objects">2.1。模拟物体</a>
<ul class="sectlevel3">
<li><a href="#mock-objects-env">2.1.1。环境</a></li>
<li><a href="#mock-objects-jndi">2.1.2。JNDI</a></li>
<li><a href="#mock-objects-servlet">2.1.3。Servlet API</a></li>
<li><a href="#mock-objects-web-reactive">2.1.4。Spring Web Reactive</a></li>
</ul>
</li>
<li><a href="#unit-testing-support-classes">2.2。单元测试支持类</a>
<ul class="sectlevel3">
<li><a href="#unit-testing-utilities">2.2.1。一般测试实用程序</a></li>
<li><a href="#unit-testing-spring-mvc">2.2.2。Spring MVC测试实用程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#integration-testing">3。集成测试</a>
<ul class="sectlevel2">
<li><a href="#integration-testing-overview">3.1。概观</a></li>
<li><a href="#integration-testing-goals">3.2。集成测试的目标</a>
<ul class="sectlevel3">
<li><a href="#testing-ctx-management">3.2.1。上下文管理和缓存</a></li>
<li><a href="#testing-fixture-di">3.2.2。测试夹具的依赖注入</a></li>
<li><a href="#testing-tx">3.2.3。交易管理</a></li>
<li><a href="#testing-support-classes">3.2.4。支持集成测试的类</a></li>
</ul>
</li>
<li><a href="#integration-testing-support-jdbc">3.3。JDBC测试支持</a></li>
<li><a href="#integration-testing-annotations">3.4。注释</a>
<ul class="sectlevel3">
<li><a href="#integration-testing-annotations-spring">3.4.1。Spring测试注释</a>
<ul class="sectlevel4">
<li><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></li>
<li><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></li>
<li><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></li>
<li><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></li>
<li><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></li>
<li><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></li>
<li><a href="#spring-testing-annotation-commit"><code>@承诺</code></a></li>
<li><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></li>
<li><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></li>
<li><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></li>
<li><a href="#spring-testing-annotation-sql"><code>@sql</code></a></li>
<li><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></li>
<li><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-standard">3.4.2。标准注释支持</a></li>
<li><a href="#integration-testing-annotations-junit4">3.4.3。Spring JUnit 4测试注释</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>同时@IfProfileValue</code></a></li>
<li><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></li>
<li><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></li>
<li><a href="#integration-testing-annotations-junit4-repeat"><code>@重复</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-junit-jupiter">3.4.4。Spring JUnit Jupiter测试注释</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-meta">3.4.5。测试的元注释支持</a></li>
</ul>
</li>
<li><a href="#testcontext-framework">3.5。Spring TestContext框架</a>
<ul class="sectlevel3">
<li><a href="#testcontext-key-abstractions">3.5.1。关键抽象</a>
<ul class="sectlevel4">
<li><a href="#code-testcontext-code"><code>的TestContext</code></a></li>
<li><a href="#code-testcontextmanager-code"><code>TestContextManager来</code></a></li>
<li><a href="#code-testexecutionlistener-code"><code>TestExecutionListener的</code></a></li>
<li><a href="#context-loaders">上下文加载器</a></li>
</ul>
</li>
<li><a href="#testcontext-bootstrapping">3.5.2。引导TestContext框架</a></li>
<li><a href="#testcontext-tel-config">3.5.3。<code>TestExecutionListener</code>配置</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tel-config-registering-tels">注册自定义<code>TestExecutionListener</code>实现</a></li>
<li><a href="#testcontext-tel-config-automatic-discovery">自动发现默认的<code>TestExecutionListener</code>实现</a></li>
<li><a href="#testcontext-tel-config-ordering">订购<code>TestExecutionListener</code>实现</a></li>
<li><a href="#testcontext-tel-config-merging">合并<code>TestExecutionListener</code>实现</a></li>
</ul>
</li>
<li><a href="#testcontext-ctx-management">3.5.4。上下文管理</a>
<ul class="sectlevel4">
<li><a href="#testcontext-ctx-management-xml">使用XML资源配置上下文</a></li>
<li><a href="#testcontext-ctx-management-groovy">使用Groovy脚本配置上下文</a></li>
<li><a href="#testcontext-ctx-management-javaconfig">带注释类的上下文配置</a></li>
<li><a href="#testcontext-ctx-management-mixed-config">混合XML，Groovy脚本和带注释的类</a></li>
<li><a href="#testcontext-ctx-management-initializers">使用上下文初始化器配置上下文</a></li>
<li><a href="#testcontext-ctx-management-inheritance">上下文配置继承</a></li>
<li><a href="#testcontext-ctx-management-env-profiles">使用环境配置文件配置上下文</a></li>
<li><a href="#testcontext-ctx-management-property-sources">使用测试属性源配置上下文</a></li>
<li><a href="#testcontext-ctx-management-web">加载<code>WebApplicationContext</code></a></li>
<li><a href="#testcontext-ctx-management-caching">上下文缓存</a></li>
<li><a href="#testcontext-ctx-management-ctx-hierarchies">上下文层次结构</a></li>
</ul>
</li>
<li><a href="#testcontext-fixture-di">3.5.5。测试夹具的依赖注入</a></li>
<li><a href="#testcontext-web-scoped-beans">3.5.6。测试请求和会话范围的Bean</a></li>
<li><a href="#testcontext-tx">3.5.7。交易管理</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tx-test-managed-transactions">测试管理的事务</a></li>
<li><a href="#testcontext-tx-enabling-transactions">启用和禁用事务</a></li>
<li><a href="#testcontext-tx-rollback-and-commit-behavior">事务回滚和提交行为</a></li>
<li><a href="#testcontext-tx-programmatic-tx-mgt">程序化交易管理</a></li>
<li><a href="#testcontext-tx-before-and-after-tx">在交易之外运行代码</a></li>
<li><a href="#testcontext-tx-mgr-config">配置事务管理器</a></li>
<li><a href="#testcontext-tx-annotation-demo">演示所有与交易相关的注释</a></li>
</ul>
</li>
<li><a href="#testcontext-executing-sql">3.5.8。执行SQL脚本</a>
<ul class="sectlevel4">
<li><a href="#testcontext-executing-sql-programmatically">以编程方式执行SQL脚本</a></li>
<li><a href="#testcontext-executing-sql-declaratively">使用@Sql以声明方式执行SQL脚本</a></li>
</ul>
</li>
<li><a href="#testcontext-parallel-test-execution">3.5.9。并行测试执行</a></li>
<li><a href="#testcontext-support-classes">3.5.10。TestContext框架支持类</a>
<ul class="sectlevel4">
<li><a href="#testcontext-junit4-runner">Spring JUnit 4 Runner</a></li>
<li><a href="#testcontext-junit4-rules">Spring JUnit 4规则</a></li>
<li><a href="#testcontext-support-classes-junit4">JUnit 4支持类</a></li>
<li><a href="#testcontext-junit-jupiter-extension">JUnit Jupiter的SpringExtension</a></li>
<li><a href="#testcontext-junit-jupiter-di"><code>SpringExtension</code>依赖注入</a></li>
<li><a href="#testcontext-support-classes-testng">TestNG支持类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-mvc-test-framework">3.6。Spring MVC测试框架</a>
<ul class="sectlevel3">
<li><a href="#spring-mvc-test-server">3.6.1。服务器端测试</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-static-imports">静态进口</a></li>
<li><a href="#spring-mvc-test-server-setup-options">设置选择</a></li>
<li><a href="#spring-mvc-test-server-setup-steps">设置功能</a></li>
<li><a href="#spring-mvc-test-server-performing-requests">执行请求</a></li>
<li><a href="#spring-mvc-test-server-defining-expectations">定义期望</a></li>
<li><a href="#spring-mvc-test-server-filters">过滤注册</a></li>
<li><a href="#spring-mvc-test-vs-end-to-end-integration-tests">容器外和端到端集成测试之间的差异</a></li>
<li><a href="#spring-mvc-test-server-resources">进一步的服务器端测试示例</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-server-htmlunit">3.6.2。HtmlUnit集成</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-htmlunit-why">为何选择HtmlUnit？</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc和HtmlUnit</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc和WebDriver</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc和Geb</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-client">3.6.3。客户端REST测试</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-client-static-imports">静态进口</a></li>
<li><a href="#spring-mvc-test-client-resources">客户端REST测试的更多示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webtestclient">3.7。WebTestClient</a>
<ul class="sectlevel3">
<li><a href="#webtestclient-setup">3.7.1。建立</a>
<ul class="sectlevel4">
<li><a href="#webtestclient-controller-config">绑定到控制器</a></li>
<li><a href="#webtestclient-fn-config">绑定到路由器功能</a></li>
<li><a href="#webtestclient-context-config">绑定到<code>ApplicationContext</code></a></li>
<li><a href="#webtestclient-server-config">绑定到服务器</a></li>
<li><a href="#webtestclient-client-config">Client Builder</a></li>
</ul>
</li>
<li><a href="#webtestclient-tests">3.7.2。写测试</a>
<ul class="sectlevel4">
<li><a href="#webtestclient-no-content">无内容</a></li>
<li><a href="#webtestclient-json">JSON内容</a></li>
<li><a href="#webtestclient-stream">流式响应</a></li>
<li><a href="#webtestclient-request-body">请求机构</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#testing-examples-petclinic">3.8。PetClinic示例</a></li>
</ul>
</li>
<li><a href="#testing-resources">4。更多资源</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍Spring对集成测试的支持和单元测试的最佳实践。Spring团队提倡测试驱动开发（TDD）。Spring团队发现正确使用控制反转（IoC）肯定会使单元和集成测试更容易（因为类的setter方法和适当的构造函数的存在使得它们更容易在测试中连接在一起而不必设置服务定位器注册表和类似结构）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-introduction"><a class="anchor" href="#testing-introduction"></a> 1。弹簧测试简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>测试是企业软件开发不可或缺的一部分。本章重点介绍IoC原理对<a href="#unit-testing">单元测试的</a>附加值以及Spring Framework对<a href="#integration-testing">集成测试</a>支持的好处。（对企业中的测试进行全面处理超出了本参考手册的范围。）</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unit-testing"><a class="anchor" href="#unit-testing"></a> 2。单元测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与传统的Java EE开发相比，依赖注入应该使您的代码对容器的依赖性降低。构成应用程序的POJO应该在JUnit或TestNG测试中可测试，对象使用<code>new</code>运算符实例化，不使用Spring或任何其他容器。您可以使用<a href="#mock-objects">模拟对象</a> （与其他有价值的测试技术结合使用）来单独测试代码。如果您遵循Spring的体系结构建议，那么代码库的干净分层和组件化便于单元测试。例如，您可以通过存根或模拟DAO或存储库接口来测试服务层对象，而无需在运行单元测试时访问持久数据。</p>
</div>
<div class="paragraph">
<p>真正的单元测试通常运行得非常快，因为没有要设置的运行时基础结构。强调真正的单元测试作为开发方法的一部分可以提高您的工作效率。您可能不需要测试章节的这一部分来帮助您为基于IoC的应用程序编写有效的单元测试。但是，对于某些单元测试场景，Spring Framework提供了模拟对象和测试支持类，本章将对其进行介绍。</p>
</div>
<div class="sect2">
<h3 id="mock-objects"><a class="anchor" href="#mock-objects"></a> 2.1。模拟物体</h3>
<div class="paragraph">
<p>Spring包含许多专门用于模拟的包：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mock-objects-env">环境</a></p>
</li>
<li>
<p><a href="#mock-objects-jndi">JNDI</a></p>
</li>
<li>
<p><a href="#mock-objects-servlet">Servlet API</a></p>
</li>
<li>
<p><a href="#mock-objects-web-reactive">Spring Web Reactive</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mock-objects-env"><a class="anchor" href="#mock-objects-env"></a> 2.1.1。环境</h4>
<div class="paragraph">
<p><code>org.springframework.mock.env</code>包中包含<code>Environment</code>和<code>PropertySource</code>抽象的模拟实现（请参阅<a href="core.html#beans-definition-profiles">Bean Definition Profiles</a>和<a href="core.html#beans-property-source-abstraction"><code>PropertySource</code> Abstraction</a> ）。
<code>MockEnvironment</code>和<code>MockPropertySource</code>对于开发依赖于特定于环境的属性的代码的容器外测试非常有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-jndi"><a class="anchor" href="#mock-objects-jndi"></a> 2.1.2。JNDI</h4>
<div class="paragraph">
<p><code>org.springframework.mock.jndi</code>包中包含JNDI SPI的实现，您可以使用它为测试套件或独立应用程序设置简单的JNDI环境。例如，如果JDBC <code>DataSource</code>实例在测试代码中绑定到与Java EE容器中相同的JNDI名称，则可以在测试方案中重用应用程序代码和配置而无需修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-servlet"><a class="anchor" href="#mock-objects-servlet"></a> 2.1.3。Servlet API</h4>
<div class="paragraph">
<p><code>org.springframework.mock.web</code>包中包含一组全面的Servlet API模拟对象，可用于测试Web上下文，控制器和过滤器。这些模拟对象的目标是使用Spring的Web MVC框架，并且通常比动态模拟对象（例如<a href="http://www.easymock.org">EasyMock</a> ）或替代Servlet API模拟对象（例如<a href="http://www.mockobjects.com">MockObjects</a> ）更方便使用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring Framework 5.0开始， <code>org.springframework.mock.web</code>中的模拟对象基于Servlet 4.0 API。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring MVC Test框架构建在模拟Servlet API对象之上，为Spring MVC提供集成测试框架。请参阅<a href="#spring-mvc-test-framework">Spring MVC测试框架</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-web-reactive"><a class="anchor" href="#mock-objects-web-reactive"></a> 2.1.4。Spring Web Reactive</h4>
<div class="paragraph">
<p><code>org.springframework.mock.http.server.reactive</code>包中包含用于WebFlux应用程序的<code>ServerHttpRequest</code>和<code>ServerHttpResponse</code>模拟实现。<code>org.springframework.mock.web.server</code>包中包含一个依赖于那些模拟请求和响应对象的模拟<code>ServerWebExchange</code> 。</p>
</div>
<div class="paragraph">
<p><code>MockServerHttpRequest</code>和<code>MockServerHttpResponse</code>从与服务器特定的实现相同的抽象基类扩展，并与它们共享行为。例如，模拟请求一旦创建就是不可变的，但您可以使用<code>ServerHttpRequest</code>的<code>mutate()</code>方法创建修改后的实例。</p>
</div>
<div class="paragraph">
<p>为了使模拟响应正确地实现写入合同并返回写入完成句柄（即<code>Mono&lt;Void&gt;</code> ），它默认使用带有<code>cache().then()</code>的<code>Flux</code> ，它缓冲数据并使其成为可能。可用于测试中的断言。应用程序可以设置自定义写入功能（例如，测试无限流）。</p>
</div>
<div class="paragraph">
<p><a href="#webtestclient">WebTestClient</a>以模拟请求和响应为基础，为不使用HTTP服务器测试WebFlux应用程序提供支持。客户端还可以用于正在运行的服务器的端到端测试。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unit-testing-support-classes"><a class="anchor" href="#unit-testing-support-classes"></a> 2.2。单元测试支持类</h3>
<div class="paragraph">
<p>Spring包含许多可以帮助进行单元测试的类。它们分为两类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#unit-testing-utilities">一般测试实用程序</a></p>
</li>
<li>
<p><a href="#unit-testing-spring-mvc">Spring MVC测试实用程序</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="unit-testing-utilities"><a class="anchor" href="#unit-testing-utilities"></a> 2.2.1。一般测试实用程序</h4>
<div class="paragraph">
<p><code>org.springframework.test.util</code>包中包含几个用于单元和集成测试的通用实用程序。</p>
</div>
<div class="paragraph">
<p><code>ReflectionTestUtils</code>是基于反射的实用程序方法的集合。您可以在测试需要更改常量值，设置非<code>public</code>字段，调用非<code>public</code> setter方法或在测试应用程序代码时调用非<code>public</code>配置或生命周期回调方法的场景中使用这些方法。用例如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ORM框架（例如JPA和Hibernate），它们容忍<code>private</code>或<code>protected</code>字段访问，而不是域实体中属性的<code>public</code> setter方法。</p>
</li>
<li>
<p>Spring支持注释（例如@ <code>@Autowired</code> ，@ <code>@Inject</code>和<code>@Resource</code> ），它们为<code>private</code>或<code>protected</code>字段，setter方法和配置方法提供依赖注入。</p>
</li>
<li>
<p>使用<code>@PostConstruct</code>和<code>@PreDestroy</code>等注释进行生命周期回调方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/util/AopTestUtils.html"><code>AopTestUtils</code></a>是AOP相关实用程序方法的集合。您可以使用这些方法获取对隐藏在一个或多个Spring代理后面的基础目标对象的引用。例如，如果您通过使用诸如EasyMock或Mockito之类的库将bean配置为动态模拟，并且模拟包装在Spring代理中，则可能需要直接访问底层模拟以配置对它的期望并执行验证。对于Spring的核心AOP实用程序，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/aop/support/AopUtils.html"><code>AopUtils</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html"><code>AopProxyUtils</code></a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="unit-testing-spring-mvc"><a class="anchor" href="#unit-testing-spring-mvc"></a> 2.2.2。Spring MVC测试实用程序</h4>
<div class="paragraph">
<p><code>org.springframework.test.web</code>包中包含<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html"><code>ModelAndViewAssert</code></a> ，您可以将其与JUnit，TestNG或任何其他用于处理Spring MVC <code>ModelAndView</code>对象的单元测试的测试框架结合使用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">单元测试Spring MVC控制器</div>要将Spring MVC <code>Controller</code>类单元测试为POJO，请使用<code>ModelAndViewAssert</code>与Spring的<a href="#mock-objects-servlet">Servlet API</a> <code>MockHttpServletRequest</code> ， <code>MockHttpSession</code>结合使用。有关Spring MVC和REST <code>Controller</code>类的完整集成测试以及Spring MVC的<code>WebApplicationContext</code>配置，请使用<a href="#spring-mvc-test-framework">Spring MVC Test Framework</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integration-testing"><a class="anchor" href="#integration-testing"></a> 3。集成测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节（本章的大部分内容）介绍了Spring应用程序的集成测试。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-overview">概观</a></p>
</li>
<li>
<p><a href="#integration-testing-goals">集成测试的目标</a></p>
</li>
<li>
<p><a href="#integration-testing-support-jdbc">JDBC测试支持</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations">注释</a></p>
</li>
<li>
<p><a href="#testcontext-framework">Spring TestContext框架</a></p>
</li>
<li>
<p><a href="#spring-mvc-test-framework">Spring MVC测试框架</a></p>
</li>
<li>
<p><a href="#testing-examples-petclinic">PetClinic示例</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="integration-testing-overview"><a class="anchor" href="#integration-testing-overview"></a> 3.1。概观</h3>
<div class="paragraph">
<p>能够执行某些集成测试非常重要，无需部署到应用程序服务器或连接到其他企业基础结构。这样做可以让您测试以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring IoC容器上下文的正确连接。</p>
</li>
<li>
<p>使用JDBC或ORM工具进行数据访问。这可以包括诸如SQL语句的正确性，Hibernate查询，JPA实体映射等等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework为<code>spring-test</code>模块中的集成测试提供了一流的支持。实际JAR文件的名称可能包含发行版本，也可能采用长<code>org.springframework.test</code>形式，具体取决于您从何处获取（ <a href="core.html#dependency-management">有关</a>说明，请参阅<a href="core.html#dependency-management">依赖关系管理部分</a> ）。该库包含<code>org.springframework.test</code>包，其中包含用于使用Spring容器进行集成测试的有价值的类。此测试不依赖于应用程序服务器或其他部署环境。这些测试比单元测试运行得慢，但比依赖部署到应用服务器的等效Selenium测试或远程测试快得多。</p>
</div>
<div class="paragraph">
<p>在Spring 2.5及更高版本中，单元和集成测试支持以注释驱动的<a href="#testcontext-framework">Spring TestContext Framework</a>的形式提供。TestContext框架与使用中的实际测试框架无关，它允许在各种环境中检测测试，包括JUnit，TestNG等。</p>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-goals"><a class="anchor" href="#integration-testing-goals"></a> 3.2。集成测试的目标</h3>
<div class="paragraph">
<p>Spring的集成测试支持有以下主要目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在测试之间管理<a href="#testing-ctx-management">Spring IoC容器缓存</a> 。</p>
</li>
<li>
<p>提供<a href="#testing-fixture-di">测试夹具实例的依赖注入</a> 。</p>
</li>
<li>
<p>提供适合集成测试的<a href="#testing-tx">事务管理</a> 。</p>
</li>
<li>
<p>提供<a href="#testing-support-classes">特定</a>于<a href="#testing-support-classes">Spring的基类</a> ，帮助开发人员编写集成测试。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来的几节将介绍每个目标，并提供实现和配置详细信息的链接。</p>
</div>
<div class="sect3">
<h4 id="testing-ctx-management"><a class="anchor" href="#testing-ctx-management"></a> 3.2.1。上下文管理和缓存</h4>
<div class="paragraph">
<p>Spring TestContext Framework提供Spring <code>ApplicationContext</code>实例和<code>WebApplicationContext</code>实例的一致加载以及这些上下文的缓存。支持缓存加载的上下文很重要，因为启动时间可能成为一个问题 - 不是因为Spring本身的开销，而是因为Spring容器实例化的对象需要时间来实例化。例如，具有50到100个Hibernate映射文件的项目可能需要10到20秒来加载映射文件，并且在每个测试夹具中运行每个测试之前产生该成本会导致整体测试运行速度变慢，从而降低开发人员的工作效率。</p>
</div>
<div class="paragraph">
<p>测试类通常声明XML或Groovy配置元数据的资源位置数组（通常在类路径中）或用于配置应用程序的带注释类的数组。这些位置或类与<code>web.xml</code>或生产部署的其他配置文件中指定的位置或类相同或类似。</p>
</div>
<div class="paragraph">
<p>默认情况下，一旦加载，配置的<code>ApplicationContext</code>将重用于每个测试。因此，每个测试套件仅产生一次设置成本，并且后续测试执行要快得多。在此上下文中，术语“测试套件”表示所有测试都在同一JVM中运行 - 例如，所有测试都是针对给定项目或模块从Ant，Maven或Gradle构建的。在不太可能的情况下，测试会破坏应用程序上下文并需要重新加载（例如，通过修改bean定义或应用程序对象的状态），可以将TestContext框架配置为在执行下一个之前重新加载配置并重建应用程序上下文测试。</p>
</div>
<div class="paragraph">
<p>请参阅使用TestContext框架的<a href="#testcontext-ctx-management">上下文管理</a>和<a href="#testcontext-ctx-management-caching">上下文缓存</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-fixture-di"><a class="anchor" href="#testing-fixture-di"></a> 3.2.2。测试夹具的依赖注入</h4>
<div class="paragraph">
<p>当TestContext框架加载应用程序上下文时，它可以选择使用依赖注入来配置测试类的实例。这为使用应用程序上下文中的预配置bean提供了一种方便的机制来设置测试夹具。这里的一个强大好处是您可以跨各种测试场景重用应用程序上下文（例如，用于配置Spring管理的对象图，事务代理， <code>DataSource</code>实例等），从而避免复制单个测试的复杂测试夹具设置的需要案例。</p>
</div>
<div class="paragraph">
<p>作为示例，考虑我们有一个类（ <code>HibernateTitleRepository</code> ）实现<code>Title</code>域实体的数据访问逻辑的场景。我们想编写测试以下方面的集成测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring配置：基本上，与<code>HibernateTitleRepository</code> bean的配置相关的所有内容是否正确和存在？</p>
</li>
<li>
<p>Hibernate映射文件配置：是否所有映射都正确并且是否具有正确的延迟加载设置？</p>
</li>
<li>
<p><code>HibernateTitleRepository</code>的逻辑：此类的已配置实例是否按预期执行？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请参阅使用<a href="#testcontext-fixture-di">TestContext框架</a>对测试装置的依赖注入。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-tx"><a class="anchor" href="#testing-tx"></a> 3.2.3。交易管理</h4>
<div class="paragraph">
<p>访问真实数据库的测试中的一个常见问题是它们对持久性存储的状态的影响。即使您使用开发数据库，​​对状态的更改也可能会影响将来的测试。此外，许多操作（例如插入或修改持久数据）无法在事务之外执行（或验证）。</p>
</div>
<div class="paragraph">
<p>TestContext框架解决了这个问题。默认情况下，框架为每个测试创建并回滚事务。您可以编写可以假定存在事务的代码。如果在测试中调用事务代理对象，则根据其配置的事务语义，它们的行为正确。此外，如果测试方法在为测试管理的事务中运行时删除所选表的内容，则事务默认回滚，并且数据库返回到执行测试之前的状态。通过使用在测试的应用程序上下文中定义的<code>PlatformTransactionManager</code> bean，为测试提供事务支持。</p>
</div>
<div class="paragraph">
<p>如果您希望事务提交（异常，但在您希望特定测试填充或修改数据库时偶尔有用），您可以通过使用<a href="#integration-testing-annotations"><code>@Commit</code></a>注释告诉TestContext框架使事务提交而不是回滚。</p>
</div>
<div class="paragraph">
<p>使用<a href="#testcontext-tx">TestContext框架</a>查看事务管理。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-support-classes"><a class="anchor" href="#testing-support-classes"></a> 3.2.4。支持集成测试的类</h4>
<div class="paragraph">
<p>Spring TestContext Framework提供了几个<code>abstract</code>支持类，可以简化集成测试的编写。这些基本测试类为测试框架提供了定义明确的钩子以及方便的实例变量和方法，使您可以访问：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ApplicationContext</code> ，用于执行显式bean查找或测试整个上下文的状态。</p>
</li>
<li>
<p><code>JdbcTemplate</code> ，用于执行SQL语句以查询数据库。您可以在执行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，Spring确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具结合使用时，请务必避免<a href="#testcontext-tx-false-positives">误报</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，您可能希望使用特定于项目的实例变量和方法创建自己的自定义应用程序范围的超类。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#testcontext-support-classes">TestContext框架的</a>支持类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-support-jdbc"><a class="anchor" href="#integration-testing-support-jdbc"></a> 3.3。JDBC测试支持</h3>
<div class="paragraph">
<p><code>org.springframework.test.jdbc</code>包中包含<code>JdbcTestUtils</code> ，它是与JDBC相关的实用程序函数的集合，旨在简化标准数据库测试方案。具体来说， <code>JdbcTestUtils</code>提供以下静态实用程序方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>countRowsInTable(..)</code> ：计算给定表中的行数。</p>
</li>
<li>
<p><code>countRowsInTableWhere(..)</code> ：使用提供的<code>WHERE</code>子句计算给定表中的行数。</p>
</li>
<li>
<p><code>deleteFromTables(..)</code> ：删除指定表中的所有行。</p>
</li>
<li>
<p><code>deleteFromTableWhere(..)</code> ：使用提供的<code>WHERE</code>子句从给定表中删除行。</p>
</li>
<li>
<p><code>dropTables(..)</code> ：删除指定的表。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>和<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>提供了方便的方法，可以委托<code>JdbcTestUtils</code>的上述方法。</p>
</div>
<div class="paragraph">
<p><code>spring-jdbc</code>模块支持配置和启动嵌入式数据库，您可以在与数据库交互的集成测试中使用它。有关详细信息，请参阅<a href="data-access.html#jdbc-embedded-database-support">嵌入式数据库支持</a>和<a href="data-access.html#jdbc-embedded-database-dao-testing">使用嵌入式数据库测试数据访</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-annotations"><a class="anchor" href="#integration-testing-annotations"></a> 3.4。注释</h3>
<div class="paragraph">
<p>本节介绍了在测试Spring应用程序时可以使用的注释。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-spring">Spring测试注释</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-standard">标准注释支持</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4">Spring JUnit 4测试注释</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter测试注释</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-meta">测试的元注释支持</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-spring"><a class="anchor" href="#integration-testing-annotations-spring"></a> 3.4.1。Spring测试注释</h4>
<div class="paragraph">
<p>Spring Framework提供了以下一组特定于Spring的注释，您可以在单元和集成测试中结合TestContext框架使用它们。有关详细信息，请参阅相应的Javadoc，包括默认属性值，属性别名和其他详细信息。</p>
</div>
<div class="paragraph">
<p>Spring的测试注释包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-commit"><code>@承诺</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sql"><code>@sql</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-bootstrapwith"><a class="anchor" href="#spring-testing-annotation-bootstrapwith"></a><code>@BootstrapWith</code></h5>
<div class="paragraph">
<p><code>@BootstrapWith</code>是一个类级注释，可用于配置Spring TestContext Framework的引导方式。具体来说，您可以使用<code>@BootstrapWith</code>指定自定义<code>TestContextBootstrapper</code> 。有关更多详细信息，请参阅<a href="#testcontext-bootstrapping">Bootstrapping the TestContext框架</a>部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contextconfiguration"><a class="anchor" href="#spring-testing-annotation-contextconfiguration"></a><code>@ContextConfiguration</code></h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code>定义类级元数据，用于确定如何为集成测试加载和配置<code>ApplicationContext</code> 。具体来说， <code>@ContextConfiguration</code>声明应用程序上下文资源<code>locations</code>或用于加载上下文的带注释的<code>classes</code> 。</p>
</div>
<div class="paragraph">
<p>资源位置通常是位于类路径中的XML配置文件或Groovy脚本，而带注释的类通常是<code>@Configuration</code>类。但是，资源位置也可以引用文件系统中的文件和脚本，注释类可以是组件类，依此类推。</p>
</div>
<div class="paragraph">
<p>以下示例显示了引用XML文件的<code>@ContextConfiguration</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test-config.xml</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">XmlApplicationContextTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>参考XML文件。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了引用类的<code>@ContextConfiguration</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> （classes = TestConfig.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ConfigClassApplicationContextTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>提到一堂课。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>作为声明资源位置或带注释的类的替代或补充，您可以使用<code>@ContextConfiguration</code>来声明<code>ApplicationContextInitializer</code>类。以下示例显示了这种情况：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> （initializers = CustomContextIntializer.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ContextInitializerTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>声明初始化类。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以选择使用<code>@ContextConfiguration</code>来声明<code>ContextLoader</code>策略。但请注意，您通常不需要显式配置加载程序，因为默认加载程序支持<code>initializers</code>以及资源<code>locations</code>或带注释的<code>classes</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例同时使用位置和加载器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> （locations = <span class="string"><span class="delimiter">“/</span> <span class="content">test-context.xml</span> <span class="delimiter">”</span></span> ，loader = CustomContextLoader.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">CustomLoaderXmlApplicationContextTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>配置位置和自定义加载程序。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@ContextConfiguration</code>支持继承资源位置或配置类以及超类声明的上下文初始化程序。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#testcontext-ctx-management">上下文管理</a>和<code>@ContextConfiguration</code> javadocs。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-webappconfiguration"><a class="anchor" href="#spring-testing-annotation-webappconfiguration"></a><code>@WebAppConfiguration</code></h5>
<div class="paragraph">
<p><code>@WebAppConfiguration</code>是一个类级别的注释，可用于声明为集成测试加载的<code>ApplicationContext</code>应该是<code>WebApplicationContext</code> 。仅在测试类上存在<code>@WebAppConfiguration</code>可确保为测试加载<code>WebApplicationContext</code> ，使用默认值<code>"file:src/main/webapp"</code>作为Web应用程序根目录的路径（即资源）基本路径）。在后台使用资源基本路径来创建<code>MockServletContext</code> ，它充当测试的<code>WebApplicationContext</code>的<code>ServletContext</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>@WebAppConfiguration</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@WebAppConfiguration</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebAppTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>@WebAppConfiguration</code>注释。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要覆盖默认值，可以使用隐式<code>value</code>属性指定不同的基本资源路径。支持<code>classpath:</code>和<code>file:</code>资源前缀。如果未提供资源前缀，则假定该路径是文件系统资源。以下示例显示如何指定类路径资源：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@WebAppConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：test-web-resources</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebAppTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定类路径资源。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>@WebAppConfiguration</code>必须与<code>@ContextConfiguration</code>结合使用，可以在单个测试类中，也可以在测试类层次结构中使用。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contexthierarchy"><a class="anchor" href="#spring-testing-annotation-contexthierarchy"></a><code>@ContextHierarchy</code></h5>
<div class="paragraph">
<p><code>@ContextHierarchy</code>是一个类级别注释，用于为集成测试定义<code>ApplicationContext</code>实例的层次结构。<code>@ContextHierarchy</code>应具有一个或多个列表中声明<code>@ContextConfiguration</code>实例中，其中的每一个定义了在上下文层次的水平。以下示例演示了在单个测试类中使用<code>@ContextHierarchy</code> （ <code>@ContextHierarchy</code>也可以在测试类层次结构中使用）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextHierarchy</span> （{ <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">parent-config.xml</span> <span class="delimiter">”</span></span> ）， <span class="annotation">@ ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">child-config.xml</span> <span class="delimiter">”</span></span> ）}） <span class="directive">public</span> <span class="type">class</span> <span class="class">ContextHierarchyTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebAppConfiguration</span> <span class="annotation">@ContextHierarchy</span> （{ <span class="annotation">@ ContextConfiguration</span> （classes = AppConfig.class）， <span class="annotation">@ ContextConfiguration</span> （classes = WebConfig.class）}） <span class="directive">public</span> <span class="type">class</span> <span class="class">WebIntegrationTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果需要合并或覆盖测试类层次结构中给定级别的上下文层次结构的配置，则必须通过在类层次结构中的每个相应级别为<code>@ContextConfiguration</code>中的<code>name</code>属性提供相同的值来显式命名该级别。有关更多示例，请参阅<a href="#testcontext-ctx-management-ctx-hierarchies">上下文层次结构</a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/ContextHierarchy.html"><code>@ContextHierarchy</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-activeprofiles"><a class="anchor" href="#spring-testing-annotation-activeprofiles"></a><code>@ActiveProfiles</code></h5>
<div class="paragraph">
<p><code>@ActiveProfiles</code>是一个类级别注释，用于在为集成测试加载<code>ApplicationContext</code>时声明哪些bean定义配置文件应该处于活动状态。</p>
</div>
<div class="paragraph">
<p>以下示例表明<code>dev</code>配置文件应处于活动状态：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@ActiveProfiles</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dev</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">DeveloperTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指示<code>dev</code>配置文件应处于活动状态。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例表明<code>dev</code>和<code>integration</code>配置文件都应处于活动状态：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@ActiveProfiles</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">dev</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">integration</span> <span class="delimiter">”</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">DeveloperIntegrationTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指示<code>dev</code>和<code>integration</code>配置文件应处于活动状态。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@ActiveProfiles</code>支持继承超类声明的活动bean定义配置文件。您还可以通过实现自定义<a href="#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"><code>ActiveProfilesResolver</code></a>并使用<code>@ActiveProfiles</code>的<code>resolver</code>属性对其进行注册来以编程方式解析活动Bean定义概要文件。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关示例和更多详细<a href="#testcontext-ctx-management-env-profiles">信息</a> ，请参阅<a href="#testcontext-ctx-management-env-profiles">使用环境配置文件的上下文配置</a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfiles.html"><code>@ActiveProfiles</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testpropertysource"><a class="anchor" href="#spring-testing-annotation-testpropertysource"></a><code>@TestPropertySource</code></h5>
<div class="paragraph">
<p><code>@TestPropertySource</code>是一个类级别注释，可用于配置属性文件的位置和内联属性，以便为集成测试加载的<code>ApplicationContext</code>添加到<code>Environment</code>的<code>PropertySources</code>集合中。</p>
</div>
<div class="paragraph">
<p>测试属性源的优先级高于从操作系统环境或Java系统属性加载的属性源，以及应用程序通过<code>@PropertySource</code>或以编程方式声明性地添加的属性源。因此，测试属性源可用于有选择地覆盖系统和应用程序属性源中定义的属性。此外，内联属性的优先级高于从资源位置加载的属性。</p>
</div>
<div class="paragraph">
<p>以下示例演示如何从类路径声明属性文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestPropertySource</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test.properties</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyIntegrationTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从类路径的根目录中的<code>test.properties</code>获取属性。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例演示如何声明内联属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestPropertySource</span> （properties = { <span class="string"><span class="delimiter">“</span> <span class="content">timezone = GMT</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">port：4242</span> <span class="delimiter">”</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyIntegrationTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>声明<code>timezone</code>和<code>port</code>属性。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-dirtiescontext"><a class="anchor" href="#spring-testing-annotation-dirtiescontext"></a><code>@DirtiesContext</code></h5>
<div class="paragraph">
<p><code>@DirtiesContext</code>指示在执行测试期间底层Spring <code>ApplicationContext</code>已被弄脏（即，测试以某种方式修改或损坏它 - 例如，通过更改单例bean的状态）并应该关闭。当应用程序上下文被标记为脏时，它将从测试框架的缓存中删除并关闭。因此，对于需要具有相同配置元数据的上下文的任何后续测试，都会重建基础Spring容器。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@DirtiesContext</code>用作同一类或类层次结构中的类级别和方法级别注释。在这种情况下， <code>ApplicationContext</code>在任何此类带注释的方法之前或之后以及当前测试类之前或之后被标记为脏，具体取决于配置的<code>methodMode</code>和<code>classMode</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例说明了各种配置方案的上下文何时会变脏：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在当前测试类之前，在类模式设置为<code>BEFORE_CLASS</code>类上<code>BEFORE_CLASS</code> 。</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DirtiesContext</span> （classMode = BEFORE_CLASS） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">FreshContextTests</span> { <span class="comment">//一些需要新Spring容器的测试</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在当前测试类之前弄脏了上下文。</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>在当前测试类之后，在类模式设置为<code>AFTER_CLASS</code> （即默认类模式）的类上声明。</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DirtiesContext</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ContextDirtyingTests</span> { <span class="comment">//导致Spring容器被弄脏的一些测试</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在当前测试类之后弄脏上下文。</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>在当前测试类中的每个测试方法之前，在类模式设置为<code>BEFORE_EACH_TEST_METHOD.</code>类上<code>BEFORE_EACH_TEST_METHOD.</code></p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DirtiesContext</span> （classMode = BEFORE_EACH_TEST_METHOD） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">FreshContextTests</span> { <span class="comment">//一些需要新Spring容器的测试</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在每种测试方法之前弄脏上下文。</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>在当前测试类中的每个测试方法之后，在类模式设置为<code>AFTER_EACH_TEST_METHOD.</code>类上<code>AFTER_EACH_TEST_METHOD.</code></p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DirtiesContext</span> （classMode = AFTER_EACH_TEST_METHOD） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ContextDirtyingTests</span> { <span class="comment">//导致Spring容器被污染的一些测试</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>每种测试方法后都会弄脏上下文。</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>在当前测试之前，在方法模式设置为<code>BEFORE_METHOD</code>的方法上<code>BEFORE_METHOD</code> 。</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DirtiesContext</span> （methodMode = BEFORE_METHOD） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessWhichRequiresFreshAppCtx（）{ <span class="comment">//一些需要新Spring容器的逻辑</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在当前测试方法之前弄脏了上下文。</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>在当前测试之后，在方法模式设置为<code>AFTER_METHOD</code> （即默认方法模式）的方法上声明。</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DirtiesContext</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessWhichDirtiesAppCtx（）{ <span class="comment">//导致Spring容器被弄脏的一些逻辑</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在当前测试方法之后弄脏上下文。</td>
</tr>
</table>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在测试中使用<code>@DirtiesContext</code> ，其上下文被配置为具有<code>@ContextHierarchy</code>的上下文层次结构的<code>@ContextHierarchy</code> ，则可以使用<code>hierarchyMode</code>标志来控制如何清除上下文高速缓存。默认情况下，使用详尽的算法来清除上下文缓存，不仅包括当前级别，还包括共享当前测试常见的祖先上下文的所有其他上下文层次结构。驻留在公共祖先上下文的子层次结构中的所有<code>ApplicationContext</code>实例将从上下文缓存中删除并关闭。如果详尽的算法对于特定用例而言过度，则可以指定更简单的当前级别算法，如以下示例所示。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextHierarchy</span> （{ <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">parent-config.xml</span> <span class="delimiter">”</span></span> ）， <span class="annotation">@ ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">child-config.xml</span> <span class="delimiter">”</span></span> ）}） <span class="directive">public</span> <span class="type">class</span> <span class="class">BaseTests</span> { <span class="comment">// class body ...</span><span class="directive">公共</span> <span class="type">类</span> <span class="class">ExtendedTests</span> <span class="directive">扩展</span> BaseTests { <span class="annotation">@Test</span> <span class="annotation">@DirtiesContext</span> （hierarchyMode = CURRENT_LEVEL） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> test（）{ <span class="comment">//导致子上下文被污染的一些逻辑</span> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用当前级算法。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有关<code>EXHAUSTIVE</code>和<code>CURRENT_LEVEL</code>算法的更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html"><code>DirtiesContext.HierarchyMode</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testexecutionlisteners"><a class="anchor" href="#spring-testing-annotation-testexecutionlisteners"></a><code>@TestExecutionListeners</code></h5>
<div class="paragraph">
<p><code>@TestExecutionListeners</code>定义了类级元数据，用于配置应该使用<code>TestContextManager</code>注册的<code>TestExecutionListener</code>实现。通常， <code>@TestExecutionListeners</code>与<code>@ContextConfiguration</code>一起使用。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何注册两个<code>TestExecutionListener</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestExecutionListeners</span> （{CustomTestExecutionListener.class，AnotherTestExecutionListener.class}） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">CustomTestExecutionListenerTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>注册两个<code>TestExecutionListener</code>实现。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>@TestExecutionListeners</code>支持继承的侦听器。有关示例和更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-commit"><a class="anchor" href="#spring-testing-annotation-commit"></a><code>@Commit</code></h5>
<div class="paragraph">
<p><code>@Commit</code>表示应在测试方法完成后提交事务测试方法的事务。您可以使用<code>@Commit</code>作为<code>@Rollback(false)</code>的直接替换，以更明确地传达代码的意图。类似于<code>@Rollback</code> ， <code>@Commit</code>也可以声明为一个类级别或方法级注释。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@Commit</code>注释：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@承诺</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessWithoutRollback（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>将测试结果提交给数据库。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-rollback"><a class="anchor" href="#spring-testing-annotation-rollback"></a><code>@Rollback</code></h5>
<div class="paragraph">
<p><code>@Rollback</code>指示在测试方法完成后是否应回滚事务测试方法的事务。如果为<code>true</code> ，则回滚事务。否则，提交事务（另请参阅<a href="#spring-testing-annotation-commit"><code>@Commit</code></a> ）。用于回滚在Spring TestContext框架默认为集成测试<code>true</code>即使<code>@Rollback</code>没有明确声明。</p>
</div>
<div class="paragraph">
<p>当作为一类级别的注解来声明， <code>@Rollback</code>定义了测试类层次结构中的所有测试方法的默认回滚语义。当作为一个方法级注解来声明， <code>@Rollback</code>限定用于特定的测试方法，有可能压倒一切的类级回滚语义<code>@Rollback</code>或<code>@Commit</code>语义。</p>
</div>
<div class="paragraph">
<p>以下示例导致测试方法的结果不回滚（即，结果提交到数据库）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Rollback</span> （ <span class="predefined-constant">假</span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessWithoutRollback（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>不要回滚结果。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-beforetransaction"><a class="anchor" href="#spring-testing-annotation-beforetransaction"></a><code>@BeforeTransaction</code></h5>
<div class="paragraph">
<p><code>@BeforeTransaction</code>指示在启动事务之前应该运行带注释的<code>void</code>方法，对于已经配置为使用Spring的<code>@Transactional</code>注释在事务中运行的测试方法。从Spring Framework 4.3开始， <code>@BeforeTransaction</code>方法不需要是<code>public</code> ，可以在基于Java 8的接口默认方法中声明。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>@BeforeTransaction</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BeforeTransaction</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">void</span> beforeTransaction（）{ <span class="comment">//在事务启动之前执行的逻辑</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在事务之前运行此方法。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-aftertransaction"><a class="anchor" href="#spring-testing-annotation-aftertransaction"></a><code>@AfterTransaction</code></h5>
<div class="paragraph">
<p>对于已经配置为在事务中使用Spring的<code>@Transactional</code>注释运行的测试方法， <code>@AfterTransaction</code>指示应在事务结束后运行带注释的<code>void</code>方法。从Spring Framework 4.3开始， <code>@AfterTransaction</code>方法不需要是<code>public</code> ，可以在基于Java 8的接口默认方法中声明。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@AfterTransaction</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">void</span> afterTransaction（）{ <span class="comment">//在事务结束后执行的逻辑</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在事务之后运行此方法。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sql"><a class="anchor" href="#spring-testing-annotation-sql"></a><code>@Sql</code></h5>
<div class="paragraph">
<p><code>@Sql</code>用于注释测试类或测试方法，以配置在集成测试期间针对给定数据库运行的SQL脚本。以下示例显示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@Sql</span> （{ <span class="string"><span class="delimiter">“/</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“/</span> <span class="content">test-user-data.sql</span> <span class="delimiter">”</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> userTest { <span class="comment">//执行依赖于测试模式和测试数据的代码</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>为此测试运行两个脚本。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#testcontext-executing-sql-declaratively">使用@Sql</a>以<a href="#testcontext-executing-sql-declaratively">声明方式执行SQL脚本</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlconfig"><a class="anchor" href="#spring-testing-annotation-sqlconfig"></a><code>@SqlConfig</code></h5>
<div class="paragraph">
<p><code>@SqlConfig</code>定义元数据，用于确定如何解析和运行使用<code>@Sql</code>批注配置的SQL脚本。以下示例显示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@Sql</span> （scripts = <span class="string"><span class="delimiter">“/</span> <span class="content">test-user-data.sql</span> <span class="delimiter">”</span></span> ，config = <span class="annotation">@SqlConfig</span> （commentPrefix = <span class="string"><span class="delimiter">“</span> <span class="content">`</span> <span class="delimiter">”</span></span> ，separator = <span class="string"><span class="delimiter">“</span> <span class="content">@@</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> ） <span class="directive">public</span> <span class="type">void</span> userTest { <span class="comment">//执行依赖于测试数据的代码</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在SQL脚本中设置注释前缀和分隔符。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlgroup"><a class="anchor" href="#spring-testing-annotation-sqlgroup"></a><code>@SqlGroup</code></h5>
<div class="paragraph">
<p><code>@SqlGroup</code>是一个容器注释，它聚合了几个<code>@Sql</code>注释。您可以原生使用<code>@SqlGroup</code>来声明几个嵌套的<code>@Sql</code>注释，或者您可以将它与Java 8对可重复注释的支持结合使用，其中<code>@Sql</code>可以在同一个类或方法上多次声明，隐式生成此容器注释。以下示例显示如何声明SQL组：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@SqlGroup</span> （{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Sql</span> （scripts = <span class="string"><span class="delimiter">“/</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ，config = <span class="annotation">@SqlConfig</span> （commentPrefix = <span class="string"><span class="delimiter">“</span> <span class="content">`</span> <span class="delimiter">”</span></span> ））， <span class="annotation">@ Sql</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test-user-data.sql</span> <span class="delimiter">”</span></span> ））} <span class="directive">public</span> <span class="type">void</span> userTest { <span class="comment">//执行使用测试模式和测试数据的代码</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>声明一组SQL脚本。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-standard"><a class="anchor" href="#integration-testing-annotations-standard"></a> 3.4.2。标准注释支持</h4>
<div class="paragraph">
<p>对于Spring TestContext Framework的所有配置，标准语义支持以下注释。请注意，这些注释并非特定于测试，可以在Spring Framework中的任何位置使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Autowired</code></p>
</li>
<li>
<p><code>@Qualifier</code></p>
</li>
<li>
<p><code>@Resource</code> （javax.annotation）如果存在JSR-250</p>
</li>
<li>
<p><code>@ManagedBean</code> （javax.annotation）如果存在JSR-250</p>
</li>
<li>
<p><code>@Inject</code> （javax.inject）如果存在JSR-330</p>
</li>
<li>
<p><code>@Named</code> （javax.inject）如果存在JSR-330</p>
</li>
<li>
<p><code>@PersistenceContext</code> （javax.persistence）如果存在JPA</p>
</li>
<li>
<p><code>@PersistenceUnit</code> （javax.persistence）如果存在JPA</p>
</li>
<li>
<p><code>@需要</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">JSR-250生命周期注释</div>
<div class="paragraph">
<p>在Spring TestContext Framework中，您可以在<code>ApplicationContext</code>配置的任何应用程序组件上使用<code>@PostConstruct</code>和<code>@PreDestroy</code>以及标准语义。但是，这些生命周期注释在实际测试类中的使用有限。</p>
</div>
<div class="paragraph">
<p>如果测试类中的方法使用<code>@PostConstruct</code>注释，则该方法在基础测试框架的任何before方法之前运行（例如，使用JUnit Jupiter的<code>@BeforeEach</code>注释的<code>@BeforeEach</code> ），并且该方法适用于测试类中的每个测试方法。另一方面，如果测试类中的方法使用<code>@PreDestroy</code>注释，则该方法永远不会运行。因此，在测试类中，我们建议您使用来自底层测试框架的测试生命周期回调，而不是<code>@PostConstruct</code>和<code>@PreDestroy</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit4"><a class="anchor" href="#integration-testing-annotations-junit4"></a> 3.4.3。Spring JUnit 4测试注释</h4>
<div class="paragraph">
<p>仅当与<a href="#testcontext-junit4-runner">SpringRunner</a> ， <a href="#testcontext-junit4-rules">Spring的JUnit 4规则</a>或<a href="#testcontext-support-classes-junit4">Spring的JUnit 4支持类</a>一起使用时，才支持以下注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>同时@IfProfileValue</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-repeat"><code>@重复</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-ifprofilevalue"><a class="anchor" href="#integration-testing-annotations-junit4-ifprofilevalue"></a><code>@IfProfileValue</code></h5>
<div class="paragraph">
<p><code>@IfProfileValue</code>表示为特定测试环境启用了带注释的测试。如果配置的<code>ProfileValueSource</code>返回所提供<code>name</code>的匹配<code>value</code> ，则启用测试。否则，将禁用测试并有效地忽略测试。</p>
</div>
<div class="paragraph">
<p>您可以在类级别，方法级别或两者中应用<code>@IfProfileValue</code> 。<code>@IfProfileValue</code>类级别使用优先于该类或其子类中的任何方法的方法级别使用。具体而言，如果在类级别和方法级别启用了测试，则启用测试。缺少<code>@IfProfileValue</code>意味着隐式启用了测试。这类似于JUnit 4的<code>@Ignore</code>注释的语义，除了<code>@Ignore</code>的存在总是禁用测试。</p>
</div>
<div class="paragraph">
<p>以下示例显示了具有<code>@IfProfileValue</code>批注的测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@IfProfileValue</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">java.vendor</span> <span class="delimiter">”</span></span> ，value = <span class="string"><span class="delimiter">“</span> <span class="content">Oracle Corporation</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessWhichRunsOnlyOnOracleJvm（）{ <span class="comment">//一些应该只在Oracle公司的Java VM上运行的逻辑</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>仅当Java供应商是“Oracle Corporation”时才运行此测试。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用<code>values</code>列表（使用<code>OR</code>语义）配置<code>@IfProfileValue</code> ，以在JUnit 4环境中为测试组实现类似TestNG的支持。请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@IfProfileValue</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">test-groups</span> <span class="delimiter">”</span></span> ，values = { <span class="string"><span class="delimiter">“</span> <span class="content">unit-tests</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">integration-tests</span> <span class="delimiter">”</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessWhichRunsForUnitOrIntegrationTestGroups（）{ <span class="comment">//一些应该仅针对单元和集成测试组运行的逻辑</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>运行此测试以进行单元测试和集成测试。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-profilevaluesourceconfiguration"><a class="anchor" href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"></a><code>@ProfileValueSourceConfiguration</code></h5>
<div class="paragraph">
<p><code>@ProfileValueSourceConfiguration</code>是一个类级别批注，用于指定何种类型的<code>ProfileValueSource</code>检索通过配置的简档值时使用<code>@IfProfileValue</code>注释。如果未为测试声明<code>@ProfileValueSourceConfiguration</code> ，则默认使用<code>SystemProfileValueSource</code> 。以下示例显示如何使用<code>@ProfileValueSourceConfiguration</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ProfileValueSourceConfiguration</span> （CustomProfileValueSource.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">CustomProfileValueSourceTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用自定义配置文件值源。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-timed"><a class="anchor" href="#integration-testing-annotations-junit4-timed"></a><code>@Timed</code></h5>
<div class="paragraph">
<p><code>@Timed</code>表示带注释的测试方法必须在指定的时间段内（以毫秒为单位）完成执行。如果文本执行时间超过指定的时间段，则测试失败。</p>
</div>
<div class="paragraph">
<p>时间段包括运行测试方法本身，测试的任何重复（参见<code>@Repeat</code> ），以及测试夹具的任何设置或拆除。以下示例显示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Timed</span> （millis = <span class="integer">1000</span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> testProcessWithOneSecondTimeout（）{ <span class="comment">//某些逻辑执行时间不应超过1秒</span> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>将测试的时间段设置为一秒。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring的<code>@Timed</code>注释具有与JUnit 4的<code>@Test(timeout=…​)</code>支持不同的语义。具体来说，由于JUnit 4处理测试执行超时的方式（即，通过在单独的<code>Thread</code>执行测试方法），如果测试时间过长，@ Test <code>@Test(timeout=…​)</code>抢先失败测试。另一方面，Spring的<code>@Timed</code>没有先发制人地未通过测试，而是在失败之前等待测试完成。</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-repeat"><a class="anchor" href="#integration-testing-annotations-junit4-repeat"></a><code>@Repeat</code></h5>
<div class="paragraph">
<p><code>@Repeat</code>表示必须重复运行带注释的测试方法。在注释中指定测试方法的执行次数。</p>
</div>
<div class="paragraph">
<p>要重复的执行范围包括执行测试方法本身以及测试夹具的任何设置或拆除。以下示例显示如何使用<code>@Repeat</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repeat</span> （ <span class="integer">10</span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testProcessRepeatedly（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>重复此测试十次。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit-jupiter"><a class="anchor" href="#integration-testing-annotations-junit-jupiter"></a> 3.4.4。Spring JUnit Jupiter测试注释</h4>
<div class="paragraph">
<p>仅当与<a href="#testcontext-junit-jupiter-extension"><code>SpringExtension</code></a>和JUnit Jupiter（即JUnit 5中的编程模型）结合使用时，才支持以下注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter=-disabledif">[集成测试的注解-的junit-木星= -disabledif]</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitconfig"></a><code>@SpringJUnitConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitConfig</code>是一个组合注释，它将来自JUnit Jupiter的<code>@ExtendWith(SpringExtension.class)</code>与来自Spring TestContext Framework的<code>@ContextConfiguration</code>相结合。它可以在类级别用作<code>@ContextConfiguration</code>替代<code>@ContextConfiguration</code> 。关于配置选项，之间的唯一区别<code>@ContextConfiguration</code>和<code>@SpringJUnitConfig</code>是注解的类可与声明<code>value</code>在属性<code>@SpringJUnitConfig</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>@SpringJUnitConfig</code>批注指定配置类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> （TestConfig.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">类</span> <span class="class">ConfigurationClassJUnitJupiterSpringTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定配置类。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>@SpringJUnitConfig</code>批注指定配置文件的位置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> （locations = <span class="string"><span class="delimiter">“/</span> <span class="content">test-config.xml</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">类</span> <span class="class">XmlJUnitJupiterSpringTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定配置文件的位置。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#testcontext-ctx-management">上下文管理</a>以及<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html"><code>@SpringJUnitConfig</code></a>和<code>@ContextConfiguration</code>的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html">Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitwebconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"></a><code>@SpringJUnitWebConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitWebConfig</code>是一个组合注释，它将来自JUnit Jupiter的<code>@ExtendWith(SpringExtension.class)</code>与来自Spring TestContext Framework的<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>相结合。您可以在类级别使用它作为<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>替代品。关于配置选项， <code>@ContextConfiguration</code>和<code>@SpringJUnitWebConfig</code>之间的唯一区别是您可以使用<code>@SpringJUnitWebConfig</code>的<code>value</code>属性声明带注释的类bu。此外，你可以重写<code>value</code>从属性<code>@WebAppConfiguration</code>只能通过使用<code>resourcePath</code>在属性<code>@SpringJUnitWebConfig</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>@SpringJUnitWebConfig</code>批注指定配置类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitWebConfig</span> （TestConfig.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">类</span> <span class="class">ConfigurationClassJUnitJupiterSpringWebTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定配置类。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>@SpringJUnitWebConfig</code>批注指定配置文件的位置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitWebConfig</span> （locations = <span class="string"><span class="delimiter">“/</span> <span class="content">test-config.xml</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="type">类</span> <span class="class">XmlJUnitJupiterSpringWebTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定配置文件的位置。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#testcontext-ctx-management">上下文管理</a>以及<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html"><code>@SpringJUnitWebConfig</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/ContextConfiguration.html"><code>@ContextConfiguration</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a>的Javadoc。</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-enabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-enabledif"></a><code>@EnabledIf</code></h5>
<div class="paragraph">
<p><code>@EnabledIf</code>用于表示已启用带注释的JUnit Jupiter测试类或测试方法，并且如果提供的<code>expression</code>求值为<code>true</code> ，则应运行该函数。具体来说，如果表达式的计算结果为<code>Boolean.TRUE</code>或<code>String</code>等于<code>true</code> （忽略大小写），启用测试。在类级别应用时，默认情况下也会自动启用该类中的所有测试方法。</p>
</div>
<div class="paragraph">
<p>表达式可以是以下任何一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring Expression Language</a> （SpEL）表达式。例如： <code>@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p>Spring <a href="core.html#beans-environment"><code>Environment</code></a>可用的属性的占位符。例如： <code>@EnabledIf("${smoke.tests.enabled}")</code></p>
</li>
<li>
<p>文字文字。例如： <code>@EnabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但请注意，不是属性占位符的动态解析结果的文本文字的实用价值为零，因为<code>@EnabledIf("false")</code>等同于<code>@Disabled</code>而<code>@EnabledIf("true")</code>在逻辑上是无意义的。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@EnabledIf</code>作为元注释来创建自定义组合注释。例如，您可以创建自定义<code>@EnabledOnMac</code>注释，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。TYPE， <span class="predefined-type">ElementType</span> 。方法}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@EnabledIf</span> （expression = <span class="string"><span class="delimiter">“</span> <span class="content">＃{systemProperties ['os.name']。toLowerCase（）。contains（'mac'）}</span> <span class="delimiter">”</span></span> ，reason = <span class="string"><span class="delimiter">“</span> <span class="content">在Mac OS上启用</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="annotation">@interface</span> EnabledOnMac {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>[[integration-testing-annotations-junit-jupiter = -disabledif]] ===== <code>@DisabledIf</code></p>
</div>
<div class="paragraph">
<p><code>@DisabledIf</code>用于表示已禁用带注释的JUnit Jupiter测试类或测试方法，并且如果提供的<code>expression</code>计算结果为<code>true</code> ，则不应执行。具体来说，如果表达式的计算结果为<code>Boolean.TRUE</code>或<code>String</code>等于<code>true</code> （忽略大小写），禁用测试。在类级别应用时，该类中的所有测试方法也会自动禁用。</p>
</div>
<div class="paragraph">
<p>表达式可以是以下任何一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring Expression Language</a> （SpEL）表达式。例如： <code>@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p>Spring <a href="core.html#beans-environment"><code>Environment</code></a>可用的属性的占位符。例如： <code>@DisabledIf("${smoke.tests.disabled}")</code></p>
</li>
<li>
<p>文字文字。例如： <code>@DisabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但请注意，不是属性占位符动态解析结果的文本文字的实用价值为零，因为<code>@DisabledIf("true")</code>等同于<code>@Disabled</code>而<code>@DisabledIf("false")</code>在逻辑上没有意义。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@DisabledIf</code>作为元注释来创建自定义组合注释。例如，您可以创建自定义<code>@DisabledOnMac</code>注释，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。TYPE， <span class="predefined-type">ElementType</span> 。方法}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@DisabledIf</span> （expression = <span class="string"><span class="delimiter">“</span> <span class="content">＃{systemProperties ['os.name']。toLowerCase（）。contains（'mac'）}</span> <span class="delimiter">”</span></span> ，reason = <span class="string"><span class="delimiter">“</span> <span class="content">在Mac OS上禁用</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="annotation">@interface</span> DisabledOnMac {}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-meta"><a class="anchor" href="#integration-testing-annotations-meta"></a> 3.4.5。测试的元注释支持</h4>
<div class="paragraph">
<p>您可以将大多数与测试相关的注释用作<a href="core.html#beans-meta-annotations">元注释，</a>以创建自定义组合注释并减少测试套件中的配置重复。</p>
</div>
<div class="paragraph">
<p>您可以将以下各项作为元注释与<a href="#testcontext-framework">TestContext框架</a>结合使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BootstrapWith</code></p>
</li>
<li>
<p><code>@ContextConfiguration</code></p>
</li>
<li>
<p><code>@ContextHierarchy</code></p>
</li>
<li>
<p><code>@ActiveProfiles</code></p>
</li>
<li>
<p><code>@TestPropertySource</code></p>
</li>
<li>
<p><code>@DirtiesContext</code></p>
</li>
<li>
<p><code>@WebAppConfiguration</code></p>
</li>
<li>
<p><code>@TestExecutionListeners</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
<li>
<p><code>@BeforeTransaction</code></p>
</li>
<li>
<p><code>@AfterTransaction</code></p>
</li>
<li>
<p><code>@承诺</code></p>
</li>
<li>
<p><code>@Rollback</code></p>
</li>
<li>
<p><code>@sql</code></p>
</li>
<li>
<p><code>@SqlConfig</code></p>
</li>
<li>
<p><code>@SqlGroup</code></p>
</li>
<li>
<p><code>@Repeat</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@Timed</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@IfProfileValue</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@ProfileValueSourceConfiguration</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@SpringJUnitConfig</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@SpringJUnitWebConfig</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@EnabledIf</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@DisabledIf</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation"><span class="annotation">@RunWith（SpringRunner.class）@ContextConfiguration（{</span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="annotation">“/test-data-access-config.xml”}）@ActiveProfiles（</span></span></span></span></span> <span class="string"><span class="content"><span class="delimiter">“dev</span>的</span> <span class="delimiter"><span class="annotation">”）@Transactional</span></span></span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">OrderRepositoryTests</span> {} <span class="annotation">@RunWith</span> <span class="annotation">（SpringRunner.class）@ContextConfiguration（{</span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="annotation">“/test-data-access-config.xml”}）@ActiveProfiles（</span></span></span></span></span> <span class="string"><span class="content"><span class="delimiter">“dev</span>的</span> <span class="delimiter"><span class="annotation">”）@Transactional</span></span></span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">UserRepositoryTests</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们发现我们在基于JUnit 4的测试套件中重复了前面的配置，我们可以通过引入一个自定义组合注释来集中Spring的常用测试配置来减少重复，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。TYPE） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。<span class="annotation">RUNTIME）@ContextConfiguration（{</span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="annotation">“/test-data-access-config.xml”}）@ActiveProfiles（</span></span></span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">开发</span></span> <span class="annotation"><span class="string"><span class="delimiter">”）@</span></span>事务</span> <span class="directive">公共</span> <span class="annotation">@interface</span> TransactionalDevTestConfig {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后我们可以使用我们的自定义<code>@TransactionalDevTestConfig</code>注释来简化基于JUnit 4的各个测试类的配置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation"><span class="annotation">@RunWith（SpringRunner.class）@TransactionalDevTestConfig</span></span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">OrderRepositoryTests</span> {} <span class="annotation"><span class="annotation">@RunWith（SpringRunner.class）@TransactionalDevTestConfig</span></span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">UserRepositoryTests</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们编写使用JUnit Jupiter的测试，我们可以进一步减少代码重复，因为JUnit 5中的注释也可以用作元注释。请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation"><span class="annotation">@ExtendWith（SpringExtension.class）@ContextConfiguration（{</span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="annotation">“/test-data-access-config.xml”}）@ActiveProfiles（</span></span></span></span></span> <span class="string"><span class="content"><span class="delimiter">“dev</span>的</span> <span class="delimiter"><span class="annotation">”）@Transactional</span></span></span> <span class="type">类</span> <span class="class">OrderRepositoryTests</span> {} <span class="annotation">@ExtendWith（</span> <span class="annotation">SpringExtension.class）@ContextConfiguration（{</span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="annotation">“/test-data-access-config.xml”}）@ActiveProfiles（</span></span></span></span></span> <span class="string"><span class="content"><span class="delimiter">“dev</span>的</span> <span class="delimiter"><span class="annotation">”）@Transactional</span></span></span> <span class="type">类</span> <span class="class">UserRepositoryTests</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们发现我们在基于JUnit Jupiter的测试套件中重复上述配置，我们可以通过引入一个自定义组合注释来集中Spring和JUnit Jupiter的常用测试配置来减少重复，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。TYPE） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。<span class="annotation"><span class="annotation">RUNTIME）@ExtendWith（SpringExtension.class）@ContextConfiguration（{</span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="annotation">“/test-data-access-config.xml”}）@ActiveProfiles（</span></span></span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">开发</span></span> <span class="annotation"><span class="string"><span class="delimiter">”）@</span></span>事务</span> <span class="directive">公共</span> <span class="annotation">@interface</span> TransactionalDevTestConfig { }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后我们可以使用我们的自定义<code>@TransactionalDevTestConfig</code>注释来简化各个基于JUnit Jupiter的测试类的配置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@TransactionalDevTestConfig</span> <span class="type">类</span> <span class="class">OrderRepositoryTests</span> {} <span class="annotation">@TransactionalDevTestConfig</span> <span class="type">类</span> <span class="class">UserRepositoryTests</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于JUnit的木星支持使用<code>@Test</code> ， <code>@RepeatedTest</code> ， <code>ParameterizedTest</code> ，以及其他为元注释，你还可以创建在测试方法级别的定制组成的注解。例如，如果我们希望创建一个组合注释，它将来自JUnit Jupiter的<code>@Test</code>和<code>@Tag</code>注释与Spring中的<code>@Transactional</code>注释相结合，我们可以创建一个<code>@TransactionalIntegrationTest</code>注释，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。方法） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Transactional</span> <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">integration-test</span> <span class="delimiter">”</span></span> ） <span class="comment">// org.junit.jupiter.api。标记</span> <span class="annotation">@Test</span> <span class="comment">// org.junit.jupiter.api。测试</span> <span class="directive">public</span> <span class="annotation">@interface</span> TransactionalIntegrationTest {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后我们可以使用我们的自定义<code>@TransactionalIntegrationTest</code>批注来简化各个基于JUnit Jupiter的测试方法的配置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@TransactionalIntegrationTest</span> <span class="type">空隙</span> saveOrder（）{} <span class="annotation">@TransactionalIntegrationTest</span> <span class="type">空隙</span> deleteOrder（）{}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="core.html#annotation-programming-model">Spring注释编程模型</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testcontext-framework"><a class="anchor" href="#testcontext-framework"></a> 3.5。Spring TestContext框架</h3>
<div class="paragraph">
<p>Spring TestContext Framework（位于<code>org.springframework.test.context</code>包中）提供了通用的，注释驱动的单元和集成测试支持，它与使用中的测试框架无关。TestContext框架也非常重视约定优于配置，合理的默认值可以通过基于注释的配置覆盖。</p>
</div>
<div class="paragraph">
<p>除了通用测试基础结构之外，TestContext框架还为JUnit 4，JUnit Jupiter（AKA JUnit 5）和TestNG提供了显式支持。对于JUnit 4和TestNG，Spring提供了<code>abstract</code>支持类。此外，Spring为JUnit 4提供了一个自定义JUnit <code>Runner</code>和自定义JUnit <code>Rules</code> ，并为JUnit Jupiter提供了一个自定义<code>Extension</code> ，允许您编写所谓的POJO测试类。POJO测试类不需要扩展特定的类层次结构，例如<code>abstract</code>支持类。</p>
</div>
<div class="paragraph">
<p>以下部分概述了TestContext框架的内部结构。如果您只对使用框架感兴趣并且不想使用自己的自定义侦听器或自定义加载器扩展它，请随意直接进入配置（ <a href="#testcontext-ctx-management">上下文管理</a> ， <a href="#testcontext-fixture-di">依赖注入</a> ， <a href="#testcontext-tx">事务管理</a> ）， <a href="#testcontext-support-classes">支持类</a>和<a href="#integration-testing-annotations">注释支持</a>部分。</p>
</div>
<div class="sect3">
<h4 id="testcontext-key-abstractions"><a class="anchor" href="#testcontext-key-abstractions"></a> 3.5.1。关键抽象</h4>
<div class="paragraph">
<p>框架的核心包括<code>TestContextManager</code>类和<code>TestContext</code> ， <code>TestExecutionListener</code>和<code>SmartContextLoader</code>接口。为每个测试类创建一个<code>TestContextManager</code> （例如，用于在JUnit Jupiter中的单个测试类中执行所有测试方法）。该<code>TestContextManager</code> ，又管理着一个<code>TestContext</code>保存当前测试的上下文。该<code>TestContextManager</code>还更新了状态<code>TestContext</code>在测试执行过程，并委托给<code>TestExecutionListener</code>实现，它用来监测测试实际的执行提供依赖注入，管理事务，等等。<code>SmartContextLoader</code>负责为给定的测试类加载<code>ApplicationContext</code> 。有关各种实现的更多信息和示例，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework">Javadoc</a>和Spring测试套件。</p>
</div>
<div class="sect4">
<h5 id="code-testcontext-code"><a class="anchor" href="#code-testcontext-code"></a><code>TestContext</code></h5>
<div class="paragraph">
<p><code>TestContext</code>封装了执行测试的上下文（与使用中的实际测试框架无关），并为其负责的测试实例提供上下文管理和缓存支持。如果请求， <code>TestContext</code>还委托<code>SmartContextLoader</code>加载<code>ApplicationContext</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="code-testcontextmanager-code"><a class="anchor" href="#code-testcontextmanager-code"></a><code>TestContextManager</code></h5>
<div class="paragraph">
<p><code>TestContextManager</code>是Spring TestContext Framework的主要入口点，负责管理单个<code>TestContext</code>并在明确定义的测试执行点向每个注册的<code>TestExecutionListener</code>发送信号事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在特定测试框架的任何“课前”或“之前”方法之前。</p>
</li>
<li>
<p>测试实例后处理。</p>
</li>
<li>
<p>在特定测试框架的任何“之前”或“之前”方法之前。</p>
</li>
<li>
<p>在执行测试方法之前，但在测试设置之后。</p>
</li>
<li>
<p>在执行测试方法之后但在测试之前立即拆除。</p>
</li>
<li>
<p>在特定测试框架的任何“之后”或“之后”方法之后。</p>
</li>
<li>
<p>在特定测试框架的任何“课后”或“毕竟”方法之后。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="code-testexecutionlistener-code"><a class="anchor" href="#code-testexecutionlistener-code"></a><code>TestExecutionListener</code></h5>
<div class="paragraph">
<p><code>TestExecutionListener</code>定义API，以<code>TestContextManager</code>由注册侦听器的<code>TestContextManager</code>发布的测试执行事件。请参阅<a href="#testcontext-tel-config"><code>TestExecutionListener</code>配置</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="context-loaders"><a class="anchor" href="#context-loaders"></a>上下文加载器</h5>
<div class="paragraph">
<p><code>ContextLoader</code>是Spring 2.5中引入的一个策略接口，用于为Spring TestContext Framework管理的集成测试加载<code>ApplicationContext</code> 。您应该实现<code>SmartContextLoader</code>而不是此接口，以提供对带注释的类，活动Bean定义配置文件，测试属性源，上下文层次结构和<code>WebApplicationContext</code>支持的支持。</p>
</div>
<div class="paragraph">
<p><code>SmartContextLoader</code>是Spring 3.1中引入的<code>ContextLoader</code>接口的扩展。<code>SmartContextLoader</code> SPI取代了Spring 2.5中引入的<code>ContextLoader</code> SPI。具体来说， <code>SmartContextLoader</code>可以选择处理资源位置，带注释的类或上下文初始值设定项。此外， <code>SmartContextLoader</code>可以在其加载的上下文中设置活动Bean定义概要文件和测试属性源。</p>
</div>
<div class="paragraph">
<p>Spring提供以下实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DelegatingSmartContextLoader</code> ：两个默认加载器之一，它内部委托给<code>AnnotationConfigContextLoader</code> ， <code>GenericXmlContextLoader</code>或<code>GenericGroovyXmlContextLoader</code> ，具体取决于为测试类声明的配置或默认位置或默认配置类的存在。仅当Groovy位于类路径上时才启用Groovy支持。</p>
</li>
<li>
<p><code>WebDelegatingSmartContextLoader</code> ：两个默认加载器之一，它内部委托给<code>AnnotationConfigWebContextLoader</code> ， <code>GenericXmlWebContextLoader</code>或<code>GenericGroovyXmlWebContextLoader</code> ，具体取决于为测试类声明的配置或默认位置或默认配置类的存在。仅当测试类中存在<code>@WebAppConfiguration</code>才使用Web <code>ContextLoader</code> 。仅当Groovy位于类路径上时才启用Groovy支持。</p>
</li>
<li>
<p><code>AnnotationConfigContextLoader</code> ：从带注释的类中加载标准<code>ApplicationContext</code> 。</p>
</li>
<li>
<p><code>AnnotationConfigWebContextLoader</code> ：从带注释的类中加载<code>WebApplicationContext</code> 。</p>
</li>
<li>
<p><code>GenericGroovyXmlContextLoader</code> ：从Groovy脚本或XML配置文件的资源位置加载标准<code>ApplicationContext</code> 。</p>
</li>
<li>
<p><code>GenericGroovyXmlWebContextLoader</code> ：从Groovy脚本或XML配置文件的资源位置加载<code>WebApplicationContext</code> 。</p>
</li>
<li>
<p><code>GenericXmlContextLoader</code> ：从XML资源位置加载标准<code>ApplicationContext</code> 。</p>
</li>
<li>
<p><code>GenericXmlWebContextLoader</code> ：从XML资源位置加载<code>WebApplicationContext</code> 。</p>
</li>
<li>
<p><code>GenericPropertiesContextLoader</code> ：从Java属性文件加载标准<code>ApplicationContext</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-bootstrapping"><a class="anchor" href="#testcontext-bootstrapping"></a> 3.5.2。引导TestContext框架</h4>
<div class="paragraph">
<p>Spring TestContext Framework内部的默认配置足以满足所有常见用例。但是，有时开发团队或第三方框架要更改默认的<code>ContextLoader</code> ，实现自定义<code>TestContext</code>或<code>ContextCache</code> ，扩充<code>ContextCustomizerFactory</code>和<code>TestExecutionListener</code>实现的默认集，依此类推。对于TestContext框架如何操作的这种低级控制，Spring提供了一种自举策略。</p>
</div>
<div class="paragraph">
<p><code>TestContextBootstrapper</code>定义了用于引导TestContext框架的SPI。<code>TestContextBootstrapper</code>使用<code>TestContextManager</code>为当前测试加载<code>TestExecutionListener</code>实现并构建它管理的<code>TestContext</code> 。您可以使用<code>@BootstrapWith</code>直接或作为元注释为测试类（或测试类层次结构）配置自定义引导策略。如果未使用<code>@BootstrapWith</code>显式配置引导程序，则使用<code>DefaultTestContextBootstrapper</code>或<code>WebTestContextBootstrapper</code> ，具体取决于<code>@WebAppConfiguration</code>的存在。</p>
</div>
<div class="paragraph">
<p>由于<code>TestContextBootstrapper</code> SPI将来可能会发生变化（以适应新的需求），我们强烈建议实施者不要直接实现此接口，而是扩展<code>AbstractTestContextBootstrapper</code>或其中一个具体的子类。</p>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tel-config"><a class="anchor" href="#testcontext-tel-config"></a> 3.5.3。<code>TestExecutionListener</code>配置</h4>
<div class="paragraph">
<p>Spring提供了以下默认注册的<code>TestExecutionListener</code>实现，完全按以下顺序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServletTestExecutionListener</code> ：为<code>WebApplicationContext</code>配置Servlet API <code>ServletTestExecutionListener</code> 。</p>
</li>
<li>
<p><code>DirtiesContextBeforeModesTestExecutionListener</code> ：处理“之前”模式的<code>@DirtiesContext</code>注释。</p>
</li>
<li>
<p><code>DependencyInjectionTestExecutionListener</code> ：为测试实例提供依赖项注入。</p>
</li>
<li>
<p><code>DirtiesContextTestExecutionListener</code> ：处理“after”模式的<code>@DirtiesContext</code>注释。</p>
</li>
<li>
<p><code>TransactionalTestExecutionListener</code> ：使用默认回滚语义提供事务测试执行。</p>
</li>
<li>
<p><code>SqlScriptsTestExecutionListener</code> ：运行使用<code>@Sql</code>批注配置的SQL脚本。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-registering-tels"><a class="anchor" href="#testcontext-tel-config-registering-tels"></a>注册自定义<code>TestExecutionListener</code>实现</h5>
<div class="paragraph">
<p>您可以使用<code>@TestExecutionListeners</code>批注为测试类及其子类注册自定义<code>TestExecutionListener</code>实现。有关详细信息和示例，请参阅<a href="#integration-testing-annotations">注释支持</a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code></a>的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">Javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-automatic-discovery"><a class="anchor" href="#testcontext-tel-config-automatic-discovery"></a>自动发现默认的<code>TestExecutionListener</code>实现</h5>
<div class="paragraph">
<p>使用<code>@TestExecutionListeners</code>注册自定义<code>TestExecutionListener</code>实现适用于在有限测试场景中使用的自定义侦听器。但是，如果需要在测试套件中使用自定义侦听器，则会变得很麻烦。从Spring Framework 4.1开始，通过支持通过<code>SpringFactoriesLoader</code>机制自动发现默认的<code>TestExecutionListener</code>实现来解决此问题。</p>
</div>
<div class="paragraph">
<p>具体来说， <code>spring-test</code>模块在<code>org.springframework.test.context.下声明所有核心默认的TestExecutionListener`实现<code>org.springframework.test.context.其<code>META-INF/spring.factories</code>属性文件中的TestExecutionListener</code>键。第三方框架和开发人员可以通过自己的<code>META-INF/spring.factories</code>属性文件以相同的方式将自己的<code>TestExecutionListener</code>实现提供给默认侦听器列表。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-ordering"><a class="anchor" href="#testcontext-tel-config-ordering"></a>订购<code>TestExecutionListener</code>实现</h5>
<div class="paragraph">
<p>当TestContext框架通过<a href="#testcontext-tel-config-automatic-discovery">前面提到的</a> <code>SpringFactoriesLoader</code>机制发现默认的<code>TestExecutionListener</code>实现时，实例化的侦听器将使用Spring的<code>AnnotationAwareOrderComparator</code>进行排序，它遵循Spring的<code>Ordered</code>接口和<code>@Order</code>注释进行排序。<code>AbstractTestExecutionListener</code>和Spring提供的所有默认<code>TestExecutionListener</code>实现都使用适当的值进行<code>Ordered</code> 。因此，第三方框架和开发人员应确保通过实现<code>Ordered</code>或声明<code>@Order</code>以正确的顺序注册其默认的<code>TestExecutionListener</code>实现。有关为每个核心侦听器分配的值的详细信息，请参阅Javadoc以获取核心默认<code>TestExecutionListener</code>实现的<code>getOrder()</code>方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-merging"><a class="anchor" href="#testcontext-tel-config-merging"></a>合并<code>TestExecutionListener</code>实现</h5>
<div class="paragraph">
<p>如果通过<code>@TestExecutionListeners</code>注册了自定义<code>TestExecutionListener</code> ，则不会注册默认侦听器。在大多数常见的测试场景中，除了任何自定义侦听器之外，这还有效地迫使开发人员手动声明所有默认侦听器。以下清单演示了这种配置风格：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestExecutionListeners</span> （{MyCustomTestExecutionListener.class，ServletTestExecutionListener.class，DirtiesContextBeforeModesTestExecutionListener.class，DependencyInjectionTestExecutionListener.class，DirtiesContextTestExecutionListener.class，TransactionalTestExecutionListener.class，SqlScriptsTestExecutionListener.class}） <span class="directive">public</span> <span class="type">class</span> <span class="class">MyTest</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法的挑战在于它要求开发人员确切地知道默认情况下注册了哪些监听器。此外，该组的默认听众可以从发行版的改变-例如， <code>SqlScriptsTestExecutionListener</code>在Spring框架4.1被引入，并<code>DirtiesContextBeforeModesTestExecutionListener</code>在Spring框架4.2推出。此外，Spring Security等第三方框架通过使用上述<a href="#testcontext-tel-config-automatic-discovery">自动发现机制</a>注册了自己的默认<code>TestExecutionListener</code>实现。</p>
</div>
<div class="paragraph">
<p>为了避免必须了解并重新申报所有默认监听器，你可以设置<code>mergeMode</code>的属性<code>@TestExecutionListeners</code>到<code>MergeMode.MERGE_WITH_DEFAULTS</code> 。 <code>MERGE_WITH_DEFAULTS</code>指示本地声明的侦听器应与默认侦听器合并。合并算法确保从列表中删除重复项，并根据<code>AnnotationAwareOrderComparator</code>的语义对生成的合并侦听器集进行排序，如<a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code>实现中所述</a> 。如果侦听器实现<code>Ordered</code>或使用<code>@Order</code>注释，它可以影响它与默认值合并的位置。否则，在合并时，本地声明的侦听器将附加到默认侦听器列表中。</p>
</div>
<div class="paragraph">
<p>例如，如果前一个示例中的<code>MyCustomTestExecutionListener</code>类将其<code>order</code>值（例如， <code>500</code> ）配置为小于<code>ServletTestExecutionListener</code> （恰好为<code>1000</code> ）的顺序，则<code>MyCustomTestExecutionListener</code>可以自动与默认值列表合并在<code>ServletTestExecutionListener</code>前面，前面的例子可以替换为以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestExecutionListeners</span> （listeners = MyCustomTestExecutionListener.class，mergeMode = MERGE_WITH_DEFAULTS） <span class="directive">public</span> <span class="type">class</span> <span class="class">MyTest</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-ctx-management"><a class="anchor" href="#testcontext-ctx-management"></a> 3.5.4。上下文管理</h4>
<div class="paragraph">
<p>每个<code>TestContext</code>为其负责的测试实例提供上下文管理和缓存支持。测试实例不会自动接收对已配置的<code>ApplicationContext</code>访问权限。但是，如果测试类实现<code>ApplicationContextAware</code>接口，则会向测试实例提供对<code>ApplicationContext</code>的引用。请注意， <code>AbstractJUnit4SpringContextTests</code>和<code>AbstractTestNGSpringContextTests</code>实现<code>ApplicationContextAware</code> ，因此可以自动提供对<code>ApplicationContext</code>访问。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">@Autowired ApplicationContext</div>
<div class="paragraph">
<p>作为实现<code>ApplicationContextAware</code>接口的替代方法，您可以通过字段或setter方法上的<code>@Autowired</code>注释为测试类注入应用程序上下文，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyTest</span> { <span class="annotation">@Autowired</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">private</span> ApplicationContext applicationContext; <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>注入<code>ApplicationContext</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，如果您的测试配置为加载<code>WebApplicationContext</code> ，则可以将Web应用程序上下文注入测试，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@WebAppConfiguration</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@ContextConfiguration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebAppTest</span> { <span class="annotation">@Autowired</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">私有</span> WebApplicationContext wac; <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>配置<code>WebApplicationContext</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入<code>WebApplicationContext</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>依赖注入通过使用<code>@Autowired</code>由提供<code>DependencyInjectionTestExecutionListener</code> ，这是默认配置（参照<a href="#testcontext-fixture-di">测试夹具的依赖注入</a> ）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用TestContext框架的测试类不需要扩展任何特定类或实现特定接口来配置其应用程序上下文。相反，通过在类级别声明<code>@ContextConfiguration</code>批注来实现配置。如果测试类未显式声明应用程序上下文资源位置或带注释的类，则配置的<code>ContextLoader</code>确定如何从默认位置或默认配置类加载上下文。除了上下文资源位置和带注释的类之外，还可以通过应用程序上下文初始化程序配置应用程序上下文。</p>
</div>
<div class="paragraph">
<p>以下部分说明如何使用Spring的<code>@ContextConfiguration</code>批注通过使用XML配置文件，Groovy脚本，带注释的类（通常为<code>@Configuration</code>类）或上下文初始化<code>ApplicationContext</code>来配置测试<code>ApplicationContext</code> 。或者，您可以为高级用例实现和配置自己的自定义<code>SmartContextLoader</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#testcontext-ctx-management-xml">使用XML资源配置上下文</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-groovy">使用Groovy脚本配置上下文</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-javaconfig">带注释类的上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-mixed-config">混合XML，Groovy脚本和带注释的类</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-initializers">使用上下文初始化器配置上下文</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-inheritance">上下文配置继承</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-env-profiles">使用环境配置文件配置上下文</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-property-sources">使用测试属性源配置上下文</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-web">加载<code>WebApplicationContext</code></a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-caching">上下文缓存</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-ctx-hierarchies">上下文层次结构</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-xml"><a class="anchor" href="#testcontext-ctx-management-xml"></a>使用XML资源配置上下文</h5>
<div class="paragraph">
<p>要使用XML配置文件为测试加载<code>ApplicationContext</code> ，请使用<code>@ContextConfiguration</code>注释测试类，并使用包含XML配置元数据的资源位置的数组配置<code>locations</code>属性。普通路径或相对路径（例如， <code>context.xml</code> ）被视为相对于定义测试类的包的类路径资源。以斜杠开头的路径被视为绝对类路径位置（例如，/ <code>/org/example/config.xml</code> example / <code>/org/example/config.xml</code> ）。表示资源URL的路径（即，以<code>classpath:</code> ， <code>file:</code> ， <code>http:</code>等为前缀的<code>classpath:</code> ） <em>按原样</em>使用。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将从</span> <span class="comment">类路径</span> <span class="annotation">@ContextConfiguration</span> （locations = { <span class="string"><span class="delimiter">“</span> <span class="content">/ app-config）</span></span> <span class="comment">的根目录中的</span> <span class="comment">”/app-config.xml“和//”/test-config.xml“加载</span> <span class="string"><span class="content">.xml</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”/</span> <span class="content">test-config.xml</span> <span class="delimiter">“</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>将locations属性设置为XML文件列表。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code>通过标准Java <code>value</code>属性支持<code>locations</code>属性的别名。因此，如果您不需要在<code>@ContextConfiguration</code>声明其他属性， <code>@ContextConfiguration</code>可以省略<code>locations</code>属性名称的声明，并使用以下示例中演示的缩写格式声明资源位置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> （{ <span class="string"><span class="delimiter">“/</span> <span class="content">app-config.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“/</span> <span class="content">test-config.xml</span> <span class="delimiter">”</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在不使用<code>location</code>属性的情况下指定XML文件。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果省略<code>@ContextConfiguration</code>批注中的<code>locations</code>和<code>value</code>属性，则TestContext框架会尝试检测默认的XML资源位置。具体来说， <code>GenericXmlContextLoader</code>和<code>GenericXmlWebContextLoader</code>根据测试类的名称检测默认位置。如果您的类名为<code>com.example.MyTest</code> ， <code>GenericXmlContextLoader</code>从<code>"classpath:com/example/MyTest-context.xml"</code>加载应用程序上下文。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.example</span> ; <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//将从</span> <span class="comment">//“classpath：com / example / MyTest-context.xml”</span> <span class="annotation">@ContextConfiguration加载ApplicationContext</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从默认位置加载配置。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-groovy"><a class="anchor" href="#testcontext-ctx-management-groovy"></a>使用Groovy脚本配置上下文</h5>
<div class="paragraph">
<p>要使用使用<a href="core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL的</a> Groovy脚本为测试加载<code>ApplicationContext</code> ，可以使用<code>@ContextConfiguration</code>注释测试类，并使用包含Groovy脚本资源位置的数组配置<code>locations</code>或<code>value</code>属性。Groovy脚本的资源查找语义与<a href="#testcontext-ctx-management-xml">XML配置文件中</a>描述的相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">启用Groovy脚本支持</div>如果Groovy在类路径上，则支持使用Groovy脚本在Spring TestContext Framework中加载<code>ApplicationContext</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何指定Groovy配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment"><span class="annotation">@RunWith（SpringRunner.class）//</span> ApplicationContext的将被从“/AppConfig.groovy”和</span> <span class="comment">// “/TestConfig.groovy”中的类路径</span> <span class="annotation">@ContextConfiguration（{</span> <span class="string"><span class="content"><span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="delimiter">“/AppConfig.groovy”，“/</span></span></span></span></span> TestConfig <span class="comment">的根</span> <span class="comment">加载</span> <span class="string"><span class="content">。Groovy</span> <span class="delimiter">“</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定Groovy配置文件的位置。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果省略<code>@ContextConfiguration</code>批注中的<code>locations</code>和<code>value</code>属性，TestContext框架将尝试检测默认的Groovy脚本。具体来说， <code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>根据测试类的名称检测默认位置。如果您的类名为<code>com.example.MyTest</code> ，Groovy上下文加载器从<code>"classpath:com/example/MyTestContext.groovy"</code>加载您的应用程序上下文。以下示例显示了如何使用默认值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.example</span> ; <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//将从</span> <span class="comment">//“classpath：com / example / MyTestContext.groovy”</span> <span class="annotation">@ContextConfiguration加载ApplicationContext</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从默认位置加载配置。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">同时声明XML配置和Groovy脚本</div>
<div class="paragraph">
<p>您可以使用<code>@ContextConfiguration</code>的<code>locations</code>或<code>value</code>属性同时声明XML配置文件和Groovy脚本。如果配置的资源位置的路径以<code>.xml</code>结尾，则使用<code>XmlBeanDefinitionReader</code>加载它。否则，使用<code>GroovyBeanDefinitionReader</code>加载它。</p>
</div>
<div class="paragraph">
<p>以下清单显示了如何在集成测试中将两者结合使用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment"><span class="annotation">@RunWith（SpringRunner.class）//</span>的ApplicationContext将从</span> <span class="comment">// “/app-config.xml”和“/TestConfig.groovy”</span> <span class="annotation">@ContextConfiguration（{</span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/app-config.xml”，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“/TestConfig.groovy”</span></span></span></span> <span class="comment">被加载</span> }） <span class="directive">public</span> <span class="type">class</span> <span class="class">MyTest</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-javaconfig"><a class="anchor" href="#testcontext-ctx-management-javaconfig"></a>带注释类的上下文配置</h5>
<div class="paragraph">
<p>要使用带注释的类为测试加载<code>ApplicationContext</code> （请参阅<a href="core.html#beans-java">基于Java的容器配置</a> ），可以使用<code>@ContextConfiguration</code>注释测试类，并使用包含对带注释类的引用的数组配置<code>classes</code>属性。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//将从AppConfig和TestConfig</span> <span class="annotation">@ContextConfiguration</span> （classes = {AppConfig.class，TestConfig.class}） <span class="comment">加载ApplicationContext</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定带注释的类。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">带注释的类</div>
<div class="paragraph">
<p>术语“带注释的类”可以指以下任何一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用<code>@Configuration</code>注释的类。</p>
</li>
<li>
<p>组件（即使用<code>@Component</code> <code>@Service</code> ， <code>@Repository</code> ， <code>@Service</code> <code>@Repository</code>或其他<code>@Repository</code>型注释注释的类）。</p>
</li>
<li>
<p>符合JSR-330的类，使用<code>javax.inject</code>注释<code>javax.inject</code>批注。</p>
</li>
<li>
<p>包含<code>@Bean</code>方法的任何其他类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关注释类的配置和语义的更多信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>的Javadoc，特别注意对<code>@Bean</code> Lite模式的讨论。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果省略<code>@ContextConfiguration</code>批注中的<code>classes</code>属性，TestContext框架将尝试检测是否存在默认配置类。具体来说， <code>AnnotationConfigContextLoader</code>和<code>AnnotationConfigWebContextLoader</code>检测满足配置类实现要求的测试类的所有<code>static</code>嵌套类，如<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> Javadoc中所指定。请注意，配置类的名称是任意的。此外，如果需要，测试类可以包含多个<code>static</code>嵌套配置类。在以下示例中， <code>OrderServiceTest</code>类声明一个名为<code>Config</code>的<code>static</code>嵌套配置类，该类自动用于加载测试类的<code>ApplicationContext</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将从</span> <span class="comment">//静态嵌套的Config类</span> <span class="annotation">加载@ContextConfiguration</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">OrderServiceTest</span> { <span class="annotation">@Configuration</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">Config</span> { <span class="comment">//这个bean将注入OrderServiceTest类</span> <span class="annotation">@Bean</span> <span class="directive">public</span> OrderService orderService（）{OrderService orderService = <span class="keyword">new</span> OrderServiceImpl（）; <span class="comment">//设置属性等</span> <span class="keyword">返回</span> orderService; <span class="annotation">@Autowired</span> <span class="directive">private</span> OrderService orderService; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testOrderService（）{ <span class="comment">//测试orderService</span> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从嵌套类加载配置信息。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-mixed-config"><a class="anchor" href="#testcontext-ctx-management-mixed-config"></a>混合XML，Groovy脚本和带注释的类</h5>
<div class="paragraph">
<p>有时可能需要混合XML配置文件，Groovy脚本和带注释的类（通常为<code>@Configuration</code>类）来为测试配置<code>ApplicationContext</code> 。例如，如果在生产中使用XML配置，则可能决定要使用<code>@Configuration</code>类为测试配置特定的Spring管理组件，反之亦然。</p>
</div>
<div class="paragraph">
<p>此外，一些第三方框架（例如Spring Boot）为同时从不同类型的资源加载<code>ApplicationContext</code>提供了一流的支持（例如，XML配置文件，Groovy脚本和<code>@Configuration</code>类）。历史上，Spring Framework并未支持标准部署。因此，Spring Framework在<code>spring-test</code>模块中提供的大多数<code>SmartContextLoader</code>实现仅支持每个测试上下文的一种资源类型。但是，这并不意味着您不能同时使用它们。一般规则的一个例外是<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>支持XML配置文件和Groovy脚本。此外，第三方框架可以选择通过<code>@ContextConfiguration</code>支持<code>locations</code>和<code>classes</code>的声明，并且，通过TestContext框架中的标准测试支持，您可以使用以下选项。</p>
</div>
<div class="paragraph">
<p>如果要使用资源位置（例如，XML或Groovy）和<code>@Configuration</code>类来配置测试，则必须选择一个作为入口点，并且必须包含或导入另一个。例如，在XML或Groovy脚本中，您可以通过使用组件扫描包含<code>@Configuration</code>类或将它们定义为普通的Spring bean，而在<code>@Configuration</code>类中，您可以使用<code>@ImportResource</code>来导入XML配置文件或Groovy脚本。请注意，此行为在语义上等同于您在生产中配置应用程序的方式：在生产配置中，您可以定义一组XML或Groovy资源位置或一组<code>@Configuration</code>类，从中加载生产<code>ApplicationContext</code> ，但您仍然拥有包含或导入其他类型配置的自由。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-initializers"><a class="anchor" href="#testcontext-ctx-management-initializers"></a>使用上下文初始化器配置上下文</h5>
<div class="paragraph">
<p>要使用上下文初始值设定<code>ApplicationContext</code>为测试配置<code>ApplicationContext</code> ，请使用<code>@ContextConfiguration</code>注释测试类，并使用包含对实现<code>ApplicationContextInitializer</code>类的引用的数组配置<code>initializers</code>属性。然后，使用声明的上下文初始值设定项初始化为测试加载的<code>ConfigurableApplicationContext</code> 。请注意，每个声明的初始化程序支持的具体<code>ConfigurableApplicationContext</code>类型必须与正在使用的<code>SmartContextLoader</code> （通常是<code>GenericApplicationContext</code> ）创建的<code>ApplicationContext</code>类型兼容。此外，调用初始值设定项的顺序取决于它们是实现Spring的<code>Ordered</code>接口还是使用Spring的<code>@Order</code>注释或标准<code>@Priority</code>注释进行注释。以下示例显示了如何使用初始值设定项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将从TestConfig</span> <span class="comment">//</span> <span class="comment">加载</span> <span class="comment">并由TestAppCtxInitializer</span> <span class="annotation">@ContextConfiguration</span> <span class="comment">初始化</span> （classes = TestConfig.class，initializers = TestAppCtxInitializer.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用配置类和初始化程序指定配置。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以完全省略<code>@ContextConfiguration</code>的XML配置文件，Groovy脚本或带注释的类的声明，而是仅声明<code>ApplicationContextInitializer</code>类，然后负责在上下文中注册bean  - 例如，通过以编程方式从XML文件加载bean定义或配置类。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将由EntireAppInitializer初始化</span> <span class="comment">//可能在上下文中注册bean</span> <span class="annotation">@ContextConfiguration</span> （initializers = EntireAppInitializer.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">课</span> <span class="class">MyTest</span> { <span class="comment">//班主体......</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>仅使用初始化程序指定配置。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-inheritance"><a class="anchor" href="#testcontext-ctx-management-inheritance"></a>上下文配置继承</h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code>支持boolean <code>inheritLocations</code>和<code>inheritInitializers</code>属性， <code>inheritInitializers</code>属性表示是否应继承超类声明的资源位置或带注释的类和上下文初始值设定项。两个标志的默认值均为<code>true</code> 。这意味着测试类继承资源位置或带注释的类以及任何超类声明的上下文初始值设定项。具体而言，测试类的资源位置或带注释的类将附加到超类声明的资源位置列表或带注释的类。类似地，给定测试类的初始值设定项被添加到由测试超类定义的初始化程序集中。因此，子类可以选择扩展资源位置，带注释的类或上下文初始化器。</p>
</div>
<div class="paragraph">
<p>如果<code>inheritLocations</code>或<code>inheritInitializers</code>在属性<code>@ContextConfiguration</code>被设置为<code>false</code> ，则资源分别在位置或注解的类和上下文初始化器，用于测试类影子和有效地替换通过超类中定义的构型。</p>
</div>
<div class="paragraph">
<p>在下一个使用XML资源位置的示例中， <code>ExtendedTest</code>的<code>ApplicationContext</code>按顺序从<code>base-config.xml</code>和<code>extended-config.xml</code>加载。因此，在<code>extended-config.xml</code>定义的Bean可以覆盖（即替换） <code>base-config.xml</code>定义的bean。以下示例显示了一个类如何扩展另一个类并使用其自己的配置文件和超类的配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将从“/base-config.xml”//</span> <span class="comment">在类路径</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">base-config.xml</span> <span class="delimiter">”</span></span> ） <span class="comment">的根目录中</span> <span class="comment">加载</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">BaseTest</span> { <span class="comment">//类体...</span><span class="comment">// // ApplicationContext将从</span> <span class="comment">类路径</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">extended_config.xml</span> <span class="delimiter">”</span></span> ） <span class="comment">的根目录中的</span> <span class="comment">“/base-config.xml”和//“/extended-config.xml”加载</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExtendedTest</span> <span class="directive">扩展</span> BaseTest { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>超类中定义的配置文件。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>子类中定义的配置文件。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>类似地，在下一个使用带注释的类的示例中， <code>ExtendedTest</code>的<code>ApplicationContext</code> <code>BaseConfig</code>顺序从<code>BaseConfig</code>和<code>ExtendedConfig</code>类加载。因此，在<code>ExtendedConfig</code>定义的Bean可以覆盖（即替换） <code>BaseConfig</code>定义的<code>BaseConfig</code> 。以下示例显示了一个类如何扩展另一个类并使用它自己的配置类和超类的配置类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//将从BaseConfig</span> <span class="annotation">@ContextConfiguration</span> （classes = BaseConfig.class） <span class="comment">加载ApplicationContext</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">BaseTest</span> { <span class="comment">//类体...</span><span class="comment">//将从BaseConfig和ExtendedConfig</span> <span class="annotation">@ContextConfiguration</span> （classes = ExtendedConfig.class） <span class="comment">加载ApplicationContext</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExtendedTest</span> <span class="directive">扩展</span> BaseTest { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>超类中定义的配置类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>子类中定义的配置类。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在下一个使用上下文初始值设定项的示例中，使用<code>BaseInitializer</code>和<code>ExtendedInitializer</code>初始化<code>ExtendedTest</code>的<code>ApplicationContext</code> 。但请注意，调用初始值设定项的顺序取决于它们是实现Spring的<code>Ordered</code>接口还是使用Spring的<code>@Order</code>注释或标准<code>@Priority</code>注释进行注释。以下示例显示了一个类如何扩展另一个类并使用它自己的初始化程序和超类的初始化程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将由BaseInitializer</span> <span class="annotation">@ContextConfiguration</span> （initializers = BaseInitializer.class）初始化<i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">BaseTest</span> { <span class="comment">//类体...</span>} <span class="comment">// ApplicationContext将由BaseInitializer</span> <span class="comment">//和ExtendedInitializer</span> <span class="annotation">@ContextConfiguration</span> （initializers = ExtendedInitializer.class）初始化<i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExtendedTest</span> <span class="directive">扩展</span> BaseTest { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>初始化程序在超类中定义。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>初始化器在子类中定义。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-env-profiles"><a class="anchor" href="#testcontext-ctx-management-env-profiles"></a>使用环境配置文件配置上下文</h5>
<div class="paragraph">
<p>Spring 3.1在框架中引入了环境和配置文件概念（AKA“bean定义配置文件”）的一流支持，并且可以配置集成测试以激活各种测试场景的特定bean定义配置文件。这是通过使用<code>@ActiveProfiles</code>注释注释测试类并提供在为测试加载<code>ApplicationContext</code>时应激活的配置文件列表来实现的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以将<code>@ActiveProfiles</code>与新<code>SmartContextLoader</code> SPI的任何实现一起使用，但旧版<code>ContextLoader</code> SPI的实现不支持<code>@ActiveProfiles</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>考虑XML配置和<code>@Configuration</code>类的两个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  app-config.xml  - &gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-实例</span> <span class="delimiter">“</span></span> <span class="attribute-name">xmlns：jdbc</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/jdbc</span> <span class="delimiter">“</span></span> <span class="attribute-name">xmlns：jee</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/jee</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">...</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">transferService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.bank.service.internal。DefaultTransferService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountRepository</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">feePolicy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountRepository</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.bank.repository.internal。JdbcAccountRepository</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">feePolicy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.bank.service.internal。ZeroFeePolicy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dev</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：embedded-database</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：com / bank / config / sql / schema.sql</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jdbc： script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / test-data.sql</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：embedded-database&gt;</span> <span class="tag">&lt;/ beans&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span> = <span class="string"><span class="delimiter">“</span> <span class="content">default</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：embedded-database</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / schema.sql</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：embedded-database&gt;</span> <span class="tag">&lt;/ beans&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service</span> ; <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// ApplicationContext将从“classpath：/app-config.xml”</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">app-config.xml</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ActiveProfiles</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dev</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">TransferServiceTest</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> TransferService transferService; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testTransferService（）{ <span class="comment">//测试transferService</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行<code>TransferServiceTest</code> ，将从类路径根目录中的<code>app-config.xml</code>配置文件加载其<code>ApplicationContext</code> 。如果检查<code>app-config.xml</code> ，则可以看到<code>accountRepository</code> bean依赖于<code>dataSource</code> bean。但是， <code>dataSource</code>未定义为顶级bean。相反， <code>dataSource</code>定义了三次：在<code>production</code>配置文件中，在<code>dev</code>配置文件中，以及在<code>default</code>配置文件中。</p>
</div>
<div class="paragraph">
<p>通过使用<code>@ActiveProfiles("dev")</code>注释<code>TransferServiceTest</code> ，我们指示Spring TestContext Framework加载<code>ApplicationContext</code> ，并将活动配置文件设置为<code>{"dev"}</code> 。因此，创建嵌入式数据库并使用测试数据填充，并且<code>accountRepository</code> bean连接到对开发<code>DataSource</code>的引用。这可能是我们在集成测试中想要的。</p>
</div>
<div class="paragraph">
<p>将bean分配给<code>default</code>配置文件有时很有用。仅当未专门激活其他配置文件时，才会包含默认配置文件中的Bean。您可以使用它来定义要在应用程序的默认状态中使用的“回退”bean。例如，您可以明确地为<code>dev</code>和<code>production</code>配置文件提供数据源，但在这些数据源都不是活动时将其定义为默认值。</p>
</div>
<div class="paragraph">
<p>以下代码清单演示了如何使用<code>@Configuration</code>类而不是XML实现相同的配置和集成测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dev</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">StandaloneDataConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。setType（EmbeddedDatabaseType。HSQL）.addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql /</span></span> schema.sql <span class="string"><span class="delimiter">”</span></span> ）。addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / test-data.sql</span> <span class="delimiter">”</span></span> ）。 <span class="string"><span class="content">build</span></span> （）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">JndiDataConfig</span> { <span class="annotation">@Bean</span> （destroyMethod = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span> （）; <span class="keyword">return</span> （ <span class="predefined-type">DataSource</span> ）ctx.lookup（ <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / datasource</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@Profile</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">default</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultDataConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource（）{ <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。setType（EmbeddedDatabaseType。HSQL）.addScript（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / bank / config / sql / schema.sql</span> <span class="delimiter">”</span></span> ）。build（）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">TransferServiceConfig</span> { <span class="annotation">@Autowired</span> <span class="predefined-type">DataSource</span> dataSource; <span class="annotation">@Bean</span> <span class="directive">public</span> TransferService transferService（）{ <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransferService（accountRepository（），feePolicy（））; } <span class="annotation">@Bean</span> <span class="directive">public</span> AccountRepository accountRepository（）{ <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository（dataSource）; } <span class="annotation">@Bean</span> <span class="directive">public</span> FeePolicy feePolicy（）{ <span class="keyword">return</span> <span class="keyword">new</span> ZeroFeePolicy（）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service</span> ; <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> （classes = {TransferServiceConfig.class，StandaloneDataConfig.class，JndiDataConfig.class，DefaultDataConfig.class}） <span class="annotation">@ActiveProfiles</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dev</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">TransferServiceTest</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> TransferService transferService; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testTransferService（）{ <span class="comment">//测试transferService</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此变体中，我们将XML配置拆分为四个独立的<code>@Configuration</code>类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransferServiceConfig</code> ：使用<code>@Autowired</code>通过依赖注入获取<code>dataSource</code> 。</p>
</li>
<li>
<p><code>StandaloneDataConfig</code> ：为适用于开发人员测试的嵌入式数据库定义<code>dataSource</code> 。</p>
</li>
<li>
<p><code>JndiDataConfig</code> ：定义在生产环境中从JNDI检索的<code>dataSource</code> 。</p>
</li>
<li>
<p><code>DefaultDataConfig</code> ：如果没有配置文件处于活动状态，则为默认嵌入式数据库定义<code>dataSource</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与基于XML的配置示例一样，我们仍然使用<code>@ActiveProfiles("dev")</code>注释<code>TransferServiceTest</code> ，但这次我们使用<code>@ContextConfiguration</code>批注指定所有四个配置类。测试类的主体本身保持完全不变。</p>
</div>
<div class="paragraph">
<p>通常情况下，在给定项目中的多个测试类中使用单组配置文件。因此，为了避免<code>@ActiveProfiles</code>注释的重复声明，您可以在基类上声明一次<code>@ActiveProfiles</code> ，并且子类自动从基类继承<code>@ActiveProfiles</code>配置。在下面的示例中， <code>@ActiveProfiles</code>的声明（以及其他注释）已移至抽象超类<code>AbstractIntegrationTest</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service</span> ; <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> （classes = {TransferServiceConfig.class，StandaloneDataConfig.class，JndiDataConfig.class，DefaultDataConfig.class}） <span class="annotation">@ActiveProfiles</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dev</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractIntegrationTest</span> {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service</span> ; <span class="comment">//从“超类”</span> <span class="directive">公共</span> <span class="type">类</span> <span class="comment">继承的“dev”配置文件</span> <span class="class">TransferServiceTest</span> <span class="directive">扩展了</span> AbstractIntegrationTest { <span class="annotation">@Autowired</span> <span class="directive">private</span> TransferService transferService; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testTransferService（）{ <span class="comment">//测试transferService</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@ActiveProfiles</code>还支持<code>inheritProfiles</code>属性，该属性可用于禁用活动配置文件的继承，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service</span> ; <span class="comment">//“dev”配置文件被“production”覆盖</span> <span class="annotation">@ActiveProfiles</span> （profiles = <span class="string"><span class="delimiter">“</span> <span class="content">production</span> <span class="delimiter">”</span></span> ，inheritProfiles = <span class="predefined-constant">false</span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductionTransferServiceTest</span> <span class="directive">扩展</span> AbstractIntegrationTest { <span class="comment">// test body</span> }</code></pre>
</div>
</div>
</div>
</div>
<div id="testcontext-ctx-management-env-profiles-ActiveProfilesResolver" class="paragraph">
<p>此外，有时需要以编程方式而不是声明性地解析测试的活动配置文件 - 例如，基于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>目前的操作系统。</p>
</li>
<li>
<p>是否在持续集成构建服务器上执行测试。</p>
</li>
<li>
<p>某些环境变量的存在。</p>
</li>
<li>
<p>存在自定义类级注释。</p>
</li>
<li>
<p>其他问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要以编程方式解析活动Bean定义概要文件，可以使用<code>@ActiveProfiles</code>的<code>resolver</code>属性实现自定义<code>ActiveProfilesResolver</code>并对其进行注册。有关详细信息，请参阅相应的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">Javadoc</a> 。以下示例演示如何实现和注册自定义<code>OperatingSystemActiveProfilesResolver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service</span> ; <span class="comment">//“dev”配置文件通过自定义解析器</span> <span class="annotation">以</span> <span class="comment">编程方式覆盖</span> <span class="annotation">@ActiveProfiles</span> （resolver = OperatingSystemActiveProfilesResolver.class，inheritProfiles = <span class="predefined-constant">false</span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">TransferServiceTest</span> <span class="directive">扩展</span> AbstractIntegrationTest { <span class="comment">// test body</span> }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.bank.service.test</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">OperatingSystemActiveProfilesResolver</span> <span class="directive">实现</span> ActiveProfilesResolver { <span class="annotation">@Override</span> <span class="predefined-type">String</span> <span class="type">[]</span> resolve（ <span class="predefined-type">Class</span> &lt;？&gt; testClass）{ <span class="predefined-type">String</span> profile = ...; <span class="comment">//根据操作系统确定profile的值</span> <span class="keyword">返回</span> <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> {profile}; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-property-sources"><a class="anchor" href="#testcontext-ctx-management-property-sources"></a>使用测试属性源配置上下文</h5>
<div class="paragraph">
<p>Spring 3.1在框架中引入了具有属性源层次结构的环境概念的一流支持。从Spring 4.1开始，您可以使用特定于测试的属性源配置集成测试。与<code>@Configuration</code>类上使用的<code>@PropertySource</code>注释相比，您可以在测试类上声明<code>@TestPropertySource</code>注释，以声明测试属性文件或内联属性的资源位置。这些测试属性源被添加到<code>Environment</code>的<code>PropertySources</code>集合中，用于为注释集成测试加载的<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以将<code>@TestPropertySource</code>与<code>SmartContextLoader</code> SPI的任何实现一起使用，但旧版<code>ContextLoader</code> SPI的实现不支持<code>@TestPropertySource</code> 。</p>
</div>
<div class="paragraph">
<p><code>SmartContextLoader</code>实现通过<code>MergedContextConfiguration</code>的<code>getPropertySourceLocations()</code>和<code>getPropertySourceProperties()</code>方法获得对合并的测试属性源值的访问。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="declaring-test-property-sources"><a class="anchor" href="#declaring-test-property-sources"></a>声明测试属性源</h6>
<div class="paragraph">
<p>您可以使用<code>@TestPropertySource</code>的<code>locations</code>或<code>value</code>属性配置测试属性文件。</p>
</div>
<div class="paragraph">
<p>支持传统和基于XML的属性文件格式 - 例如， <code>"classpath:/com/example/test.properties"</code>或<code>"file:///path/to/file.xml"</code> 。</p>
</div>
<div class="paragraph">
<p>每个路径都被解释为Spring <code>Resource</code> 。普通路径（例如， <code>"test.properties"</code> ）被视为相对于定义测试类的包的类路径资源。以斜杠开头的路径被视为绝对类路径资源（例如： <code>"/org/example/test.xml"</code> example / <code>"/org/example/test.xml"</code> ）。使用指定的资源协议加载引用URL的路径（例如，前缀为<code>classpath:</code> ， <code>file:</code>或<code>http:</code> :)的<code>classpath:</code> 。不允许使用资源位置通配符（例如<code><strong>*/</strong> .properties</code> ）：每个位置必须仅评估一个<code>.properties</code>或<code>.xml</code>资源。</p>
</div>
<div class="paragraph">
<p>以下示例使用测试属性文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestPropertySource</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test.properties</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyIntegrationTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用绝对路径指定属性文件。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@TestPropertySource</code>的<code>properties</code>属性以<code>@TestPropertySource</code>对的形式配置内联属性，如下一个示例所示。所有键值对都作为具有最高优先级的单个测试<code>PropertySource</code>添加到封闭<code>Environment</code>中。</p>
</div>
<div class="paragraph">
<p>键值对支持的语法与为Java属性文件中的条目定义的语法相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>键=值</code></p>
</li>
<li>
<p><code>核心价值</code></p>
</li>
<li>
<p><code>核心价值</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例设置两个内联属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestPropertySource</span> （properties = { <span class="string"><span class="delimiter">“</span> <span class="content">timezone = GMT</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">port：4242</span> <span class="delimiter">”</span></span> }） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyIntegrationTests</span> { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用键值语法的两种变体设置两个属性。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="default-properties-file-detection"><a class="anchor" href="#default-properties-file-detection"></a>默认属性文件检测</h6>
<div class="paragraph">
<p>如果将<code>@TestPropertySource</code>声明为空注释（即，没有<code>locations</code>或<code>properties</code>属性的显式值），则会尝试检测相对于声明注释的类的默认属性文件。例如，如果带注释的测试类是<code>com.example.MyTest</code> ，相应的默认属性文件是<code>classpath:com/example/MyTest.properties</code> 。如果无法检测到默认值，则抛出<code>IllegalStateException</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="precedence"><a class="anchor" href="#precedence"></a>优先权</h6>
<div class="paragraph">
<p>测试属性源的优先级高于从操作系统环境，Java系统属性或应用程序通过使用<code>@PropertySource</code>或以编程方式声明性地添加的属性源的优先级。因此，测试属性源可用于有选择地覆盖系统和应用程序属性源中定义的属性。此外，内联属性的优先级高于从资源位置加载的属性。</p>
</div>
<div class="paragraph">
<p>在下一个示例中， <code>timezone</code>和<code>port</code>属性以及<code>"/test.properties"</code>定义的任何属性<code>"/test.properties"</code>覆盖在系统和应用程序属性源中定义的同名属性。此外，如果<code>"/test.properties"</code>文件定义了<code>timezone</code>和<code>port</code>属性的条目，那么这些条目将被使用<code>properties</code>属性声明的内联属性覆盖。以下示例显示如何在文件和内联中指定属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <span class="annotation">@TestPropertySource</span> （locations = <span class="string"><span class="delimiter">“/</span> <span class="content">test.properties</span> <span class="delimiter">”</span></span> ，properties = { <span class="string"><span class="delimiter">“</span> <span class="content">timezone = GMT</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">port：4242</span> <span class="delimiter">”</span></span> }） <span class="directive">public</span> <span class="type">class</span> <span class="class">MyIntegrationTests</span> { <span class="comment">// class body ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="inheriting-and-overriding-test-property-sources"><a class="anchor" href="#inheriting-and-overriding-test-property-sources"></a>继承和覆盖测试属性源</h6>
<div class="paragraph">
<p><code>@TestPropertySource</code>支持boolean <code>inheritLocations</code>和<code>inheritProperties</code>属性， <code>inheritProperties</code>属性表示是否应继承属性文件的资源位置和超类声明的内联属性。两个标志的默认值均为<code>true</code> 。这意味着测试类继承了任何超类声明的位置和内联属性。具体而言，测试类的位置和内联属性将附加到超类声明的位置和内联属性。因此，子类可以选择扩展位置和内联属性。请注意，稍后出现的属性会影响（即覆盖）先前出现的同名属性。此外，上述优先规则也适用于继承的测试属性源。</p>
</div>
<div class="paragraph">
<p>如果<code>inheritLocations</code>或<code>inheritProperties</code>在属性<code>@TestPropertySource</code>被设置为<code>false</code>分别的位置或内联的属性，用于测试类影子和有效地替换通过超类中定义的构型。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，仅使用<code>base.properties</code>文件作为测试属性源来加载<code>BaseTest</code>的<code>ApplicationContext</code> 。相反，使用<code>base.properties</code>和<code>extended.properties</code>文件作为测试属性源位置来加载<code>ExtendedTest</code>的<code>ApplicationContext</code> 。以下示例显示如何使用<code>properties</code>文件在子类及其超类中定义属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@TestPropertySource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">base.properties</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">BaseTest</span> { <span class="comment">// ...</span>} <span class="annotation">@TestPropertySource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">extended.properties</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ContextConfiguration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExtendedTest</span> <span class="directive">扩展</span> BaseTest { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在下一个示例中，仅使用内联<code>key1</code>属性加载<code>BaseTest</code>的<code>ApplicationContext</code> 。相反，使用内联的<code>key1</code>和<code>key2</code>属性加载<code>ExtendedTest</code>的<code>ApplicationContext</code> 。以下示例显示如何使用内联属性在子类及其超类中定义属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@TestPropertySource</span> （properties = <span class="string"><span class="delimiter">“</span> <span class="content">key1 = value1</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">BaseTest</span> { <span class="comment">// ...</span>} <span class="annotation">@TestPropertySource</span> （properties = <span class="string"><span class="delimiter">“</span> <span class="content">key2 = value2</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">ExtendedTest</span> <span class="directive">extends</span> BaseTest { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-web"><a class="anchor" href="#testcontext-ctx-management-web"></a>加载<code>WebApplicationContext</code></h5>
<div class="paragraph">
<p>Spring 3.2引入了对在集成测试中加载<code>WebApplicationContext</code>支持。要指示TestContext框架加载<code>WebApplicationContext</code>而不是标准<code>ApplicationContext</code> ，您可以使用<code>@WebAppConfiguration</code>注释相应的测试类。</p>
</div>
<div class="paragraph">
<p>测试类上存在<code>@WebAppConfiguration</code>指示TestContext框架（TCF）应为您的集成测试加载<code>WebApplicationContext</code> （WAC）。在后台，TCF确保创建<code>MockServletContext</code>并将其提供给测试的WAC。默认情况下， <code>MockServletContext</code>的基本资源路径设置为<code>src/main/webapp</code> 。这被解释为相对于JVM根目录的路径（通常是项目的路径）。如果您熟悉Maven项目中Web应用程序的目录结构，则您知道<code>src/main/webapp</code>是WAR根目录的默认位置。如果需要覆盖此默认值，则可以提供<code>@WebAppConfiguration</code>批注的备用路径（例如， <code>@WebAppConfiguration("src/test/webapp")</code> ）。如果您希望从类路径而不是文件系统引用基本资源路径，则可以使用Spring的<code>classpath:</code>前缀。</p>
</div>
<div class="paragraph">
<p>请注意，Spring对<code>WebApplicationContext</code>实现的测试支持与其对标准<code>ApplicationContext</code>实现的支持相同。使用<code>WebApplicationContext</code>进行测试时，可以使用<code>@ContextConfiguration</code>自由声明XML配置文件，Groovy脚本或<code>@Configuration</code>类。您也可以自由使用任何其他测试注释，如<code>@ActiveProfiles</code> ， <code>@TestExecutionListeners</code> ， <code>@Sql</code> ， <code>@Rollback</code> ，等等。</p>
</div>
<div class="paragraph">
<p>本节中的其余示例显示了用于加载<code>WebApplicationContext</code>一些配置选项。以下示例显示了TestContext框架对约定优于配置的支持：</p>
</div>
<div class="exampleblock">
<div class="title">例1。约定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//默认为“file：src / main / webapp”</span> <span class="annotation">@WebAppConfiguration</span> <span class="comment">//在同一个包</span> <span class="comment">//中</span> <span class="comment">检测“WacTests-context.xml”</span> <span class="comment">//静态嵌套@Configuration类</span> <span class="annotation">@ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">WacTests</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用<code>@WebAppConfiguration</code>注释测试类而未指定资源基路径，则资源路径有效默认为<code>file:src/main/webapp</code> 。类似地，如果声明<code>@ContextConfiguration</code>而未指定资源<code>locations</code> ，带注释的<code>classes</code>或上下文<code>initializers</code> ，Spring会尝试使用约定来检测配置是否存在（即<code>WacTests-context.xml</code>与<code>WacTests</code>类相同的包或静态）嵌套的<code>@Configuration</code>类）。</p>
</div>
<div class="paragraph">
<p>下面的例子演示了如何明确声明与资源基本路径<code>@WebAppConfiguration</code>并用XML资源位置<code>@ContextConfiguration</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">例2。默认资源语义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//文件系统资源</span> <span class="annotation">@WebAppConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">webapp</span> <span class="delimiter">”</span></span> ） <span class="comment">// classpath资源</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">spring/test-servlet-config.xml</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">WacTests</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里要注意的重要一点是具有这两个注释的路径的不同语义。默认情况下， <code>@WebAppConfiguration</code>资源路径是基于文件系统的，而<code>@ContextConfiguration</code>资源位置是基于类路径的。</p>
</div>
<div class="paragraph">
<p>以下示例显示我们可以通过指定Spring资源前缀来覆盖两个注释的默认资源语义：</p>
</div>
<div class="exampleblock">
<div class="title">例3。显式资源语义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">// classpath资源</span> <span class="annotation">@WebAppConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：test-web-resources</span> <span class="delimiter">”</span></span> ） <span class="comment">//文件系统资源</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">file：src / main / webapp / WEB-INF / servlet-config.xml</span> <span class="delimiter">“</span></span> ） <span class="directive">公共</span> <span class="type">课</span> <span class="class">WacTests</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将此示例中的注释与前一个示例进行对比。</p>
</div>
<div class="openblock">
<div class="title"><a id="testcontext-ctx-management-web-mocks"></a>使用Web Mocks</div>
<div class="content">
<div class="paragraph">
<p>为了提供全面的Web测试支持，Spring 3.2引入了默认启用的<code>ServletTestExecutionListener</code> 。当对一个测试<code>WebApplicationContext</code> ，这<a href="#testcontext-key-abstractions"><code>TestExecutionListener</code></a>使用了Spring Web的设置默认的线程局部状态<code>RequestContextHolder</code>各测试方法之前，并创建一个<code>MockHttpServletRequest</code> ，一个<code>MockHttpServletResponse</code>和<code>ServletWebRequest</code>基于与配置的基本资源路径上<code>@WebAppConfiguration</code> 。<code>ServletTestExecutionListener</code>还确保可以将<code>MockHttpServletResponse</code>和<code>ServletWebRequest</code>注入到测试实例中，并且一旦测试完成，它就会清除线程本地状态。</p>
</div>
<div class="paragraph">
<p>一旦为测试加载了<code>WebApplicationContext</code> ，您可能会发现需要与Web模拟进行交互 - 例如，设置测试夹具或在调用Web组件后执行断言。以下示例显示可以将哪些模拟自动装配到测试实例中。请注意， <code>WebApplicationContext</code>和<code>MockServletContext</code>都在测试套件中缓存，而其他<code>ServletTestExecutionListener</code>由<code>ServletTestExecutionListener</code>按照每种测试方法进行管理。</p>
</div>
<div class="exampleblock">
<div class="title">例4。注射嘲笑</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebAppConfiguration</span> <span class="annotation">@ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">WacTests</span> { <span class="annotation">@Autowired</span> WebApplicationContext wac; <span class="comment">//缓存</span> <span class="annotation">@Autowired</span> MockServletContext servletContext; <span class="comment">//缓存</span> <span class="annotation">@Autowired</span> MockHttpSession会话; <span class="annotation">@Autowired</span> MockHttpServletRequest请求; <span class="annotation">@Autowired</span> MockHttpServletResponse响应; <span class="annotation">@Autowired</span> ServletWebRequest webRequest; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-caching"><a class="anchor" href="#testcontext-ctx-management-caching"></a>上下文缓存</h5>
<div class="paragraph">
<p>一旦TestContext框架为测试加载<code>ApplicationContext</code> （或<code>WebApplicationContext</code> ），该上下文就会被缓存并重用于在同一测试套件中声明相同唯一上下文配置的所有后续测试。要了解缓存的工作原理，了解“独特”和“测试套件”的含义非常重要。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code>可以通过用于加载它的配置参数的组合来唯一标识。因此，配置参数的唯一组合用于生成高速缓存上下文的密钥。TestContext框架使用以下配置参数来构建上下文缓存键：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>locations</code> （来自<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>classes</code> （来自<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>contextInitializerClasses</code> （来自<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>contextCustomizers</code> （来自<code>ContextCustomizerFactory</code> ）</p>
</li>
<li>
<p><code>contextLoader</code> （来自<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>parent</code> （来自<code>@ContextHierarchy</code> ）</p>
</li>
<li>
<p><code>activeProfiles</code> （从<code>@ActiveProfiles</code> ）</p>
</li>
<li>
<p><code>propertySourceLocations</code> （来自<code>@TestPropertySource</code> ）</p>
</li>
<li>
<p><code>propertySourceProperties</code> （来自<code>@TestPropertySource</code> ）</p>
</li>
<li>
<p><code>resourceBasePath</code> （来自<code>@WebAppConfiguration</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，如果<code>TestClassA</code>为<code>@ContextConfiguration</code>的<code>locations</code> （或<code>value</code> ）属性指定<code>{"app-config.xml", "test-config.xml"}</code> ，则TestContext框架会加载相应的<code>ApplicationContext</code>并将其存储在<code>static</code>上下文缓存中在仅基于这些位置的密钥下。因此，如果<code>TestClassB</code>还为其位置定义<code>{"app-config.xml", "test-config.xml"}</code> （通过继承显式或隐式）但未定义<code>@WebAppConfiguration</code> ，则不同的<code>ContextLoader</code> ，不同的活动配置文件，不同上下文初始化器，不同的测试属性源或不同的父上下文，然后两个测试类共享相同的<code>ApplicationContext</code> 。这意味着加载应用程序上下文的设置成本仅产生一次（每个测试套件），并且后续测试执行要快得多。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">测试套件和分叉流程</div>
<div class="paragraph">
<p>Spring TestContext框架将应用程序上下文存储在静态缓存中。这意味着上下文实际上存储在<code>static</code>变量中。换句话说，如果测试在单独的进程中执行，则在每次测试执行之间清除静态高速缓存，这有效地禁用了高速缓存机制。</p>
</div>
<div class="paragraph">
<p>要从缓存机制中受益，所有测试必须在同一进程或测试套件中运行。这可以通过在IDE中作为一个组执行所有测试来实现。类似地，当使用诸如Ant，Maven或Gradle之类的构建框架执行测试时，确保构建框架不在测试之间进行分配是很重要的。例如，如果<a href="http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode"><code>forkMode</code></a>的神火的Maven插件被设置为<code>always</code>或<code>pertest</code> ，TestContext框架不能缓存测试类之间的应用环境，以及构建过程中运行显著更慢的结果。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从Spring Framework 4.3开始，上下文缓存的大小受限于默认的最大大小32。每当达到最大大小时，最近最少使用（LRU）驱逐策略用于驱逐和关闭过时的上下文。您可以通过设置名为<code>spring.test.context.cache.maxSize</code>的JVM系统属性，从命令行或构建脚本配置最大大小。或者，您可以使用<code>SpringProperties</code> API以编程方式设置相同的属性。</p>
</div>
<div class="paragraph">
<p>由于在给定的测试套件中加载大量应用程序上下文会导致套件执行不必要的长时间，因此确切地知道已加载和缓存了多少上下文通常是有益的。要查看基础上下文缓存的统计信息，可以将<code>org.springframework.test.context.cache</code>日志记录类别的日志级别设置为<code>DEBUG</code> 。</p>
</div>
<div class="paragraph">
<p>在不太可能的情况下，测试会破坏应用程序上下文并需要重新加载（例如，通过修改bean定义或应用程序对象的状态），您可以使用<code>@DirtiesContext</code>注释测试类或测试方法（请参阅<code>@DirtiesContext</code>的讨论） <a href="#integration-testing-annotations-spring">Spring测试注释中的</a> <code>@DirtiesContext</code> ）。这指示Spring在运行下一个测试之前从缓存中删除上下文并重建应用程序上下文。请注意，对于<code>@DirtiesContext</code>注释的支持由<code>DirtiesContextBeforeModesTestExecutionListener</code>和<code>DirtiesContextTestExecutionListener</code> ，默认情况下已启用。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-ctx-hierarchies"><a class="anchor" href="#testcontext-ctx-management-ctx-hierarchies"></a>上下文层次结构</h5>
<div class="paragraph">
<p>编写依赖于加载的Spring <code>ApplicationContext</code>集成测试时，通常可以针对单个上下文进行测试。但是，有时候对<code>ApplicationContext</code>实例的层次结构进行测试是有益的，甚至是必要的。例如，如果您正在开发Spring MVC Web应用程序，则通常会有Spring的<code>ContextLoaderListener</code>加载的根<code>WebApplicationContext</code>和Spring的<code>DispatcherServlet</code>加载的子<code>WebApplicationContext</code> 。这将生成父子上下文层次结构，其中共享组件和基础结构配置在根上下文中声明，并由特定于Web的组件在子上下文中使用。可以在Spring Batch应用程序中找到另一个用例，其中您经常有一个父上下文，它提供共享批处理基础结构的配置，以及一个用于配置特定批处理作业的子上下文。</p>
</div>
<div class="paragraph">
<p>从Spring Framework 3.2.2开始，您可以通过在单个测试类或测试类层次结构中使用<code>@ContextHierarchy</code>注释声明上下文配置来编写使用上下文层次结构的集成测试。如果在测试类层次结构中的多个类上声明了上下文层次结构，则还可以合并或覆盖上下文层次结构中特定的命名级别的上下文配置。合并层次结构中给定级别的配置时，配置资源类型（即XML配置文件或带注释的类）必须一致。否则，在使用不同资源类型配置的上下文层次结构中具有不同级别是完全可以接受的。</p>
</div>
<div class="paragraph">
<p>本节中剩余的基于JUnit 4的示例显示了需要使用上下文层次结构的集成测试的常见配置方案。</p>
</div>
<div class="openblock">
<div class="title">带上下文层次结构的单个测试类</div>
<div class="content">
<div class="paragraph">
<p><code>ControllerIntegrationTests</code>表示Spring MVC Web应用程序的典型集成测试场景，它声明了一个由两个级别组成的上下文层次结构，一个用于根<code>WebApplicationContext</code> （使用<code>TestAppConfig</code> <code>@Configuration</code>类加载），另一个用于调度程序servlet <code>WebApplicationContext</code> （通过使用加载） <code>WebConfig</code> <code>@Configuration</code>类）。自动装配到测试实例中的<code>WebApplicationContext</code>是子上下文的<code>WebApplicationContext</code> （即层次结构中的最低上下文）。以下清单显示了此配置方案：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@WebAppConfiguration</span> <span class="annotation">@ContextHierarchy</span> （{ <span class="annotation">@ ContextConfiguration</span> （classes = TestAppConfig.class）， <span class="annotation">@ ContextConfiguration</span> （classes = WebConfig.class）}） <span class="directive">public</span> <span class="type">class</span> <span class="class">ControllerIntegrationTests</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> WebApplicationContext wac; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">具有隐式父上下文的类层次结构</div>
<div class="content">
<div class="paragraph">
<p>此示例中的测试类定义测试类层次结构中的上下文层次结构。<code>AbstractWebTests</code>在Spring驱动的Web应用程序中声明根<code>WebApplicationContext</code>的配置。但请注意， <code>AbstractWebTests</code>不声明<code>@ContextHierarchy</code> 。因此， <code>AbstractWebTests</code>子类可以选择参与上下文层次结构或遵循<code>@ContextConfiguration</code>的标准语义。<code>SoapWebServiceTests</code>和<code>RestWebServiceTests</code>都使用<code>@ContextHierarchy</code>扩展<code>AbstractWebTests</code>并定义上下文层次结构。结果是加载了三个应用程序上下文（每个<code>@ContextConfiguration</code>声明一个），并且基于<code>AbstractWebTests</code>的配置加载的应用程序上下文被设置为为具体子类加载的每个上下文的父上下文。以下清单显示了此配置方案：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@WebAppConfiguration</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">file：src / main / webapp / WEB-INF / applicationContext.xml</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractWebTests</span> {} <span class="annotation">@ContextHierarchy</span> （ <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ spring / soap-ws- config.xml</span> <span class="delimiter">“</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">SoapWebServiceTests</span> <span class="directive">扩展</span> AbstractWebTests {} <span class="annotation">@ContextHierarchy</span> （ <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">”/</span> <span class="content">spring/rest-ws-config.xml</span> <span class="delimiter">“</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">RestWebServiceTests</span> <span class="directive">扩展</span> AbstractWebTests {}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">具有合并的上下文层次结构配置的类层次</div>
<div class="content">
<div class="paragraph">
<p>此示例中的类显示了命名层次结构级别的使用，以便合并上下文层次结构中特定级别的配置。<code>BaseTests</code>在层次结构中定义了两个级别， <code>parent</code>和<code>child</code> 。<code>ExtendedTests</code>扩展<code>BaseTests</code>并指示Spring TestContext Framework合并<code>child</code>层次结构级别的上下文配置，方法是确保<code>@ContextConfiguration</code>中<code>name</code>属性中声明的<code>name</code>都是<code>child</code> 。结果是加载了三个应用程序上下文：一个用于<code>/app-config.xml</code> ，一个用于<code>/user-config.xml</code> ，另一个用于<code>{"/user-config.xml", "/order-config.xml"}</code> 。与前面的示例一样，从<code>/app-config.xml</code>加载的应用程序上下文被设置为从<code>/user-config.xml</code>和<code>{"/user-config.xml", "/order-config.xml"}</code>加载的上下文的父上下文<code>{"/user-config.xml", "/order-config.xml"}</code> 。以下清单显示了此配置方案：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextHierarchy</span> （{ <span class="annotation">@ContextConfiguration</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">parent</span> <span class="delimiter">”</span></span> ，locations = <span class="string"><span class="delimiter">“/</span> <span class="content">app-config.xml</span> <span class="delimiter">”</span></span> ）， <span class="annotation">@ ContextConfiguration</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">child</span> <span class="delimiter">”</span></span> ，locations = <span class="string"><span class="delimiter">“/</span> <span class="content">user-config.xml</span> <span class="delimiter">“</span></span> ）}） <span class="directive">public</span> <span class="type">class</span> <span class="class">BaseTests</span> {} <span class="annotation">@ContextHierarchy</span> （ <span class="annotation">@ContextConfiguration</span> （name = <span class="string"><span class="delimiter">”</span> <span class="content">child</span> <span class="delimiter">“</span></span> ，locations = <span class="string"><span class="delimiter">”/</span> <span class="content">order-config.xml</span> <span class="delimiter">“</span></span> ）） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExtendedTests</span> <span class="directive">extends</span> BaseTests {}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">具有重写的上下文层次结构配置的类层次结构</div>
<div class="content">
<div class="paragraph">
<p>相较于之前的例子，这个例子演示了如何通过设置来覆盖在上下文结构给定名为级别的配置<code>inheritLocations</code>旗<code>@ContextConfiguration</code>给<code>false</code> 。因此， <code>ExtendedTests</code>的应用程序上下文仅从<code>/test-user-config.xml</code>加载， <code>/test-user-config.xml</code>其父级设置为从<code>/app-config.xml</code>加载的上下文。以下清单显示了此配置方案：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextHierarchy</span> （{ <span class="annotation">@ContextConfiguration</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">parent</span> <span class="delimiter">”</span></span> ，locations = <span class="string"><span class="delimiter">“/</span> <span class="content">app-config.xml</span> <span class="delimiter">”</span></span> ）， <span class="annotation">@ ContextConfiguration</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">child</span> <span class="delimiter">”</span></span> ，locations = <span class="string"><span class="delimiter">“/</span> <span class="content">user-config.xml</span> <span class="delimiter">“</span></span> ）}） <span class="directive">public</span> <span class="type">class</span> <span class="class">BaseTests</span> {} <span class="annotation">@ContextHierarchy</span> （ <span class="annotation">@ContextConfiguration</span> （name = <span class="string"><span class="delimiter">”</span> <span class="content">child</span> <span class="delimiter">“</span></span> ，locations = <span class="string"><span class="delimiter">”/</span> <span class="content">test-user-config.xml</span> <span class="delimiter">“</span></span> ，inheritLocations = <span class="predefined-constant">false</span> ）） <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExtendedTests</span> <span class="directive">扩展</span> BaseTests {}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">在上下文层次结构中消除上下文</div>如果在其上下文配置为上下文层次结构的一部分的测试中使用<code>@DirtiesContext</code> ，则可以使用<code>hierarchyMode</code>标志来控制如何清除上下文高速缓存。有关详细信息，请参阅的讨论<code>@DirtiesContext</code>在<a href="#integration-testing-annotations-spring">弹簧试验注解</a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"><code>@DirtiesContext</code>的Javadoc</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-fixture-di"><a class="anchor" href="#testcontext-fixture-di"></a> 3.5.5。测试夹具的依赖注入</h4>
<div class="paragraph">
<p>当您使用<code>DependencyInjectionTestExecutionListener</code> （默认配置）时，测试实例的依赖项将从您使用<code>@ContextConfiguration</code>配置的应用程序上下文中的bean中注入。您可以使用setter injection，field injection或两者，具体取决于您选择的注释以及是否将它们放在setter方法或字段上。为了与Spring 2.5和3.0中引入的注释支持保持一致，您可以使用Spring的<code>@Autowired</code>注释或JSR 330中的<code>@Inject</code>注释。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">TestContext框架没有检测实例化测试实例的方式。因此，对于构造函数使用<code>@Autowired</code>或<code>@Inject</code>对测试类没有影响。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>因为<code>@Autowired</code>用于<a href="core.html#beans-factory-autowire">按类型</a>执行<a href="core.html#beans-factory-autowire">自动装配</a> ，如果您有多个相同类型的bean定义，则不能依赖此方法来处理这些特定的bean。在这种情况下，您可以将<code>@Autowired</code>与<code>@Qualifier</code>结合使用。从Spring 3.0开始，您还可以选择将<code>@Inject</code>与<code>@Named</code>结合使用。或者，如果您的测试类可以访问其<code>ApplicationContext</code> ，则可以使用（例如）对<code>applicationContext.getBean("titleRepository")</code>的调用来执行显式查找。</p>
</div>
<div class="paragraph">
<p>如果您不希望将依赖项注入应用于测试实例，请不要使用<code>@Autowired</code>或<code>@Inject</code>注释字段或setter方法。或者，您可以通过使用<code>@TestExecutionListeners</code>显式配置类并从侦听器列表中省略<code>DependencyInjectionTestExecutionListener.class</code>来完全禁用依赖项注入。</p>
</div>
<div class="paragraph">
<p>考虑一下测试<code>HibernateTitleRepository</code>类的场景，如<a href="#integration-testing-goals">目标</a>部分所述。接下来的两个代码清单演示了在字段和setter方法中使用<code>@Autowired</code> 。在所有示例代码列表之后呈现应用程序上下文配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下代码清单中的依赖项注入行为并非特定于JUnit 4。相同的DI技术可以与任何测试框架结合使用。</p>
</div>
<div class="paragraph">
<p>以下示例调用静态断言方法，例如<code>assertNotNull()</code> ，但不使用<code>Assert</code>预先调用。在这种情况下，假设通过示例中未显示的<code>import static</code>声明正确导入了该方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第一个代码清单显示了一个基于JUnit 4的测试类实现，它使用<code>@Autowired</code>进行字段注入：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//指定要为此测试夹具加载的Spring配置</span> <strong><span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">repository-config.xml</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> <span class="type">class</span> <span class="class">HibernateTitleRepositoryTests</span> { <span class="comment">//此实例将依赖于</span> <strong><span class="annotation">@Autowired</span></strong> <span class="directive">私有</span> HibernateTitleRepository titleRepository注入; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> findById（）{Title title = titleRepository.findById（ <span class="keyword">new</span> <span class="predefined-type">Long</span> （ <span class="integer">10</span> ））; assertNotNull（标题）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以将类配置为使用<code>@Autowired</code>进行setter注入，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="comment">//指定要为此测试夹具加载的Spring配置</span> <strong><span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">repository-config.xml</span> <span class="delimiter">”</span></span> ）</strong> <span class="directive">public</span> <span class="type">class</span> <span class="class">HibernateTitleRepositoryTests</span> { <span class="comment">//此实例将由类型</span> <span class="directive">private</span> HibernateTitleRepository titleRepository <span class="comment">注入依赖</span>项; <strong><span class="annotation">@Autowired</span></strong> <span class="directive">public</span> <span class="type">void</span> setTitleRepository（HibernateTitleRepository titleRepository）{ <span class="local-variable">this</span> .titleRepository = titleRepository; } <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> findById（）{Title title = titleRepository.findById（ <span class="keyword">new</span> <span class="predefined-type">Long</span> （ <span class="integer">10</span> ））; assertNotNull（标题）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码清单使用<code>@ContextConfiguration</code>批注（即<code>repository-config.xml</code> ）引用的相同XML上下文文件。以下显示了此配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 此bean将被注入HibernateTitleRepositoryTests类 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content"><strong>titleRepository</strong></span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content"><strong>com.foo.repository.hibernate。HibernateTitleRepository</strong></span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.orm.hibernate5。LocalSessionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 为了简洁而省略了配置 - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您从Spring提供的测试基类扩展到其自身的一个setter方法上使用<code>@Autowired</code> ，则可能在应用程序上下文中定义了多个受影响类型的bean（例如，多个<code>DataSource</code> bean）。在这种情况下，您可以覆盖setter方法并使用<code>@Qualifier</code>批注指示特定的目标bean，如下所示（但请确保也委托给超类中的重写方法）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// ...</span>

    <span class="annotation">@Autowired</span> <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> setDataSource（ <strong><span class="annotation">@Qualifier</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> ）</strong> <span class="predefined-type">DataSource</span> dataSource）{ <strong><span class="local-variable">super</span></strong> .setDataSource（dataSource）; } <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>指定的限定符值指示要注入的特定<code>DataSource</code> bean，将类型匹配集缩小到特定bean。它的值与相应<code>&lt;bean&gt;</code>定义中的<code>&lt;qualifier&gt;</code>声明匹配。bean名称用作回退限定符值，因此您还可以有效地按名称指向特定的bean（如前所示，假设<code>myDataSource</code>是bean <code>id</code> ）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-web-scoped-beans"><a class="anchor" href="#testcontext-web-scoped-beans"></a> 3.5.6。测试请求和会话范围的Bean</h4>
<div class="paragraph">
<p>从早年开始，Spring就一直支持<a href="core.html#beans-factory-scopes-other">Request和session-scoped bean</a> 。从Spring 3.2开始，您可以按照以下步骤测试请求范围和会话范围的bean：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过使用<code>@WebAppConfiguration</code>注释测试类，确保为测试加载了<code>WebApplicationContext</code> 。</p>
</li>
<li>
<p>将模拟请求或会话注入测试实例并根据需要准备测试夹具。</p>
</li>
<li>
<p>调用从配置的<code>WebApplicationContext</code>检索的Web组件（具有依赖项注入）。</p>
</li>
<li>
<p>对模拟执行断言。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一个代码段显示了登录用例的XML配置。请注意， <code>userService</code> bean依赖于请求范围的<code>loginAction</code> bean。另外， <code>LoginAction</code>通过使用实例化<a href="core.html#expressions">使用SpEL表达式</a>用于检索从当前的HTTP请求的用户名和密码。在我们的测试中，我们希望通过TestContext框架管理的模拟配置这些请求参数。以下清单显示了此用例的配置：</p>
</div>
<div class="exampleblock">
<div class="title">例5。请求范围的bean配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。SimpleUserService</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：loginAction-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">loginAction</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">loginAction</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.example。LoginAction</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：username</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{request.getParameter（'user'）}</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：password</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{request.getParameter（'pswd'）}</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">request</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：scoped-proxy</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<code>RequestScopedBeanTests</code> ，我们将<code>UserService</code> （即测试中的主题）和<code>MockHttpServletRequest</code>注入我们的测试实例。在我们的<code>requestScope()</code>测试方法中，我们通过在提供的<code>MockHttpServletRequest</code>设置请求参数来设置我们的测试夹具。当在我们的<code>userService</code>上调用<code>loginUser()</code>方法时，我们可以确保用户服务可以访问当前<code>MockHttpServletRequest</code>的请求范围的<code>loginAction</code> （也就是我们刚刚设置参数的那个）。然后，我们可以根据用户名和密码的已知输入对结果执行断言。以下清单显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">例6。请求范围的bean测试</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> <span class="annotation">@WebAppConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">RequestScopedBeanTests</span> { <span class="annotation">@Autowired</span> UserService userService; <span class="annotation">@Autowired</span> MockHttpServletRequest请求; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> requestScope（）{request.setParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">enigma</span> <span class="delimiter">”</span></span> ）; request.setParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">pswd</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">$ pr！ng</span> <span class="delimiter">“</span></span> ）; LoginResults results = userService.loginUser（）; <span class="comment">//断言结果</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下代码片段类似于我们之前针对请求范围的bean看到的代码片段。但是，这次， <code>userService</code> bean依赖于会话范围的<code>userPreferences</code> bean。请注意， <code>UserPreferences</code> bean是使用SpEL表达式实例化的，该表达式从当前HTTP会话中检索主题。在我们的测试中，我们需要在T​​estContext框架管理的模拟会话中配置主题。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">例7。会话范围的bean配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。SimpleUserService</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：userPreferences-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.example。UserPreferences</span> <span class="delimiter">“</span></span> <span class="attribute-name">c：theme</span> = <span class="string"><span class="delimiter">”</span> <span class="content">＃{session.getAttribute（'theme'）}</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">session</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：scoped-proxy</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<code>SessionScopedBeanTests</code> ，我们将<code>UserService</code>和<code>MockHttpSession</code>注入到我们的测试实例中。在我们的<code>sessionScope()</code>测试方法中，我们通过在提供的<code>MockHttpSession</code>设置预期的<code>theme</code>属性来设置我们的测试夹具。当我们在<code>userService</code>上调用<code>processUserPreferences()</code>方法时，我们可以确保用户服务可以访问当前<code>MockHttpSession</code>的会话范围的<code>userPreferences</code> ，并且我们可以根据配置的主题对结果执行断言。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">例8。会话范围的bean测试</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> <span class="annotation">@WebAppConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedBeanTests</span> { <span class="annotation">@Autowired</span> UserService userService; <span class="annotation">@Autowired</span> MockHttpSession会话; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> sessionScope（） <span class="directive">抛出</span> <span class="exception">异常</span> {session.setAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">theme</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">blue</span> <span class="delimiter">”</span></span> ）;结果结果= userService.processUserPreferences（）; <span class="comment">//断言结果</span> }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tx"><a class="anchor" href="#testcontext-tx"></a> 3.5.7。交易管理</h4>
<div class="paragraph">
<p>在TestContext框架中，事务由<code>TransactionalTestExecutionListener</code>管理，即使您未在测试类上显式声明<code>@TestExecutionListeners</code> ，也会默认配置该<code>TransactionalTestExecutionListener</code> 。但是，要启用对事务的支持，必须在<code>ApplicationContext</code>中配置一个加载了<code>@ContextConfiguration</code>语义的<code>PlatformTransactionManager</code> bean（稍后会提供更多详细信息）。此外，您必须在类或方法级别为测试声明Spring的<code>@Transactional</code>注释。</p>
</div>
<div class="sect4">
<h5 id="testcontext-tx-test-managed-transactions"><a class="anchor" href="#testcontext-tx-test-managed-transactions"></a>测试管理的事务</h5>
<div class="paragraph">
<p>测试管理的事务是通过使用<code>TransactionalTestExecutionListener</code>编程方式管理的<code>TransactionalTestExecutionListener</code>或使用<code>TestTransaction</code>编程方式管理的<code>TransactionalTestExecutionListener</code> （稍后描述）。您不应将此类事务与Spring管理的事务（在为测试加载的<code>ApplicationContext</code>由Spring直接管理的事务）或应用程序管理的事务（在测试调用的应用程序代码中以编程方式管理的事务）混淆。Spring管理和应用程序管理的事务通常参与测试管理的事务。但是，如果Spring管理的事务或应用程序管理的事务配置了除<code>REQUIRED</code>或<code>SUPPORTS</code>之外的任何传播类型，则应谨慎使用（有关详细信息，请参阅有关<a href="data-access.html#tx-propagation">事务传播</a>的讨论）。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-enabling-transactions"><a class="anchor" href="#testcontext-tx-enabling-transactions"></a>启用和禁用事务</h5>
<div class="paragraph">
<p>使用<code>@Transactional</code>注释测试方法会导致测试在事务中运行，默认情况下，该事务在测试完成后自动回滚。如果使用<code>@Transactional</code>注释测试类，则该类层次结构中的每个测试方法都在事务中运行。未使用<code>@Transactional</code>注释的测试方法（在类或方法级别）不在事务中运行。此外，使用<code>@Transactional</code>注释但<code>propagation</code>类型设置为<code>NOT_SUPPORTED</code>的测试不会在事务中运行。</p>
</div>
<div class="paragraph">
<p>请注意， <a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>和<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>已预先配置为类级别的事务支持。</p>
</div>
<div class="paragraph">
<p>以下示例演示了为基于Hibernate的<code>UserRepository</code>编写集成测试的常见方案：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> （classes = TestConfig.class） <span class="annotation">@Transactional</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">HibernateUserRepositoryTests</span> { <span class="annotation">@Autowired</span> HibernateUserRepository repository; <span class="annotation">@Autowired</span> SessionFactory sessionFactory; JdbcTemplate jdbcTemplate; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; } <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> createUser（）{ <span class="comment">//跟踪测试数据库中的初始状态：</span> <span class="directive">final</span> <span class="type">int</span> count = countRowsInTable（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ）;用户user = <span class="keyword">新</span>用户（...）; repository.save（用户）; <span class="comment">//需要手动刷新以避免测试</span> sessionFactory.getCurrentSession（）中的<span class="comment">误报</span> .flush（）; assertNumUsers（count + <span class="integer">1</span> ）; <span class="directive">protected</span> <span class="type">int</span> countRowsInTable（ <span class="predefined-type">String</span> tableName）{ <span class="keyword">return</span> JdbcTestUtils.countRowsInTable（ <span class="local-variable">this</span> .jdbcTemplate，tableName）; } <span class="directive">protected</span> <span class="type">void</span> assertNumUsers（ <span class="type">int</span> expected）{assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">[user] table中的行数。</span> <span class="delimiter">”</span></span> ，expected，countRowsInTable（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如<a href="#testcontext-tx-rollback-and-commit-behavior">事务回滚和提交行为中所述</a> ，在<code>createUser()</code>方法运行后无需清理数据库，因为对<code>TransactionalTestExecutionListener</code>自动回滚对数据库所做的任何更改。有关<a href="#testing-examples-petclinic">其他示例</a> ，请参阅<a href="#testing-examples-petclinic">PetClinic</a>示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-rollback-and-commit-behavior"><a class="anchor" href="#testcontext-tx-rollback-and-commit-behavior"></a>事务回滚和提交行为</h5>
<div class="paragraph">
<p>默认情况下，测试完成后将自动回滚测试事务;但是，可以通过<code>@Commit</code>和<code>@Rollback</code>注释以声明方式配置事务提交和回滚行为。有关更多详细信息，请参阅<a href="#integration-testing-annotations">注释支持</a>部分中的相应条目。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-programmatic-tx-mgt"><a class="anchor" href="#testcontext-tx-programmatic-tx-mgt"></a>程序化交易管理</h5>
<div class="paragraph">
<p>从Spring Framework 4.1开始，您可以使用<code>TestTransaction</code>的静态方法以编程方式与测试管理的事务进行<code>TestTransaction</code> 。例如，您可以在测试方法中，在方法之前，在方法之后使用<code>TestTransaction</code>来启动或结束当前的测试管理事务，或者为回滚或提交配置当前测试管理的事务。每当启用<code>TransactionalTestExecutionListener</code>时，都会自动提供对<code>TestTransaction</code>支持。</p>
</div>
<div class="paragraph">
<p>以下示例演示了<code>TestTransaction</code>一些功能（有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html">Javadoc for <code>TestTransaction</code></a> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> （classes = TestConfig.class） <span class="directive">public</span> <span class="type">class</span> <span class="class">ProgrammaticTransactionManagementTests</span> <span class="directive">extends</span> AbstractTransactionalJUnit4SpringContextTests { <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> transactionalTest（）{ <span class="comment">//在测试数据库中断言初始状态：</span> assertNumUsers（ <span class="integer">2</span> ）; deleteFromTables（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ）; <span class="comment">//将提交对数据库的更改！</span>TestTransaction.flagForCommit（）; TestTransaction.end（）; assertFalse（TestTransaction.isActive（））; assertNumUsers（ <span class="integer">0</span> ）; TestTransaction.start（）; <span class="comment">//对数据库执行其他操作，</span> <span class="comment">//将在测试完成后自动回滚...</span>} <span class="directive">protected</span> <span class="type">void</span> assertNumUsers（ <span class="type">int</span> expected）{assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">[user] table中的行数。</span> <span class="delimiter">”</span></span> ，expected，countRowsInTable（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-before-and-after-tx"><a class="anchor" href="#testcontext-tx-before-and-after-tx"></a>在交易之外运行代码</h5>
<div class="paragraph">
<p>有时，您可能需要在事务测试方法之前或之后但在事务上下文之外执行某些代码 - 例如，在运行测试之前验证初始数据库状态或在测试运行后验证预期的事务提交行为（如果test配置为提交事务）。
<code>TransactionalTestExecutionListener</code>支持<code>@BeforeTransaction</code>和<code>@AfterTransaction</code>注释。您可以使用其中一个注释在测试类或测试接口中的任何<code>void</code> default方法中注释任何<code>void</code>方法，并且<code>TransactionalTestExecutionListener</code>可确保您的before transaction方法或事务方法在适当的时间运行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">任何before方法（例如使用JUnit Jupiter的<code>@BeforeEach</code>注释的<code>@BeforeEach</code> ）和任何after方法（例如使用JUnit Jupiter的<code>@AfterEach</code>注释的<code>@AfterEach</code> ）都在事务中运行。此外，对于未配置为在事务中运行的测试方法，不会运行使用<code>@BeforeTransaction</code>或<code>@AfterTransaction</code>注释的方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-mgr-config"><a class="anchor" href="#testcontext-tx-mgr-config"></a>配置事务管理器</h5>
<div class="paragraph">
<p><code>TransactionalTestExecutionListener</code>期望在Spring <code>ApplicationContext</code>定义<code>PlatformTransactionManager</code> bean以进行测试。如果测试的<code>ApplicationContext</code>有多个<code>PlatformTransactionManager</code>实例，则可以使用<code>@Transactional("myTxMgr")</code>或<code>@Transactional(transactionManager = "myTxMgr")</code>声明限定符，或者可以通过<code>@Configuration</code>类实现<code>TransactionManagementConfigurer</code> 。有关用于在测试的<code>ApplicationContext</code>查找事务管理器的算法的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager">Javadoc for <code>TestContextTransactionUtils.retrieveTransactionManager()</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-annotation-demo"><a class="anchor" href="#testcontext-tx-annotation-demo"></a>演示所有与交易相关的注释</h5>
<div class="paragraph">
<p>以下基于JUnit 4的示例显示了一个虚构的集成测试场景，该场景突出显示了所有与事务相关的注释。该示例不是为了演示最佳实践，而是为了演示如何使用这些注释。有关更多信息和配置示例，请参阅<a href="#integration-testing-annotations">注释支持</a>部分。<a href="#testcontext-executing-sql-declaratively-tx"><code>@Sql</code>事务管理</a>包含一个使用<code>@Sql</code>进行声明性SQL脚本执行并具有默认事务回滚语义的附加示例。以下示例以粗体显示相关注释：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> <strong><span class="annotation">@Transactional</span> （transactionManager = <span class="string"><span class="delimiter">“</span> <span class="content">txMgr</span> <span class="delimiter">”</span></span> ）</strong> <strong><span class="annotation">@Commit</span></strong> <span class="directive">public</span> <span class="type">class</span> <span class="class">FictitiousTransactionalTest</span> { <strong><span class="annotation">@BeforeTransaction</span></strong> <span class="type">void</span> verifyInitialDatabaseState（）{ <span class="comment">//在事务启动之前验证初始状态的逻辑</span> } <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setUpTestDataWithinTransaction （）{ <span class="comment">//在事务中设置测试数据</span> } <span class="annotation">@Test</span> <span class="comment">//覆盖类级别@Commit设置</span> <strong><span class="annotation">@Rollback</span></strong> <span class="directive">public</span> <span class="type">void</span> modifyDatabaseWithinTransaction（）{ <span class="comment">//使用测试数据的逻辑并修改数据库状态</span> } <span class="annotation">@After</span> <span class="directive">public</span> <span class="type">void</span> tearDownWithinTransaction（）{ <span class="comment">//在事务中执行“拆除”逻辑</span> } <strong><span class="annotation">@AfterTransaction</span></strong> <span class="type">void</span> verifyFinalDatabaseState（）{ <span class="comment">//在事务回滚后验证最终状态的逻辑</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div id="testcontext-tx-false-positives" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">在测试ORM代码时避免误报</div>
<div class="paragraph">
<p>当您测试操作Hibernate会话或JPA持久性上下文状态的应用程序代码时，请确保在运行该代码的测试方法中刷新基础工作单元。未能刷新基础工作单元可能会产生误报：您的测试通过，但相同的代码会在实时生产环境中引发异常。请注意，这适用于维护内存工作单元的任何ORM框架。在下面基于Hibernate的示例测试用例中，一个方法演示了误报，另一个方法正确地公开了刷新会话的结果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// ...</span>

<span class="annotation">@Autowired</span> SessionFactory sessionFactory; <span class="annotation">@Transactional</span> <span class="annotation">@Test</span> <span class="comment">//没有预期的异常！</span>
<span class="directive">public</span> <span class="type">void</span> falsePositive（）{updateEntityInHibernateSession（）; <span class="comment">//误报：一旦Hibernate</span> <span class="comment">// Session最终被刷新（即在生产代码中），</span> <span class="comment">将抛出异常</span> } <span class="annotation">@Transactional</span> <span class="annotation">@Test</span> （expected = ...）
<span class="directive">public</span> <span class="type">void</span> updateWithSessionFlush（）{updateEntityInHibernateSession（）; <span class="comment">//需要手动刷新以避免测试</span> sessionFactory.getCurrentSession（）中的<span class="comment">误报</span> .flush（）; } <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了JPA的匹配方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// ...</span>

<span class="annotation">@PersistenceContext</span> EntityManager entityManager; <span class="annotation">@Transactional</span> <span class="annotation">@Test</span> <span class="comment">//没有预期的异常！</span>
<span class="directive">public</span> <span class="type">void</span> falsePositive（）{updateEntityInJpaPersistenceContext（）; <span class="comment">//误报：一旦JPA</span> <span class="comment">// EntityManager最终被刷新（即在生产代码中），</span> <span class="comment">将抛出异常</span> } <span class="annotation">@Transactional</span> <span class="annotation">@Test</span> （expected = ...）
<span class="directive">public</span> <span class="type">void</span> updateWithEntityManagerFlush（）{updateEntityInJpaPersistenceContext（）; <span class="comment">//需要手动刷新以避免测试</span> entityManager.flush（）; } <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-executing-sql"><a class="anchor" href="#testcontext-executing-sql"></a> 3.5.8。执行SQL脚本</h4>
<div class="paragraph">
<p>在针对关系数据库编写集成测试时，执行SQL脚本来修改数据库模式或将测试数据插入表中通常是有益的。<code>spring-jdbc</code>模块通过在加载Spring <code>ApplicationContext</code>时执行SQL脚本来支持<em>初始化</em>嵌入或现有数据库。有关详细信息，请参阅<a href="data-access.html#jdbc-embedded-database-support">嵌入式数据库支持</a>和使用<a href="data-access.html#jdbc-embedded-database-support">嵌入式数据库</a> <a href="data-access.html#jdbc-embedded-database-dao-testing">测试数据访</a></p>
</div>
<div class="paragraph">
<p>虽然在加载<code>ApplicationContext</code>时初始化数据库以进行<em>一次</em>测试非常有用，但有时<em>在</em>集成测试<em>期间</em>能够修改数据库是很重要的。以下部分说明如何在集成测试期间以编程方式和声明方式执行SQL脚本。</p>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-programmatically"><a class="anchor" href="#testcontext-executing-sql-programmatically"></a>以编程方式执行SQL脚本</h5>
<div class="paragraph">
<p>Spring提供了以下选项，用于在集成测试方法中以编程方式执行SQL脚本。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.jdbc.datasource.init。ScriptUtils</code></p>
</li>
<li>
<p><code>org.springframework.jdbc.datasource.init。ResourceDatabasePopulator</code></p>
</li>
<li>
<p><code>org.springframework.test.context.junit4。AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>org.springframework.test.context.testng。AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ScriptUtils</code>提供了一组用于处理SQL脚本的静态实用程序方法，主要用于框架内部使用。但是，如果您需要完全控制SQL脚本的解析和执行方式，则<code>ScriptUtils</code>可能比后面描述的其他一些替代方案更适合您的需求。有关更多详细信息，请参阅<code>ScriptUtils</code>各个方法的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html">Javadoc</a> 。</p>
</div>
<div class="paragraph">
<p><code>ResourceDatabasePopulator</code>提供基于对象的API，用于使用外部资源中定义的SQL脚本以编程方式填充，初始化或清理数据库。<code>ResourceDatabasePopulator</code>提供用于配置解析和运行脚本时使用的字符编码，语句分隔符，注释分隔符和错误处理标志的选项。每个配置选项都有一个合理的默认值。有关默认值的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">Javadoc</a> 。要运行在<code>ResourceDatabasePopulator</code>配置的脚本，可以调用<code>populate(Connection)</code>方法来对<code>java.sql.执行populator <code>java.sql.Connection</code>或<code>execute(DataSource)</code>方法来对<code>javax.sql.执行populator <code>javax.sql.DataSource</code> 。以下示例为测试模式和测试数据指定SQL脚本，将语句分隔符设置为<code>@@</code> ，并针对<code>DataSource</code>执行脚本：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> databaseTest {ResourceDatabasePopulator populator = <span class="keyword">new</span> ResourceDatabasePopulator（）; populator.addScripts（ <span class="keyword">新的</span> ClassPathResource（ <span class="string"><span class="delimiter">“</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ）， <span class="keyword">新的</span> ClassPathResource（ <span class="string"><span class="delimiter">“</span> <span class="content">test-data.sql</span> <span class="delimiter">”</span></span> ））; populator.setSeparator（ <span class="string"><span class="delimiter">“</span> <span class="content">@@</span> <span class="delimiter">”</span></span> ）; populator.execute（ <span class="local-variable">this</span> .dataSource）; <span class="comment">//执行使用测试模式和数据的代码</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>ResourceDatabasePopulator</code>内部委托给<code>ScriptUtils</code>来解析和运行SQL脚本。类似地， <a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>和<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>的<code>executeSqlScript(..)</code>方法在内部使用<code>ResourceDatabasePopulator</code>来运行SQL脚本。有关更多详细信息，请参阅Javadoc以获取各种<code>executeSqlScript(..)</code>方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-declaratively"><a class="anchor" href="#testcontext-executing-sql-declaratively"></a>使用@Sql以声明方式执行SQL脚本</h5>
<div class="paragraph">
<p>除了上述以编程方式运行SQL脚本的机制之外，您还可以在Spring TestContext Framework中以声明方式配置SQL脚本。具体来说，您可以在测试类或测试方法上声明<code>@Sql</code>批注，以配置应在集成测试方法之前或之后针对给定数据库运行的SQL脚本的资源路径。请注意，方法级声明会覆盖类级声明，并且<code>@Sql</code>会提供对<code>SqlScriptsTestExecutionListener</code>支持，默认情况下会启用它。</p>
</div>
<div class="sect5">
<h6 id="path-resource-semantics"><a class="anchor" href="#path-resource-semantics"></a>路径资源语义</h6>
<div class="paragraph">
<p>每个路径都被解释为Spring <code>Resource</code> 。普通路径（例如， <code>"schema.sql"</code> ）被视为相对于定义测试类的包的类路径资源。以斜杠开头的路径被视为绝对类路径资源（例如， <code>"/org/example/schema.sql"</code> ）。使用指定的资源协议加载引用URL的路径（例如，前缀为<code>classpath:</code> ， <code>file:</code> ， <code>http:</code> :)的<code>classpath:</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何在类级别和基于JUnit Jupiter的集成测试类中的方法级别使用<code>@Sql</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> <span class="annotation">@Sql</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ） <span class="type">类</span> <span class="class">DatabaseTests</span> { <span class="annotation">@Test</span> <span class="type">void</span> emptySchemaTest { <span class="comment">//执行使用没有任何测试数据的测试模式的代码</span> } <span class="annotation">@Test</span> <span class="annotation">@Sql</span> （{ <span class="string"><span class="delimiter">“/</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“/</span> <span class="content">test-user-data.sql</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> userTest { <span class="comment">//执行使用测试模式和测试数据的代码</span> }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="default-script-detection"><a class="anchor" href="#default-script-detection"></a>默认脚本检测</h6>
<div class="paragraph">
<p>如果未指定SQL脚本，则会尝试检测<code>default</code>脚本，具体取决于声明<code>@Sql</code>位置。如果无法检测到默认值，则抛出<code>IllegalStateException</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类级声明：如果带注释的测试类是<code>com.example.MyTest</code> ，相应的默认脚本是<code>classpath:com/example/MyTest.sql</code> 。</p>
</li>
<li>
<p>方法级声明：如果带注释的测试方法名为<code>testMethod()</code>并且在<code>com.example.类中定义<code>com.example.MyTest</code> ，相应的默认脚本是<code>classpath:com/example/MyTest.testMethod.sql</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="declaring-multiple-code-sql-code-sets"><a class="anchor" href="#declaring-multiple-code-sql-code-sets"></a>声明多个<code>@Sql</code>集</h6>
<div class="paragraph">
<p>如果需要为给定的测试类或测试方法配置多组SQL脚本，但具有不同的语法配置，不同的错误处理规则或每组不同的执行阶段，则可以声明<code>@Sql</code>多个实例。使用Java 8，您可以使用<code>@Sql</code>作为可重复的注释。否则，您可以使用<code>@SqlGroup</code>批注作为显式容器来声明<code>@Sql</code>多个实例。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java 8 <code>@Sql</code>用作可重复的注释：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@Sql</span> （scripts = <span class="string"><span class="delimiter">“/</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ，config = <span class="annotation">@SqlConfig</span> （commentPrefix = <span class="string"><span class="delimiter">“</span> <span class="content">`</span> <span class="delimiter">”</span></span> ）） <span class="annotation">@Sql</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test-user-data.sql</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> userTest { <span class="comment">//执行代码使用测试模式和测试数据</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面示例中显示的方案中， <code>test-schema.sql</code>脚本对单行注释使用不同的语法。</p>
</div>
<div class="paragraph">
<p>下面的例子是相同于前面的例子，不同之处在于<code>@Sql</code>声明内分组在一起<code>@SqlGroup</code> ，以兼容的Java 6和Java 7。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@SqlGroup</span> （{ <span class="annotation">@Sql</span> （scripts = <span class="string"><span class="delimiter">“/</span> <span class="content">test-schema.sql</span> <span class="delimiter">”</span></span> ，config = <span class="annotation">@SqlConfig</span> （commentPrefix = <span class="string"><span class="delimiter">“</span> <span class="content">`</span> <span class="delimiter">”</span></span> ））， <span class="annotation">@ Sql</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test-user-data.sql</span> <span class="delimiter">”</span></span> ））} <span class="directive">public</span> <span class="type">void</span> userTest { <span class="comment">//执行使用测试模式和测试数据的代码</span> }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="script-execution-phases"><a class="anchor" href="#script-execution-phases"></a>脚本执行阶段</h6>
<div class="paragraph">
<p>默认情况下，SQL脚本在相应的测试方法之前执行。但是，如果需要在测试方法之后运行一组特定的脚本（例如，清理数据库状态），则可以使用<code>@Sql</code>的<code>executionPhase</code>属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@Sql</span> （scripts = <span class="string"><span class="delimiter">“</span> <span class="content">create-test-data.sql</span> <span class="delimiter">”</span></span> ，config = <span class="annotation">@SqlConfig</span> （transactionMode = <span class="annotation">ISOLATED</span> ）） <span class="annotation">@Sql</span> （scripts = <span class="string"><span class="delimiter">“</span> <span class="content">delete-test-data.sql</span> <span class="delimiter">”</span></span> ，config = <span class="annotation">@SqlConfig</span> （transactionMode = <span class="annotation">ISOLATED）</span> ），executionPhase = AFTER_TEST_METHOD） <span class="directive">public</span> <span class="type">void</span> userTest { <span class="comment">//执行代码，需要将测试数据提交</span> <span class="comment">到测试事务之外的数据库</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>需要注意的是<code>ISOLATED</code>和<code>AFTER_TEST_METHOD</code>静态进口<code>Sql.TransactionMode</code>和<code>Sql.ExecutionPhase</code> ，分别。</p>
</div>
</div>
<div class="sect5">
<h6 id="script-configuration-with-code-sqlconfig-code"><a class="anchor" href="#script-configuration-with-code-sqlconfig-code"></a>使用<code>@SqlConfig</code>脚本配置</h6>
<div class="paragraph">
<p>您可以使用<code>@SqlConfig</code>批注配置脚本解析和错误处理。在集成测试类中声明为类级别注释时， <code>@SqlConfig</code>用作测试类层次结构中所有SQL脚本的全局配置。当使用<code>@Sql</code>批注的<code>config</code>属性直接声明时， <code>@SqlConfig</code>用作在封闭的<code>@Sql</code>批注中声明的SQL脚本的本地配置。<code>@SqlConfig</code>中的每个属性都有一个隐式默认值，该值在相应属性的Javadoc中记录。由于在Java语言规范中为注释属性定义了规则，遗憾的是，不可能将<code>null</code>值赋给注释属性。因此，为了支持继承的全局配置的覆盖， <code>@SqlConfig</code>属性具有显式默认值<code>""</code> （对于字符串）或<code>DEFAULT</code> （对于枚举）。这种方法允许的局部声明<code>@SqlConfig</code>选择性地覆盖从全局声明单个属性<code>@SqlConfig</code>提供以外的值<code>""</code>或<code>DEFAULT</code> 。只要本地<code>@SqlConfig</code>属性不提供<code>""</code>或“ <code>DEFAULT</code> <code>""</code>以外的显式值，就会继承全局<code>@SqlConfig</code>属性。因此，显式本地配置会覆盖全局配置。</p>
</div>
<div class="paragraph">
<p><code>@Sql</code>和<code>@SqlConfig</code>提供的配置选项等同于<code>ScriptUtils</code>和<code>ResourceDatabasePopulator</code>支持的配置选项，但它们是<code>&lt;jdbc:initialize-database/&gt;</code> XML命名空间元素提供的超集。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/jdbc/Sql.html"><code>@Sql</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a>中各个属性的Javadoc。</p>
</div>
<div id="testcontext-executing-sql-declaratively-tx" class="paragraph">
<p><strong><code>@Sql</code>事务管理</strong></p>
</div>
<div class="paragraph">
<p>默认情况下， <code>SqlScriptsTestExecutionListener</code>为使用<code>@Sql</code>配置的脚本推断所需的事务语义。具体地，SQL脚本没有事务运行时，现有的Spring管理的事务中（例如，由被管理事务<code>TransactionalTestExecutionListener</code>用于与注释测试<code>@Transactional</code> ），或分离的事务内，这取决于所配置的值<code>transactionMode</code> <code>@SqlConfig</code>属性以及测试的<code>ApplicationContext</code>是否存在<code>PlatformTransactionManager</code> 。但是，最简单的是<code>javax.sql.DataSource</code>必须存在于测试的<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>如果<code>SqlScriptsTestExecutionListener</code>用于检测<code>DataSource</code>和<code>PlatformTransactionManager</code>并推断事务语义的算法不符合您的需要，则可以通过设置<code>@SqlConfig</code>的<code>dataSource</code>和<code>transactionManager</code>属性来指定显式名称。此外，您可以通过设置<code>@SqlConfig</code>的<code>transactionMode</code>属性来控制事务传播行为（例如，脚本是否应该在隔离的事务中运行）。虽然对使用<code>@Sql</code>进行事务管理的所有受支持选项的详尽讨论超出了本参考手册的范围，但<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html"><code>SqlScriptsTestExecutionListener</code></a>的Javadoc提供了详细信息，以下示例显示了使用JUnit Jupiter和事务测试的典型测试场景。与<code>@Sql</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> （TestDatabaseConfig.class） <span class="annotation">@Transactional</span> <span class="type">类</span> <span class="class">TransactionalSqlScriptsTests</span> { <span class="directive">final</span> JdbcTemplate jdbcTemplate; <span class="annotation">@Autowired</span> TransactionalSqlScriptsTests（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; } <span class="annotation">@Test</span> <span class="annotation">@Sql</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">test-data.sql</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> usersTest（）{ <span class="comment">//验证测试数据库中的状态：</span> assertNumUsers（ <span class="integer">2</span> ）; <span class="comment">//执行使用测试数据的代码......</span>} <span class="type">int</span> countRowsInTable（ <span class="predefined-type">String</span> tableName）{ <span class="keyword">return</span> JdbcTestUtils.countRowsInTable（ <span class="local-variable">this</span> .jdbcTemplate，tableName）; <span class="type">void</span> assertNumUsers（ <span class="type">int</span> expected）{assertEquals（expected，countRowsInTable（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ）， <span class="string"><span class="delimiter">“</span> <span class="content">[user] table中的行数。</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，运行<code>usersTest()</code>方法后无需清理数据库，因为对数据库所做的任何更改（在测试方法内或在<code>/test-data.sql</code>脚本中）都会自动回滚。 <code>TransactionalTestExecutionListener</code> （有关详细信息，请参阅<a href="#testcontext-tx">事务管理</a> ）。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-parallel-test-execution"><a class="anchor" href="#testcontext-parallel-test-execution"></a> 3.5.9。并行测试执行</h4>
<div class="paragraph">
<p>Spring Framework 5.0引入了在使用Spring TestContext Framework时在单个JVM中并行执行测试的基本支持。通常，这意味着大多数测试类或测试方法可以并行执行，而无需对测试代码或配置进行任何更改。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关如何设置并行测试执行的详细信息，请参阅测试框架，构建工具或IDE的文档。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请记住，在您的测试套件中引入并发可能会导致意外的副作用，奇怪的运行时行为以及间歇性或看似随机失败的测试。因此，Spring Team提供了以下关于何时不并行执行测试的一般指导原则。</p>
</div>
<div class="paragraph">
<p>如果测试，请不要并行执行测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Spring的<code>@DirtiesContext</code>支持。</p>
</li>
<li>
<p>使用JUnit 4的<code>@FixMethodOrder</code>支持或任何旨在确保测试方法以特定顺序运行的测试框架功能。但请注意，如果并行执行整个测试类，则不适用。</p>
</li>
<li>
<p>更改共享服务或系统的状态，例如数据库，消息代理，文件系统等。这适用于内存和外部系统。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果并行测试执行失败，并且异常声明当前测试的<code>ApplicationContext</code>不再处于活动状态，则这通常意味着<code>ApplicationContext</code>已从另一个线程中的<code>ContextCache</code>中删除。</p>
</div>
<div class="paragraph">
<p>这可能是由于使用了<code>@DirtiesContext</code>或者是由于<code>ContextCache</code>自动驱逐。如果<code>@DirtiesContext</code>是罪魁祸首，您需要找到一种方法来避免使用<code>@DirtiesContext</code>或从并行执行中排除此类测试。如果已超出<code>ContextCache</code>的最大大小，则可以增加高速缓存的最大大小。有关详细信息，请参阅有关<a href="#testcontext-ctx-management-caching">上下文缓存</a>的讨论</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">只有在底层的<code>TestContext</code>实现提供了一个拷贝构造函数时，Spring TestContext Framework中的并行测试才能执行，如<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/context/TestContext.html">Javadoc for <code>TestContext</code></a> 。Spring中使用的<code>DefaultTestContext</code>提供了这样的构造函数。但是，如果使用提供自定义<code>TestContext</code>实现的第三方库，则需要验证它是否适合并行测试执行。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-support-classes"><a class="anchor" href="#testcontext-support-classes"></a> 3.5.10。TestContext框架支持类</h4>
<div class="paragraph">
<p>本节描述了支持Spring TestContext Framework的各种类。</p>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-runner"><a class="anchor" href="#testcontext-junit4-runner"></a> Spring JUnit 4 Runner</h5>
<div class="paragraph">
<p>Spring TestContext Framework通过自定义运行器（在JUnit 4.12或更高版本上支持）提供与JUnit 4的完全集成。通过使用<code>@RunWith(SpringJUnit4ClassRunner.class)</code>或更短的<code>@RunWith(SpringRunner.class)</code>变体来注释测试类，开发人员可以实现基于标准JUnit 4的单元和集成测试，同时获得TestContext框架的好处，例如支持加载应用程序上下文，测试实例的依赖项注入，事务测试方法执行等。如果您想将Spring TestContext Framework与替代运行器（例如JUnit 4的<code>Parameterized</code> runner）或第三方运行程序（例如<code>MockitoJUnitRunner</code> ）一起使用，您可以选择使用<a href="#testcontext-junit4-rules">Spring对JUnit规则的支持</a> 。</p>
</div>
<div class="paragraph">
<p>以下代码清单显示了配置测试类以使用自定义Spring <code>Runner</code>运行的最低要求：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@TestExecutionListeners</span> （{}） <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleTest</span> { <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testMethod（）{ <span class="comment">//执行测试逻辑...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例， <code>@TestExecutionListeners</code>配置有一个空列表，禁用默认监听器，否则这将需要<code>ApplicationContext</code>通过被配置<code>@ContextConfiguration</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-rules"><a class="anchor" href="#testcontext-junit4-rules"></a> Spring JUnit 4规则</h5>
<div class="paragraph">
<p><code>org.springframework.test.context.junit4.rules</code>包提供以下JUnit 4规则（JUnit 4.12或更高版本支持）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SpringClassRule</code></p>
</li>
<li>
<p><code>SpringMethodRule</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SpringClassRule</code>是一个JUnit <code>TestRule</code> ，它支持Spring TestContext Framework的类级功能，而<code>SpringMethodRule</code>是一个JUnit <code>MethodRule</code> ，它支持Spring TestContext Framework的实例级和方法级功能。</p>
</div>
<div class="paragraph">
<p>与<code>SpringRunner</code> ，Spring基于规则的JUnit支持具有独立于任何<code>org.junit.runner.的优势<code>org.junit.runner.因此， Runner</code>实现可以与现有的替代运行程序（例如JUnit 4的<code>Parameterized</code> ）或第三方运行程序（例如<code>MockitoJUnitRunner</code> ）结合使用。</p>
</div>
<div class="paragraph">
<p>要支持TestContext框架的完整功能，必须将<code>SpringClassRule</code>与<code>SpringMethodRule</code>结合使用。以下示例显示了在集成测试中声明这些规则的正确方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//可选择通过@RunWith（...）指定非Spring Runner</span>
<span class="annotation">@ContextConfiguration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">IntegrationTest</span> { <span class="annotation">@ClassRule</span> <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> SpringClassRule springClassRule = <span class="keyword">new</span> SpringClassRule（）; <span class="annotation">@Rule</span> <span class="directive">public</span> <span class="directive">final</span> SpringMethodRule springMethodRule = <span class="keyword">new</span> SpringMethodRule（）; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testMethod（）{ <span class="comment">//执行测试逻辑...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-junit4"><a class="anchor" href="#testcontext-support-classes-junit4"></a> JUnit 4支持类</h5>
<div class="paragraph">
<p><code>org.springframework.test.context.junit4</code>包为基于JUnit 4的测试用例提供以下支持类（在JUnit 4.12或更高版本上受支持）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractJUnit4SpringContextTests时</code></p>
</li>
<li>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractJUnit4SpringContextTests</code>是一个抽象基础测试类，它将Spring TestContext Framework与JUnit 4环境中的显式<code>ApplicationContext</code>测试支持集成在一起。扩展<code>AbstractJUnit4SpringContextTests</code> ，可以访问<code>protected</code> <code>applicationContext</code>实例变量，该变量可用于执行显式bean查找或测试整个上下文的状态。</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalJUnit4SpringContextTests</code>是一个抽象的事务扩展<code>AbstractJUnit4SpringContextTests</code>是为JDBC访问增加了一些方便的功能。这个类需要一个<code>javax.sql.DataSource</code> bean和要在<code>ApplicationContext</code>定义的<code>PlatformTransactionManager</code> bean。扩展<code>AbstractTransactionalJUnit4SpringContextTests</code> ，可以访问<code>protected</code> <code>jdbcTemplate</code>实例变量，该变量可用于运行SQL语句以查询数据库。您可以在运行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，Spring确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具结合使用时，请务必避免<a href="#testcontext-tx-false-positives">误报</a> 。正如<a href="#integration-testing-support-jdbc">JDBC测试支持中</a>所提到的， <code>AbstractTransactionalJUnit4SpringContextTests</code>还提供了方便的方法，通过使用前面提到的<code>jdbcTemplate</code>委托给<code>JdbcTestUtils</code>的方法。此外， <code>AbstractTransactionalJUnit4SpringContextTests</code>提供了一个<code>executeSqlScript(..)</code>方法，用于针对配置的<code>DataSource</code>运行SQL脚本。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这些类是扩展的便利。如果您不希望将测试类绑定到特定于Spring的类层次结构，则可以使用<code>@RunWith(SpringRunner.class)</code>或<a href="#testcontext-junit4-rules">Spring的JUnit规则</a>来配置您自己的自定义测试类。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-extension"><a class="anchor" href="#testcontext-junit-jupiter-extension"></a> JUnit Jupiter的SpringExtension</h5>
<div class="paragraph">
<p>Spring TestContext Framework提供了与JUnit 5中引入的JUnit Jupiter测试框架的完全集成。通过使用<code>@ExtendWith(SpringExtension.class)</code>注释测试类，您可以实现标准的基于JUnit Jupiter的单元和集成测试，同时获得TestContext框架的好处，例如支持加载应用程序上下文，依赖注入测试实例，事务性测试方法执行，等等。</p>
</div>
<div class="paragraph">
<p>此外，由于JUnit Jupiter中的丰富扩展API，Spring可以提供以下功能，这些功能超出了Spring支持JUnit 4和TestNG的功能集：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>测试构造函数，测试方法和测试生命周期回调方法的依赖注入。有关更多详细信息，请参阅<a href="#testcontext-junit-jupiter-di">使用<code>SpringExtension</code>依赖注入</a> 。</p>
</li>
<li>
<p>强大支持基于SpEL表达式，环境变量，系统属性等的<a href="http://junit.org/junit5/docs/current/user-guide/#extensions-conditions">条件测试执行</a> 。有关更多详细信息和示例，请参阅<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter测试注释中的</a> <code>@EnabledIf</code>和<code>@DisabledIf</code>文档。</p>
</li>
<li>
<p>自定义组合注释，结合了Spring和JUnit Jupiter的注释。有关详细信息，请参阅<a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing中</a>的<code>@TransactionalDevTestConfig</code>和<code>@TransactionalIntegrationTest</code>示例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码清单显示了如何配置测试类以将<code>SpringExtension</code>与<code>@ContextConfiguration</code>结合使用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//指示JUnit Jupiter使用Spring支持扩展测试。</span>
<span class="annotation">@ExtendWith</span> （SpringExtension.class） <span class="comment">//指示Spring从TestConfig.class加载ApplicationContext</span> <span class="annotation">@ContextConfiguration</span> （classes = TestConfig.class） <span class="type">类</span> <span class="class">SimpleTests</span> { <span class="annotation">@Test</span> <span class="type">void</span> testMethod（）{ <span class="comment">//执行测试逻辑...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于您还可以在JUnit 5中使用注释作为元注释，因此Spring可以提供<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>组成的注释，以简化测试<code>ApplicationContext</code>和JUnit Jupiter的配置。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@SpringJUnitConfig</code>来减少上一个示例中使用的配置量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//指示Spring使用JUnit</span> <span class="comment">// Jupiter</span> <span class="comment">注册SpringExtension</span> <span class="comment">并从TestConfig.class加载ApplicationContext</span> <span class="annotation">@SpringJUnitConfig</span> （TestConfig.class） <span class="type">类</span> <span class="class">SimpleTests</span> { <span class="annotation">@Test</span> <span class="type">void</span> testMethod（）{ <span class="comment">//执行测试逻辑...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类似地，以下示例使用<code>@SpringJUnitWebConfig</code>创建用于JUnit Jupiter的<code>WebApplicationContext</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//指示Spring使用JUnit</span> <span class="comment">// Jupiter</span> <span class="comment">注册SpringExtension</span> <span class="comment">并从TestWebConfig.class加载WebApplicationContext</span> <span class="annotation">@SpringJUnitWebConfig</span> （TestWebConfig.class） <span class="type">类</span> <span class="class">SimpleWebTests</span> { <span class="annotation">@Test</span> <span class="type">void</span> testMethod（）{ <span class="comment">//执行测试逻辑...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter测试注释中的</a> <code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>的文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-di"><a class="anchor" href="#testcontext-junit-jupiter-di"></a> <code>SpringExtension</code>依赖注入</h5>
<div class="paragraph">
<p><code>SpringExtension</code>从JUnit Jupiter实现了<a href="http://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution"><code>ParameterResolver</code></a>扩展API，它允许Spring为测试构造函数，测试方法和测试生命周期回调方法提供依赖注入。</p>
</div>
<div class="paragraph">
<p>具体来说， <code>SpringExtension</code>可以注入从测试的依赖关系<code>ApplicationContext</code>成被注解为测试构造函数和方法<code>@BeforeAll</code> ， <code>@AfterAll</code> ， <code>@BeforeEach</code> ， <code>@AfterEach</code> ， <code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code> ，等等。</p>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-constructor"><a class="anchor" href="#testcontext-junit-jupiter-di-constructor"></a>构造函数注入</h6>
<div class="paragraph">
<p>如果在对于一个JUnit木星测试类的构造函数的参数的类型的<code>ApplicationContext</code> （或子类型）或其被注释或与间注释<code>@Autowired</code> ， <code>@Qualifier</code> ，或<code>@Value</code> ，弹簧注入该特定参数的值使用来自test的<code>ApplicationContext</code>的相应bean。如果所有参数都应由Spring提供，您也可以使用<code>@Autowired</code>直接注释测试构造函数。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果测试类的构造函数本身用<code>@Autowired</code>注释，则Spring承担解析构造函数中<em>所有</em>参数的责任。因此，没有向JUnit Jupiter注册的其他<code>ParameterResolver</code>可以解析此类构造函数的参数。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在下面的示例中，Spring将从<code>TestConfig.class</code>加载的<code>ApplicationContext</code>的<code>OrderService</code> bean注入<code>OrderServiceIntegrationTests</code>构造函数。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> （TestConfig.class） <span class="type">类</span> <span class="class">OrderServiceIntegrationTests</span> { <span class="directive">private</span> <span class="directive">final</span> OrderService orderService; <span class="annotation">@Autowired</span> OrderServiceIntegrationTests（OrderService orderService）{ <span class="local-variable">this</span> .orderService = orderService。} <span class="comment">//使用注入的OrderService的测试</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，此功能允许测试依赖项是<code>final</code> ，因此是不可变的。</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-method"><a class="anchor" href="#testcontext-junit-jupiter-di-method"></a>方法注入</h6>
<div class="paragraph">
<p>如果在一个JUnit木星的测试方法或测试生命周期回调方法的参数的类型的<code>ApplicationContext</code> （或子类型）或其被注释或与间注释<code>@Autowired</code> ， <code>@Qualifier</code> ，或<code>@Value</code> ，弹簧注入该值来自test的<code>ApplicationContext</code>的相应bean的特定参数。</p>
</div>
<div class="paragraph">
<p>在下面的示例中，Spring将从<code>TestConfig.class</code>加载的<code>ApplicationContext</code>的<code>OrderService</code>注入到<code>deleteOrder()</code>测试方法中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> （TestConfig.class） <span class="type">类</span> <span class="class">OrderServiceIntegrationTests</span> { <span class="annotation">@Test</span> <span class="type">void</span> deleteOrder（ <span class="annotation">@Autowired</span> OrderService orderService）{ <span class="comment">//使用来自test的ApplicationContext的orderService</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于JUnit Jupiter中的<code>ParameterResolver</code>支持的健壮性，您还可以将多个依赖项注入单个方法，不仅来自Spring，还来自JUnit Jupiter本身或其他第三方扩展。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何同时将Spring和JUnit Jupiter注入<code>placeOrderRepeatedly()</code>测试方法。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SpringJUnitConfig</span> （TestConfig.class） <span class="type">类</span> <span class="class">OrderServiceIntegrationTests</span> { <span class="annotation">@RepeatedTest</span> （ <span class="integer">10</span> ） <span class="type">void</span> placeOrderRepeatedly（RepetitionInfo repetitionInfo，@ <span class="annotation">Autowired</span> OrderService orderService）{ <span class="comment">//使用来自测试的ApplicationContext的orderService</span> <span class="comment">//和来自JUnit Jupiter的repetitionInfo</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，使用JUnit Jupiter中的<code>@RepeatedTest</code>可以让测试方法获得对<code>RepetitionInfo</code>访问权限。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-testng"><a class="anchor" href="#testcontext-support-classes-testng"></a> TestNG支持类</h5>
<div class="paragraph">
<p><code>org.springframework.test.context.testng</code>包为基于TestNG的测试用例提供以下支持类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractTestNGSpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractTestNGSpringContextTests</code>是一个抽象基础测试类，它将Spring TestContext Framework与TestNG环境中的显式<code>ApplicationContext</code>测试支持集成在一起。扩展<code>AbstractTestNGSpringContextTests</code> ，可以访问<code>protected</code> <code>applicationContext</code>实例变量，该变量可用于执行显式bean查找或测试整个上下文的状态。</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalTestNGSpringContextTests</code>是一个抽象的事务扩展<code>AbstractTestNGSpringContextTests</code>是为JDBC访问增加了一些方便的功能。这个类需要一个<code>javax.sql.DataSource</code> bean和要在<code>ApplicationContext</code>定义的<code>PlatformTransactionManager</code> bean。扩展<code>AbstractTransactionalTestNGSpringContextTests</code> ，可以访问<code>protected</code> <code>jdbcTemplate</code>实例变量，该变量可用于执行SQL语句以查询数据库。您可以在运行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，Spring确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具结合使用时，请务必避免<a href="#testcontext-tx-false-positives">误报</a> 。正如<a href="#integration-testing-support-jdbc">JDBC测试支持中</a>所提到的， <code>AbstractTransactionalTestNGSpringContextTests</code>还提供了方便的方法，通过使用前面提到的<code>jdbcTemplate</code>委托给<code>JdbcTestUtils</code>的方法。此外， <code>AbstractTransactionalTestNGSpringContextTests</code>提供了一个<code>executeSqlScript(..)</code>方法，用于针对配置的<code>DataSource</code>运行SQL脚本。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这些类是扩展的便利。如果您不希望将测试类绑定到特定于Spring的类层次结构，则可以使用<code>@ContextConfiguration</code> ， <code>@TestExecutionListeners</code>配置自己的自定义测试类，并使用<code>TestContextManager</code>手动检测测试类。有关如何检测测试类的示例，请参阅<code>AbstractTestNGSpringContextTests</code>的源代码。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-mvc-test-framework"><a class="anchor" href="#spring-mvc-test-framework"></a> 3.6。Spring MVC测试框架</h3>
<div class="paragraph">
<p>Spring MVC Test框架提供了一流的支持，可以使用流畅的API测试Spring MVC代码，您可以将其与JUnit，TestNG或任何其他测试框架一起使用。它构建在<code>spring-test</code>模块的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html">Servlet API模拟对象</a>之上，因此不使用正在运行的Servlet容器。它使用<code>DispatcherServlet</code>提供完整的Spring MVC运行时行为，并提供对使用TestContext框架加载实际Spring配置的支持，以及独立模式，您可以在其中手动实例化控制器并一次测试一个。</p>
</div>
<div class="paragraph">
<p>Spring MVC Test还为测试使用<code>RestTemplate</code>代码提供客户端支持。客户端测试模拟服务器响应，也不使用正在运行的服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Boot提供了一个选项来编写包含正在运行的服务器的完整的端到端集成测试。如果这是您的目标，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications">Spring Boot参考页面</a> 。有关容器外和端到端集成测试之间差异的更多信息，请参阅容器外和端到端集成测试<a href="#spring-mvc-test-vs-end-to-end-integration-tests">之间的差异</a> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server"><a class="anchor" href="#spring-mvc-test-server"></a> 3.6.1。服务器端测试</h4>
<div class="paragraph">
<p>您可以使用JUnit或TestNG为Spring MVC控制器编写一个普通的单元测试。为此，实例化控制器，使用模拟或存根依赖项注入它，并调用其方法（根据需要传递<code>MockHttpServletRequest</code> ， <code>MockHttpServletResponse</code>和其他）。但是，在编写这样的单元测试时，仍有许多未经测试：例如，请求映射，数据绑定，类型转换，验证等等。此外，其它的控制器方法如<code>@InitBinder</code> ， <code>@ModelAttribute</code>和<code>@ExceptionHandler</code>也可以被调用作为请求处理生命周期的一部分。</p>
</div>
<div class="paragraph">
<p>Spring MVC Test的目标是通过执行请求并通过实际的<code>DispatcherServlet</code>生成响应来提供测试控制器的有效方法。</p>
</div>
<div class="paragraph">
<p>Spring MVC Test建立在<code>spring-test</code>模块中可用<a href="#mock-objects-servlet">的Servlet API</a>的熟悉的<a href="#mock-objects-servlet">“模拟”实现之上</a> 。这允许执行请求并生成响应，而无需在Servlet容器中运行。在大多数情况下，一切都应该像在运行时一样工作，但有一些值得注意的例外，如<a href="#spring-mvc-test-vs-end-to-end-integration-tests">容器外和端到端集成测试之间的差异所述</a> 。以下基于JUnit Jupiter的示例使用Spring MVC Test：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.test.web.servlet.request.MockMvcRequestBuilders</span> 。*; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.test.web.servlet.result。MockMvcResultMatchers</span> 。*; <span class="annotation">@SpringJUnitWebConfig</span> （locations = <span class="string"><span class="delimiter">“</span> <span class="content">test-servlet-context.xml</span> <span class="delimiter">”</span></span> ） <span class="type">类</span> <span class="class">ExampleTests</span> { <span class="directive">private</span> MockMvc mockMvc; <span class="annotation">@BeforeEach</span> <span class="type">void</span> setup（WebApplicationContext wac）{ <span class="local-variable">this</span> .mockMvc = MockMvcBuilders.webAppContextSetup（wac）.build（）; } <span class="annotation">@Test</span> <span class="type">void</span> getAccount（） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="local-variable">this</span> .mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts / 1</span> <span class="delimiter">”</span></span> ）。accept（MediaType.parseMediaType（ <span class="string"><span class="delimiter">“</span> <span class="content">application / json; charset = UTF-8</span> <span class="delimiter">”</span></span> ）））。andExpect（status （）。isOk（））。and Expect（content（）。contentType（ <span class="string"><span class="delimiter">“</span> <span class="content">application / json</span> <span class="delimiter">”</span></span> ））。and Expect（jsonPath（ <span class="string"><span class="delimiter">“</span> <span class="content">$ .name</span> <span class="delimiter">”</span></span> ）。value（ <span class="string"><span class="delimiter">“</span> <span class="content">Lee</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述测试依赖于TestContext框架的<code>WebApplicationContext</code>支持，以从与测试类位于同一包中的XML配置文件加载Spring配置，但也支持基于Java和Groovy的配置。请参阅这些<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context">示例测试</a> 。</p>
</div>
<div class="paragraph">
<p><code>MockMvc</code>实例用于对<code>/accounts/1</code>执行<code>GET</code>请求，并验证生成的响应的状态为200，内容类型为<code>application/json</code> ，响应正文具有名为<code>name</code>的值为<code>Lee</code>的JSON属性。Jayway <a href="https://github.com/jayway/JsonPath">JsonPath项目</a>支持<code>jsonPath</code>语法。验证执行请求结果的许多其他选项将在本文档的后面部分讨论。</p>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-static-imports"><a class="anchor" href="#spring-mvc-test-server-static-imports"></a>静态进口</h5>
<div class="paragraph">
<p>上<a href="#spring-mvc-test-server">一节</a>示例中的流畅API需要一些静态导入，例如<code>MockMvcRequestBuilders.*</code> ， <code>MockMvcResultMatchers.*</code>和<code>MockMvcBuilders.*</code> 。查找这些类的简单方法是搜索与<code>MockMvc*</code>匹配的类型。如果您使用Eclipse或基于Eclipse的Spring Tool Suite，请确保在Java→编辑器→内容辅助→收藏夹下的Eclipse首选项中将它们添加为“最喜欢的静态成员”。这样做可以在键入静态方法名称的第一个字符后使用内容辅助。其他IDE（例如IntelliJ）可能不需要任何其他配置。检查静态成员的代码完成支持。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-options"><a class="anchor" href="#spring-mvc-test-server-setup-options"></a>设置选择</h5>
<div class="paragraph">
<p>您有两个主要选项来创建<code>MockMvc</code>的实例。第一种是通过TestContext框架加载Spring MVC配置，该框架加载Spring配置并将<code>WebApplicationContext</code>注入测试以用于构建<code>MockMvc</code>实例。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@WebAppConfiguration</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">my-servlet-context.xml</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">MyWebTests</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> WebApplicationContext wac; <span class="directive">私人</span> MockMvc mockMvc; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{ <span class="local-variable">this</span> .mockMvc = MockMvcBuilders.webAppContextSetup（ <span class="local-variable">this</span> .wac）.build（）; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您的第二个选择是手动创建控制器实例而不加载Spring配置。相反，将自动创建与MVC JavaConfig或MVC命名空间大致相当的基本默认配置。您可以在一定程度上自定义它。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebTests</span> { <span class="directive">private</span> MockMvc mockMvc; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{ <span class="local-variable">this</span> .mockMvc = MockMvcBuilders.standaloneSetup（ <span class="keyword">new</span> AccountController（））。build（）; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您应该使用哪种设置选项？</p>
</div>
<div class="paragraph">
<p><code>webAppContextSetup</code>加载您的实际Spring MVC配置，从而实现更完整的集成测试。由于TestContext框架缓存了加载的Spring配置，因此即使您在测试套件中引入了更多测试，它也有助于保持测试快速运行。此外，您可以通过Spring配置将模拟服务注入控制器，以便专注于测试Web层。以下示例使用Mockito声明了一个模拟服务：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.mockito。Mockito</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mock</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将模拟服务注入测试以设置和验证您的期望，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@WebAppConfiguration</span> <span class="annotation">@ContextConfiguration</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">test-servlet-context.xml</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">AccountTests</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> WebApplicationContext wac; <span class="directive">私人</span> MockMvc mockMvc; <span class="annotation">@Autowired</span> <span class="directive">私人</span> AccountService帐户服务; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一方面， <code>standaloneSetup</code>更接近单元测试。它一次测试一个控制器。您可以使用模拟依赖项手动注入控制器，但不涉及加载Spring配置。这些测试更侧重于样式，并且更容易看到正在测试哪个控制器，是否需要任何特定的Spring MVC配置，等等。<code>standaloneSetup</code>也是编写临时测试以验证特定行为或调试问题的一种非常方便的方法。</p>
</div>
<div class="paragraph">
<p>与大多数“整合与单元测试”辩论一样，没有正确或错误的答案。但是，使用<code>standaloneSetup</code>确实需要额外的<code>webAppContextSetup</code>测试才能验证Spring MVC配置。或者，您可以使用<code>webAppContextSetup</code>编写所有测试，以便始终针对您的实际Spring MVC配置进行测试。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-steps"><a class="anchor" href="#spring-mvc-test-server-setup-steps"></a>设置功能</h5>
<div class="paragraph">
<p>无论您使用哪个MockMvc构建器，所有<code>MockMvcBuilder</code>实现都提供了一些常用且非常有用的功能。例如，您可以为所有请求声明<code>Accept</code>标头，并期望所有响应中的状态为200以及<code>Content-Type</code>标头，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//静态导入MockMvcBuilders.standaloneSetup</span> MockMvc mockMvc = standaloneSetup（ <span class="keyword">new</span> MusicController（））。defaultRequest（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ）。accept（MediaType。APPLICATION_JSON））。fromwaysExpect（status（）。isOk（））。roundwaysExpect（content（）。contentType（ <span class="string"><span class="delimiter">“</span> <span class="content">application / json; charset = UTF-8</span> <span class="delimiter">”</span></span> ））。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，第三方框架（和应用程序）可以预先打包设置指令，例如<code>MockMvcConfigurer</code>设置指令。Spring Framework有一个这样的内置实现，可以帮助跨请求保存和重用HTTP会话。您可以按如下方式使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// SharedHttpSessionConfigurer.sharedHttpSession的静态导入</span> MockMvc mockMvc = MockMvcBuilders.standaloneSetup（ <span class="keyword">new</span> TestController（））。apply（sharedHttpSession（））。build（）; <span class="comment">//使用mockMvc执行请求...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关所有MockMvc构建器功能的列表，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html">Javadoc for <code>ConfigurableMockMvcBuilder</code></a> ，或使用IDE探索可用选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-performing-requests"><a class="anchor" href="#spring-mvc-test-server-performing-requests"></a>执行请求</h5>
<div class="paragraph">
<p>您可以执行使用任何HTTP方法的请求，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（post（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotels / {id}</span> <span class="delimiter">”</span></span> ， <span class="integer">42</span> ）.accept（MediaType。APPLICATION_JSON））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以执行内部使用<code>MockMultipartHttpServletRequest</code>文件上载请求，以便不会实际解析多部分请求。相反，您必须将其设置为类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（multipart（ <span class="string"><span class="delimiter">“</span> <span class="content">/ doc</span> <span class="delimiter">”</span></span> ）。file（ <span class="string"><span class="delimiter">“</span> <span class="content">a1</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">ABC</span> <span class="delimiter">”</span></span> .getBytes（ <span class="string"><span class="delimiter">“</span> <span class="content">UTF-8</span> <span class="delimiter">”</span></span> ）））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在URI模板样式中指定查询参数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotels？thing = {thing}</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">某处</span> <span class="delimiter">“</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以添加表示查询或表单参数的Servlet请求参数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotels</span> <span class="delimiter">”</span></span> ）。param（ <span class="string"><span class="delimiter">“</span> <span class="content">thing</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">somewhere</span> <span class="delimiter">”</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序代码依赖于Servlet请求参数，并且未明确检查查询字符串（通常情况下），则使用哪个选项无关紧要。但请记住，URI模板提供的查询参数已被解码，而通过<code>param(…​)</code>方法提供的请求参数预计已被解码。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，最好将上下文路径和Servlet路径保留在请求URI之外。如果必须使用完整请求URI进行测试，请确保相应地设置<code>contextPath</code>和<code>servletPath</code>以使请求映射有效，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app / main / hotels / {id}</span> <span class="delimiter">”</span></span> ）。。entextPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）。servletPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ main</span> <span class="delimiter">”</span></span> ））</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，为每个执行的请求设置<code>contextPath</code>和<code>servletPath</code>是很麻烦的。相反，您可以设置默认请求属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebTests</span> { <span class="directive">private</span> MockMvc mockMvc; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{mockMvc = standaloneSetup（ <span class="keyword">new</span> AccountController（））。devaultRequest（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ）。enctextPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ app</span> <span class="delimiter">”</span></span> ）。servletPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ main</span> <span class="delimiter">”</span></span> ）。accept（MediaType。APPLICATION_JSON））建立（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的属性会影响通过<code>MockMvc</code>实例执行的每个请求。如果在给定请求上也指定了相同的属性，则它将覆盖默认值。这就是默认请求中的HTTP方法和URI无关紧要的原因，因为必须在每个请求中指定它们。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-defining-expectations"><a class="anchor" href="#spring-mvc-test-server-defining-expectations"></a>定义期望</h5>
<div class="paragraph">
<p>您可以通过在执行请求后附加一个或多个<code>.andExpect(..)</code>调用来定义期望，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts / 1</span> <span class="delimiter">”</span></span> ））。andExpect（status（）。isOk（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>MockMvcResultMatchers.*</code>提供了许多期望，其中一些进一步嵌套了更详细的期望。</p>
</div>
<div class="paragraph">
<p>期望分为两大类。第一类断言验证响应的属性（例如，响应状态，标头和内容）。这些是断言最重要的结果。</p>
</div>
<div class="paragraph">
<p>第二类断言超出了回应范围。这些断言允许您检查Spring MVC特定方面，例如处理请求的控制器方法，是否引发和处理异常，模型的内容是什么，选择了哪个视图，添加了哪些Flash属性等等。它们还允许您检查Servlet的特定方面，例如请求和会话属性。</p>
</div>
<div class="paragraph">
<p>以下测试断言绑定或验证失败：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（post（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ））。and Expect（status（）。isOk（））。and Expect（model（）。attributeHasErrors（ <span class="string"><span class="delimiter">“</span> <span class="content">person</span> <span class="delimiter">”</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>很多时候，在编写测试时，转储执行的请求的结果很有用。您可以按如下方式执行此操作，其中<code>print()</code>是来自<code>MockMvcResultHandlers</code>的静态导入：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（post（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ））。and Do（print（））。and Expect（status（）。isOk（））。and Expect（model（）。attributeHasErrors（ <span class="string"><span class="delimiter">“</span> <span class="content">person</span> <span class="delimiter">”</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>只要请求处理不会导致未处理的异常， <code>print()</code>方法就会将所有可用的结果数据打印到<code>System.out</code> 。Spring Framework 4.2引入了一个<code>log()</code>方法和<code>print()</code>方法的另外两个变体，一个接受<code>OutputStream</code> ，另一个接受<code>Writer</code> 。例如，调用<code>print(System.err)</code>将结果数据打印到<code>System.err</code> ，而调用<code>print(myWriter)</code>将结果数据打印到自定义<code>print(myWriter)</code> 。如果要记录结果数据而不是打印结果数据，可以调用<code>log()</code>方法，该方法将结果数据记录为<code>org.springframework.test.web.servlet.result</code>日志记录类别下的单个<code>DEBUG</code>消息。</p>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望直接访问结果并验证无法验证的内容。这可以通过在所有其他期望之后附加<code>.andReturn()</code>来实现，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MvcResult mvcResult = mockMvc.perform（post（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ））。andExpect（status（）。isOk（））。andReturn（）; <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果所有测试都重复相同的期望，则可以在构建<code>MockMvc</code>实例时设置一次共同期望，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">standaloneSetup（ <span class="keyword">new</span> SimpleController（））。alwaysExpect（status（）。isOk（））。roundwaysExpect（content（）。contentType（ <span class="string"><span class="delimiter">“</span> <span class="content">application / json; charset = UTF-8</span> <span class="delimiter">”</span></span> ））。build（）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，如果不创建单独的<code>MockMvc</code>实例，则始终应用常见期望并且无法覆盖。</p>
</div>
<div class="paragraph">
<p>当JSON响应内容包含使用<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时，您可以使用JsonPath表达式验证生成的链接，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ people</span> <span class="delimiter">”</span></span> ）。accept（MediaType。APPLICATION_JSON））。and Expect（jsonPath（ <span class="string"><span class="delimiter">“</span> <span class="content">$ .links [？（@ .rel =='self'）]。href</span> <span class="delimiter">“</span></span> ）。value（ <span class="string"><span class="delimiter">”</span> <span class="content">http：// localhost：8080 / people</span> <span class="delimiter">“</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当XML响应内容包含使用<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时，您可以使用XPath表达式验证生成的链接：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; ns = <span class="predefined-type">Collections</span> .singletonMap（ <span class="string"><span class="delimiter">“</span> <span class="content">ns</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2005/Atom</span> <span class="delimiter">”</span></span> ）; mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ handle</span> <span class="delimiter">”</span></span> ）。accept（MediaType。APPLICATION_XML））。andExpect（xpath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person / ns：link [@ rel ='self'] / @ href</span> <span class="delimiter">”</span></span> ，ns）.string（ <span class="string"><span class="delimiter">“</span> <span class="content">http：// localhost：8080 / people</span> <span class="delimiter">”</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-filters"><a class="anchor" href="#spring-mvc-test-server-filters"></a>过滤注册</h5>
<div class="paragraph">
<p>设置<code>MockMvc</code>实例时，可以注册一个或多个Servlet <code>Filter</code>实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc = standaloneSetup（ <span class="keyword">new</span> PersonController（））。addFilters（ <span class="keyword">new</span> CharacterEncodingFilter（））。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注册过滤器通过<code>spring-test</code>的<code>MockFilterChain</code>调用，最后一个过滤器委托给<code>DispatcherServlet</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-end-to-end-integration-tests"><a class="anchor" href="#spring-mvc-test-vs-end-to-end-integration-tests"></a>容器外和端到端集成测试之间的差异</h5>
<div class="paragraph">
<p>如前所述，Spring MVC Test构建于<code>spring-test</code>模块的Servlet API模拟对象之上，并不使用正在运行的Servlet容器。因此，与实际客户端和服务器运行的完整端到端集成测试相比，存在一些重要差异。</p>
</div>
<div class="paragraph">
<p>考虑这一点的最简单方法是从空白的<code>MockHttpServletRequest</code> 。无论你添加什么是请求变成什么。可能会让您感到意外的事情是默认情况下没有上下文路径;没有<code>jsessionid</code> cookie;没有转发，错误或异步调度;因此，没有实际的JSP渲染。相反，“转发”和“重定向”URL保存在<code>MockHttpServletResponse</code>并且<code>MockHttpServletResponse</code>期望。</p>
</div>
<div class="paragraph">
<p>这意味着，如果使用JSP，则可以验证请求转发到的JSP页面，但不呈现HTML。换句话说，不调用JSP。但请注意，所有其他不依赖转发的渲染技术（如Thymeleaf和Freemarker）都会按预期将HTML呈现给响应主体。通过<code>@ResponseBody</code>方法渲染JSON，XML和其他格式<code>@ResponseBody</code> 。</p>
</div>
<div class="paragraph">
<p>或者，您可以考虑使用<code>@WebIntegrationTest</code>从Spring Boot获得完整的端到端集成测试支持。请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications">Spring Boot参考指南</a> 。</p>
</div>
<div class="paragraph">
<p>每种方法都有利弊。Spring MVC Test中提供的选项在从经典单元测试到完全集成测试的规模上是不同的停止。可以肯定的是，Spring MVC Test中没有一个选项属于经典单元测试类别，但它们更接近它。例如，您可以通过将模拟服务注入控制器来隔离Web层，在这种情况下，您只通过<code>DispatcherServlet</code>测试Web层，但使用实际的Spring配置，因为您可以单独测试数据访问层与其上面的层。此外，您可以使用独立设置，一次关注一个控制器并手动提供使其工作所需的配置。</p>
</div>
<div class="paragraph">
<p>使用Spring MVC Test时的另一个重要区别是，从概念上讲，这样的测试是服务器端，因此您可以检查使用了什么处理程序，是否使用HandlerExceptionResolver处理异常，模型的内容是什么，绑定错误是什么有，和其他细节。这意味着编写期望更容易，因为服务器不是黑盒子，就像通过实际的HTTP客户端测试它一样。这通常是经典单元测试的一个优点：它更容易编写，推理和调试，但不能取代完全集成测试的需要。同时，重要的是不要忽视响应是最重要的检查事实。简而言之，即使在同一个项目中，也存在多种样式和测试策略的空间。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-resources"><a class="anchor" href="#spring-mvc-test-server-resources"></a>进一步的服务器端测试示例</h5>
<div class="paragraph">
<p>框架自己的测试包括<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">许多样本测试，</a>旨在展示如何使用Spring MVC测试。您可以浏览这些示例以获取更多想法。此外， <a href="https://github.com/spring-projects/spring-mvc-showcase"><code>spring-mvc-showcase</code></a>项目具有基于Spring MVC Test的完整测试覆盖率。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server-htmlunit"><a class="anchor" href="#spring-mvc-test-server-htmlunit"></a> 3.6.2。HtmlUnit集成</h4>
<div class="paragraph">
<p>Spring提供了<a href="#spring-mvc-test-server">MockMvc</a>和<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>之间的集成。这简化了使用基于HTML的视图时执行端到端测试的过程。这种集成让您：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a> ， <a href="http://seleniumhq.org/projects/webdriver/">WebDriver</a>和<a href="http://www.gebish.org/manual/current/testing.html#spock_junit__testng">Geb</a>等工具轻松测试HTML页面，而无需部署到Servlet容器。</p>
</li>
<li>
<p>在页面中测试JavaScript。</p>
</li>
<li>
<p>（可选）使用模拟服务进行测试以加快测试速度。</p>
</li>
<li>
<p>在容器内端到端测试和容器外集成测试之间共享逻辑。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">MockMvc使用不依赖于Servlet容器的模板技术（例如，Thymeleaf，FreeMarker等），但它不适用于JSP，因为它们依赖于Servlet容器。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why"></a>为何选择HtmlUnit？</h5>
<div class="paragraph">
<p>想到的最明显的问题是“为什么我需要这个？”通过探索一个非常基本的示例应用程序可以找到答案。假设您有一个Spring MVC Web应用程序，它支持<code>Message</code>对象上的CRUD操作。该应用程序还支持分页所有消息。你会如何测试它？</p>
</div>
<div class="paragraph">
<p>使用Spring MVC Test，我们可以轻松测试是否能够创建<code>Message</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MockHttpServletRequestBuilder的CreateMessage =后（ <span class="string"><span class="content"><span class="delimiter">“/</span>消息<span class="delimiter">/”）.PARAM（</span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">摘要</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">春岩</span> <span class="delimiter">”）.PARAM（</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">文字</span></span> <span class="string"><span class="string"><span class="delimiter"><span class="delimiter">”，“</span></span></span> <span class="content">如果你不知道，春岩！</span><span class="delimiter">“</span></span> ）; mockMvc.perform（createMessage）.andExpect（status（）。is3xxRedirection（））。and Expect（redirectedUrl（ <span class="string"><span class="delimiter">”</span> <span class="content">/ messages / 123</span> <span class="delimiter">“</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们要测试允许我们创建消息的表单视图，该怎么办？例如，假设我们的表单看起来像以下代码段：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;表格</span> <span class="attribute-name">ID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“messageForm”</span></span></span></span> <span class="attribute-name">行动</span> = <span class="string"><span class="content"><span class="delimiter">“/</span>消息<span class="delimiter">/”</span></span></span> <span class="attribute-name">方法</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“POST”&gt;</span></span></span></span></span> <span class="tag">&lt;DIV</span> <span class="attribute-name">类</span> = <span class="string"><span class="delimiter">“</span> <span class="content">右拉</span> <span class="delimiter"><span class="tag">”&gt;</span></span></span> <span class="tag">&lt;a</span> <span class="attribute-name">HREF</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“/messages/”&gt;</span></span></span></span></span>消息<span class="tag">&lt;/A&gt;</span> <span class="tag">&lt;/ DIV&gt;</span> <span class="tag">&lt; label</span> <span class="attribute-name">for</span> = <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>摘要<span class="tag">&lt;/ label&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">required</span> <span class="delimiter">”</span></span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;label</span> <span class="attribute-name">for</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span>消息<span class="tag">&lt; / label&gt;</span> <span class="tag">&lt;textarea</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;/ textarea&gt;</span> <span class="tag">&lt;div</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">form-actions</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;input</span> <span class="attribute-name">type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Create</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ div&gt;</span> <span class="tag">&lt;/形式&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们如何确保我们的表单产生正确的请求以创建新消息？天真的尝试可能类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ messages / form</span> <span class="delimiter">”</span></span> ））。and Expect（xpath（ <span class="string"><span class="delimiter">“</span> <span class="content">// input [@ name ='summary']</span> <span class="delimiter">”</span></span> ）。exists（））。and Expect（xpath（ <span class="string"><span class="delimiter">“</span> <span class="content">// textarea [@name ='text']</span> <span class="delimiter">“</span></span> ）.exists（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该测试有一些明显的缺点。如果我们更新控制器以使用参数<code>message</code>而不是<code>text</code> ，我们的表单测试将继续通过，即使HTML表单与控制器不同步。要解决这个问题，我们可以结合两个测试，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div id="spring-mvc-test-server-htmlunit-mock-mvc-test" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> summaryParamName = <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> ; <span class="predefined-type">String</span> textParamName = <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> ; mockMvc.perform（get（ <span class="string"><span class="delimiter">“</span> <span class="content">/ messages / form</span> <span class="delimiter">”</span></span> ））。and Expect（xpath（ <span class="string"><span class="delimiter">“</span> <span class="content">// input [@ name ='</span> <span class="delimiter">”</span></span> + summaryParamName + <span class="string"><span class="delimiter">“</span> <span class="content">']</span> <span class="delimiter">”</span></span> ）。exists（））。and Expect（xpath（ <span class="string"><span class="delimiter">“</span> <span class="content">// textarea [@ name ='</span> <span class="delimiter">“</span></span> + textParamName + <span class="string"><span class="delimiter">”</span> <span class="content">']</span> <span class="delimiter">“</span></span> ）.exists（））; MockHttpServletRequestBuilder的CreateMessage =后（ <span class="string"><span class="content"><span class="delimiter">“/</span>消息<span class="delimiter">/”）.PARAM（summaryParamName，</span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">春岩</span></span> <span class="string"><span class="string"><span class="delimiter"><span class="delimiter">”）.PARAM（textParamName，“</span></span></span> <span class="content">如果你不知道，春岩！</span><span class="delimiter">“</span></span> ）; mockMvc.perform（createMessage）.andExpect（status（）。is3xxRedirection（））。and Expect（redirectedUrl（ <span class="string"><span class="delimiter">”</span> <span class="content">/ messages / 123</span> <span class="delimiter">“</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样可以降低我们测试错误传递的风险，但仍然存在一些问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果我们的页面上有多个表单怎么办？不可否认，我们可以更新我们的XPath表达式，但是由于我们考虑了更多因素，它们变得更加复杂：字段是否是正确的类型？字段是否已启用？等等。</p>
</li>
<li>
<p>另一个问题是我们正在做的工作量是我们预期的两倍。我们必须首先验证视图，然后我们使用我们刚刚验证的相同参数提交视图。理想情况下，这可以一次完成。</p>
</li>
<li>
<p>最后，我们仍然无法解释一些事情。例如，如果表单具有我们希望测试的JavaScript验证，该怎么办？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>总体问题是测试网页不涉及单个交互。相反，它是用户如何与网页交互以及该网页如何与其他资源交互的组合。例如，表单视图的结果用作用户输入以创建消息。此外，我们的表单视图可能会使用影响页面行为的其他资源，例如JavaScript验证。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-integration"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-integration"></a>集成测试到救援？</h6>
<div class="paragraph">
<p>为解决前面提到的问题，我们可以执行端到端集成测试，但这有一些缺点。考虑测试让我们浏览消息的视图。我们可能需要以下测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们的页面是否向用户显示通知，指示消息为空时没有结果可用？</p>
</li>
<li>
<p>我们的页面是否正确显示单个消息？</p>
</li>
<li>
<p>我们的页面是否正确支持分页？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要设置这些测试，我们需要确保我们的数据库包含正确的消息。这导致了许多额外的挑战：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保数据库中存在正确的消息可能很繁琐。（考虑外键约束。）</p>
</li>
<li>
<p>测试可能会变慢，因为每个测试都需要确保数据库处于正确的状态。</p>
</li>
<li>
<p>由于我们的数据库需要处于特定状态，因此我们无法并行运行测试。</p>
</li>
<li>
<p>对自动生成的ID，时间戳等项目执行断言可能很困难。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些挑战并不意味着我们应该放弃端到端的集成测试。相反，我们可以通过重构我们的详细测试来减少端到端集成测试的数量，以使用运行速度更快，更可靠且没有副作用的模拟服务。然后，我们可以实现少量真正的端到端集成测试，以验证简单的工作流程，以确保一切正常工作。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-mockmvc"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-mockmvc"></a>输入HtmlUnit Integration</h6>
<div class="paragraph">
<p>那么我们如何才能在测试页面交互之间取得平衡并在测试套件中保持良好的性能呢？答案是：“通过将MockMvc与HtmlUnit集成。”</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-options"><a class="anchor" href="#spring-mvc-test-server-htmlunit-options"></a> HtmlUnit集成选项</h6>
<div class="paragraph">
<p>当您想要将MockMvc与HtmlUnit集成时，您有许多选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc和HtmlUnit</a> ：如果要使用原始HtmlUnit库，请使用此选项。</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc和WebDriver</a> ：使用此选项可以简化集成和端到端测试之间的开发和重用代码。</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc和Geb</a> ：如果要在集成和端到端测试之间使用Groovy进行测试，简化开发和重用代码，请使用此选项。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-mah"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah"></a> MockMvc和HtmlUnit</h5>
<div class="paragraph">
<p>本节介绍如何集成MockMvc和HtmlUnit。如果要使用原始HtmlUnit库，请使用此选项。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-setup"></a> MockMvc和HtmlUnit设置</h6>
<div class="paragraph">
<p>首先，确保在<code>net.sourceforge.htmlunit:htmlunit</code>包含了测试依赖<code>net.sourceforge.htmlunit:htmlunit</code> 。为了将HtmlUnit与Apache HttpComponents 4.5+一起使用，您需要使用HtmlUnit 2.18或更高版本。</p>
</div>
<div class="paragraph">
<p>我们可以很容易地创建一个的HtmlUnit <code>WebClient</code> ，通过使用与MockMvc集成<code>MockMvcWebClientBuilder</code> ，具体如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span> WebApplicationContext上下文; WebClient webClient; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{webClient = MockMvcWebClientBuilder .webAppContextSetup（context）.build（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是使用<code>MockMvcWebClientBuilder</code>一个简单示例。有关高级用法，请参阅<a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">高级<code>MockMvcWebClientBuilder</code></a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这可确保将任何引用<code>localhost</code>作为服务器的URL定向到我们的<code>MockMvc</code>实例，而无需真正的HTTP连接。正常情况下，使用网络连接请求任何其他URL。这让我们可以轻松测试CDN的使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-usage"></a> MockMvc和HtmlUnit用法</h6>
<div class="paragraph">
<p>现在我们可以像往常一样使用HtmlUnit，但不需要将我们的应用程序部署到Servlet容器。例如，我们可以请求视图使用以下内容创建消息：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HtmlPage createMsgFormPage = webClient.getPage（ <span class="string"><span class="delimiter">“</span> <span class="content">http：// localhost / messages / form</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认上下文路径为<code>""</code> 。或者，我们可以指定上下文路径，如<a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一旦我们引用了<code>HtmlPage</code> ，我们就可以填写表单并提交它以创建消息，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HtmlForm form = createMsgFormPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">messageForm</span> <span class="delimiter">”</span></span> ）; HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> ）; summaryInput.setValueAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">Spring Rocks</span> <span class="delimiter">”</span></span> ）; HtmlTextArea textInput = createMsgFormPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> ）; textInput.setText（ <span class="string"><span class="delimiter">“</span> <span class="content">如果你不知道，Spring Rocks！</span><span class="delimiter">“</span></span> ）; HtmlSubmitInput submit = form.getOneHtmlElementByAttribute（ <span class="string"><span class="delimiter">”</span> <span class="content">input</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">type</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">submit</span> <span class="delimiter">“</span></span> ）; HtmlPage newMessagePage = submit.click（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，我们可以验证是否已成功创建新消息。以下断言使用<a href="http://joel-costigliola.github.io/assertj/">AssertJ</a>库：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">assertThat（newMessagePage.getUrl（）。toString（））。endsWith（ <span class="string"><span class="delimiter">“</span> <span class="content">/ messages / 123</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> id = newMessagePage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ）。getTextContent（）; assertThat（id）.isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> summary = newMessagePage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> ）。getTextContent（）; assertThat（summary）.isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">Spring Rocks</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> text = newMessagePage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">text</span> <span class="delimiter">”</span></span> ）。getTextContent（）; assertThat（text）.isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">如果你不知道，Spring Rocks！</span><span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述代码以多种方式改进了我们的<a href="#spring-mvc-test-server-htmlunit-mock-mvc-test">MockMvc测试</a> 。首先，我们不再需要显式验证我们的表单，然后创建一个看起来像表单的请求。相反，我们请求表单，填写表单并提交表单，从而显着减少开销。</p>
</div>
<div class="paragraph">
<p>另一个重要因素是<a href="http://htmlunit.sourceforge.net/javascript.html">HtmlUnit使用Mozilla Rhino引擎</a>来评估JavaScript。这意味着我们还可以在页面中测试JavaScript的行为。</p>
</div>
<div class="paragraph">
<p>有关使用HtmlUnit的其他信息，请参阅<a href="http://htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit文档</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-advanced-builder"></a>高级<code>MockMvcWebClientBuilder</code></h6>
<div class="paragraph">
<p>在目前为止的示例中，我们以最简单的方式使用<code>MockMvcWebClientBuilder</code> ，方法是基于Spring TestContext Framework为我们加载的<code>WebApplicationContext</code>构建<code>WebClient</code> 。在以下示例中重复此方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span> WebApplicationContext上下文; WebClient webClient; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{webClient = MockMvcWebClientBuilder .webAppContextSetup（context）.build（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还可以指定其他配置选项，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient webClient; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{webClient = MockMvcWebClientBuilder <span class="comment">//演示应用MockMvcConfigurer（Spring Security）</span> .webAppContextSetup（context，springSecurity（）） <span class="comment">//仅供参考 - 默认为“”</span> .contextPath（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="comment">//默认情况下MockMvc仅用于localhost;</span> <span class="comment">//以下将使用MockMvc作为example.com和example.org</span> .useMockMvcForHosts（ <span class="string"><span class="delimiter">“</span> <span class="content">example.com</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">example.org</span> <span class="delimiter">”</span></span> ）。build（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>作为替代方案，我们可以通过单独配置<code>MockMvc</code>实例并将其提供给<code>MockMvcWebClientBuilder</code>来执行完全相同的设置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MockMvc mockMvc = MockMvcBuilders .webAppContextSetup（context）.apply（springSecurity（））。build（）; webClient = MockMvcWebClientBuilder .mockMvcSetup（mockMvc） <span class="comment">//仅供参考 - 默认为“”</span> .contextPath（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="comment">//默认情况下，MockMvc仅用于localhost;</span> <span class="comment">//以下将使用MockMvc作为example.com和example.org</span> .useMockMvcForHosts（ <span class="string"><span class="delimiter">“</span> <span class="content">example.com</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">example.org</span> <span class="delimiter">”</span></span> ）。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这更加冗长，但是，通过使用<code>MockMvc</code>实例构建<code>WebClient</code> ，我们可以<code>MockMvc</code>获得<code>MockMvc</code>的全部功能。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关创建<code>MockMvc</code>实例的其他信息，请参阅“ <a href="#spring-mvc-test-server-setup-options">安装选择”</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-webdriver"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver"></a> MockMvc和WebDriver</h5>
<div class="paragraph">
<p>在前面的部分中，我们已经了解了如何将MockMvc与原始HtmlUnit API结合使用。在本节中，我们使用Selenium <a href="http://docs.seleniumhq.org/projects/webdriver/">WebDriver中的</a>其他抽象来使事情变得更加容易。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-why"></a>为什么选择WebDriver和MockMvc？</h6>
<div class="paragraph">
<p>我们已经可以使用HtmlUnit和MockMvc了，为什么我们要使用WebDriver呢？Selenium WebDriver提供了一个非常优雅的API，可以让我们轻松地组织我们的代码。为了更好地展示它的工作原理，我们将在本节中探讨一个示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管是<a href="http://docs.seleniumhq.org/">Selenium</a>的一部分，但WebDriver不需要Selenium Server来运行您的测试。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>假设我们需要确保正确创建消息。测试涉及查找HTML表单输入元素，填写它们以及进行各种断言。</p>
</div>
<div class="paragraph">
<p>这种方法导致许多单独的测试，因为我们也想测试错误条件。例如，如果我们只填写表单的一部分，我们希望确保收到错误。如果我们填写整个表单，则应在之后显示新创建的消息。</p>
</div>
<div class="paragraph">
<p>如果其中一个字段被命名为“summary”，我们可能会在我们的测试中有多个类似于以下重复的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HtmlTextInput summaryInput = currentPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> ）; summaryInput.setValueAttribute（摘要）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>那么如果我们将<code>id</code>更改为<code>smmry</code>会发生什么？这样做会迫使我们更新所有测试以包含此更改。这违反了DRY原则，因此我们理想情况下应将此代码提取到自己的方法中，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> HtmlPage createMessage（HtmlPage currentPage， <span class="predefined-type">String</span> summary， <span class="predefined-type">String</span> text）{setSummary（currentPage，summary）; <span class="comment">// ...</span><span class="directive">public</span> <span class="type">void</span> setSummary（HtmlPage currentPage， <span class="predefined-type">String</span> summary）{HtmlTextInput summaryInput = currentPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> ）; summaryInput.setValueAttribute（摘要）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样做可确保我们在更改UI时不必更新所有测试。</p>
</div>
<div class="paragraph">
<p>我们甚至可以更进一步，将此逻辑放在一个<code>Object</code> ，该<code>Object</code>表示我们当前所在的<code>HtmlPage</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CreateMessagePage</span> { <span class="directive">final</span> HtmlPage currentPage; <span class="directive">final</span> HtmlTextInput summaryInput; <span class="directive">最后的</span> HtmlSubmitInput提交; <span class="directive">public</span> CreateMessagePage（HtmlPage currentPage）{ <span class="local-variable">this</span> .currentPage = currentPage; <span class="local-variable">this</span> .summaryInput = currentPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">summary</span> <span class="delimiter">”</span></span> ）; <span class="local-variable">这个</span> .submit = currentPage.getHtmlElementById（ <span class="string"><span class="delimiter">“</span> <span class="content">submit</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> &lt;T&gt; T createMessage（ <span class="predefined-type">String</span> summary， <span class="predefined-type">String</span> text） <span class="directive">throws</span> <span class="exception">Exception</span> {setSummary（summary）; HtmlPage result = submit.click（）; <span class="type">boolean</span> error = CreateMessagePage.at（result）; <span class="keyword">返回</span> （T）（错误？<span class="keyword">new</span> CreateMessagePage（result）： <span class="keyword">new</span> ViewMessagePage（result））; <span class="directive">public</span> <span class="type">void</span> setSummary（ <span class="predefined-type">String</span> summary） <span class="directive">throws</span> <span class="exception">Exception</span> {summaryInput.setValueAttribute（summary）; <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> at（HtmlPage page）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">Create Message</span> <span class="delimiter">”</span></span> .equals（page.getTitleText（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以前，这种模式称为<a href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects">页面对象模式</a> 。虽然我们当然可以使用HtmlUnit执行此操作，但WebDriver提供了一些我们在以下部分中探讨的工具，以使此模式更容易实现。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-setup"></a> MockMvc和WebDriver设置</h6>
<div class="paragraph">
<p>要将Selenium WebDriver与Spring MVC Test框架一起使用，请确保您的项目包含对<code>org.seleniumhq.selenium:selenium-htmlunit-driver</code>的测试依赖<code>org.seleniumhq.selenium:selenium-htmlunit-driver</code> 。</p>
</div>
<div class="paragraph">
<p>我们可以很容易地创建一个硒的webdriver通过使用与MockMvc集成<code>MockMvcHtmlUnitDriverBuilder</code>如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Autowired</span> WebApplicationContext上下文; WebDriver驱动程序; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{driver = MockMvcHtmlUnitDriverBuilder .webAppContextSetup（context）.build（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是使用<code>MockMvcHtmlUnitDriverBuilder</code>的简单示例。有关更高级的用法，请参阅<a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">高级<code>MockMvcHtmlUnitDriverBuilder</code></a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的示例确保将任何引用<code>localhost</code>作为服务器的URL定向到我们的<code>MockMvc</code>实例，而无需真正的HTTP连接。正常情况下，使用网络连接请求任何其他URL。这让我们可以轻松测试CDN的使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-usage"></a> MockMvc和WebDriver用法</h6>
<div class="paragraph">
<p>现在我们可以像往常一样使用WebDriver，但不需要将我们的应用程序部署到Servlet容器。例如，我们可以请求视图使用以下内容创建消息：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">CreateMessagePage page = CreateMessagePage.to（driver）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后我们可以填写表单并提交它以创建消息，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ViewMessagePage viewMessagePage = page.createMessage（ViewMessagePage.class，expectedSummary，expectedText）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这通过利用页面对象模式改进了<a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit测试</a>的设计。正如我们在<a href="#spring-mvc-test-server-htmlunit-webdriver-why">为什么选择WebDriver和MockMvc？</a> ，我们可以将页面对象模式与HtmlUnit一起使用，但使用WebDriver会更容易。请考虑以下<code>CreateMessagePage</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CreateMessagePage</span> <span class="directive">扩展</span> AbstractPage { <i class="conum" data-value="1"></i> <b>（1）</b> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">私有</span> WebElement摘要; <span class="directive">私有</span> WebElement文本; <i class="conum" data-value="3"></i> <b>（3）</b> <span class="annotation">@FindBy</span> （css = <span class="string"><span class="delimiter">“</span> <span class="content">input [type = submit]</span> <span class="delimiter">”</span></span> ） <span class="directive">私有</span> WebElement提交; <span class="directive">public</span> CreateMessagePage（WebDriver driver）{ <span class="local-variable">super</span> （driver）; <span class="directive">public</span> &lt;T&gt; T createMessage（ <span class="predefined-type">Class</span> &lt;T&gt; resultPage， <span class="predefined-type">String</span> summary， <span class="predefined-type">String</span> details）{ <span class="local-variable">this</span> .summary.sendKeys（summary）; <span class="local-variable">这个</span> .text.sendKeys（详情）; <span class="local-variable">这个</span> .submit.click（）; <span class="keyword">return</span> PageFactory.initElements（driver，resultPage）; <span class="directive">public</span> <span class="directive">static</span> CreateMessagePage to（WebDriver driver）{driver.get（ <span class="string"><span class="delimiter">“</span> <span class="content">http：// localhost：9990 / mail / messages / form</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> PageFactory.initElements（driver，CreateMessagePage.class）; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>CreateMessagePage</code>扩展了<code>AbstractPage</code> 。我们不会详细介绍<code>AbstractPage</code> ，但总的来说，它包含了我们所有页面的常用功能。例如，如果我们的应用程序具有导航栏，全局错误消息和其他功能，我们可以将此逻辑放在共享位置。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们有一个成员变量，用于我们感兴趣的HTML页面的每个部分。这些是<code>WebElement</code>类型。WebDriver的<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a>允许我们通过自动解析每个<code>WebElement</code>从HtmlUnit版本的<code>CreateMessagePage</code>删除大量代码。<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>方法使用字段名称自动解析每个<code>WebElement</code> ，并通过HTML页面中元素的<code>id</code>或<code>name</code>查找它。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以使用<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code>批注</a>来覆盖默认的查找行为。我们的示例演示了如何使用<code>@FindBy</code>批注查找带有<code>css</code>选择器的提交按钮（ <strong>input [type = submit]</strong> ）。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，我们可以验证是否已成功创建新消息。以下断言使用<a href="http://joel-costigliola.github.io/assertj/">AssertJ</a>断言库：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">assertThat（viewMessagePage.getMessage（））isEqualTo（expectedMessage）。 assertThat（viewMessagePage.getSuccess（））。isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">成功创建新消息</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以看到我们的<code>ViewMessagePage</code>允许我们与自定义域模型进行交互。例如，它公开了一个返回<code>Message</code>对象的方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> Message getMessage（） <span class="directive">throws</span> <span class="exception">ParseException</span> {Message message = <span class="keyword">new</span> Message（）; message.setId（的getId（））; message.setCreated（getCreated（））; message.setSummary（getSummary（））; message.setText（的getText（））; <span class="keyword">返回</span>消息; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后我们可以在断言中使用富域对象。</p>
</div>
<div class="paragraph">
<p>最后，我们不要忘记在测试完成时关闭<code>WebDriver</code>实例，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@After</span> <span class="directive">public</span> <span class="type">void</span> destroy（）{ <span class="keyword">if</span> （driver！）= <span class="predefined-constant">null</span> ）{driver.close（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关使用WebDriver的其他信息，请参阅Selenium <a href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started">WebDriver文档</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder"></a>高级<code>MockMvcHtmlUnitDriverBuilder</code></h6>
<div class="paragraph">
<p>在到目前为止的示例中，我们通过构建基于Spring TestContext Framework为我们加载的<code>WebApplicationContext</code>的<code>WebDriver</code> ，以最简单的方式使用了<code>MockMvcHtmlUnitDriverBuilder</code> 。这里重复这种方法，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span> WebApplicationContext上下文; WebDriver驱动程序; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{driver = MockMvcHtmlUnitDriverBuilder .webAppContextSetup（context）.build（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还可以指定其他配置选项，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebDriver驱动程序; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setup（）{driver = MockMvcHtmlUnitDriverBuilder <span class="comment">//演示应用MockMvcConfigurer（Spring Security）</span> .webAppContextSetup（context，springSecurity（）） <span class="comment">//仅供参考 - 默认为“”</span> .contextPath（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="comment">//默认情况下MockMvc仅用于localhost;</span> <span class="comment">//以下将使用MockMvc作为example.com和example.org</span> .useMockMvcForHosts（ <span class="string"><span class="delimiter">“</span> <span class="content">example.com</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">example.org</span> <span class="delimiter">”</span></span> ）。build（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>作为替代方案，我们可以通过单独配置<code>MockMvc</code>实例并将其提供给<code>MockMvcHtmlUnitDriverBuilder</code>来执行完全相同的设置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MockMvc mockMvc = MockMvcBuilders .webAppContextSetup（context）.apply（springSecurity（））。build（）; driver = MockMvcHtmlUnitDriverBuilder .mockMvcSetup（mockMvc） <span class="comment">//仅供参考 - 默认为“”</span> .contextPath（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ） <span class="comment">//默认情况下，MockMvc仅用于localhost;</span> <span class="comment">//以下将使用MockMvc作为example.com和example.org</span> .useMockMvcForHosts（ <span class="string"><span class="delimiter">“</span> <span class="content">example.com</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">example.org</span> <span class="delimiter">”</span></span> ）。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这更详细，但是，通过使用<code>MockMvc</code>实例构建<code>WebDriver</code> ，我们可以<code>MockMvc</code>获得<code>MockMvc</code>的全部功能。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关创建<code>MockMvc</code>实例的其他信息，请参阅“ <a href="#spring-mvc-test-server-setup-options">安装选择”</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-geb"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb"></a> MockMvc和Geb</h5>
<div class="paragraph">
<p>在上一节中，我们了解了如何将MockMvc与WebDriver一起使用。在本节中，我们使用<a href="http://www.gebish.org/">Geb</a>使我们的测试甚至是Groovy-er。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-why"></a>为什么选择Geb和MockMvc？</h6>
<div class="paragraph">
<p>Geb由WebDriver支持，因此它提供了许多与WebDriver <a href="#spring-mvc-test-server-htmlunit-webdriver-why">相同的好处</a> 。但是，通过为我们处理一些样板代码，Geb使事情变得更加容易。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-setup"></a> MockMvc和Geb设置</h6>
<div class="paragraph">
<p>我们可以使用使用MockMvc的Selenium WebDriver轻松初始化Geb <code>Browser</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="function">setup</span> （）{browser.driver = MockMvcHtmlUnitDriverBuilder .webAppContextSetup（context）.build（）}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是使用<code>MockMvcHtmlUnitDriverBuilder</code>的简单示例。有关更高级的用法，请参阅<a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">高级<code>MockMvcHtmlUnitDriverBuilder</code></a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这可确保将引用<code>localhost</code>作为服务器的任何URL定向到我们的<code>MockMvc</code>实例，而无需真正的HTTP连接。正常使用网络连接请求任何其他URL。这让我们可以轻松测试CDN的使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-usage"></a> MockMvc和Geb用法</h6>
<div class="paragraph">
<p>现在我们可以像往常一样使用Geb，但不需要将我们的应用程序部署到Servlet容器。例如，我们可以请求视图使用以下内容创建消息：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">到CreateMessagePage</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后我们可以填写表单并提交它以创建消息，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="key">when</span> ：form.summary = expectedSummary form.text = expectedMessage submit.click（ViewMessagePage）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>任何未识别的方法调用或属性访问或未找到的引用都将转发到当前页面对象。这样就删除了直接使用WebDriver时需要的大量样板代码。</p>
</div>
<div class="paragraph">
<p>与直接使用WebDriver一样，这通过使用页面对象模式改进了<a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit测试</a>的设计。如前所述，我们可以将页面对象模式与HtmlUnit和WebDriver一起使用，但使用Geb更容易。考虑一下我们新的基于Groovy的<code>CreateMessagePage</code>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">类</span> <span class="class">CreateMessagePage</span> <span class="directive">延伸</span>页{ <span class="directive">静态</span> URL <span class="string"><span class="delimiter">=“</span> <span class="content">消息/形式</span> <span class="delimiter">”</span></span>在<span class="directive">静态</span> = { <span class="keyword">断言</span>标题<span class="string"><span class="delimiter">==“</span> <span class="content">消息：创建</span> <span class="delimiter">”;</span></span> <span class="predefined-constant">true</span> } <span class="directive">static</span> content = {submit { <span class="error">$</span> （ <span class="string"><span class="delimiter">'</span> <span class="content">input [type = submit]</span> <span class="delimiter">'</span></span> ）} form { <span class="error">$</span> （ <span class="string"><span class="delimiter">'</span> <span class="content">form</span> <span class="delimiter">'</span></span> ）} errors（ <span class="key">required</span> ： <span class="predefined-constant">false</span> ）{ <span class="error">$</span> （ <span class="string"><span class="delimiter">'</span> <span class="content">label.error，.alert-error</span> <span class="delimiter">'</span></span> ）？ .text（）}}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们的<code>CreateMessagePage</code>扩展了<code>Page</code> 。我们不会详细介绍<code>Page</code> ，但总的来说，它包含了我们所有页面的常用功能。我们定义了一个可以在其中找到此页面的URL。这让我们可以导航到页面，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">到CreateMessagePage</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还有一个<code>at</code>闭包，用于确定我们是否在指定页面。如果我们在正确的页面上，它应该返回<code>true</code> 。这就是为什么我们可以断言我们在正确的页面上，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="key">然后</span> ：在CreateMessagePage errors.contains（ <span class="string"><span class="delimiter">'</span> <span class="content">此字段是必需的。</span><span class="delimiter">'</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们在闭包中使用断言，这样我们就可以确定如果我们在错误的页面上出错了。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>接下来，我们创建一个<code>content</code>闭包，指定页面中所有感兴趣的区域。我们可以使用<a href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api">jQuery-ish Navigator API</a>来选择我们感兴趣的内容。</p>
</div>
<div class="paragraph">
<p>最后，我们可以验证是否已成功创建新消息，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="key">然后</span> ：在ViewMessagePage成功== <span class="string"><span class="delimiter">'</span> <span class="content">成功创建了一条新消息</span> <span class="delimiter">'</span></span> id date summary == expectedSummary message == expectedMessage</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关如何充分利用Geb的更多详细信息，请参阅<a href="http://www.gebish.org/manual/current/">The Book of Geb</a>用户手册。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-client"><a class="anchor" href="#spring-mvc-test-client"></a> 3.6.3。客户端REST测试</h4>
<div class="paragraph">
<p>您可以使用客户端测试来测试内部使用<code>RestTemplate</code>代码。我们的想法是声明预期的请求并提供“存根”响应，以便您可以专注于单独测试代码（即，无需运行服务器）。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate（）; MockRestServiceServer mockServer = MockRestServiceServer.bindTo（restTemplate）.build（）; mockServer.expect（requestTo（ <span class="string"><span class="delimiter">“</span> <span class="content">/ greeting</span> <span class="delimiter">”</span></span> ））。andRespond（withSuccess（））; <span class="comment">//测试使用上述RestTemplate的代码......</span>mockServer.verify（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>MockRestServiceServer</code> （客户端REST测试的中心类）使用自定义<code>ClientHttpRequestFactory</code>配置<code>RestTemplate</code> ，该客户<code>ClientHttpRequestFactory</code>根据预期断言实际请求并返回“存根”响应。在这种情况下，我们期望对<code>/greeting</code>发出请求，并希望返回带有<code>text/plain</code>内容的200响应。我们可以根据需要定义其他预期请求和存根响应。当我们定义期望的请求和存根响应时， <code>RestTemplate</code>可以像往常一样在客户端代码中使用。在测试结束时， <code>mockServer.verify()</code>可用于验证是否已满足所有期望。</p>
</div>
<div class="paragraph">
<p>默认情况下，请求按预期声明的顺序进行。您可以在构建服务器时设置<code>ignoreExpectOrder</code>选项，在这种情况下，将检查所有期望（按顺序）以查找给定请求的匹配项。这意味着允许请求以任何顺序出现。以下示例使用<code>ignoreExpectOrder</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">server = MockRestServiceServer.bindTo（restTemplate）.ignoreExpectOrder（ <span class="predefined-constant">true</span> ）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使默认情况下使用无序请求，每个请求也只允许执行一次。<code>expect</code>方法提供了一个重载变量，它接受指定计数范围的<code>ExpectedCount</code>参数（例如， <code>once</code> ， <code>manyTimes</code> ， <code>max</code> ， <code>min</code> ， <code>between</code>等）。以下示例使用<code>times</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate（）; MockRestServiceServer mockServer = MockRestServiceServer.bindTo（restTemplate）.build（）; mockServer.expect（times（ <span class="integer">2</span> ），requestTo（ <span class="string"><span class="delimiter">“</span> <span class="content">/ something</span> <span class="delimiter">”</span></span> ））。andRespond（withSuccess（））; mockServer.expect（times（ <span class="integer">3</span> ），requestTo（ <span class="string"><span class="delimiter">“</span> <span class="content">/ somewhere</span> <span class="delimiter">”</span></span> ））。andRespond（withSuccess（））; <span class="comment">// ...</span>mockServer.verify（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，如果未设置<code>ignoreExpectOrder</code> （默认值），因此，请求按声明顺序排列，则该顺序仅适用于任何预期请求中的第一个。例如，如果“/ something”预期两次，然后是“/ somewhere”三次，那么在“/ somewhere”请求之前应该有“/ something”的请求，但是，除了后续的“/”之外某些“和”/某处“，请求可以随时出现。</p>
</div>
<div class="paragraph">
<p>作为上述所有选项的替代方案，客户端测试支持还提供了<code>ClientHttpRequestFactory</code>实现，您可以将其配置为<code>RestTemplate</code>以将其绑定到<code>MockMvc</code>实例。这允许使用实际的服务器端逻辑处理请求但不运行服务器。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup（ <span class="local-variable">this</span> .wac）.build（）; <span class="local-variable">这个</span> .restTemplate = <span class="keyword">new</span> RestTemplate（ <span class="keyword">new</span> MockMvcClientHttpRequestFactory（mockMvc））; <span class="comment">//测试使用上述RestTemplate的代码......</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-client-static-imports"><a class="anchor" href="#spring-mvc-test-client-static-imports"></a>静态进口</h5>
<div class="paragraph">
<p>与服务器端测试一样，用于客户端测试的流畅API需要一些静态导入。通过搜索<code>MockRest*</code>很容易找到<code>MockRest*</code> 。Eclipse用户应该在Java→编辑器→内容辅助→收藏夹下的Eclipse首选项中添加<code>MockRestRequestMatchers.*</code>和<code>MockRestResponseCreators.*</code>作为“最喜欢的静态成员”。这允许在键入静态方法名称的第一个字符后使用内容辅助。其他IDE（例如IntelliJ）可能不需要任何其他配置。检查静态成员对代码完成的支持。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-client-resources"><a class="anchor" href="#spring-mvc-test-client-resources"></a>客户端REST测试的更多示例</h5>
<div class="paragraph">
<p>Spring MVC Test自己的测试包括客户端REST测试的<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples">示例</a>测试。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient"><a class="anchor" href="#webtestclient"></a> 3.7。WebTestClient</h3>
<div class="paragraph">
<p><code>WebTestClient</code>是围绕<a href="web-reactive.html#webflux-webclient">WebClient的</a>一个瘦shell，使用它来执行请求并公开一个专用的，流畅的API来验证响应。
<code>WebTestClient</code>通过使用<a href="#mock-objects-web-reactive">模拟请求和响应</a>绑定到WebFlux应用程序，或者它可以通过HTTP连接测试任何Web服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Kotlin用户：请参阅<a href="languages.html#kotlin-webtestclient-issue">本节</a>与<code>WebTestClient</code>使用相关的<code>WebTestClient</code> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="webtestclient-setup"><a class="anchor" href="#webtestclient-setup"></a> 3.7.1。建立</h4>
<div class="paragraph">
<p>要创建<code>WebTestClient</code>您必须选择多个服务器设置选项之一。实际上，您要么将WebFlux应用程序配置为绑定到，要么使用URL连接到正在运行的服务器。</p>
</div>
<div class="sect4">
<h5 id="webtestclient-controller-config"><a class="anchor" href="#webtestclient-controller-config"></a>绑定到控制器</h5>
<div class="paragraph">
<p>以下示例显示如何创建服务器设置以一次测试一个<code>@Controller</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client = WebTestClient.bindToController（ <span class="keyword">new</span> TestController（））。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例加载<a href="web-reactive.html#webflux-config">WebFlux Java配置</a>并注册给定的控制器。通过使用模拟请求和响应对象，在没有HTTP服务器的情况下测试生成的WebFlux应用程序。构建器上有更多方法可以自定义默认的WebFlux Java配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-fn-config"><a class="anchor" href="#webtestclient-fn-config"></a>绑定到路由器功能</h5>
<div class="paragraph">
<p>以下示例显示如何从<a href="web-reactive.html#webflux-fn">RouterFunction</a>设置服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction &lt;？&gt; route = ...client = WebTestClient.bindToRouterFunction（route）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在内部，配置传递给<code>RouterFunctions.toWebHandler</code> 。通过使用模拟请求和响应对象，在没有HTTP服务器的情况下测试生成的WebFlux应用程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-context-config"><a class="anchor" href="#webtestclient-context-config"></a>绑定到<code>ApplicationContext</code></h5>
<div class="paragraph">
<p>以下示例说明如何从应用程序的Spring配置或其某个子集设置服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@RunWith</span> （SpringRunner.class） <span class="annotation">@ContextConfiguration</span> （classes = WebConfig.class） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyTests</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> ApplicationContext context; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">私有</span> WebTestClient客户端; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setUp（）{client = WebTestClient.bindToApplicationContext（context）.build（）; <i class="conum" data-value="3"></i> <b>（3）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定要加载的配置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入配置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建<code>WebTestClient</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在内部，配置被传递给<code>WebHttpHandlerBuilder</code>以设置请求处理链。有关更多详细信息，请参阅<a href="web-reactive.html#webflux-web-handler-api">WebHandler API</a> 。通过使用模拟请求和响应对象，在没有HTTP服务器的情况下测试生成的WebFlux应用程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-server-config"><a class="anchor" href="#webtestclient-server-config"></a>绑定到服务器</h5>
<div class="paragraph">
<p>以下服务器设置选项允许您连接到正在运行的服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client = WebTestClient.bindToServer（）。baseUrl（ <span class="string"><span class="delimiter">“</span> <span class="content">http：// localhost：8080</span> <span class="delimiter">”</span></span> ）。build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-client-config"><a class="anchor" href="#webtestclient-client-config"></a> Client Builder</h5>
<div class="paragraph">
<p>除了前面介绍的服务器设置选项之外，您还可以配置客户端选项，包括基本URL，默认标头，客户端过滤器等。<code>bindToServer</code>可以使用这些选项。对于所有其他人，您需要使用<code>configureClient()</code>从服务器配置转换为客户端配置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client = WebTestClient.bindToController（ <span class="keyword">new</span> TestController（））。configureCompient（）。baseUrl（ <span class="string"><span class="delimiter">“</span> <span class="content">/ test</span> <span class="delimiter">”</span></span> ）。build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webtestclient-tests"><a class="anchor" href="#webtestclient-tests"></a> 3.7.2。写测试</h4>
<div class="paragraph">
<p><code>WebTestClient</code>是围绕<a href="web-reactive.html#webflux-webclient">WebClient</a>的瘦shell。它提供了一个相同的API，直到使用<code>exchange()</code>执行请求。在<code>exchange()</code>是用于验证响应的链式API工作流。</p>
</div>
<div class="paragraph">
<p>通常，您首先声明响应状态和标头，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / 1</span> <span class="delimiter">”</span></span> ）。accept（MediaType。APPLICATION_JSON_UTF8）.exchange（）。exppectStatus（）。isOk（）。exppectHeader（）。contentType（MediaType。APPLICATION_JSON_UTF8） <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后指定如何解码和使用响应正文：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectBody(Class&lt;T&gt;)</code> ：解码为单个对象。</p>
</li>
<li>
<p><code>expectBodyList(Class&lt;T&gt;)</code> ：将对象解码并收集到<code>List&lt;T&gt;</code> 。</p>
</li>
<li>
<p><code>expectBody()</code> ：为<a href="#webtestclient-json">JSON内容</a>或空体解码为<code>byte[]</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后你可以使用内置的断言为身体。以下示例显示了一种方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ）。exchange（）。exppectStatus（）。isOk（）。expectBodyList（Person.class）.hasSize（ <span class="integer">3</span> ）.contains（person）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以超越内置断言并创建自己的断言，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>client.get（）。uri（“/ persons / 1”）。expand（）。exppectStatus（）。isOk（）。exppectBody（Person.class）.consumeWith（result  - &gt; {// custom assertions（例如AssertJ））。 ..}）;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以退出工作流程并获得结果，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>EntityExchangeResult &lt;Person&gt; result = client.get（）。uri（“/ persons / 1”）。exchange（）。exppectStatus（）。isOk（）。appendBody（Person.class）.returnResult（）;</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">当您需要使用泛型解码为目标类型时，请查找接受<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/ParameterizedTypeReference.html"><code>ParameterizedTypeReference</code></a>而不是<code>Class&lt;T&gt;</code>的重载方法。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="webtestclient-no-content"><a class="anchor" href="#webtestclient-no-content"></a>无内容</h5>
<div class="paragraph">
<p>如果响应没有内容（或者您不关心它），请使用<code>Void.class</code> ，以确保释放资源。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / 123</span> <span class="delimiter">”</span></span> ）。exchange（）。exppectStatus（）。isNotFound（）。appendBody（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果要断言没有响应内容，可以使用类似于以下内容的代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.post（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ）。body（personMono，Person.class）.exchange（）。exppectStatus（）。isCreated（）。emerpectBody（）。isEmpty（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-json"><a class="anchor" href="#webtestclient-json"></a> JSON内容</h5>
<div class="paragraph">
<p>使用<code>expectBody()</code> ，响应将作为<code>byte[]</code> 。这对原始内容断言很有用。例如，您可以使用<a href="http://jsonassert.skyscreamer.org">JSONAssert</a>来验证JSON内容，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / 1</span> <span class="delimiter">”</span></span> ）。expand（）。exppectStatus（）。isOk（）。appendBody（）。json（ <span class="string"><span class="delimiter">“</span> <span class="content">{</span> <span class="char">\”</span> <span class="content">name</span> <span class="char">\“</span> <span class="content">：</span> <span class="char">\”</span> <span class="content">Jane</span> <span class="char">\“</span> <span class="content">}</span> <span class="delimiter">”</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<a href="https://github.com/jayway/JsonPath">JSONPath</a>表达式，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ）。exchange（）。exppectStatus（）。isOk（）。appendBody（）。jsonPath（ <span class="string"><span class="delimiter">“</span> <span class="content">$ [0] .name</span> <span class="delimiter">”</span></span> ）。isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">Jane</span> <span class="delimiter">”</span></span> ）。jsonPath （ <span class="string"><span class="delimiter">“</span> <span class="content">$ [1] .name</span> <span class="delimiter">”</span></span> ）。isEqualTo（ <span class="string"><span class="delimiter">“</span> <span class="content">Jason</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-stream"><a class="anchor" href="#webtestclient-stream"></a>流式响应</h5>
<div class="paragraph">
<p>要测试无限流（例如， <code>"text/event-stream"</code>或<code>"application/stream+json"</code> ），您需要在响应状态和标头断言之后立即退出链式API（通过使用<code>returnResult</code> ），如下所示示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FluxExchangeResult &lt;MyEvent&gt; result = client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ events</span> <span class="delimiter">”</span></span> ）。accept（TEXT_EVENT_STREAM）.exchange（）。exppectStatus（）。isOk（）.returnResult（MyEvent.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在您可以使用<code>Flux&lt;T&gt;</code> ，在它们到来时断言已解码的对象，然后在满足测试目标时取消。我们建议使用<code>reactor-test</code>模块中的<code>StepVerifier</code>来执行此操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt; <span class="predefined-type">Event</span> &gt; eventFux = result.getResponseBody（）; StepVerifier.create（eventFlux）.expectNext（person）.expectNextCount（ <span class="integer">4</span> ）.consumeNextWith（p  - &gt; ...）.thenCancel（）。verify（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-request-body"><a class="anchor" href="#webtestclient-request-body"></a>请求机构</h5>
<div class="paragraph">
<p>在构建请求时， <code>WebTestClient</code>提供了与<code>WebClient</code>相同的API，实现主要是简单的传递。有关如何使用正文准备请求的示例，请参阅<a href="web-reactive.html#webflux-client-body">WebClient文档</a> ，包括提交表单数据，多部分请求等。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing-examples-petclinic"><a class="anchor" href="#testing-examples-petclinic"></a> 3.8。PetClinic示例</h3>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-petclinic">GitHub上</a>提供的PetClinic应用程序在JUnit 4环境中显示了Spring TestContext Framework的几个特性。大多数测试功能都包含在<code>AbstractClinicTests</code> ，其部分列表如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit。Assert.assertEquals</span> ; <span class="comment">//导入...</span>

<span class="annotation">@ContextConfiguration</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="directive">抽象</span> <span class="type">类</span> <span class="class">AbstractClinicTests</span> <span class="directive">扩展</span> AbstractTransactionalJUnit4SpringContextTests { <i class="conum" data-value="2"></i> <b>（2）</b> <span class="annotation">@Autowired</span> <i class="conum" data-value="3"></i> <b>（3）</b> <span class="directive">保护</span>诊所; <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> getVets（）{ <span class="predefined-type">Collection</span> &lt;Vet&gt; vets = <span class="local-variable">this</span> .clinic.getVets（）; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">JDBC查询必须显示相同数量的</span></span> vets <span class="string"><span class="delimiter">”</span></span> ， <span class="local-variable">超级</span> .countRowsInTable（ <span class="string"><span class="delimiter">“</span> <span class="content">VETS</span> <span class="delimiter">”</span></span> ），vets.size（））; <i class="conum" data-value="4"></i> <b>（4）</b> Vet v1 = EntityUtils.getById（vets，Vet.class， <span class="integer">2</span> ）; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">Leary</span> <span class="delimiter">”</span></span> ，v1.getLastName（））; assertEquals（ <span class="integer">1</span> ，v1.getNrOfSpecialties（））; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">radiology</span> <span class="delimiter">”</span></span> ，（v1.getSpecialties（）。get（ <span class="integer">0</span> ））。getName（））; <span class="comment">// ...</span>} <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从默认位置加载应用程序上下文： <code>AbstractClinicTests-context.xml</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>此测试用例扩展了<code>AbstractTransactionalJUnit4SpringContextTests</code>类，从该类继承了依赖注入（通过<code>DependencyInjectionTestExecutionListener</code> ）和事务行为（通过<code>TransactionalTestExecutionListener</code> ）的配置。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>clinic</code>实例变量（正在测试的应用程序对象）由依赖注入通过<code>@Autowired</code>语义设置。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>getVets()</code>方法显示了如何使用继承的<code>countRowsInTable()</code>方法轻松验证给定表中的行数，从而验证正在测试的应用程序代码的正确行为。这允许更强的测试并减少对精确测试数据的依赖性。例如，您可以在数据库中添加其他行而不会破坏测试。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>与使用数据库的许多集成测试一样， <code>AbstractClinicTests</code>大多数测试依赖于在测试用例运行之前数据库中已存在的最小数据量。或者，您可以在测试用例的测试夹具设置中填充数据库（同样，在与测试相同的事务中）。</p>
</div>
<div class="paragraph">
<p>PetClinic应用程序支持三种数据访问技术：JDBC，Hibernate和JPA。通过在没有任何特定资源位置的情况下声明<code>@ContextConfiguration</code> ， <code>AbstractClinicTests</code>类的应用程序上下文从默认位置<code>AbstractClinicTests-context.xml</code>加载，该位置声明了一个公共<code>DataSource</code> 。子类指定必须声明<code>PlatformTransactionManager</code>其他上下文位置以及<code>Clinic</code>的具体实现。</p>
</div>
<div class="paragraph">
<p>例如，PetClinic测试的Hibernate实现包含以下实现。对于此示例， <code>HibernateClinicTests</code>不包含单行代码。我们只需声明<code>@ContextConfiguration</code> ，测试继承自<code>AbstractClinicTests</code> 。因为声明了<code>@ContextConfiguration</code>而没有任何特定的资源位置，所以Spring TestContext Framework从<code>AbstractClinicTests-context.xml</code> （即继承的位置）和<code>HibernateClinicTests-context.xml</code>定义的所有bean加载应用程序上下文，并使用<code>HibernateClinicTests-context.xml</code>可能覆盖<code>AbstractClinicTests-context.xml</code>定义的bean。以下清单显示了<code>HibernateClinicTests</code>类的定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ContextConfiguration</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">HibernateClinicTests</span> <span class="directive">扩展</span> AbstractClinicTests {}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从<code>AbstractClinicTests-context.xml</code>和<code>HibernateClinicTests-context.xml</code>加载应用程序上下文。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在大型应用程序中，Spring配置通常分为多个文件。因此，配置位置通常在所有特定于应用程序的集成测试的公共基类中指定。这样的基类还可以添加有用的实例变量（自然地由依赖注入填充），例如在使用Hibernate的应用程序的情况下的<code>SessionFactory</code> 。</p>
</div>
<div class="paragraph">
<p>您应尽可能在集成测试中使用与部署环境中完全相同的Spring配置文件。一个可能的差异点涉及数据库连接池和事务基础结构。如果要部署到成熟的应用程序服务器，则可能使用其连接池（可通过JNDI获得）和JTA实现。因此，在生产中，您可以为<code>DataSource</code>和<code>JtaTransactionManager</code>使用<code>JndiObjectFactoryBean</code>或<code>&lt;jee:jndi-lookup&gt;</code> 。JNDI和JTA不适用于容器外集成测试，因此您应该使用Commons DBCP <code>BasicDataSource</code>和<code>DataSourceTransactionManager</code>或<code>HibernateTransactionManager</code>等组合。您可以将此变体行为分解为单个XML文件，可在应用程序服务器和与所有其他配置分离的“本地”配置之间进行选择，这在测试和生产环境之间不会有所不同。此外，我们建议您使用属性文件进行连接设置。有关示例，请参阅PetClinic应用程序。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-resources"><a class="anchor" href="#testing-resources"></a> 4。更多资源</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有关测试的更多信息，请参阅以下资源：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.junit.org/">JUnit</a> ：“面向程序员的Java测试框架”。由Spring Framework在其测试套件中使用。</p>
</li>
<li>
<p><a href="http://testng.org/">TestNG</a> ：受JUnit启发的测试框架，增加了对注释，测试组，数据驱动测试，分布式测试和其他功能的支持。</p>
</li>
<li>
<p><a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> ：“流畅的Java断言”，包括对Java 8 lambdas，流和其他功能的支持。</p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Mock_Object">模拟对象</a> ：维基百科中的文章。</p>
</li>
<li>
<p><a href="http://www.mockobjects.com/">MockObjects.com</a> ：专门用于模拟对象的网站，一种用于改进测试驱动开发中的代码设计的技术。</p>
</li>
<li>
<p><a href="http://mockito.org/">Mockito</a> ：基于<a href="http://xunitpatterns.com/Test Spy.html">Test Spy</a>模式的Java模拟库。</p>
</li>
<li>
<p><a href="http://www.easymock.org/">EasyMock</a> ：Java库“通过使用Java的代理机制动态生成接口（以及通过类扩展的对象）提供Mock对象。”由Spring Framework在其测试套件中使用。</p>
</li>
<li>
<p><a href="http://www.jmock.org/">JMock</a> ：支持使用模拟对象进行Java代码的测试驱动开发的库。</p>
</li>
<li>
<p><a href="http://dbunit.sourceforge.net/">DbUnit</a> ：针对数据库驱动项目的JUnit扩展（也可用于Ant和Maven），以及在测试运行之间将数据库置于已知状态。</p>
</li>
<li>
<p><a href="http://grinder.sourceforge.net/">Grinder</a> ：Java负载测试框架。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>