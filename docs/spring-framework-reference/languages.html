<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>语言支持</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="languages" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>语言支持</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#kotlin">1。科特林</a>
<ul class="sectlevel2">
<li><a href="#kotlin-requirements">1.1。要求</a></li>
<li><a href="#kotlin-extensions">1.2。扩展</a></li>
<li><a href="#kotlin-null-safety">1.3。空安全</a></li>
<li><a href="#kotlin-classes-interfaces">1.4。类和接口</a></li>
<li><a href="#kotlin-annotations">1.5。注释</a></li>
<li><a href="#kotlin-bean-definition-dsl">1.6。Bean定义DSL</a></li>
<li><a href="#kotlin-web">1.7。卷筒纸</a>
<ul class="sectlevel3">
<li><a href="#webflux-functional-dsl">1.7.1。WebFlux功能DSL</a></li>
<li><a href="#kotlin-script-templates">1.7.2。Kotlin脚本模板</a></li>
</ul>
</li>
<li><a href="#kotlin-spring-projects-in-kotlin">1.8。Kotlin的春季项目</a>
<ul class="sectlevel3">
<li><a href="#final-by-default">1.8.1。默认为最终</a></li>
<li><a href="#using-immutable-class-instances-for-persistence">1.8.2。使用不可变类实例进行持久化</a></li>
<li><a href="#injecting-dependencies">1.8.3。注入依赖项</a></li>
<li><a href="#injecting-configuration-properties">1.8.4。注入配置属性</a></li>
<li><a href="#annotation-array-attributes">1.8.5。注释数组属性</a></li>
<li><a href="#testing">1.8.6。测试</a>
<ul class="sectlevel4">
<li><a href="#per-class-lifecycle">每个类的生命周期</a></li>
<li><a href="#specification-like-tests">类似规范的测试</a></li>
<li><a href="#kotlin-webtestclient-issue">Kotlin中的<code>WebTestClient</code>类型推断问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#kotlin-getting-started">1.9。入门</a>
<ul class="sectlevel3">
<li><a href="#start-spring-io">1.9.1。 start.spring.io</a></li>
<li><a href="#choosing-the-web-flavor">1.9.2。选择网络风味</a></li>
</ul>
</li>
<li><a href="#kotlin-resources">1.10。资源</a>
<ul class="sectlevel3">
<li><a href="#tutorials">1.10.1。教程</a></li>
<li><a href="#blog-posts">1.10.2。博客文章</a></li>
<li><a href="#examples">1.10.3。例子</a></li>
<li><a href="#issues">1.10.4。问题</a>
<ul class="sectlevel4">
<li><a href="#spring-framework">Spring框架</a></li>
<li><a href="#spring-boot">春季启动</a></li>
<li><a href="#kotlin-2">科特林</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#groovy">2。Apache Groovy</a></li>
<li><a href="#dynamic-language">3。动态语言支持</a>
<ul class="sectlevel2">
<li><a href="#dynamic-language-introduction">3.1。介绍</a></li>
<li><a href="#dynamic-language-a-first-example">3.2。第一个例子</a></li>
<li><a href="#dynamic-language-beans">3.3。定义由动态语言支持的bean</a>
<ul class="sectlevel3">
<li><a href="#dynamic-language-beans-concepts">3.3.1。常见的概念</a>
<ul class="sectlevel4">
<li><a href="#dynamic-language-beans-concepts-xml-language-element">&lt;lang：language /&gt;元素</a></li>
<li><a href="#dynamic-language-refreshable-beans">可磨豆</a></li>
<li><a href="#dynamic-language-beans-inline">内联动态语言源文件</a></li>
<li><a href="#dynamic-language-beans-ctor-injection">在动态语言支持的bean的上下文中理解构造函数注入</a></li>
</ul>
</li>
<li><a href="#dynamic-language-beans-groovy">3.3.2。Groovy豆</a>
<ul class="sectlevel4">
<li><a href="#dynamic-language-beans-groovy-customizer">通过回调自定义Groovy对象</a></li>
</ul>
</li>
<li><a href="#dynamic-language-beans-bsh">3.3.3。BeanShell bean</a></li>
</ul>
</li>
<li><a href="#dynamic-language-scenarios">3.4。方案</a>
<ul class="sectlevel3">
<li><a href="#dynamic-language-scenarios-controllers">3.4.1。脚本化的Spring MVC控制器</a></li>
<li><a href="#dynamic-language-scenarios-validators">3.4.2。脚本验证器</a></li>
</ul>
</li>
<li><a href="#dynamic-language-final-notes">3.5。比特和鲍勃</a>
<ul class="sectlevel3">
<li><a href="#dynamic-language-final-notes-aop">3.5.1。AOP  - 建议脚本bean</a></li>
<li><a href="#dynamic-language-final-notes-scopes">3.5.2。作用域</a></li>
<li><a href="#xsd-schemas-lang">3.5.3。lang XML架构</a></li>
</ul>
</li>
<li><a href="#dynamic-language-resources">3.6。更多资源</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a> 1。科特林</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a>是一种针对JVM（和其他平台）的静态类型语言，它允许编写简洁而优雅的代码，同时提供与用Java编写的现有库的非常好的<a href="https://kotlinlang.org/docs/reference/java-interop.html">互操作性</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Framework为Kotlin提供了一流的支持，允许开发人员编写Kotlin应用程序，就像Spring Framework是本机Kotlin框架一样。</p>
</div>
<div class="paragraph">
<p>了解Spring + Kotlin的最简单方法是遵循<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">这个全面的教程</a> 。如果您需要支持，请随意加入<a href="http://slack.kotlinlang.org/">Kotlin Slack</a>的#spring频道或在<a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stackoverflow</a>上使用<code>spring</code>和<code>kotlin</code>标签提问。</p>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a> 1.1。要求</h3>
<div class="paragraph">
<p>弹簧框架支持科特林1.1+并且需要<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib"><code>kotlin-stdlib</code></a> （或类似的其变体之一<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre8"><code>kotlin-stdlib-jre8</code></a>为科特林1.1或<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jdk8"><code>kotlin-stdlib-jdk8</code></a>为科特林1.2+）和<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-reflect"><code>kotlin-reflect</code></a>到存在于类路径。如果在<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>上引导Kotlin项目， <a href="https://start.spring.io/#!language=kotlin">则</a>默认提供它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a> 1.2。扩展</h3>
<div class="paragraph">
<p>Kotlin <a href="https://kotlinlang.org/docs/reference/extensions.html">扩展</a>提供了使用附加功能扩展现有类的能力。Spring Framework Kotlin API利用这些扩展为现有的Spring API添加了新的Kotlin特定便利。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/kdoc-api/spring-framework/">Spring Framework KDoc API</a>列出并记录了所有可用的Kotlin扩展和DSL。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请记住，需要导入Kotlin扩展才能使用。这意味着，例如，只有<code>import org.springframework.context.support.registerBean</code>导入时， <code>GenericApplicationContext.registerBean</code> Kotlin扩展才可用。也就是说，类似于静态导入，IDE应该在大多数情况下自动建议导入。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如， <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin reified类型参数</a>为JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">泛型类型擦除</a>提供了一种解决方法，Spring Framework提供了一些扩展来利用此功能。这允许更好的Kotlin API <code>RestTemplate</code> ，来自Spring WebFlux的新<code>WebClient</code>以及各种其他API。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>其他库如Reactor和Spring Data也为其API提供Kotlin扩展，从而提供更好的Kotlin开发体验。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要在Java中检索<code>Foo</code>对象列表，通常会写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt;User&gt; users = client.get（）。retrieve（）。bodyToFlux（User.class）</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Kotlin和Spring Framework扩展时，可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val users = client.get（）。retrieve（）。bodyToFlux &lt;User&gt;（）//或（两者都是等价的）val用户：Flux &lt;User&gt; = client.get（）。retrieve（）。bodyToFlux（）</code></pre>
</div>
</div>
<div class="paragraph">
<p>与在Java中一样，Kotlin中的<code>users</code>是强类型的，但Kotlin的聪明类型推断允许更短的语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a> 1.3。空安全</h3>
<div class="paragraph">
<p>Kotlin的一个关键特性是<a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a> - 它在编译时干净地处理<code>null</code>值，而不是在运行时碰到着名的<code>NullPointerException</code> 。这使得应用程序通过可空性声明更安全，并表达“有价值或无价值”的语义，而无需支付像<code>Optional</code>这样的包装器的成本。（Kotlin允许使用具有可空值的功能构造;请查看这本<a href="http://www.baeldung.com/kotlin-null-safety">关于Kotlin零安全的综合指南</a> 。）</p>
</div>
<div class="paragraph">
<p>尽管Java不允许在其类型系统中表达null安全性，但Spring Framework现在通过<code>org.springframework.lang</code>包中声明的工具友好注释提供<a href="core.html#null-safety">整个Spring Framework API的空安全性</a> 。默认情况下，Kotlin中使用的Java API类型被识别为放宽空检查的<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">平台类型</a> 。
<a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">Kotlin对JSR 305注释的支持</a> + Spring可空性注释为整个Spring Framework API提供了对Kotlin开发人员的空安全性，具有在编译时处理<code>null</code>相关问题的优势。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Reactor或Spring Data等库提供了利用此功能的空安全API。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以通过添加带有以下选项的<code>-Xjsr305</code>编译器标志来配置JSR 305检查： <code>-Xjsr305={strict|warn|ignore}</code> 。</p>
</div>
<div class="paragraph">
<p>对于kotlin版本1.1+，默认行为与<code>-Xjsr305=warn</code>相同。在从Spring API推断的Kotlin类型中考虑Spring Framework API的空安全性需要<code>strict</code>值，但是应该知道Spring API可空性声明甚至可以在次要版本之间发展，并且将来可能会添加更多检查）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尚未支持泛型类型参数，varargs和数组元素可空性，但应该在即将发布的版本中，请参阅<a href="https://github.com/Kotlin/KEEP/issues/79">此讨论</a>以获取最新信息。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-classes-interfaces"><a class="anchor" href="#kotlin-classes-interfaces"></a> 1.4。类和接口</h3>
<div class="paragraph">
<p>Spring Framework支持各种Kotlin构造，例如通过主构造函数实例化Kotlin类，不可变类数据绑定和具有默认值的函数可选参数。</p>
</div>
<div class="paragraph">
<p>Kotlin参数名称通过专用的<code>KotlinReflectionParameterNameDiscoverer</code>识别，它允许查找接口方法参数名称，而无需在编译期间启用Java 8 <code>-parameters</code>编译器标志。</p>
</div>
<div class="paragraph">
<p>当在类路径中找到时，序列化/反序列化JSON数据所需的<a href="https://github.com/FasterXML/jackson-module-kotlin">Jackson Kotlin模块</a>会自动注册，如果在没有Jackson Kotlin模块的情况下检测到Jackson和Kotlin，则会记录警告消息。</p>
</div>
<div class="paragraph">
<p>配置类可以是<a href="https://kotlinlang.org/docs/reference/nested-classes.html">顶级或嵌套但不是内部的，</a>因为后者需要引用外部类。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-annotations"><a class="anchor" href="#kotlin-annotations"></a> 1.5。注释</h3>
<div class="paragraph">
<p>Spring Framework还利用<a href="https://kotlinlang.org/docs/reference/null-safety.html">Kotlin null-safety</a>来确定是否需要HTTP参数，而无需显式定义<code>required</code>属性。这意味着<code>@RequestParam name: String?</code> 将被视为不需要，相反，@ <code>@RequestParam name: String</code> as required。Spring Messaging <code>@Header</code>注释也支持此功能。</p>
</div>
<div class="paragraph">
<p>以类似的方式，使用@ <code>@Autowired</code> ， <code>@Bean</code>或<code>@Inject</code> Spring bean注入使用此信息来确定是否需要bean。</p>
</div>
<div class="paragraph">
<p>例如，@ <code>@Autowired lateinit var foo: Foo</code>意味着必须在应用程序上下文中注册<code>Foo</code>类型的bean，而<code>@Autowired lateinit var foo: Foo?</code>如果这样的bean不存在，则不会引发错误。</p>
</div>
<div class="paragraph">
<p>按照同样的原则， <code>@Bean fun baz(foo: Foo, bar: Bar?)= Baz(foo, bar)</code>意味着必须在应用程序上下文中注册类型为<code>Foo</code>的bean，而类型为<code>Bar</code>的bean可能存在也可能不存在。相同的行为适用于自动装配的构造函数参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在具有属性或主构造函数参数的类上使用bean验证，则可能需要利用<a href="https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets">注释使用站点目标，</a>如<code>@field:NotNull</code>或<code>@get:Size(min=5, max=15)</code> ， <a href="https://stackoverflow.com/a/35853200/1092077">如此堆栈中所述溢出响应</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-bean-definition-dsl"><a class="anchor" href="#kotlin-bean-definition-dsl"></a> 1.6。Bean定义DSL</h3>
<div class="paragraph">
<p>Spring Framework 5引入了一种以函数方式注册bean的新方法，使用lambdas作为XML或JavaConfig（ <code>@Configuration</code>和<code>@Bean</code> ）的替代方法。简而言之，它可以使用充当<code>FactoryBean</code>的lambda注册bean。这种机制非常有效，因为它不需要任何反射或CGLIB代理。</p>
</div>
<div class="paragraph">
<p>在Java中，例如可以写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext（）; context.registerBean（让Foo.class）; context.registerBean（Bar.class，（） - &gt; <span class="keyword">new</span> Bar（context.getBean（Foo.class）））;</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然在Kotlin中使用了reified类型参数和<code>GenericApplicationContext</code> Kotlin扩展，但可以简单地写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val context = GenericApplicationContext（）。apply {registerBean &lt;Foo&gt;（）registerBean {Bar（it.getBean &lt;Foo&gt;（））}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了允许更具声明性的方法和更清晰的语法，Spring Framework提供了一个<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/kdoc-api/spring-framework/org.springframework.context.support/-bean-definition-dsl/">Kotlin bean定义DSL</a>它通过一个干净的声明性API声明一个<code>ApplicationContextInitializer</code> ，它允许人们处理配置文件和<code>Environment</code>来定制bean的注册方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">fun beans（）= beans {bean &lt;UserHandler&gt;（）bean &lt;Routes&gt;（）bean &lt;WebHandler&gt;（“webHandler”）{RouterFunctions.toWebHandler（ref &lt;Routes&gt;（）。router（），HandlerStrategies.builder（））。 viewResolver（ref（））。build（））} bean（“messageSource”）{ReloadableResourceBundleMessageSource（）。apply {setBasename（“messages”）setDefaultEncoding（“UTF-8”）}} bean {val prefix =“classpath：/ templates /“val suffix =”.mustache“val loader = MustacheResourceTemplateLoader（prefix，suffix）MustacheViewResolver（Mustache.compiler（）。withLoader（loader））。apply {setPrefix（prefix）setSuffix（suffix）}} profile（”foo“） ）{bean &lt;Foo&gt;（）}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中， <code>bean&lt;Routes&gt;()</code>使用构造函数进行自动装配， <code>ref&lt;Routes&gt;()</code>是<code>applicationContext.getBean(Routes::class.java)</code>的快捷方式。</p>
</div>
<div class="paragraph">
<p>然后可以使用此<code>beans()</code>函数在应用程序上下文中注册bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val context = GenericApplicationContext（）。apply {beans（）。initialize（this）refresh（）}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这个DSL是程序化的，因此它允许通过<code>if</code>表达式， <code>for</code>循环或任何其他Kotlin结构自定义bean的注册逻辑。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关具体示例，请参阅<a href="https://github.com/sdeleuze/spring-kotlin-functional/blob/master/src/main/kotlin/functional/Beans.kt">spring-kotlin-functional beans声明</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Boot基于Java Config， <a href="https://github.com/spring-projects/spring-boot/issues/8115">并没有提供对功能bean定义的特定支持</a> ，但是可以通过Spring Boot的<code>ApplicationContextInitializer</code>支持实验性地使用功能bean定义，请参阅<a href="https://stackoverflow.com/questions/45935931/how-to-use-functional-bean-definition-kotlin-dsl-with-spring-boot-and-spring-w/46033685#46033685">此Stack Overflow答案</a>以获取更多详细信息和最新信息。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-web"><a class="anchor" href="#kotlin-web"></a> 1.7。卷筒纸</h3>
<div class="sect3">
<h4 id="webflux-functional-dsl"><a class="anchor" href="#webflux-functional-dsl"></a> 1.7.1。WebFlux功能DSL</h4>
<div class="paragraph">
<p>Spring Framework现在附带了一个<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/-router-function-dsl/">Kotlin路由DSL</a> ，允许人们利用<a href="web-reactive.html#webflux-fn">WebFlux功能API</a>编写干净且惯用的Kotlin代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">router {accept（TEXT_HTML）.nest {GET（“/”）{ok（）。render（“index”）} GET（“/ sse”）{ok（）。render（“sse”）} GET（“/ users“，userHandler :: findAllView）}”/ api".nest {accept（APPLICATION_JSON）.nest {GET（“/ users”，userHandler :: findAll）} accept（TEXT_EVENT_STREAM）。{GET（“/ users”， userHandler :: stream）}} resources（“/ **”，ClassPathResource（“static /”））}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这个DSL是程序化的，因此它允许通过<code>if</code>表达式， <code>for</code>循环或任何其他Kotlin结构自定义bean的注册逻辑。当需要根据动态数据（例如，从数据库）注册路由时，这可能很有用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关具体示例，请参阅<a href="https://github.com/mixitconf/mixit/tree/bad6b92bce6193f9b3f696af9d416c276501dbf1/src/main/kotlin/mixit/web/routes">MiXiT项目路线</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="kotlin-script-templates"><a class="anchor" href="#kotlin-script-templates"></a> 1.7.2。Kotlin脚本模板</h4>
<div class="paragraph">
<p>从4.3版开始，Spring Framework提供了一个<a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/view/script/ScriptTemplateView.html">ScriptTemplateView</a> ，使用支持<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223的</a>脚本引擎来呈现模板。通过将此功能扩展到WebFlux并支持<a href="https://jira.spring.io/browse/SPR-15064">i18n和嵌套模板，</a> Spring Framework 5更进一步。</p>
</div>
<div class="paragraph">
<p>Kotlin提供类似的支持并允许渲染基于Kotlin的模板，有关详细信息，请参阅<a href="https://github.com/spring-projects/spring-framework/commit/badde3a479a53e1dd0777dd1bd5b55cb1021cf9e">此提交</a> 。</p>
</div>
<div class="paragraph">
<p>这可以实现一些有趣的用例 - 比如使用<a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html</a> DSL编写类型安全的模板，或者只使用带插值的Kotlin多线<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>这可以让我们在支持的IDE中编写具有完全自动完成和重构支持的Kotlin模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import io.spring.demo。*“”“$ {include（”header“）} &lt;h1&gt; $ {i18n（”title“）} &lt;/ h1&gt; &lt;ul&gt; $ {users.joinToLine {”&lt;li&gt; $ {i18n（“user”） } $ {it.firstname} $ {it.lastname} &lt;/ li&gt;“}} &lt;/ ul&gt; $ {include（”footer“）}”“”</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://github.com/sdeleuze/kotlin-script-templating">kotlin-script-templating</a>示例项目。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-spring-projects-in-kotlin"><a class="anchor" href="#kotlin-spring-projects-in-kotlin"></a> 1.8。Kotlin的春季项目</h3>
<div class="paragraph">
<p>本节重点介绍在Kotlin开发Spring项目时需要了解的一些特定提示和建议。</p>
</div>
<div class="sect3">
<h4 id="final-by-default"><a class="anchor" href="#final-by-default"></a> 1.8.1。默认为最终</h4>
<div class="paragraph">
<p>默认情况下， <a href="https://discuss.kotlinlang.org/t/classes-final-by-default/166">Kotlin中的所有类都是<code>final</code></a> 。类的<code>open</code>修饰符与Java的<code>final</code>相反：它允许其他人继承此类。这也适用于成员函数，因为它们需要被标记为<code>open</code>才能被覆盖。</p>
</div>
<div class="paragraph">
<p>虽然Kotlin的JVM友好型设计通常与Spring无摩擦，但如果不考虑这一事实，这种特定的Kotlin功能可能会阻止应用程序启动。这是因为Spring bean通常由CGLIB代理 - 例如<code>@Configuration</code>类 - 由于技术原因需要在运行时继承。解决方法是在CGLIB代理的每个类和成员函数上添加一个<code>open</code>关键字，例如<code>@Configuration</code>类，这很快就会变得很痛苦，并且违反了保持代码简洁和可预测的Kotlin原则。</p>
</div>
<div class="paragraph">
<p>幸运的是，Kotlin现在提供了一个<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin"><code>kotlin-spring</code></a>插件，一个预先配置的<code>kotlin-allopen</code>插件版本，可以自动打开类及其成员函数，用于注释或使用以下注释之一进行元注释的类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@零件</code></p>
</li>
<li>
<p><code>@Async</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
<li>
<p><code>@Cacheable</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>元注释支持意味着有注解的类型<code>@Configuration</code> ， <code>@Controller</code> ， <code>@RestController</code> ， <code>@Service</code>或<code>@Repository</code>但这些注解元标注有自动打开<code>@Component</code> 。</p>
</div>
<div class="paragraph">
<p><a href="http://start.spring.io/#!language=kotlin">start.spring.io</a>默认启用它，所以在实践中你将能够编写你的Kotlin bean而不需要任何额外的<code>open</code>关键字，就像在Java中一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-immutable-class-instances-for-persistence"><a class="anchor" href="#using-immutable-class-instances-for-persistence"></a> 1.8.2。使用不可变类实例进行持久化</h4>
<div class="paragraph">
<p>在Kotlin中，在主构造函数中声明只读属性是非常方便且被认为是最佳实践，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">class Person（val name：String，val age：Int）</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以选择添加<a href="https://kotlinlang.org/docs/reference/data-classes.html"><code>data</code>关键字，</a>以使编译器自动从主构造函数中声明的所有属性派生以下成员：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>equals（）/ hashCode（）对</p>
</li>
<li>
<p>toString（）形式为“User（name = John，age = 42）”</p>
</li>
<li>
<p>componentN（）函数对应于声明顺序中的属性</p>
</li>
<li>
<p>copy（）函数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>即使<code>Person</code>属性是只读的，这也允许轻松更改单个属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">data class Person（val name：String，val age：Int）val jack = Person（name =“Jack”，age = 1）val olderJack = jack.copy（age = 2）</code></pre>
</div>
</div>
<div class="paragraph">
<p>诸如JPA之类的常见持久性技术需要默认构造函数，从而阻止了这种设计。幸运的是，现在有了这个<a href="https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-hell">“默认构造函数地狱”</a>的解决方法，因为Kotlin提供了一个<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-jpa-compiler-plugin">kotlin-jpa</a>插件，它为使用JPA注释注释的类生成合成的无参数构造函数。</p>
</div>
<div class="paragraph">
<p>如果您需要将此类机制用于其他持久性技术，则可以配置<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#how-to-use-no-arg-plugin">kotlin-noarg</a>插件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Kay发布系列开始，Spring Data支持Kotlin不可变类实例，如果模块利用Spring Data对象映射（如MongoDB，Redis，Cassandra等），则不需要<code>kotlin-noarg</code>插件。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="injecting-dependencies"><a class="anchor" href="#injecting-dependencies"></a> 1.8.3。注入依赖项</h4>
<div class="paragraph">
<p>我们的建议是尝试使用<code>val</code>只读（并且在可能的情况下不可为空） <a href="https://kotlinlang.org/docs/reference/properties.html">属性</a>来支持构造函数注入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">@Component类YourBean（private val mongoTemplate：MongoTemplate，private val solrClient：SolrClient）</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.3开始，具有单个构造函数的类的参数会自动自动装配，这就是为什么在上面显示的示例中不需要显式的<code>@Autowired constructor</code>的原因。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果确实需要使用场注入，请使用<code>lateinit var</code>构造，即</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">@Component类YourBean {@Autowired lateinit var mongoTemplate：MongoTemplate @Autowired lateinit var solrClient：SolrClient}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injecting-configuration-properties"><a class="anchor" href="#injecting-configuration-properties"></a> 1.8.4。注入配置属性</h4>
<div class="paragraph">
<p>在Java中，可以使用<code>@Value("${property}")</code>等注释注入配置属性，但在Kotlin中， <code>$</code>是一个用于<a href="https://kotlinlang.org/docs/reference/idioms.html#string-interpolation">字符串插值</a>的保留字符。</p>
</div>
<div class="paragraph">
<p>因此，如果希望在Kotlin中使用<code>@Value</code>注释，则需要通过编写<code>@Value("\${property}")</code>来转义<code>$</code>字符。</p>
</div>
<div class="paragraph">
<p>作为替代方案，可以通过声明以下配置bean来自定义属性占位符前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">@Bean fun propertyConfigurer（）= PropertySourcesPlaceholderConfigurer（）。apply {setPlaceholderPrefix（“％{”）}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用<code>${…​}</code>语法的现有代码（如Spring Boot actuator或<code>@LocalServerPort</code> ）可以使用配置bean进行自定义，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">@Bean fun kotlinPropertyConfigurer（）= PropertySourcesPlaceholderConfigurer（）。apply {setPlaceholderPrefix（“％{”）setIgnoreUnresolvablePlaceholders（true）} @Bean fun defaultPropertyConfigurer（）= PropertySourcesPlaceholderConfigurer（）</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果正在使用Spring Boot，则可以使用<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties"><code>@ConfigurationProperties</code></a>而不是<code>@Value</code>注释，但是目前这仅适用于<code>lateinit</code>或nullable <code>var</code>属性（建议使用前者），因为尚不支持由构造函数初始化的不可变类。有关更多详细信息，请参阅有关<a href="https://github.com/spring-projects/spring-boot/issues/8762">不可变POJO的</a> <a href="https://github.com/spring-projects/spring-boot/issues/1254"><code>@ConfigurationProperties</code>绑定和接口上的</a> <a href="https://github.com/spring-projects/spring-boot/issues/8762"><code>@ConfigurationProperties</code>绑定的</a>这些问题。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="annotation-array-attributes"><a class="anchor" href="#annotation-array-attributes"></a> 1.8.5。注释数组属性</h4>
<div class="paragraph">
<p>Kotlin注释大多类似于Java注释，但是在Spring中广泛使用的数组属性表现不同。如<a href="https://kotlinlang.org/docs/reference/annotations.html">Kotlin文档中所述，</a>与其他属性不同，可以省略<code>value</code>属性名称并将其指定为<code>vararg</code>参数。</p>
</div>
<div class="paragraph">
<p>要理解这意味着什么，让我们以<code>@RequestMapping</code>为例，它是最广泛使用的Spring注释之一。此Java注释声明为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="annotation">@interface</span> RequestMapping { <span class="annotation">@AliasFor</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">path</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> <span class="type">[]</span> value（） <span class="keyword">default</span> {}; <span class="annotation">@AliasFor</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">value</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> <span class="type">[]</span> path（） <span class="keyword">default</span> {}; RequestMethod <span class="type">[]</span> method（） <span class="keyword">default</span> {}; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code>的典型用例是将处理程序方法映射到特定的路径和方法。在Java中，可以为注释数组属性指定单个值，它将自动转换为数组。</p>
</div>
<div class="paragraph">
<p>这就是为什么人们可以编写<code>@RequestMapping(value = "/foo", method = RequestMethod.GET)</code>或<code>@RequestMapping(path = "/foo", method = RequestMethod.GET)</code> 。</p>
</div>
<div class="paragraph">
<p>但是，在Kotlin 1.2+中，必须编写<code>@RequestMapping("/foo", method = [RequestMethod.GET])</code>或<code>@RequestMapping(path = ["/foo"], method = [RequestMethod.GET])</code> （方括号需要用命名数组属性指定）。</p>
</div>
<div class="paragraph">
<p>此特定<code>method</code>属性（最常见的<code>method</code>的替代<code>method</code>是使用快捷方式注释，例如<code>@GetMapping</code>或<code>@PostMapping</code>等。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>提醒：如果未指定<code>@RequestMapping</code> <code>method</code>属性，则将匹配所有HTTP方法，而不仅仅是<code>GET</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testing"><a class="anchor" href="#testing"></a> 1.8.6。测试</h4>
<div class="sect4">
<h5 id="per-class-lifecycle"><a class="anchor" href="#per-class-lifecycle"></a>每个类的生命周期</h5>
<div class="paragraph">
<p>Kotlin允许在反引号之间指定有意义的测试函数名称，从JUnit 5开始，Kotlin测试类可以使用<code>@TestInstance(TestInstance.生命周期。PER_CLASS)</code>注释，允许单个实例化测试类，允许在非静态方法上使用<code>@BeforeAll</code>和<code>@AfterAll</code>注释，这非常适合Kotlin。</p>
</div>
<div class="paragraph">
<p>由于<code>junit-platform.properties</code>文件带有<code>junit.jupiter.testinstance.lifecycle.default = per_class</code>属性，现在可以将默认行为更改为<code>PER_CLASS</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>class IntegrationTests {val application = Application（8181）val client = WebClient.create（“http：// localhost：8181”）@BeforeAll fun beforeAll（）{application.start（）} @Test fun`在HTML页面上查找所有用户`（）{client.get（）。uri（“/ users”）。accept（TEXT_HTML）.retrieve（）。bodyToMono &lt;String&gt;（）。test（）。expectNextMatches {it.contains（“Foo”）}。 verifyComplete（）} @AfterAll fun afterAll（）{application.stop（）}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specification-like-tests"><a class="anchor" href="#specification-like-tests"></a>类似规范的测试</h5>
<div class="paragraph">
<p>可以使用JUnit 5和Kotlin创建类似规范的测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>class SpecificationLikeTests {@Nested @DisplayName（“a calculator”）内部类Calculator {val calculator = SampleCalculator（）@ Test fun`应返回将第一个数字添加到第二个数字的结果`（）{val sum = calculator.sum （2,4）assertEquals（6，sum）} @ Test fun`应该返回从第一个数字减去第二个数字的结果`（）{val subtract = calculator.subtract（4,2）assertEquals（2，subtract） }}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kotlin-webtestclient-issue"><a class="anchor" href="#kotlin-webtestclient-issue"></a> Kotlin中的<code>WebTestClient</code>类型推断问题</h5>
<div class="paragraph">
<p>由于<a href="https://youtrack.jetbrains.com/issue/KT-5464">类型推断问题</a> ，请确保使用Kotlin <code>expectBody</code>扩展（如<code>.expectBody&lt;String&gt;().isEqualTo("foo")</code> ），因为它为Java API提供了Kotlin问题的解决方法。</p>
</div>
<div class="paragraph">
<p>另请参阅相关的<a href="https://jira.spring.io/browse/SPR-16057">SPR-16057</a>问题。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-getting-started"><a class="anchor" href="#kotlin-getting-started"></a> 1.9。入门</h3>
<div class="sect3">
<h4 id="start-spring-io"><a class="anchor" href="#start-spring-io"></a> 1.9.1。 start.spring.io</h4>
<div class="paragraph">
<p>在Kotlin中启动新的Spring Framework 5项目的最简单方法是在<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>上创建一个新的Spring Boot 2项目。</p>
</div>
<div class="paragraph">
<p>也可以创建一个独立的WebFlux项目，如<a href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way">本博客文章中所述</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="choosing-the-web-flavor"><a class="anchor" href="#choosing-the-web-flavor"></a> 1.9.2。选择网络风味</h4>
<div class="paragraph">
<p>Spring Framework现在提供了两个不同的Web堆栈： <a href="web.html#mvc">Spring MVC</a>和<a href="web-reactive.html#spring-web-reactive">Spring WebFlux</a> 。</p>
</div>
<div class="paragraph">
<p>如果想要创建应用程序来处理延迟，长期连接，流式传输方案或者只是想要使用Web功能的Kotlin DSL，建议使用Spring WebFlux。</p>
</div>
<div class="paragraph">
<p>对于其他用例，特别是如果您使用像JPA这样的阻塞技术，Spring MVC及其基于注释的编程模型是完全有效且完全支持的选择。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-resources"><a class="anchor" href="#kotlin-resources"></a> 1.10。资源</h3>
<div class="ulist">
<ul>
<li>
<p><a href="http://kotlinlang.org/docs/reference/">Kotlin语言参考</a></p>
</li>
<li>
<p><a href="http://slack.kotlinlang.org/">Kotlin Slack</a> （带有专用的#spring频道）</p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stackoverflow与<code>spring</code>和<code>kotlin</code>标签</a></p>
</li>
<li>
<p><a href="https://try.kotlinlang.org/">在浏览器中尝试Kotlin</a></p>
</li>
<li>
<p><a href="https://blog.jetbrains.com/kotlin/">科特林博客</a></p>
</li>
<li>
<p><a href="https://kotlin.link/">令人敬畏的Kotlin</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="tutorials"><a class="anchor" href="#tutorials"></a> 1.10.1。教程</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">使用Spring Boot和Kotlin构建Web应用程序</a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/tutorials/spring-boot-restful.html">使用Spring Boot创建RESTful Web服务</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="blog-posts"><a class="anchor" href="#blog-posts"></a> 1.10.2。博客文章</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">使用Kotlin开发Spring Boot应用程序</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql">带有Kotlin，Spring Boot和PostgreSQL的地理空间信使</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">在Spring Framework 5.0中引入Kotlin支持</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way">Spring Framework 5 Kotlin API，功能方式</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="examples"><a class="anchor" href="#examples"></a> 1.10.3。例子</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a> ：常规Spring Boot + Spring Data JPA项目</p>
</li>
<li>
<p><a href="https://github.com/mixitconf/mixit">mixit</a> ：Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-functional">spring-kotlin-functional</a> ：独立的WebFlux +功能bean定义DSL</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-fullstack">spring-kotlin-fullstack</a> ：WebFlux Kotlin fullstack示例，其中Kotlin2js用于前端而不是JavaScript或TypeScript</p>
</li>
<li>
<p><a href="https://github.com/spring-petclinic/spring-petclinic-kotlin">spring-petclinic-kotlin</a> ：Spring PetClinic样品应用的Kotlin版本</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-deepdive">spring-kotlin-deepdive</a> ：将Boot 1.0 + Java逐步迁移到Boot 2.0 + Kotlin</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="issues"><a class="anchor" href="#issues"></a> 1.10.4。问题</h4>
<div class="paragraph">
<p>以下是与Spring + Kotlin支持相关的待处理问题列表。</p>
</div>
<div class="sect4">
<h5 id="spring-framework"><a class="anchor" href="#spring-framework"></a> Spring框架</h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://jira.spring.io/browse/SPR-16057">无法在Kotlin中将WebTestClient与模拟服务器一起使用</a></p>
</li>
<li>
<p><a href="https://jira.spring.io/browse/SPR-15942">支持泛型，变量和数组元素级别的空安全性</a></p>
</li>
<li>
<p><a href="https://jira.spring.io/browse/SPR-15413">添加对Kotlin协同程序的支持</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-boot"><a class="anchor" href="#spring-boot"></a>春季启动</h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/issues/8762">允许<code>@ConfigurationProperties</code>绑定不可变的POJO</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/issues/1254">允许在接口上绑定<code>@ConfigurationProperties</code></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/issues/8115">通过<code>SpringApplication</code>公开功能bean注册API</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/issues/10712">在Spring Boot API上添加null-safety批注</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/issues/9486">使用Kotlin的bom为Kotlin提供依赖管理</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="kotlin-2"><a class="anchor" href="#kotlin-2"></a>科特林</h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-6380">Spring Framework支持的父问题</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-5464">Kotlin需要类型推断，而Java则不需要</a></p>
</li>
<li>
<p><a href="https://github.com/Kotlin/KEEP/issues/79">更好的泛型零安全支持</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-20283">使用开放类的智能投射回归</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-14984">无法将所有SAM参数作为函数传递</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-19592">将JSR 305元注释应用于泛型类型参数</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-18398">为库提供一种避免混合Kotlin 1.0和1.1依赖项的方法</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-15125">通过脚本变量直接支持JSR 223绑定</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-15467">支持Kotlin Eclipse插件中的all-open和no-arg编译器插件</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="groovy"><a class="anchor" href="#groovy"></a> 2。Apache Groovy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy是一种功能强大的可选类型和动态语言，具有静态类型和静态编译功能。它提供了简洁的语法，可以与任何现有的Java应用程序平滑集成。</p>
</div>
<div class="paragraph">
<p>Spring Framework提供了一个专用的<code>ApplicationContext</code> ，它支持基于Groovy的Bean Definition DSL。有关更多详细信息，请参阅<a href="core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL</a> 。</p>
</div>
<div class="paragraph">
<p>Groovy的进一步支持包括用Groovy编写的bean，可刷新的脚本bean等，下一节<a href="#dynamic-language">动态语言支持</a>部分提供了这些<a href="#dynamic-language">支持</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dynamic-language"><a class="anchor" href="#dynamic-language"></a> 3。动态语言支持</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="dynamic-language-introduction"><a class="anchor" href="#dynamic-language-introduction"></a> 3.1。介绍</h3>
<div class="paragraph">
<p>Spring 2.0引入了对使用Spring和动态语言（如JRuby）定义的类和对象的全面支持。此支持允许您以受支持的动态语言编写任意数量的类，并让Spring容器透明地实例化，配置和依赖注入生成的对象。</p>
</div>
<div class="paragraph">
<p>目前支持的动态语言包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JRuby 1.5+</p>
</li>
<li>
<p>Groovy 1.8+</p>
</li>
<li>
<p>BeanShell 2.0</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">为什么只有这些语言？</div>
<div class="paragraph">
<p>选择支持的语言是因为<em>a）</em>语言在Java企业社区中具有很大的吸引力， <em>b）</em>在添加此支持时没有为其他语言提出请求，以及<em>c）</em> Spring开发人员最熟悉它们。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#dynamic-language-scenarios">方案</a>中描述了动态语言支持可以立即有用的完整工作示例。</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-a-first-example"><a class="anchor" href="#dynamic-language-a-first-example"></a> 3.2。第一个例子</h3>
<div class="paragraph">
<p>本章的大部分内容涉及详细描述动态语言支持。在深入研究动态语言支持的所有细节之前，让我们看一个用动态语言定义的bean的快速示例。第一个bean的动态语言是Groovy（这个例子的基础来自Spring测试套件，所以如果你想看到任何其他支持语言的等效例子，请看一下源代码）。</p>
</div>
<div class="paragraph">
<p>在下面找到Groovy bean将要实现的<code>Messenger</code>接口，并注意此接口是在普通Java中定义的。注入了对<code>Messenger</code>的引用的依赖对象将不知道底层实现是Groovy脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.scripting</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">Messenger</span> { <span class="predefined-type">String</span> getMessage（）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是依赖于<code>Messenger</code>接口的类的定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.scripting</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultBookingService</span> <span class="directive">实现</span> BookingService { <span class="directive">private</span> Messenger messenger; <span class="directive">public</span> <span class="type">void</span> setMessenger（Messenger messenger）{ <span class="local-variable">this</span> .messenger = messenger; <span class="directive">public</span> <span class="type">void</span> processBooking（）{ <span class="comment">//使用注入的Messenger对象...</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是Groovy中<code>Messenger</code>接口的一个实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//来自'Messenger.groovy'文件</span> <span class="keyword">包</span> <span class="namespace">org.springframework.scripting.groovy</span> ; <span class="comment">//导入要实现的</span> <span class="keyword">导入</span> <span class="include">org.springframework.scripting <span class="comment">的Messenger接口（用Java编写）</span> <span class="include">。Messenger</span> <span class="comment">//在Groovy</span> <span class="include">类中</span> <span class="comment">定义实现</span> <span class="include">GroovyMessenger</span> <span class="include">实现</span> <span class="include">Messenger</span> { <span class="include">String</span> <span class="include">message</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，这里是bean定义，它们将影响Groovy定义的<code>Messenger</code>实现注入<code>DefaultBookingService</code>类的实例。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用自定义动态语言标记来定义动态语言支持的bean，您需要在Spring XML配置文件的顶部使用XML Schema前导码。您还需要使用Spring <code>ApplicationContext</code>实现作为IoC容器。支持使用带有简单<code>BeanFactory</code>实现的动态语言支持的bean，但是您必须管理Spring内部的管道才能这样做。</p>
</div>
<div class="paragraph">
<p>有关基于模式的配置的更多信息，请参阅<a href="appendix.html#xsd-configuration">基于XML模式的配置</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：lang</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/lang</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这是Groovy支持的Messenger实现的bean定义 - &gt;</span> <span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messenger</span> <span class="delimiter">”</span></span> <span class="attribute-name">script-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：Messenger.groovy</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">message</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">I Can Do The Frug</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ lang：groovy&gt;</span> <span class="comment">&lt;！ - - 一个由Groovy支持的Messenger注入的普通bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">bookingService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyDefaultBookingService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该<code>bookingService</code>豆（一<code>DefaultBookingService</code> ）现在可以使用自己的私人<code>messenger</code>成员变量作为正常的，因为<code>Messenger</code>是注入它的实例<em>是</em>一个<code>Messenger</code>实例。这里没有什么特别的东西，只是简单的Java和普通的Groovy。</p>
</div>
<div class="paragraph">
<p>希望上面的XML代码段是不言自明的，但如果不是，请不要过分担心。请继续阅读有关上述配置的原因和内容的详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-beans"><a class="anchor" href="#dynamic-language-beans"></a> 3.3。定义由动态语言支持的bean</h3>
<div class="paragraph">
<p>本节将准确描述如何使用任何受支持的动态语言定义Spring托管bean。</p>
</div>
<div class="paragraph">
<p>请注意，本章不会尝试解释支持的动态语言的语法和习语。例如，如果您想使用Groovy编写应用程序中的某些类，那么假设您已经了解了Groovy。如果您需要有关动态语言本身的更多详细信息，请参阅本章末尾的“ <a href="#dynamic-language-resources">更多资源</a> ”。</p>
</div>
<div class="sect3">
<h4 id="dynamic-language-beans-concepts"><a class="anchor" href="#dynamic-language-beans-concepts"></a> 3.3.1。常见的概念</h4>
<div class="paragraph">
<p>使用动态语言支持的bean涉及的步骤如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编写动态语言源代码的测试（自然）</p>
</li>
<li>
<p><em>然后</em>编写动态语言源代码本身:)</p>
</li>
<li>
<p>使用XML配置中相应的<code>&lt;lang:language/&gt;</code>元素定义动态语言支持的bean（当然，您可以使用Spring API以编程方式定义此类bean  - 尽管您必须查阅源代码以获取有关如何使用的方法这样做是因为本章未介绍此类高级配置。请注意，这是一个迭代步骤。每个动态语言源文件至少需要一个bean定义（尽管同一个动态语言源文件当然可以由多个bean定义引用）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前两个步骤（测试和编写动态语言源文件）超出了本章的范围。请参阅所选动态语言的语言规范和/或参考手册，并开发动态语言源文件。您<em>将</em>首先阅读本章的其余部分，因为Spring的动态语言支持确实对动态语言源文件的内容做了一些（小的）假设。</p>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-concepts-xml-language-element"><a class="anchor" href="#dynamic-language-beans-concepts-xml-language-element"></a> &lt;lang：language /&gt;元素</h5>
<div class="paragraph">
<p>最后一步涉及定义动态语言支持的bean定义，每个bean对应一个您要配置的bean（这与普通的JavaBean配置没有区别）。但是，不是指定要由容器实例化和配置的类的完全限定类名，而是使用<code>&lt;lang:language/&gt;</code>元素来定义动态语言支持的bean。</p>
</div>
<div class="paragraph">
<p>每种受支持的语言都有一个对应的<code>&lt;lang:language/&gt;</code>元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;lang:groovy/&gt;</code> （Groovy）</p>
</li>
<li>
<p><code>&lt;lang:bsh/&gt;</code> （BeanShell）</p>
</li>
<li>
<p><code>&lt;lang:std/&gt;</code> （JSR-223）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可用于配置的确切属性和子元素取决于bean定义的确切语言（下面的语言特定部分提供了完整的内容）。</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-language-refreshable-beans"><a class="anchor" href="#dynamic-language-refreshable-beans"></a>可磨豆</h5>
<div class="paragraph">
<p>之一（如果<em>不是</em> ）Spring对动态语言支持中最引人注目价值在于增加了对<em>“refreshable bean”</em>特征<em>的</em> 。</p>
</div>
<div class="paragraph">
<p>可刷新的bean是一个动态语言支持的bean，只需少量配置，动态语言支持的bean就可以监视其底层源文件资源的更改，然后在更改动态语言源文件时重新加载（对于例如，开发人员编辑并保存对文件系统上文件的更改）。</p>
</div>
<div class="paragraph">
<p>这允许开发人员将任意数量的动态语言源文件部署为应用程序的一部分，将Spring容器配置为创建由动态语言源文件支持的bean（使用本章中描述的机制），然后随着需求的变化或其他一些外部因素发挥作用，只需编辑动态语言源文件，并在由更改的动态语言源文件支持的bean中进行任何更改。无需关闭正在运行的应用程序（或在Web应用程序的情况下重新部署）。如此修改的动态语言支持的bean将从更改的动态语言源文件中获取新的状态和逻辑。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，默认情况下此功能处于<em>关闭状态</em> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>让我们看一个例子来看看开始使用可刷新的bean是多么容易。要<em>打开</em>可刷新的bean功能，您只需在bean定义的<code>&lt;lang:language/&gt;</code>元素上指定<em>一个</em>额外的属性。因此，如果我们坚持本章前面<a href="#dynamic-language-a-first-example">的示例</a> ，那么我们将在Spring XML配置中更改以实现可刷新的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 由于'refresh-check-delay'属性的存在，这个bean现在是'可刷新的' - &gt;</span> <span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messenger</span> <span class="delimiter">”</span></span> <span class="attribute-name">refresh-check-delay</span> = <span class="string"><span class="delimiter">“</span> <span class="content">5000</span> <span class="delimiter">”</span></span> <span class="error">&lt;</span> <span class="error">！</span> <span class="attribute-name">-</span> <span class="attribute-name">开关</span> <span class="attribute-name">刷新</span> <span class="attribute-name"><span class="attribute-name">与</span></span> <span class="attribute-name">检查</span> <span class="attribute-name">之间</span> <span class="attribute-name"><span class="attribute-name">5秒</span></span> <span class="attribute-name">-</span> <span class="tag">&gt;</span>脚本的源=“类路径<span class="error">：Messenger.groovy”&gt;</span> <span class="tag">&lt;郎：属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=“</span> <span class="content">消息</span> <span class="delimiter">”</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=“</span> <span class="content">我可以做<span class="delimiter">Frug”</span></span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/郎：常规&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">bookingService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyDefaultBookingService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是你所要做的一切。<code>'messenger'</code>定义中定义的<code>'refresh-check-delay'</code>属性是在对基础动态语言源文件进行任何更改之后刷新bean的毫秒数。您可以通过为<code>'refresh-check-delay'</code>属性指定负值来关闭刷新行为。请记住，默认情况下，禁用刷新行为。如果您不想要刷新行为，则只需不要定义属性。</p>
</div>
<div class="paragraph">
<p>如果我们运行以下应用程序，我们可以运行可刷新的功能;请在下一段代码中请原谅<em>'跳过箍到暂停执行'的</em>诡计。<code>System.in.read()</code>调用仅在那里，以便在我（作者）关闭并编辑底层动态语言源文件时暂停程序的执行，以便在动态语言支持的bean上触发刷新程序恢复执行时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.scripting。信使</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> {ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ）; Messenger messenger =（Messenger）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">messenger</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">System</span> .out.println（messenger.getMessage（））; <span class="comment">//在我离开时暂停执行并对源文件进行更改...</span>
        <span class="predefined-type">System</span> .in.read（）; <span class="predefined-type">System</span> .out.println（messenger.getMessage（））; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，为了本示例的目的，我们假设必须更改对<code>Messenger</code>实现的<code>getMessage()</code>方法的所有调用，以使消息被引号括起来。以下是我（作者）暂停执行程序时对<code>Messenger.groovy</code>源文件所做的更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.scripting</span> <span class="namespace">类</span> <span class="namespace">GroovyMessenger</span> <span class="namespace">实现</span> <span class="namespace">Messenger</span> { <span class="namespace">private</span> <span class="namespace">String</span> <span class="namespace">message</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Bingo</span> <span class="delimiter">”</span></span> <span class="namespace">public</span> <span class="namespace">String</span> <span class="namespace">getMessage</span> （）{ <span class="comment">//更改实现以在引号中包围消息</span> <span class="namespace">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">'</span> <span class="delimiter">”</span></span> + <span class="namespace">this.message</span> + <span class="string"><span class="delimiter">“</span> <span class="content">'</span> <span class="delimiter">”</span></span> } <span class="namespace">public</span> <span class="namespace">void</span> <span class="namespace">setMessage</span> （ <span class="namespace">String</span> <span class="namespace">message</span> ）{ <span class="namespace">this.message</span> = <span class="namespace">message</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当程序执行时，输入暂停之前的输出将是<em>I Can Do The Frug</em> 。在对源文件进行更改并保存并且程序恢复执行之后，在动态语言支持的<code>Messenger</code>实现上调用<code>getMessage()</code>方法的结果将是<em>“我能做到这一点”</em> （注意包含额外的报价）。</p>
</div>
<div class="paragraph">
<p>重要的是要理解，如果在<code>'refresh-check-delay'</code>值的窗口内发生更改，脚本的更改将<em>不会</em>触发刷新。同样重要的是要理解，在动态语言支持的bean上调用方法之前，实际上<em>不会</em> “拾取”脚本的更改。只有在动态语言支持的bean上调用方法时，它才会检查其底层脚本源是否已更改。与刷新脚本相关的任何异常（例如遇到编译错误或发现脚本文件已被删除）都会导致<em>致命</em>异常传播到调用代码。</p>
</div>
<div class="paragraph">
<p>上述的可刷新的豆行为<em>并不</em>适用于使用所定义的动态语言的源文件<code>&lt;lang:inline-script/&gt;</code>元素符号（参照<a href="#dynamic-language-beans-inline">内置动态语言的源文件</a> ）。此外，它<em>仅</em>适用于实际可以检测到对基础源文件的更改的bean;例如，通过检查文件系统上存在的动态语言源文件的上次修改日期的代码。</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-inline"><a class="anchor" href="#dynamic-language-beans-inline"></a>内联动态语言源文件</h5>
<div class="paragraph">
<p>动态语言支持还可以满足直接嵌入Spring bean定义的动态语言源文件。更具体地说， <code>&lt;lang:inline-script/&gt;</code>元素允许您在Spring配置文件中立即定义动态语言源。一个例子可能会使内联脚本功能清晰明了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messenger</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：inline-script&gt;</span> package org.springframework.scripting.groovy; import org.springframework.scripting。Messenger类GroovyMessenger实现Messenger {String message} <span class="tag">&lt;/ lang：inline-script&gt;</span> <span class="tag">&lt;lang：property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">message</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">I Can Do The Frug</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ lang：groovy&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将围绕在Spring配置文件中定义动态语言源是否合适的问题放在一边，那么<code>&lt;lang:inline-script/&gt;</code>元素在某些情况下会很有用。例如，我们可能希望快速将Spring <code>Validator</code>实现添加到Spring MVC <code>Controller</code> 。这只是使用内联源的片刻工作。（有关此类示例，请参阅<a href="#dynamic-language-scenarios-validators">脚本验证器</a> 。）</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-ctor-injection"><a class="anchor" href="#dynamic-language-beans-ctor-injection"></a>在动态语言支持的bean的上下文中理解构造函数注入</h5>
<div class="paragraph">
<p>关于Spring的动态语言支持，有一点<em>非常</em>重要。也就是说，（当前）不可能为动态语言支持的bean提供构造函数参数（因此构造函数注入不适用于动态语言支持的bean）。为了将构造器和属性100％清楚的这种特殊处理的利益，代码和配置以下混合物将<em>无法</em>正常工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//来自'Messenger.groovy'文件</span> <span class="keyword">包</span> <span class="namespace">org.springframework.scripting.groovy</span> ; <span class="keyword">import</span> <span class="include">org.springframework.scripting。Messenger</span> <span class="include">类</span> <span class="include">GroovyMessenger</span> <span class="include">实现了</span> <span class="include">Messenger</span> { <span class="include">GroovyMessenger</span> （）{} <span class="comment">//这个构造函数不适用于构造函数注入</span> <span class="include">GroovyMessenger</span> （ <span class="include">String</span> <span class="include">message</span> ）{ <span class="include">this.message</span> = <span class="include">message</span> ; } <span class="predefined-type">字符串</span>消息<span class="predefined-type">字符串</span> anotherMessage}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">badMessenger</span> <span class="delimiter">”</span></span> <span class="attribute-name">script-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：Messenger.groovy</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这个下一个构造函数参数<strong>不会</strong>被注入到GroovyMessenger中 - &gt;</span> <span class="comment">&lt;！ - 实际上，这不是即使按照该模式允许- &gt;</span> <span class="tag">&lt;构造带参数的</span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=“</span> <span class="content">这样可<strong>不行</strong></span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="comment"><span class="tag">&lt;！</span> -仅属性值注入到动态语言支持的对象- &gt;</span> <span class="tag">&lt;郎咸平<span class="comment">：</span>属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=“</span> <span class="content">anotherMessage</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">直接传递给动态语言支持的对象</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ lang&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在实践中，这种限制并不像它最初看起来那么重要，因为二手注射是绝大多数开发人员所青睐的注射方式（让我们继续讨论这对于另一天来说是否是好事）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-beans-groovy"><a class="anchor" href="#dynamic-language-beans-groovy"></a> 3.3.2。Groovy豆</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">Groovy库依赖项</div>
<div class="paragraph">
<p>Spring中的Groovy脚本支持要求以下库位于应用程序的类路径中。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>常规-1.8.jar</code></p>
</li>
<li>
<p><code>ASM-3.2.jar</code></p>
</li>
<li>
<p><code>ANTLR-2.7.7.jar</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>来自Groovy主页......</p>
</div>
<div class="paragraph">
<p>“ <em>Groovy是Java 2平台的一种敏捷动态语言，它具有人们在Python，Ruby和Smalltalk等语言中非常喜欢的许多功能，使Java开发人员可以使用类似Java的语法。</em> ”</p>
</div>
<div class="paragraph">
<p>如果您直接从顶部阅读本章，您将<a href="#dynamic-language-a-first-example">看到</a>一个Groovy动态语言支持的bean <a href="#dynamic-language-a-first-example">的示例</a> 。让我们看另一个例子（再次使用Spring测试套件中的一个例子）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.scripting</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">Calculator</span> { <span class="type">int</span> add（ <span class="type">int</span> x， <span class="type">int</span> y）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是Groovy中<code>Calculator</code>接口的实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">//来自'calculator.groovy'文件</span> <span class="keyword">包</span> org.springframework.scripting.groovy <span class="type">类</span> <span class="class">GroovyCalculator</span> <span class="directive">实现</span> Calculator { <span class="type">int</span> add（ <span class="type">int</span> x， <span class="type">int</span> y）{x + y}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt; -</span> <span class="attribute-name"><span class="attribute-name">从</span></span> <span class="attribute-name">文件</span> <span class="error">'</span> <span class="attribute-name">的<span class="error">beans.xml'</span></span> <span class="attribute-name">-</span> <span class="tag">&gt;</span> <span class="tag">&lt;豆&gt;</span> <span class="tag">的&lt;lang：常规</span> <span class="attribute-name">的id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">计算器</span> <span class="delimiter">”</span></span> <span class="attribute-name">脚本的源</span> = <span class="string"><span class="delimiter">“</span> <span class="content">类路径<span class="delimiter"><span class="tag">：calculator.groovy”/&gt;</span></span></span></span> <span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，这是一个小应用程序来执行上述配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.scripting</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> Main（ <span class="predefined-type">String</span> <span class="type">[]</span> args）{ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">beans.xml</span> <span class="delimiter">”</span></span> ）;计算器calc =（计算器）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">计算器</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">系统</span> <span class="integer"><span class="integer">.out.println（calc.add（2,8））;</span></span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行上述程序产生的结果将是（不出所料） <em>10</em> 。（令人兴奋的例子，是吗？请记住，目的是说明这个概念。有关更复杂的示例，请参阅动态语言展示项目，或者本章后面的<a href="#dynamic-language-scenarios">方案</a> 。</p>
</div>
<div class="paragraph">
<p>重要的是， <em>不要</em>为每个Groovy源文件定义多个类。虽然这在Groovy中是完全合法的，但它（可以说）是一种不好的做法：为了一致的方法，您应该（在本作者看来）尊重每个源文件的一个（公共）类的标准Java约定。</p>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-groovy-customizer"><a class="anchor" href="#dynamic-language-beans-groovy-customizer"></a>通过回调自定义Groovy对象</h5>
<div class="paragraph">
<p><code>GroovyObjectCustomizer</code>接口是一个回调，允许您将其他创建逻辑挂钩到创建Groovy支持的bean的过程中。例如，此接口的实现可以调用任何所需的初始化方法，或设置一些默认属性值，或指定自定义<code>MetaClass</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">GroovyObjectCustomizer</span> { <span class="type">void</span> customize（GroovyObject goo）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Framework将实例化Groovy支持的bean的实例，然后将创建的<code>GroovyObject</code>传递给指定的<code>GroovyObjectCustomizer</code>如果已定义）。你可以使用提供的<code>GroovyObject</code>引用做任何你喜欢的<code>GroovyObject</code> ：预计自定义<code>MetaClass</code>的设置是大多数人想要对这个回调做的事情，你可以在下面看到这样做的一个例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">SimpleMethodTracingCustomizer</span> <span class="directive">实现</span> GroovyObjectCustomizer { <span class="directive">public</span> <span class="type">void</span> customize（GroovyObject goo）{DelegatingMetaClass metaClass = <span class="keyword">new</span> DelegatingMetaClass（goo.getMetaClass（））{ <span class="directive">public</span> <span class="predefined-type">Object</span> invokeMethod（ <span class="predefined-type">Object</span> object， <span class="predefined-type">String</span> methodName， <span class="predefined-type">Object</span> <span class="type">[]</span> arguments）{ <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span> <span class="content">调用'</span> <span class="delimiter">”</span></span> + methodName + <span class="string"><span class="delimiter">“</span> <span class="content">'。</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> <span class="local-variable">super</span> .invokeMethod（object，methodName，arguments）; }}; metaClass.initialize（）; goo.setMetaClass（metaClass上）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Groovy中对元编程的完整讨论超出了Spring参考手册的范围。请参阅Groovy参考手册的相关部分，或在线搜索：有很多关于此主题的文章。如果您使用Spring命名空间支持，实际上很容易使用<code>GroovyObjectCustomizer</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 像任何其他bean一样定义GroovyObjectCustomizer  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">tracingCustomizer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMethodTracingCustomizer</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  ...并通过'customizer-ref'属性将其插入所需的Groovy bean  - &gt;</span> <span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">calculator</span> <span class="delimiter">“</span></span> <span class="attribute-name">script-source</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：org / springframework / scripting / groovy / Calculator.groovy</span> <span class="delimiter">“</span></span> <span class="attribute-name">customizer-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tracingCustomizer</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不使用Spring命名空间支持，您仍然可以使用<code>GroovyObjectCustomizer</code>功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">calculator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scripting.groovy。GroovyScriptFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：org / springframework / scripting / groovy / Calculator.groovy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 定义GroovyObjectCustomizer（作为内部bean） - &gt;</span> <span class="tag">&lt;constructor-arg&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">tracingCustomizer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。SimpleMethodTracingCustomizer</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ constructor-arg&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.scripting.support。ScriptFactoryPostProcessor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.3.3开始，您还可以在与Spring的<code>GroovyObjectCustomizer</code>相同的位置指定Groovy <code>CompilationCustomizer</code> （例如<code>ImportCustomizer</code> ）或甚至完整的Groovy <code>CompilerConfiguration</code>对象。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-beans-bsh"><a class="anchor" href="#dynamic-language-beans-bsh"></a> 3.3.3。BeanShell bean</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">BeanShell库依赖项</div>
<div class="paragraph">
<p>Spring中的BeanShell脚本支持要求以下库位于应用程序的类路径中。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BSH-2.0b4.jar</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>来自BeanShell主页......</p>
</div>
<div class="paragraph">
<p>“ <em>BeanShell是一个小型，免费，可嵌入的Java源代码解释器，具有动态语言功能，用Java编写。BeanShell动态执行标准Java语法，并使用常见的脚本编写方便性扩展它，例如松散类型，命令和方法闭包，如Perl和JavaScript中的那些。</em> “</p>
</div>
<div class="paragraph">
<p>与Groovy相比，BeanShell支持的bean定义需要一些（小）额外配置。Spring中BeanShell动态语言支持的实现很有意思，因为它发生了这样的事情：Spring创建了一个JDK动态代理，实现了<code>&lt;lang:bsh&gt;</code>元素的<code>'script-interfaces'</code>属性值中指定的所有<code>'script-interfaces'</code> （这就是为什么你<em>必须</em>在属性的值中提供至少一个接口，并且（相应地）在使用BeanShell支持的bean时编程到接口）。这意味着对BeanShell支持的对象的每个方法调用都将通过JDK动态代理调用机制。</p>
</div>
<div class="paragraph">
<p>让我们看一个使用基于BeanShell的bean的完整工作示例，该bean实现本章前面定义的<code>Messenger</code>接口（为方便起见，下面重复）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.scripting</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">Messenger</span> { <span class="predefined-type">String</span> getMessage（）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是<code>Messenger</code>接口的BeanShell“实现”（这里使用的术语很松散）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">字符串</span>消息; <span class="predefined-type">String</span> getMessage（）{ <span class="keyword">return</span> message; <span class="type">void</span> setMessage（ <span class="predefined-type">String</span> aMessage）{message = aMessage; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是定义上述“类”的“实例”的Spring XML（同样，这里使用的术语非常松散）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;lang：bsh</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messageService</span> <span class="delimiter">”</span></span> <span class="attribute-name">script-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：BshMessenger.bsh</span> <span class="delimiter">”</span></span> <span class="attribute-name">script-interfaces</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scripting。Messenger</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">message</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Hello World！</span><span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ lang：bsh&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关您可能希望使用基于BeanShell的bean的某些方案，请参阅<a href="#dynamic-language-scenarios">方案</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-scenarios"><a class="anchor" href="#dynamic-language-scenarios"></a> 3.4。方案</h3>
<div class="paragraph">
<p>当然，使用脚本语言定义Spring托管bean的可能场景是有益的。本节介绍Spring中动态语言支持的两种可能用例。</p>
</div>
<div class="sect3">
<h4 id="dynamic-language-scenarios-controllers"><a class="anchor" href="#dynamic-language-scenarios-controllers"></a> 3.4.1。脚本化的Spring MVC控制器</h4>
<div class="paragraph">
<p>可以从使用动态语言支持的bean中受益的一组类是Spring MVC控制器。在纯Spring MVC应用程序中，通过Web应用程序的导航流程在很大程度上取决于Spring MVC控制器中封装的代码。由于需要更新Web应用程序的导航流程和其他表示层逻辑以响应支持问题或更改业务需求，因此通过编辑一个或多个动态语言源文件并查看这些文件可能更容易实现任何此类所需的更改更改会立即反映在正在运行的应用程序的状态中。</p>
</div>
<div class="paragraph">
<p>请记住，在Spring等项目所支持的轻量级架构模型中，您通常希望拥有一个非常<em>精简的</em>表示层，应用程序的所有内容业务逻辑都包含在域和服务层类中。将Spring MVC控制器开发为动态语言支持的bean允许您通过简单地编辑和保存文本文件来更改表示层逻辑;对此类动态语言源文件的任何更改（取决于配置）将自动反映在由动态语言源文件支持的Bean中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了实现对动态语言支持bean的任何更改的自动“拾取”，您必须启用“可刷新bean”功能。请参阅<a href="#dynamic-language-refreshable-beans">Refreshable beans</a>以获得此功能的完整处理。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在下面找到<code>org.springframework.web.servlet.mvc.的示例<code>org.springframework.web.servlet.mvc.使用Groovy动态语言实现的Controller</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//来自文件'/WEB-INF/groovy/FortuneController.groovy'</span> <span class="keyword">包</span> <span class="namespace">org.springframework.showcase.fortune.web</span> <span class="namespace">import</span> <span class="namespace">org.springframework.showcase.fortune.service。FortuneService</span> <span class="namespace">导入</span> <span class="namespace">org.springframework.showcase.fortune.domain。财富</span> <span class="namespace">导入</span> <span class="namespace">org.springframework.web.servlet。ModelAndView</span> <span class="namespace">导入</span> <span class="namespace">org.springframework.web.servlet.mvc。控制器</span> <span class="namespace">导入</span> <span class="namespace">javax.servlet.http。HttpServletRequest</span> <span class="namespace">导入</span> <span class="namespace">javax.servlet.http。HttpServletResponse</span> <span class="namespace">类</span> <span class="namespace">FortuneController</span> <span class="namespace">实现</span> <span class="namespace">Controller</span> { <span class="annotation">@Property</span> <span class="namespace">FortuneService</span> <span class="namespace">fortuneService</span> <span class="namespace">ModelAndView</span> <span class="namespace">handleRequest</span> （ <span class="namespace">HttpServletRequest</span> <span class="namespace">request</span> ， <span class="namespace">HttpServletResponse</span> <span class="namespace">httpServletResponse</span> ）{ <span class="namespace">return</span> <span class="namespace">new</span> <span class="namespace">ModelAndView</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">tell</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">fortune</span> <span class="delimiter">”</span></span> ， <span class="namespace">this.fortuneService.tellFortune</span> （））}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">的&lt;lang：常规</span> <span class="attribute-name">的id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">运气</span> <span class="delimiter">”</span></span> <span class="attribute-name">刷新检查延迟</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“3000”</span></span></span></span> <span class="attribute-name">脚本的源</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“/WEB-INF/groovy/FortuneController.groovy”&gt;</span></span></span></span></span> <span class="tag">&lt;郎：属性</span> <span class="attribute-name">名</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“fortuneService”</span></span></span></span> <span class="attribute-name">REF</span> = <span class="tag"><span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“fortuneService”/</span></span></span></span> &gt;</span> <span class="tag">&lt;/ lang：groovy&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-scenarios-validators"><a class="anchor" href="#dynamic-language-scenarios-validators"></a> 3.4.2。脚本验证器</h4>
<div class="paragraph">
<p>Spring的应用程序开发的另一个领域可能受益于动态语言支持的bean提供的灵活性，即验证。与常规Java相比，使用松散类型的动态语言（也可能支持内联正则表达式）来表达复杂的验证逻辑<em>可能</em>更容易。</p>
</div>
<div class="paragraph">
<p>同样，将验证器开发为动态语言支持的bean允许您通过简单地编辑和保存简单的文本文件来更改验证逻辑;任何此类更改将（根据配置）自动反映在正在运行的应用程序的执行中，并且不需要重新启动应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，为了实现对动态语言支持的bean的任何更改的自动“拾取”，您必须启用“可刷新的bean”功能。有关此功能的详细信息，请参阅可<a href="#dynamic-language-refreshable-beans">刷新的豆类</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在下面找到一个Spring <code>org.springframework.validation.的示例<code>org.springframework.validation.Validator</code>使用Groovy动态语言实现。（有关<a href="core.html#validator">Validator接口</a>的讨论，请参阅<a href="core.html#validator">使用Spring的Validator接口</a>进行<code>Validator</code> 。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.springframework.validation。验证器</span> <span class="keyword">导入</span> <span class="include">org.springframework.validation。错误</span> <span class="keyword">导入</span> <span class="include">org.springframework.beans。TestBean</span> <span class="type">类</span> <span class="class">TestBeanValidator</span> <span class="directive">实现</span> <span class="predefined-type">Validator</span> { <span class="type">boolean</span> supports（ <span class="predefined-type">Class</span> clazz）{ <span class="keyword">return</span> TestBean.class.isAssignableFrom（clazz）} <span class="type">void</span> validate（ <span class="predefined-type">Object</span> bean，Errors errors）{ <span class="keyword">if</span> （bean.name?.trim（）?. size（）&gt; <span class="integer">0</span> ）{ <span class="keyword">return</span> } errors.reject（ <span class="string"><span class="delimiter">“</span> <span class="content">whitespace</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">不能完全由空格组成。</span> <span class="delimiter">”</span></span> ）}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-final-notes"><a class="anchor" href="#dynamic-language-final-notes"></a> 3.5。比特和鲍勃</h3>
<div class="paragraph">
<p>最后一节包含与动态语言支持相关的一些位和bobs。</p>
</div>
<div class="sect3">
<h4 id="dynamic-language-final-notes-aop"><a class="anchor" href="#dynamic-language-final-notes-aop"></a> 3.5.1。AOP  - 建议脚本bean</h4>
<div class="paragraph">
<p>可以使用Spring AOP框架来建议脚本bean。Spring AOP框架实际上并不知道被建议的bean可能是一个脚本bean，因此您可能正在使用或打算使用的所有AOP用例和功能都适用于脚本bean。在建议脚本化bean时，您只需要注意一件事（小事）......您不能使用基于类的代理，您必须使用<a href="core.html#aop-proxying">基于接口的代理</a> 。</p>
</div>
<div class="paragraph">
<p>您当然不仅限于为脚本bean提供建议......您还可以使用受支持的动态语言编写方面本身，并使用此类bean来建议其他Spring bean。这确实是动态语言支持的高级用法。</p>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-final-notes-scopes"><a class="anchor" href="#dynamic-language-final-notes-scopes"></a> 3.5.2。作用域</h4>
<div class="paragraph">
<p>如果不是很明显，脚本bean当然可以像任何其他bean一样限定范围。各种<code>&lt;lang:language/&gt;</code>元素的<code>scope</code>属性允许您控制底层脚本bean的范围，就像使用常规bean一样。（默认范围是<a href="core.html#beans-factory-scopes-singleton">单例</a> ，就像'常规'bean一样。）</p>
</div>
<div class="paragraph">
<p>下面是一个使用<code>scope</code>属性定义作为<a href="core.html#beans-factory-scopes-prototype">原型</a>的Groovy bean的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：lang</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/lang</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：groovy</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="attribute-name">script-source</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：Messenger.groovy</span> <span class="delimiter">“</span></span> <span class="attribute-name">scope</span> = <span class="string"><span class="delimiter">”</span> <span class="content">prototype</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;lang：property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">message</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">我可以做RoboCop</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ lang：groovy&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bookingService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyDefaultBookingService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messenger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="core.html#beans">IoC容器</a>中的<a href="core.html#beans-factory-scopes">Bean作用域</a> ，以更全面地讨论Spring Framework中的作用域支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-lang"><a class="anchor" href="#xsd-schemas-lang"></a> 3.5.3。lang XML架构</h4>
<div class="paragraph">
<p>Spring XML配置中的<code>lang</code>标记处理暴露用动态语言（如JRuby或Groovy）编写的对象作为Spring容器中的bean。</p>
</div>
<div class="paragraph">
<p>这些标记（以及动态语言支持）在题为<a href="integration.html#dynamic-language">动态语言支持</a>的章节中全面介绍。有关此支持和<code>lang</code>标签本身的详细信息，请参阅该章节。</p>
</div>
<div class="paragraph">
<p>为了完整性，要在<code>lang</code>模式中使用标记，您需要在Spring XML配置文件的顶部有以下前导码;以下代码段中的文本引用了正确的架构，以便您可以使用<code>lang</code>命名空间中的标记。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：lang</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/lang</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-resources"><a class="anchor" href="#dynamic-language-resources"></a> 3.6。更多资源</h3>
<div class="paragraph">
<p>请在下面找到有关本章所述各种动态语言的更多资源的链接。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://jruby.org/">JRuby</a>主页</p>
</li>
<li>
<p><a href="http://www.groovy-lang.org/">Groovy</a>主页</p>
</li>
<li>
<p><a href="http://www.beanshell.org/">BeanShell</a>主页</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>