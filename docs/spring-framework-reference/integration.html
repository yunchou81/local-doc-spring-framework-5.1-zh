<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>积分</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="spring-integration" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>积分</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#remoting">1。使用Spring进行远程处理和Web服务</a>
<ul class="sectlevel2">
<li><a href="#remoting-introduction">1.1。介绍</a></li>
<li><a href="#remoting-rmi">1.2。使用RMI公开服务</a>
<ul class="sectlevel3">
<li><a href="#remoting-rmi-server">1.2.1。使用RmiServiceExporter导出服务</a></li>
<li><a href="#remoting-rmi-client">1.2.2。链接到客户端的服务</a></li>
</ul>
</li>
<li><a href="#remoting-caucho-protocols">1.3。使用Hessian通过HTTP远程调用服务</a>
<ul class="sectlevel3">
<li><a href="#remoting-caucho-protocols-hessian">1.3.1。连接Hessian和co的DispatcherServlet。</a></li>
<li><a href="#remoting-caucho-protocols-hessian-server">1.3.2。使用HessianServiceExporter公开您的bean</a></li>
<li><a href="#remoting-caucho-protocols-hessian-client">1.3.3。在客户端上链接服务</a></li>
<li><a href="#remoting-caucho-protocols-security">1.3.4。将HTTP基本身份验证应用于通过Hessian公开的服务</a></li>
</ul>
</li>
<li><a href="#remoting-httpinvoker">1.4。使用HTTP调用程序公开服务</a>
<ul class="sectlevel3">
<li><a href="#remoting-httpinvoker-server">1.4.1。公开服务对象</a></li>
<li><a href="#remoting-httpinvoker-client">1.4.2。链接到客户端的服务</a></li>
</ul>
</li>
<li><a href="#remoting-web-services">1.5。网页服务</a>
<ul class="sectlevel3">
<li><a href="#remoting-web-services-jaxws-export-servlet">1.5.1。使用JAX-WS公开基于servlet的Web服务</a></li>
<li><a href="#remoting-web-services-jaxws-export-standalone">1.5.2。使用JAX-WS导出独立Web服务</a></li>
<li><a href="#remoting-web-services-jaxws-export-ri">1.5.3。使用JAX-WS RI的Spring支持导出Web服务</a></li>
<li><a href="#remoting-web-services-jaxws-access">1.5.4。使用JAX-WS访问Web服务</a></li>
</ul>
</li>
<li><a href="#remoting-jms">1.6。JMS</a>
<ul class="sectlevel3">
<li><a href="#remoting-jms-server">1.6.1。服务器端配置</a></li>
<li><a href="#remoting-jms-client">1.6.2。客户端配置</a></li>
</ul>
</li>
<li><a href="#remoting-amqp">1.7。AMQP</a></li>
<li><a href="#remoting-autodection-remote-interfaces">1.8。远程接口未实现自动检测</a></li>
<li><a href="#remoting-considerations">1.9。选择技术时的注意事项</a></li>
<li><a href="#rest-client-access">1.10。REST端点</a>
<ul class="sectlevel3">
<li><a href="#rest-resttemplate">1.10.1。RestTemplate</a>
<ul class="sectlevel4">
<li><a href="#rest-resttemplate-create">初始化</a></li>
<li><a href="#rest-resttemplate-uri">的URI</a></li>
<li><a href="#rest-template-headers">头</a></li>
<li><a href="#rest-template-body">身体</a></li>
<li><a href="#rest-message-conversion">消息转换</a></li>
<li><a href="#rest-template-jsonview">杰克逊JSON观点</a></li>
<li><a href="#rest-template-multipart">多</a></li>
</ul>
</li>
<li><a href="#rest-async-resttemplate">1.10.2。异步RestTemplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ejb">2。Enterprise JavaBeans（EJB）集成</a>
<ul class="sectlevel2">
<li><a href="#ejb-introduction">2.1。介绍</a></li>
<li><a href="#ejb-access">2.2。访问EJB</a>
<ul class="sectlevel3">
<li><a href="#ejb-access-concepts">2.2.1。概念</a></li>
<li><a href="#ejb-access-local">2.2.2。访问本地SLSB</a></li>
<li><a href="#ejb-access-remote">2.2.3。访问远程SLSB</a></li>
<li><a href="#ejb-access-ejb2-ejb3">2.2.4。访问EJB 2.x SLSB与EJB 3 SLSB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jms">3。JMS（Java消息服务）</a>
<ul class="sectlevel2">
<li><a href="#jms-introduction">3.1。介绍</a></li>
<li><a href="#jms-using">3.2。使用Spring JMS</a>
<ul class="sectlevel3">
<li><a href="#jms-jmstemplate">3.2.1。JmsTemplate的</a></li>
<li><a href="#jms-connections">3.2.2。连接</a>
<ul class="sectlevel4">
<li><a href="#jms-caching-resources">缓存消息传递资源</a></li>
<li><a href="#jms-connection-factory">SingleConnectionFactory</a></li>
<li><a href="#jdbc-connection-factory-caching">CachingConnectionFactory</a></li>
</ul>
</li>
<li><a href="#jms-destinations">3.2.3。目的地管理</a></li>
<li><a href="#jms-mdp">3.2.4。消息侦听器容器</a>
<ul class="sectlevel4">
<li><a href="#jms-mdp-simple">SimpleMessageListenerContainer一样</a></li>
<li><a href="#jms-mdp-default">使用DefaultMessageListenerContainer</a></li>
</ul>
</li>
<li><a href="#jms-tx">3.2.5。交易管理</a></li>
</ul>
</li>
<li><a href="#jms-sending">3.3。发送消息</a>
<ul class="sectlevel3">
<li><a href="#jms-msg-conversion">3.3.1。使用消息转换器</a></li>
<li><a href="#jms-callbacks">3.3.2。SessionCallback和ProducerCallback</a></li>
</ul>
</li>
<li><a href="#jms-receiving">3.4。收到消息</a>
<ul class="sectlevel3">
<li><a href="#jms-receiving-sync">3.4.1。同步接收</a></li>
<li><a href="#jms-asynchronousMessageReception">3.4.2。异步接收：消息驱动的POJO</a></li>
<li><a href="#jms-receiving-async-session-aware-message-listener">3.4.3。SessionAwareMessageListener接口</a></li>
<li><a href="#jms-receiving-async-message-listener-adapter">3.4.4。的MessageListenerAdapter</a></li>
<li><a href="#jms-tx-participation">3.4.5。处理交易中的消息</a></li>
</ul>
</li>
<li><a href="#jms-jca-message-endpoint-manager">3.5。支持JCA消息端点</a></li>
<li><a href="#jms-annotated">3.6。注释驱动的侦听器端点</a>
<ul class="sectlevel3">
<li><a href="#jms-annotated-support">3.6.1。启用侦听器端点注释</a></li>
<li><a href="#jms-annotated-programmatic-registration">3.6.2。程序化端点注册</a></li>
<li><a href="#jms-annotated-method-signature">3.6.3。带注释的端点方法签名</a></li>
<li><a href="#jms-annotated-response">3.6.4。响应管理</a></li>
</ul>
</li>
<li><a href="#jms-namespace">3.7。JMS命名空间支持</a></li>
</ul>
</li>
<li><a href="#jmx">4。JMX</a>
<ul class="sectlevel2">
<li><a href="#jmx-introduction">4.1。介绍</a></li>
<li><a href="#jmx-exporting">4.2。将bean导出到JMX</a>
<ul class="sectlevel3">
<li><a href="#jmx-exporting-mbeanserver">4.2.1。创建MBeanServer</a></li>
<li><a href="#jmx-mbean-server">4.2.2。重用现有的MBeanServer</a></li>
<li><a href="#jmx-exporting-lazy">4.2.3。延迟初始化的MBean</a></li>
<li><a href="#jmx-exporting-auto">4.2.4。自动注册MBean</a></li>
<li><a href="#jmx-exporting-registration-behavior">4.2.5。控制注册行为</a></li>
</ul>
</li>
<li><a href="#jmx-interface">4.3。控制bean的管理界面</a>
<ul class="sectlevel3">
<li><a href="#jmx-interface-assembler">4.3.1。MBeanInfoAssembler接口</a></li>
<li><a href="#jmx-interface-metadata">4.3.2。使用源级元数据：Java注释</a></li>
<li><a href="#jmx-interface-metadata-types">4.3.3。源级元数据类型</a></li>
<li><a href="#jmx-interface-autodetect">4.3.4。AutodetectCapableMBeanInfoAssembler接口</a></li>
<li><a href="#jmx-interface-java">4.3.5。使用Java接口定义管理接口</a></li>
<li><a href="#jmx-interface-methodnames">4.3.6。使用MethodNameBasedMBeanInfoAssembler</a></li>
</ul>
</li>
<li><a href="#jmx-naming">4.4。控制bean的ObjectNames</a>
<ul class="sectlevel3">
<li><a href="#jmx-naming-properties">4.4.1。从属性中读取ObjectNames</a></li>
<li><a href="#jmx-naming-metadata">4.4.2。使用MetadataNamingStrategy</a></li>
<li><a href="#jmx-context-mbeanexport">4.4.3。配置基于MBean导出的注释</a></li>
</ul>
</li>
<li><a href="#jmx-jsr160">4.5。JSR-160连接器</a>
<ul class="sectlevel3">
<li><a href="#jmx-jsr160-server">4.5.1。服务器端连接器</a></li>
<li><a href="#jmx-jsr160-client">4.5.2。客户端连接器</a></li>
<li><a href="#jmx-jsr160-protocols">4.5.3。JMX over Hessian或SOAP</a></li>
</ul>
</li>
<li><a href="#jmx-proxy">4.6。通过代理访问MBean</a></li>
<li><a href="#jmx-notifications">4.7。通知</a>
<ul class="sectlevel3">
<li><a href="#jmx-notifications-listeners">4.7.1。注册通知的侦听器</a></li>
<li><a href="#jmx-notifications-publishing">4.7.2。发布通知</a></li>
</ul>
</li>
<li><a href="#jmx-resources">4.8。更多资源</a></li>
</ul>
</li>
<li><a href="#cci">5。JCA CCI</a>
<ul class="sectlevel2">
<li><a href="#cci-introduction">5.1。介绍</a></li>
<li><a href="#cci-config">5.2。配置CCI</a>
<ul class="sectlevel3">
<li><a href="#cci-config-connector">5.2.1。连接器配置</a></li>
<li><a href="#cci-config-connectionfactory">5.2.2。Spring中的ConnectionFactory配置</a></li>
<li><a href="#cci-config-cci-connections">5.2.3。配置CCI连接</a></li>
<li><a href="#cci-config-single-connection">5.2.4。使用单个CCI连接</a></li>
</ul>
</li>
<li><a href="#cci-using">5.3。使用Spring的CCI访问支持</a>
<ul class="sectlevel3">
<li><a href="#cci-record-creator">5.3.1。记录转换</a></li>
<li><a href="#cci-using-template">5.3.2。CciTemplate</a></li>
<li><a href="#cci-using-dao">5.3.3。DAO支持</a></li>
<li><a href="#automatic-output-generation">5.3.4。自动输出记录生成</a></li>
<li><a href="#template-summary">5.3.5。概要</a></li>
<li><a href="#cci-straight">5.3.6。直接使用CCI连接和交互</a></li>
<li><a href="#cci-template-example">5.3.7。CciTemplate用法示例</a></li>
</ul>
</li>
<li><a href="#cci-object">5.4。将CCI访问建模为操作对象</a>
<ul class="sectlevel3">
<li><a href="#cci-object-mapping-record">5.4.1。MappingRecordOperation</a></li>
<li><a href="#cci-object-mapping-comm-area">5.4.2。MappingCommAreaOperation</a></li>
<li><a href="#cci-automatic-record-gen">5.4.3。自动输出记录生成</a></li>
<li><a href="#cci-object-summary">5.4.4。概要</a></li>
<li><a href="#cci-objects-mappring-record-example">5.4.5。MappingRecordOperation用法示例</a></li>
<li><a href="#cci-objects-mapping-comm-area-example">5.4.6。MappingCommAreaOperation用法示例</a></li>
</ul>
</li>
<li><a href="#cci-tx">5.5。交易</a></li>
</ul>
</li>
<li><a href="#mail">6。电子邮件</a>
<ul class="sectlevel2">
<li><a href="#mail-introduction">6.1。介绍</a></li>
<li><a href="#mail-usage">6.2。用法</a>
<ul class="sectlevel3">
<li><a href="#mail-usage-simple">6.2.1。基本MailSender和SimpleMailMessage用法</a></li>
<li><a href="#mail-usage-mime">6.2.2。使用JavaMailSender和MimeMessagePreparator</a></li>
</ul>
</li>
<li><a href="#mail-javamail-mime">6.3。使用JavaMail MimeMessageHelper</a>
<ul class="sectlevel3">
<li><a href="#mail-javamail-mime-attachments">6.3.1。发送附件和内联资源</a>
<ul class="sectlevel4">
<li><a href="#mail-javamail-mime-attachments-attachment">附件</a></li>
<li><a href="#mail-javamail-mime-attachments-inline">内联资源</a></li>
</ul>
</li>
<li><a href="#mail-templates">6.3.2。使用模板库创建电子邮件内容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#scheduling">7。任务执行和调度</a>
<ul class="sectlevel2">
<li><a href="#scheduling-introduction">7.1。介绍</a></li>
<li><a href="#scheduling-task-executor">7.2。Spring TaskExecutor抽象</a>
<ul class="sectlevel3">
<li><a href="#scheduling-task-executor-types">7.2.1。TaskExecutor类型</a></li>
<li><a href="#scheduling-task-executor-usage">7.2.2。使用TaskExecutor</a></li>
</ul>
</li>
<li><a href="#scheduling-task-scheduler">7.3。Spring TaskScheduler抽象</a>
<ul class="sectlevel3">
<li><a href="#scheduling-trigger-interface">7.3.1。触发界面</a></li>
<li><a href="#scheduling-trigger-implementations">7.3.2。触发器实现</a></li>
<li><a href="#scheduling-task-scheduler-implementations">7.3.3。TaskScheduler实现</a></li>
</ul>
</li>
<li><a href="#scheduling-annotation-support">7.4。调度和异步执行的注释支持</a>
<ul class="sectlevel3">
<li><a href="#scheduling-enable-annotation-support">7.4.1。启用计划注释</a></li>
<li><a href="#scheduling-annotation-support-scheduled">7.4.2。@Scheduled注释</a></li>
<li><a href="#scheduling-annotation-support-async">7.4.3。@Async注释</a></li>
<li><a href="#scheduling-annotation-support-qualification">7.4.4。使用@Async执行者资格</a></li>
<li><a href="#scheduling-annotation-support-exception">7.4.5。使用@Async进行异常管理</a></li>
</ul>
</li>
<li><a href="#scheduling-task-namespace">7.5。任务名称空间</a>
<ul class="sectlevel3">
<li><a href="#scheduling-task-namespace-scheduler">7.5.1。'scheduler'元素</a></li>
<li><a href="#scheduling-task-namespace-executor">7.5.2。'executor'元素</a></li>
<li><a href="#scheduling-task-namespace-scheduled-tasks">7.5.3。'scheduled-tasks'元素</a></li>
</ul>
</li>
<li><a href="#scheduling-quartz">7.6。使用Quartz Scheduler</a>
<ul class="sectlevel3">
<li><a href="#scheduling-quartz-jobdetail">7.6.1。使用JobDetailFactoryBean</a></li>
<li><a href="#scheduling-quartz-method-invoking-job">7.6.2。使用MethodInvokingJobDetailFactoryBean</a></li>
<li><a href="#scheduling-quartz-cron">7.6.3。使用触发器和SchedulerFactoryBean连接作业</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cache">8。缓存抽象</a>
<ul class="sectlevel2">
<li><a href="#cache-introduction">8.1。介绍</a></li>
<li><a href="#cache-strategies">8.2。理解缓存抽象</a></li>
<li><a href="#cache-annotations">8.3。基于声明注释的缓存</a>
<ul class="sectlevel3">
<li><a href="#cache-annotations-cacheable">8.3.1。@Cacheable注释</a>
<ul class="sectlevel4">
<li><a href="#cache-annotations-cacheable-default-key">默认密钥生成</a></li>
<li><a href="#cache-annotations-cacheable-key">自定义密钥生成声明</a></li>
<li><a href="#cache-annotations-cacheable-default-cache-resolver">默认缓存分辨率</a></li>
<li><a href="#cache-annotations-cacheable-cache-resolver">自定义缓存分辨率</a></li>
<li><a href="#cache-annotations-cacheable-synchronized">同步缓存</a></li>
<li><a href="#cache-annotations-cacheable-condition">有条件的缓存</a></li>
<li><a href="#cache-spel-context">可用缓存SpEL评估上下文</a></li>
</ul>
</li>
<li><a href="#cache-annotations-put">8.3.2。@CachePut注释</a></li>
<li><a href="#cache-annotations-evict">8.3.3。@CacheEvict注释</a></li>
<li><a href="#cache-annotations-caching">8.3.4。@Caching注释</a></li>
<li><a href="#cache-annotations-config">8.3.5。@CacheConfig注释</a></li>
<li><a href="#cache-annotation-enable">8.3.6。启用缓存注释</a></li>
<li><a href="#cache-annotation-stereotype">8.3.7。使用自定义注释</a></li>
</ul>
</li>
<li><a href="#cache-jsr-107">8.4。JCache（JSR-107）注释</a>
<ul class="sectlevel3">
<li><a href="#cache-jsr-107-summary">8.4.1。功能摘要</a></li>
<li><a href="#enabling-jsr-107-support">8.4.2。启用JSR-107支持</a></li>
</ul>
</li>
<li><a href="#cache-declarative-xml">8.5。声明性的基于XML的缓存</a></li>
<li><a href="#cache-store-configuration">8.6。配置缓存存储</a>
<ul class="sectlevel3">
<li><a href="#cache-store-configuration-jdk">8.6.1。基于JDK ConcurrentMap的Cache</a></li>
<li><a href="#cache-store-configuration-ehcache">8.6.2。基于Ehcache的缓存</a></li>
<li><a href="#cache-store-configuration-caffeine">8.6.3。咖啡因缓存</a></li>
<li><a href="#cache-store-configuration-gemfire">8.6.4。基于GemFire的缓存</a></li>
<li><a href="#cache-store-configuration-jsr107">8.6.5。JSR-107缓存</a></li>
<li><a href="#cache-store-configuration-noop">8.6.6。处理没有后备存储的缓存</a></li>
</ul>
</li>
<li><a href="#cache-plug">8.7。插入不同的后端缓存</a></li>
<li><a href="#cache-specific-config">8.8。如何设置TTL / TTI /逐出政策/ XXX功能？</a></li>
</ul>
</li>
<li><a href="#appendix">9。附录</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">9.1。XML模式</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-jee">9.1.1。jee架构</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-jee-jndi-lookup">&lt;jee：jndi-lookup /&gt;（简单）</a></li>
<li><a href="#xsd-schemas-jee-jndi-lookup-environment-single">&lt;jee：jndi-lookup /&gt;（使用单个JNDI环境设置）</a></li>
<li><a href="#xsd-schemas-jee-jndi-lookup-evironment-multiple">&lt;jee：jndi-lookup /&gt;（具有多个JNDI环境设置）</a></li>
<li><a href="#xsd-schemas-jee-jndi-lookup-complex">&lt;jee：jndi-lookup /&gt;（复杂）</a></li>
<li><a href="#xsd-schemas-jee-local-slsb">&lt;jee：local-slsb /&gt;（简单）</a></li>
<li><a href="#xsd-schemas-jee-local-slsb-complex">&lt;jee：local-slsb /&gt;（复杂）</a></li>
<li><a href="#xsd-schemas-jee-remote-slsb">&lt;JEE：远程SLSB /&gt;</a></li>
</ul>
</li>
<li><a href="#xsd-schemas-jms">9.1.2。jms架构</a></li>
<li><a href="#xsd-schemas-context-mbe">9.1.3。 &lt;上下文：mbean的出口/&gt;</a></li>
<li><a href="#xsd-schemas-cache">9.1.4。缓存架构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>这部分参考文档涵盖了Spring Framework与许多Java EE（及相关）技术的集成。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="remoting"><a class="anchor" href="#remoting"></a> 1。使用Spring进行远程处理和Web服务</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="remoting-introduction"><a class="anchor" href="#remoting-introduction"></a> 1.1。介绍</h3>
<div class="paragraph">
<p>Spring提供了使用各种技术进行远程支持的集成类。远程支持简化了通常（Spring）POJO实现的远程启用服务的开发。目前，Spring支持以下远程技术：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>远程方法调用（RMI）</em> 。通过使用<code>RmiProxyFactoryBean</code>和<code>RmiServiceExporter</code> Spring支持传统的RMI（使用<code>java.rmi.Remote</code>接口和<code>java.rmi.RemoteException</code> ）和透明的远程处理通过RMI调用程序（使用任何Java接口）。</p>
</li>
<li>
<p><em>Spring的HTTP调用者</em> 。Spring提供了一种特殊的远程处理策略，允许通过HTTP进行Java序列化，支持任何Java接口（就像RMI调用程序一样）。相应的支持类是<code>HttpInvokerProxyFactoryBean</code>和<code>HttpInvokerServiceExporter</code> 。</p>
</li>
<li>
<p><em>黑森州</em> 。通过使用Spring的<code>HessianProxyFactoryBean</code>和<code>HessianServiceExporter</code>您可以使用Caucho提供的基于HTTP的轻量级二进制协议透明地公开您的服务。</p>
</li>
<li>
<p><em>JAX-WS</em> 。 Spring通过JAX-WS（Java EE 5和Java 6中引入的JAX-RPC的后继者）为Web服务提供远程支持。</p>
</li>
<li>
<p><em>JMS</em> 。通过<code>JmsInvokerServiceExporter</code>和<code>JmsInvokerProxyFactoryBean</code>类支持使用JMS作为底层协议进行远程处理。</p>
</li>
<li>
<p><em>AMQP</em> 。 Spring AMQP项目支持使用AMQP作为底层协议进行远程处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在讨论Spring的远程处理功能时，我们将使用以下域模型和相应的服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">帐户</span> <span class="directive">实现</span> <span class="predefined-type">Serializable</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> name; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AccountService</span> { <span class="directive">public</span> <span class="type">void</span> insertAccount（Account account）; <span class="directive">public</span> <span class="predefined-type">List</span> &lt;Account&gt; getAccounts（ <span class="predefined-type">String</span> name）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//实现什么都不做</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountServiceImpl</span> <span class="directive">实现</span> AccountService { <span class="directive">public</span> <span class="type">void</span> insertAccount（Account acc）{ <span class="comment">//做点什么......</span><span class="directive">public</span> <span class="predefined-type">List</span> &lt;Account&gt; getAccounts（ <span class="predefined-type">String</span> name）{ <span class="comment">//做点什么......</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将使用RMI开始向远程客户端公开服务，并谈谈使用RMI的缺点。然后我们将继续显示使用Hessian作为协议的示例。</p>
</div>
</div>
<div class="sect2">
<h3 id="remoting-rmi"><a class="anchor" href="#remoting-rmi"></a> 1.2。使用RMI公开服务</h3>
<div class="paragraph">
<p>使用Spring对RMI的支持，您可以透明地通过RMI基础结构公开您的服务。完成此设置后，您基本上具有类似于远程EJB的配置，除了没有对安全上下文传播或远程事务传播的标准支持这一事实。在使用RMI调用程序时，Spring确实为这样的附加调用上下文提供了钩子，因此您可以在此处插入安全框架或自定义安全凭证。</p>
</div>
<div class="sect3">
<h4 id="remoting-rmi-server"><a class="anchor" href="#remoting-rmi-server"></a> 1.2.1。使用RmiServiceExporter导出服务</h4>
<div class="paragraph">
<p>使用<code>RmiServiceExporter</code> ，我们可以将AccountService对象的接口公开为RMI对象。可以使用<code>RmiProxyFactoryBean</code>访问该接口，或者在传统RMI服务的情况下通过普通RMI访问该接口。<code>RmiServiceExporter</code>显式支持通过RMI <code>RmiServiceExporter</code>公开任何非RMI服务。</p>
</div>
<div class="paragraph">
<p>当然，我们首先要在Spring容器中设置我们的服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。AccountServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 任何其他属性，也许是DAO？ - &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们将使用<code>RmiServiceExporter</code>公开我们的服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.rmi。RmiServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 不一定必须与要导出的bean同名 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 默认为1099  - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">registryPort</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1199</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，我们正在覆盖RMI注册表的端口。通常，您的应用程序服务器也维护一个RMI注册表，明智的做法是不干扰那个。此外，服务名称用于绑定服务。所以现在，该服务将绑定在<code>'rmi://HOST:1199/AccountService'</code> 。我们稍后将使用该URL链接到客户端的服务。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>servicePort</code>属性已被省略（默认为0）。这意味着将使用匿名端口与服务进行通信。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="remoting-rmi-client"><a class="anchor" href="#remoting-rmi-client"></a> 1.2.2。链接到客户端的服务</h4>
<div class="paragraph">
<p>我们的客户端是一个使用<code>AccountService</code>管理帐户的简单对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleObject</span> { <span class="directive">private</span> AccountService accountService; <span class="directive">public</span> <span class="type">void</span> setAccountService（AccountService accountService）{ <span class="local-variable">this</span> .accountService = accountService; } <span class="comment">//使用accountService的其他方法</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要链接客户端上的服务，我们将创建一个单独的Spring容器，其中包含简单对象和连接配置位的服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">示例。SimpleObject</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.remoting.rmi。RmiProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">rmi：// HOST：1199 / AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是我们需要做的就是支持客户端上的远程帐户服务。Spring将透明地创建一个调用者，并通过<code>RmiServiceExporter</code>远程启用帐户服务。在客户端，我们使用<code>RmiProxyFactoryBean</code>链接它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-caucho-protocols"><a class="anchor" href="#remoting-caucho-protocols"></a> 1.3。使用Hessian通过HTTP远程调用服务</h3>
<div class="paragraph">
<p>Hessian提供基于HTTP的二进制远程协议。它由Caucho开发，有关Hessian本身的更多信息可以在<a href="http://www.caucho.com" class="bare">http://www.caucho.com</a>找到。</p>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian"><a class="anchor" href="#remoting-caucho-protocols-hessian"></a> 1.3.1。连接Hessian和co的DispatcherServlet。</h4>
<div class="paragraph">
<p>Hessian通过HTTP进行通信，并使用自定义servlet进行通信。使用Spring的<code>DispatcherServlet</code>原则，从Spring Web MVC用法中可以看出，您可以轻松地连接这样的servlet来公开您的服务。首先，我们必须在您的应用程序中创建一个新的servlet（这是<code>'web.xml'</code>的摘录）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;servlet&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> remoting <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;servlet-class&gt;</span> org.springframework.web.servlet。DispatcherServlet <span class="tag">&lt;/ servlet-class&gt;</span> <span class="tag">&lt;load-on-startup&gt;</span> 1 <span class="tag">&lt;/ load-on-startup&gt;</span> <span class="tag">&lt;/ servlet&gt;</span> <span class="tag">&lt;servlet-mapping&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> remoting <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> /远程处理/ * <span class="tag">&lt;/ url-pattern&gt;</span> <span class="tag">&lt;/ servlet-mapping&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能熟悉Spring的<code>DispatcherServlet</code>原则，如果是这样，您知道现在您必须在<code>'WEB-INF'</code>创建一个名为<code>'remoting-servlet.xml'</code>的Spring容器配置资源（在您的servlet名称之后） <code>'WEB-INF'</code>目录。应用程序上下文将在下一节中使用。</p>
</div>
<div class="paragraph">
<p>或者，考虑使用Spring更简单的<code>HttpRequestHandlerServlet</code> 。这允许您将远程导出器定义嵌入根应用程序上下文中（默认情况下在<code>'WEB-INF/applicationContext.xml'</code> ），其中各个servlet定义指向特定的导出器bean。在这种情况下，每个servlet名称都需要匹配其目标导出器的bean名称。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian-server"><a class="anchor" href="#remoting-caucho-protocols-hessian-server"></a> 1.3.2。使用HessianServiceExporter公开您的bean</h4>
<div class="paragraph">
<p>在新创建的名为<code>remoting-servlet.xml</code>应用程序上下文中，我们将创建一个导出服务的<code>HessianServiceExporter</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。AccountServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 任何其他属性，可能是DAO？ - &gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">/ AccountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.remoting.caucho。HessianServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们已准备好在客户端的服务中链接。没有指定显式的处理程序映射，将请求URL映射到服务上，因此将使用<code>BeanNameUrlHandlerMapping</code> ：因此，服务将通过其包含的<code>DispatcherServlet</code>映射中的bean名称指示的URL导出（如上所述）： <code>'http://HOST:8080/remoting/AccountService'</code> 。</p>
</div>
<div class="paragraph">
<p>或者，在根应用程序上下文中创建一个<code>HessianServiceExporter</code> （例如，在<code>'WEB-INF/applicationContext.xml'</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountExporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.caucho。HessianServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在后一种情况下，在<code>'web.xml'</code>为此导出器定义相应的servlet，结果相同：导出器映射到请求路径<code>/remoting/AccountService</code> 。请注意，servlet名称需要与目标导出器的bean名称匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;servlet&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> accountExporter <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;servlet-class&gt;</span> org.springframework.web.context.support。HttpRequestHandlerServlet <span class="tag">&lt;/ servlet-class&gt;</span> <span class="tag">&lt;/ servlet&gt;</span> <span class="tag">&lt;servlet-mapping&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> accountExporter <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> / remoting / AccountService <span class="tag">&lt;/ url-pattern&gt;</span> <span class="tag">&lt;/ servlet-mapping&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian-client"><a class="anchor" href="#remoting-caucho-protocols-hessian-client"></a> 1.3.3。在客户端上链接服务</h4>
<div class="paragraph">
<p>使用<code>HessianProxyFactoryBean</code>我们可以在客户端的服务中进行链接。同样的原则适用于RMI示例。我们将创建一个单独的bean工厂或应用程序上下文，并提及以下bean，其中<code>SimpleObject</code>使用<code>AccountService</code>来管理帐户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">示例。SimpleObject</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.remoting.caucho。HessianProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http：// remotehost：8080 / remoting / AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-security"><a class="anchor" href="#remoting-caucho-protocols-security"></a> 1.3.4。将HTTP基本身份验证应用于通过Hessian公开的服务</h4>
<div class="paragraph">
<p>Hessian的一个优点是我们可以轻松应用HTTP基本身份验证，因为这两种协议都是基于HTTP的。例如，可以通过使用<code>web.xml</code>安全功能轻松应用正常的HTTP服务器安全机制。通常，您不在此处使用每用户安全凭证，而是使用在<code>HessianProxyFactoryBean</code>级别定义的共享凭证（类似于JDBC <code>DataSource</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.web.servlet.handler。BeanNameUrlHandlerMapping</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">interceptors</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">authorizationInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">authorizationInterceptor</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.web.servlet.handler。UserRoleAuthorizationInterceptor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">authorizedRoles</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">administrator，operator</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个示例，我们明确提到<code>BeanNameUrlHandlerMapping</code>并设置一个拦截器，只允许管理员和操作员调用此应用程序上下文中提到的bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当然，此示例未显示灵活的安全基础结构。有关安全性的更多选项，请查看<a href="http://projects.spring.io/spring-security/" class="bare">http://projects.spring.io/spring-security/</a>上的Spring Security项目。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-httpinvoker"><a class="anchor" href="#remoting-httpinvoker"></a> 1.4。使用HTTP调用程序公开服务</h3>
<div class="paragraph">
<p>与Hessian相反，Hessian都是使用自己的苗条序列化机制的轻量级协议，Spring HTTP调用者使用标准的Java序列化机制通过HTTP公开服务。如果您的参数和返回类型是使用Hessian使用的序列化机制无法序列化的复杂类型，那么这具有巨大的优势（在选择远程处理技术时，请参阅下一节以了解更多注意事项）。</p>
</div>
<div class="paragraph">
<p>在引擎盖下，Spring使用JDK或Apache <code>HttpComponents</code>提供的标准工具来执行HTTP调用。如果您需要更高级且更易于使用的功能，请使用后者。有关更多信息，请参阅<a href="http://hc.apache.org/httpcomponents-client-ga/">hc.apache.org/httpcomponents-client-ga/</a> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意由于不安全的Java反序列化导致的漏洞：在反序列化步骤中，操作的输入流可能导致服务器上执行不需要的代码。因此，不要将HTTP调用程序端点暴露给不受信任的客户端，而只是在您自己的服务之间。通常，我们强烈建议使用任何其他消息格式（例如JSON）。</p>
</div>
<div class="paragraph">
<p>如果您担心Java序列化导致的安全漏洞，请考虑核心JVM级别的通用序列化过滤机制，最初是为JDK 9开发的，但同时向后移植到JDK 8,7和6： <a href="https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a" class="bare">https：// blogs。 oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a</a> <a href="http://openjdk.java.net/jeps/290" class="bare">http://openjdk.java.net/jeps/290</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="remoting-httpinvoker-server"><a class="anchor" href="#remoting-httpinvoker-server"></a> 1.4.1。公开服务对象</h4>
<div class="paragraph">
<p>为服务对象设置HTTP调用程序基础结构与使用Hessian的方式非常相似。正如Hessian支持提供<code>HessianServiceExporter</code> ，Spring的HttpInvoker支持提供了<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code> 。</p>
</div>
<div class="paragraph">
<p>要在Spring Web MVC <code>DispatcherServlet</code>公开<code>AccountService</code> （如上所述），需要在调度程序的应用程序上下文中使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">/ AccountService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.httpinvoker。HttpInvokerServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的导出器定义将通过<code>DispatcherServlet</code>的标准映射工具公开，如Hessian一节中所述。</p>
</div>
<div class="paragraph">
<p>或者，在根应用程序上下文中创建一个<code>HttpInvokerServiceExporter</code> （例如，在<code>'WEB-INF/applicationContext.xml'</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountExporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.httpinvoker。HttpInvokerServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，在<code>'web.xml'</code>为此导出器定义相应的servlet，其servlet名称与目标导出器的bean名称匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;servlet&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> accountExporter <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;servlet-class&gt;</span> org.springframework.web.context.support。HttpRequestHandlerServlet <span class="tag">&lt;/ servlet-class&gt;</span> <span class="tag">&lt;/ servlet&gt;</span> <span class="tag">&lt;servlet-mapping&gt;</span> <span class="tag">&lt;servlet-name&gt;</span> accountExporter <span class="tag">&lt;/ servlet-name&gt;</span> <span class="tag">&lt;url-pattern&gt;</span> / remoting / AccountService <span class="tag">&lt;/ url-pattern&gt;</span> <span class="tag">&lt;/ servlet-mapping&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-httpinvoker-client"><a class="anchor" href="#remoting-httpinvoker-client"></a> 1.4.2。链接到客户端的服务</h4>
<div class="paragraph">
<p>同样，从客户端链接服务非常类似于使用Hessian时的方式。使用代理，Spring将能够将对HTTP POST请求的调用转换为指向导出服务的URL。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">httpInvokerProxy</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.httpinvoker。HttpInvokerProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http：// remotehost：8080 / remoting / AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，您可以选择要使用的HTTP客户端。默认情况下， <code>HttpInvokerProxy</code>使用JDK的HTTP功能，但您也可以通过设置<code>httpInvokerRequestExecutor</code>属性来使用Apache <code>HttpComponents</code>客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">httpInvokerRequestExecutor</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.httpinvoker。HttpComponentsHttpInvokerRequestExecutor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-web-services"><a class="anchor" href="#remoting-web-services"></a> 1.5。网页服务</h3>
<div class="paragraph">
<p>Spring为标准Java Web服务API提供全面支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用JAX-WS公开Web服务</p>
</li>
<li>
<p>使用JAX-WS访问Web服务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了Spring Core中JAX-WS的库存支持外，Spring产品组合还提供<a href="http://www.springframework.org/spring-ws">Spring Web Services</a> ，这是一种针对契约优先，文档驱动的Web服务的解决方案 - 强烈建议用于构建现代的，面向未来的Web服务。</p>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-servlet"><a class="anchor" href="#remoting-web-services-jaxws-export-servlet"></a> 1.5.1。使用JAX-WS公开基于servlet的Web服务</h4>
<div class="paragraph">
<p>Spring为JAX-WS servlet端点实现提供了一个方便的基类 - <code>SpringBeanAutowiringSupport</code> 。为了公开我们的<code>AccountService</code>我们扩展了Spring的<code>SpringBeanAutowiringSupport</code>类并在这里实现了我们的业务逻辑，通常将调用委托给业务层。我们将简单地使用Spring的<code>@Autowired</code>注释来表达对Spring管理的bean的依赖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/ ** *符合JAX-WS的AccountService实现，它简单地将*委托给根Web应用程序上下文中的AccountService实现。* *这个包装类是必需的，因为JAX-WS需要使用专用的*端点类。如果需要导出现有服务，那么*为最简单的Spring bean自动装配（通过* @Autowired注释）扩展SpringBeanAutowiringSupport的包装器是最简单的JAX-WS兼容方式。* *这是在服务器端JAX-WS实现中注册的类。*对于Java EE 5服务器，这将简单地定义为web.xml中的servlet *，服务器检测到这是一个JAX-WS端点并相应地做出反应*。servlet名称通常需要与指定的WS服务名称匹配。* * Web服务引擎管理此类实例的生命周期。* Spring bean引用只是在这里连接。* /</span> <span class="keyword">import</span> <span class="include">org.springframework.web.context.support。SpringBeanAutowiringSupport</span> ; <span class="annotation">@WebService</span> （serviceName = <span class="string"><span class="delimiter">“</span> <span class="content">AccountService</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountServiceEndpoint</span> <span class="directive">扩展</span> SpringBeanAutowiringSupport { <span class="annotation">@Autowired</span> <span class="directive">private</span> AccountService biz; <span class="annotation">@WebMethod</span> <span class="directive">public</span> <span class="type">void</span> insertAccount（Account acc）{biz.insertAccount（acc）; } <span class="annotation">@WebMethod</span> <span class="directive">public</span> Account <span class="type">[]</span> getAccounts（ <span class="predefined-type">String</span> name）{ <span class="keyword">return</span> biz.getAccounts（name）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的<code>AccountServiceEndpoint</code>需要在与Spring上下文相同的Web应用程序中运行，以允许访问Spring的工具。默认情况下，在Java EE 5环境中使用JAX-WS servlet端点部署的标准协定就是这种情况。有关详细信息，请参阅Java EE 5 Web服务教程。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-standalone"><a class="anchor" href="#remoting-web-services-jaxws-export-standalone"></a> 1.5.2。使用JAX-WS导出独立Web服务</h4>
<div class="paragraph">
<p>Oracle JDK附带的内置JAX-WS提供程序支持使用JDK中包含的内置HTTP服务器来暴露Web服务。Spring的<code>SimpleJaxWsServiceExporter</code>检测Spring应用程序上下文中的所有<code>@WebService</code>注释bean，并通过默认的JAX-WS服务器（JDK HTTP服务器）导出它们。</p>
</div>
<div class="paragraph">
<p>在这种情况下，端点实例是作为Spring bean本身定义和管理的;它们将在JAX-WS引擎中注册，但它们的生命周期将取决于Spring应用程序上下文。这意味着可以将诸如显式依赖注入之类的Spring功能应用于端点实例。当然，通过<code>@Autowired</code>注释驱动的注入也会起作用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.jaxws。SimpleJaxWsServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">baseAddress</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http：// localhost：8080 /</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">accountServiceEndpoint</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountServiceEndpoint</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...
<span class="tag">&lt;/ bean&gt;</span> ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AccountServiceEndpoint</code>可以从Spring的<code>SpringBeanAutowiringSupport</code>派生，但不必，因为端点是一个完全由Spring管理的bean。这意味着端点实现可能如下所示，没有声明任何超类 - 并且Spring的<code>@Autowired</code>配置注释仍然受到尊重：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebService</span> （serviceName = <span class="string"><span class="delimiter">“</span> <span class="content">AccountService</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">AccountServiceEndpoint</span> { <span class="annotation">@Autowired</span> <span class="directive">private</span> AccountService biz; <span class="annotation">@WebMethod</span> <span class="directive">public</span> <span class="type">void</span> insertAccount（Account acc）{biz.insertAccount（acc）; } <span class="annotation">@WebMethod</span> <span class="directive">public</span> <span class="predefined-type">List</span> &lt;Account&gt; getAccounts（ <span class="predefined-type">String</span> name）{ <span class="keyword">return</span> biz.getAccounts（name）; }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-ri"><a class="anchor" href="#remoting-web-services-jaxws-export-ri"></a> 1.5.3。使用JAX-WS RI的Spring支持导出Web服务</h4>
<div class="paragraph">
<p>Oracle的JAX-WS RI是作为​​GlassFish项目的一部分开发的，它将Spring支持作为其JAX-WS Commons项目的一部分。这允许将JAX-WS端点定义为Spring管理的bean，类似于上一节中讨论的独立模式 - 但这次是在Servlet环境中。<em>请注意，这在Java EE 5环境中不可移植;它主要用于非EE环境，如Tomcat，将JAX-WS RI作为Web应用程序的一部分嵌入。</em></p>
</div>
<div class="paragraph">
<p>导出基于servlet的端点的标准样式的不同之处在于，端点实例本身的生命周期将由Spring管理，并且在<code>web.xml</code>只定义一个JAX-WS servlet。使用标准的Java EE 5样式（如上所示），每个服务端点都有一个servlet定义，每个端点通常委托给Spring bean（通过使用<code>@Autowired</code> ，如上所示）。</p>
</div>
<div class="paragraph">
<p>有关设置和使用方式的详细信息，请访问<a href="https://jax-ws-commons.java.net/spring/">https://jax-ws-commons.java.net/spring/</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-access"><a class="anchor" href="#remoting-web-services-jaxws-access"></a> 1.5.4。使用JAX-WS访问Web服务</h4>
<div class="paragraph">
<p>Spring提供了两个工厂bean来创建JAX-WS Web服务代理，即<code>LocalJaxWsServiceFactoryBean</code>和<code>JaxWsPortProxyFactoryBean</code> 。前者只能返回一个JAX-WS服务类供我们使用。后者是完整版本，可以返回实现我们的业务服务接口的代理。在此示例中，我们使用后者为<code>AccountService</code>端点创建代理（再次）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountWebService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.jaxws。JaxWsPortProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。AccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">wsdlDocumentUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http：// localhost：8888 / AccountServiceEndpoint？WSDL</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namespaceUri</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http：// example /</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serviceName</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">AccountService</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">portName</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">AccountServiceEndpointPort</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>serviceInterface</code>是我们的业务接口，客户端将使用。
<code>wsdlDocumentUrl</code>是WSDL文件的URL。Spring需要一个启动时间来创建JAX-WS服务。 <code>namespaceUri</code>对应于.wsdl文件中的targetNamespace。 <code>serviceName</code>对应于.wsdl文件中的服务名称。 <code>portName</code>对应于.wsdl文件中的端口名称。</p>
</div>
<div class="paragraph">
<p>现在访问Web服务非常简单，因为我们有一个bean工厂，它将它作为<code>AccountService</code>接口公开。我们可以在Spring中连接它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">client</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">example。AccountClientImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">service</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">accountWebService</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从客户端代码我们可以访问Web服务，就像它是一个普通的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AccountClientImpl</span> { <span class="directive">private</span> AccountService service; <span class="directive">public</span> <span class="type">void</span> setService（AccountService service）{ <span class="local-variable">this</span> .service = service; <span class="directive">public</span> <span class="type">void</span> foo（）{service.insertAccount（...）; }}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>上面的内容略有简化，因为JAX-WS要求端点接口和实现类使用@ <code>@WebService</code> ， <code>@SOAPBinding</code>等注释进行注释。这意味着您不能（轻松地）将纯Java接口和实现类用作JAX-WS端点工件;你需要先对它们进行相应的注释。有关这些要求的详细信息，请查看JAX-WS文档。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-jms"><a class="anchor" href="#remoting-jms"></a> 1.6。JMS</h3>
<div class="paragraph">
<p>还可以使用JMS作为底层通信协议透明地公开服务。Spring Framework中的JMS远程支持是非常基本的 - 它在<code>same thread</code>和<em>同一个非事务性</em> <code>Session</code>发送和接收，因此吞吐量将非常依赖于实现。请注意，这些单线程和非事务约束仅适用于Spring的JMS <em>远程</em>支持。有关Spring对基于JMS的<em>消息传递</em>的丰富支持的信息，请参阅<a href="#jms">JMS（Java消息服务）</a> 。</p>
</div>
<div class="paragraph">
<p>服务器和客户端都使用以下接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">CheckingAccountService</span> { <span class="directive">public</span> <span class="type">void</span> cancelAccount（ <span class="predefined-type">Long</span> accountId）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在服务器端使用以下简单的上述接口实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleCheckingAccountService</span> <span class="directive">实现</span> CheckingAccountService { <span class="directive">public</span> <span class="type">void</span> cancelAccount（ <span class="predefined-type">Long</span> accountId）{ <span class="predefined-type">System</span> .out.println（ <span class="string"><span class="delimiter">“</span></span> Cancenting <span class="string"><span class="content">account [</span> <span class="delimiter">”</span></span> + accountId + <span class="string"><span class="delimiter">“</span> <span class="content">]</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此配置文件包含在客户端和服务器上共享的JMS基础结构Bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.apache.activemq。ActiveMQConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">brokerURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tcp：// ep</span></span> <span class="string"><span class="content">-t43</span></span> <span class="string"><span class="content">：61616</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">queue</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.apache.activemq.command。ActiveMQQueue</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mmm</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="remoting-jms-server"><a class="anchor" href="#remoting-jms-server"></a> 1.6.1。服务器端配置</h4>
<div class="paragraph">
<p>在服务器上，您只需要使用<code>JmsInvokerServiceExporter</code>公开服务对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">checkingAccountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jms.remoting。JmsInvokerServiceExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo。CheckingAccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo。SimpleCheckingAccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jms.listener。SimpleMessageListenerContainer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">queue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">concurrentConsumers</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">3</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">checkingAccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Server</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> { <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">com / foo / server.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">com / foo / jms.xml</span> <span class="delimiter">”</span></span> }）; }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-jms-client"><a class="anchor" href="#remoting-jms-client"></a> 1.6.2。客户端配置</h4>
<div class="paragraph">
<p>客户端只需要创建一个客户端代理，它将实现商定的接口（ <code>CheckingAccountService</code> ）。在以下bean定义的后面创建的结果对象可以注入到其他客户端对象中，并且代理将负责通过JMS将调用转发到服务器端对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/beans</span> <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">checkingAccountService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jms.remoting。JmsInvokerProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo。CheckingAccountService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">queue</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">queue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.foo</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Client</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> {ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">com / foo / client.xml</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">com / foo / jms.xml</span> <span class="delimiter">”</span></span> }）; CheckingAccountService service =（CheckingAccountService）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">checkingAccountService</span> <span class="delimiter">”</span></span> ）; service.cancelAccount（ <span class="keyword">new</span> <span class="predefined-type">Long</span> （ <span class="integer">10</span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-amqp"><a class="anchor" href="#remoting-amqp"></a> 1.7。AMQP</h3>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://docs.spring.io/spring-amqp/docs/current/reference/html/_reference.html#remoting">Spring AMQP参考文档“使用AMQP进行Spring Remoting”部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="remoting-autodection-remote-interfaces"><a class="anchor" href="#remoting-autodection-remote-interfaces"></a> 1.8。远程接口未实现自动检测</h3>
<div class="paragraph">
<p>为远程接口不会自动检测已实现接口的主要原因是为了避免向远程呼叫者打开太多门。目标对象可能实现内部回调接口，如<code>InitializingBean</code>或<code>DisposableBean</code> ，这些接口不希望向调用者公开。</p>
</div>
<div class="paragraph">
<p>提供具有目标实现的所有接口的代理通常在本地情况下无关紧要。但是，在导出远程服务时，您应该公开特定的服务接口，以及用于远程使用的特定操作。除了内部回调接口，目标可能会实现多个业务接口，其中只有一个用于远程暴露。出于这些原因，我们<em>需要</em>指定这样的服务接口。</p>
</div>
<div class="paragraph">
<p>这是配置便利性和内部方法意外暴露风险之间的权衡。始终指定服务接口不是太费力，并且使您在特定方法的受控暴露方面处于安全的位置。</p>
</div>
</div>
<div class="sect2">
<h3 id="remoting-considerations"><a class="anchor" href="#remoting-considerations"></a> 1.9。选择技术时的注意事项</h3>
<div class="paragraph">
<p>这里介绍的每项技术都有其缺点。在选择技术时，您应该仔细考虑您的需求，您要暴露的服务以及您将通过网络发送的对象。</p>
</div>
<div class="paragraph">
<p>使用RMI时，除非您正在隧道传输RMI流量，否则无法通过HTTP协议访问对象。RMI是一种相当重量级的协议，因为它支持全对象序列化，这在使用需要通过线路进行序列化的复杂数据模型时非常重要。但是，RMI-JRMP与Java客户端绑定：它是Java-to-Java远程处理解决方案。</p>
</div>
<div class="paragraph">
<p>如果您需要基于HTTP的远程处理，而且还依赖于Java序列化，那么Spring的HTTP调用程序是一个不错的选择。它与RMI调用程序共享基本基础结构，只使用HTTP作为传输。请注意，HTTP调用程序不仅限于Java-to-Java远程处理，还包括客户端和服务器端的Spring。（后者也适用于非RMI接口的Spring的RMI调用程序。）</p>
</div>
<div class="paragraph">
<p>在异构环境中运行时，Hessian可能会提供重要的价值，因为它们明确允许非Java客户端。但是，非Java支持仍然有限。已知问题包括将Hibernate对象与lazily-initialized集合一起序列化。如果您有这样的数据模型，请考虑使用RMI或HTTP调用程序而不是Hessian。</p>
</div>
<div class="paragraph">
<p>JMS可用于提供服务集群并允许JMS代理负责负载平衡，发现和自动故障转移。默认情况下：使用JMS远程处理时使用Java序列化，但JMS提供程序可以使用不同的线程格式化机制，例如XStream，以允许服务器在其他技术中实现。</p>
</div>
<div class="paragraph">
<p>最后但同样重要的是，EJB比RMI具有优势，因为它支持基于标准角色的身份验证和授权以及远程事务传播。有可能让RMI调用者或HTTP调用者也支持安全上下文传播，尽管核心Spring没有提供这一点：这里只插入适当的钩子来插入第三方或自定义解决方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="rest-client-access"><a class="anchor" href="#rest-client-access"></a> 1.10。REST端点</h3>
<div class="paragraph">
<p>Spring Framework为调用REST端点提供了两种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rest-resttemplate">RestTemplate</a> - 具有同步模板方法API的原始Spring REST客户端。</p>
</li>
<li>
<p><a href="web-reactive.html#webflux-client">WebClient</a> - 支持同步和异步以及流方案的非阻塞，反应式替代方案。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从5.0开始，非阻塞，反应式<code>WebClient</code>提供了<code>RestTemplate</code>的现代替代方案，同时有效支持同步和异步以及流方案。<code>RestTemplate</code>将在未来版本中弃用，并且不会在未来添加主要的新功能。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="rest-resttemplate"><a class="anchor" href="#rest-resttemplate"></a> 1.10.1。RestTemplate</h4>
<div class="paragraph">
<p><code>RestTemplate</code>通过HTTP客户端库提供更高级别的API。它使得在一行中调用REST端点变得容易。它公开了以下重载方法组：</p>
</div>
<table id="rest-overview-of-resttemplate-methods-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。RestTemplate方法</caption>
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法组</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过GET检索表示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getForEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过GET检索<code>ResponseEntity</code> ，即状态，标题和正文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>headForHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过HEAD检索资源的所有标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过POST创建新资源，并从响应中返回Location标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过POST创建新资源并从响应中返回表示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过POST创建新资源并从响应中返回表示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>放</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过PUT创建或更新资源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>patchForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过PATCH更新资源并从响应中返回表示。请注意，JDK <code>HttpURLConnection</code>不支持<code>PATCH</code>但支持Apache HttpComponents，而其他人则支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>删除</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过DELETE删除指定URI处的资源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optionsForAllow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过ALLOW检索资源的允许HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>交换</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">上述方法的更通用，更少见解的版本，在需要时提供额外的灵活性。它接受<code>RequestEntity</code> ，包括HTTP方法，URL，标题和正文作为输入，并返回<code>ResponseEntity</code> 。
</p><p class="tableblock">这些方法允许使用<code>ParameterizedTypeReference</code>而不是<code>Class</code>来指定具有泛型的响应类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>执行</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行请求的最通用方式，通过回调接口完全控制请求准备和响应提取。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="rest-resttemplate-create"><a class="anchor" href="#rest-resttemplate-create"></a>初始化</h5>
<div class="paragraph">
<p>默认构造函数使用<code>java.net.HttpURLConnection</code>执行请求。您可以使用<code>ClientHttpRequestFactory</code>的实现切换到不同的HTTP库。内置支持以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache HttpComponents</p>
</li>
<li>
<p>网状</p>
</li>
<li>
<p>OkHttp</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，切换到Apache HttpComponents使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RestTemplate template = <span class="keyword">new</span> RestTemplate（ <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory（））;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个<code>ClientHttpRequestFactory</code>公开特定于底层HTTP客户端库的配置选项，例如，用于凭据，连接池等。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，HTTP请求的<code>java.net</code>实现在访问表示错误的响应的状态时可能引发异常（例如401）。如果这是一个问题，请切换到另一个HTTP客户端库。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="rest-resttemplate-uri"><a class="anchor" href="#rest-resttemplate-uri"></a>的URI</h5>
<div class="paragraph">
<p>许多<code>RestTemplate</code>方法接受URI模板和URI模板变量，可以是<code>String</code> vararg，也可以是<code>Map&lt;String,String&gt;</code> 。</p>
</div>
<div class="paragraph">
<p>例如，使用<code>String</code> vararg：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> result = restTemplate.getForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}/bookings/{booking}</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">String</span> .class， <span class="string"><span class="delimiter">“</span> <span class="content">42</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">21</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用<code>Map&lt;String, String&gt;</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; vars = <span class="predefined-type">Collections</span> .singletonMap（ <span class="string"><span class="delimiter">“</span> <span class="content">hotel</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">42</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> result = restTemplate.getForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}/rooms/{hotel}</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">String</span> .class，vars）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，URI模板是自动编码的。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">restTemplate.getForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotel list</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">String</span> .class）; <span class="comment">//请求“http://example.com/hotel%20list”的结果</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>uriTemplateHandler</code>属性<code>RestTemplate</code>定义URI的编码方式。或者你可以准备一个<code>java.net.URI</code>并将其传递给接受<code>URI</code>的<code>RestTemplate</code>方法之一。</p>
</div>
<div class="paragraph">
<p>有关使用和编码URI的更多详细信息，请参阅<a href="web.html#mvc-uri-building">URI链接</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-headers"><a class="anchor" href="#rest-template-headers"></a>头</h5>
<div class="paragraph">
<p>使用<code>exchange()</code>方法指定请求标头。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> uriTemplate = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ; <span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromUriString（uriTemplate）.build（ <span class="integer">42</span> ）; RequestEntity &lt; <span class="predefined-type">空隙</span> &gt; requestEntity = RequestEntity.get（URI）.header（（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“MyRequestHeader”，</span></span></span></span> <span class="string"><span class="content"><span class="delimiter">“myvalue</span>的</span> <span class="delimiter">”）.build（）;</span></span> ResponseEntity &lt; <span class="predefined-type">字符串</span> &gt;响应= template.exchange（requestEntity， <span class="predefined-type">字符串</span>的.class）; <span class="predefined-type">字符串</span> responseHeader =响应.getHeaders（）。getFirst（ <span class="string"><span class="delimiter">“</span> <span class="content">MyResponseHeader</span> <span class="delimiter">”</span></span> ）; <span class="predefined-type">String</span> body = response.getBody（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过返回<code>ResponseEntity</code>许多<code>RestTemplate</code>方法变体获取响应标头。</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-body"><a class="anchor" href="#rest-template-body"></a>身体</h5>
<div class="paragraph">
<p>对象传入和返回<code>RestTemplate</code>方法被转换成从原始内容用的帮助<code>HttpMessageConverter</code> 。</p>
</div>
<div class="paragraph">
<p>在POST上，输入对象被序列化到请求主体：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>URI location = template.postForLocation（“http://example.com/people”，person）;</pre>
</div>
</div>
<div class="paragraph">
<p>请求的“Content-Type”标头不需要显式设置。在大多数情况下，可以根据源对象类型找到兼容的消息转换器，并且所选的消息转换器将相应地设置内容类型。如有必要，您可以使用<code>exchange</code>方法显式提供“Content-Type”请求标头，这反过来将影响选择的消息转换器。</p>
</div>
<div class="paragraph">
<p>在GET上，响应的主体被反序列化为输出对象：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Person person = restTemplate.getForObject（“http://example.com/people/{id}”，Person.class，42）;</pre>
</div>
</div>
<div class="paragraph">
<p>请求的“Accept”标头不需要显式设置。在大多数情况下，可以根据预期的响应类型找到兼容的消息转换器，然后有助于填充“Accept”标头。如有必要，您可以使用<code>exchange</code>方法显式提供“Accept”标头。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>RestTemplate</code>注册所有内置<a href="#rest-message-conversion">消息转换器</a> ，具体取决于有助于确定存在哪些可选转换库的类路径检查。您还可以将消息转换器设置为显式使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-message-conversion"><a class="anchor" href="#rest-message-conversion"></a>消息转换</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs">在Spring WebFlux中也是如此</a></span></p>
</div>
<div class="paragraph">
<p><code>spring-web</code>模块包含<code>HttpMessageConverter</code>合约，用于通过<code>InputStream</code>和<code>OutputStream</code>读取和写入HTTP请求和响应的主体。
<code>HttpMessageConverter</code>用于客户端，例如<code>RestTemplate</code> ，也用于服务器端，例如Spring MVC REST控制器。</p>
</div>
<div class="paragraph">
<p>框架中提供了主要媒体（MIME）类型的具体实现，默认情况下在客户端使用<code>RestTemplate</code>注册，在服务器端使用<code>RequestMethodHandlerAdapter</code> （请参阅<a href="web.html#mvc-config-message-converters">配置消息转换器</a> ）。</p>
</div>
<div class="paragraph">
<p><code>HttpMessageConverter</code>的实现将在以下部分中介绍。对于所有转换器，使用默认媒体类型，但可以通过设置<code>supportedMediaTypes</code> bean属性来覆盖它</p>
</div>
<table id="rest-message-converters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表2。HttpMessageConverter实现</caption>
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">的MessageConverter</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以从HTTP请求和响应中读取和写入字符串。默认情况下，此转换器支持所有文本媒体类型（ <code>text/*</code> ），并使用<code>Content-Type</code> of <code>text/plain</code>写入。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FormHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以从HTTP请求和响应中读取和写入表单数据。默认情况下，此转换器读取和写入媒体类型<code>application/x-www-form-urlencoded</code> 。表单数据从<code>MultiValueMap&lt;String, String&gt;</code>读取并写入。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以从HTTP请求和响应中读取和写入字节数组。默认情况下，此转换器支持所有媒体类型（ <code>*/*</code> ），并使用<code>Content-Type</code> of <code>application/octet-stream</code>写入。这可以通过设置<code>supportedMediaTypes</code>属性并覆盖<code>getContentType(byte[])</code>覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MarshallingHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以使用<code>org.springframework.oxm</code>包中的Spring的<code>Marshaller</code>和<code>Unmarshaller</code>抽象来读写XML。该转换器需要<code>Marshaller</code>和<code>Unmarshaller</code>才能使用。这些可以通过构造函数或bean属性注入。默认情况下，此转换器支持（ <code>text/xml</code> ）和（ <code>application/xml</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingJackson2HttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以使用Jackson的<code>ObjectMapper</code>读写JSON。通过使用Jackson提供的注释，可以根据需要自定义JSON映射。当需要进一步控制时，可以通过<code>ObjectMapper</code>属性注入自定义<code>ObjectMapper</code> ，以用于需要为特定类型提供自定义JSON序列化器/反序列化器的情况。默认情况下，此转换器支持（ <code>application/json</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingJackson2XmlHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以使用<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML</a>扩展的<code>XmlMapper</code>读写XML。可以根据需要通过使用JAXB或Jackson提供的注释来自定义XML映射。当需要进一步控制时，可以通过<code>ObjectMapper</code>属性注入自定义<code>XmlMapper</code> ，以用于需要为特定类型提供自定义XML序列化器/反序列化器的情况。默认情况下，此转换器支持（ <code>application/xml</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SourceHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>实现，可以读写<code>javax.xml.transform.来自HTTP请求和响应的Source</code> 。仅支持<code>DOMSource</code> ， <code>SAXSource</code>和<code>StreamSource</code> 。默认情况下，此转换器支持（ <code>text/xml</code> ）和（ <code>application/xml</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BufferedImageHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个可以读写<code>java.awt.image.的<code>HttpMessageConverter</code>实现<code>java.awt.image.来自HTTP请求和响应的BufferedImage</code> 。此转换器读取和写入Java I / O API支持的媒体类型。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="rest-template-jsonview"><a class="anchor" href="#rest-template-jsonview"></a>杰克逊JSON观点</h5>
<div class="paragraph">
<p>可以指定<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson JSON视图</a>以仅序列化对象属性的子集。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MappingJacksonValue value = <span class="keyword">new</span> MappingJacksonValue（ <span class="keyword">新</span>用户（ <span class="string"><span class="delimiter">“</span> <span class="content">eric</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">7！jd＃h23</span> <span class="delimiter">“</span></span> ））; value.setSerializationView（User。WithoutPasswordView.class）; RequestEntity &lt;MappingJacksonValue&gt; requestEntity = RequestEntity.post（ <span class="keyword">new</span> <span class="predefined-type">URI</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/user</span> <span class="delimiter">”</span></span> ））。body（value）; ResponseEntity &lt; <span class="predefined-type">String</span> &gt; response = template.exchange（requestEntity， <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-multipart"><a class="anchor" href="#rest-template-multipart"></a>多</h5>
<div class="paragraph">
<p>要发送多部分数据，您需要提供<code>MultiValueMap&lt;String, ?&gt;</code>其值为表示部件内容的对象，或表示部件内容和标题的<code>HttpEntity</code> 。<code>MultipartBodyBuilder</code>提供了一个方便的API来准备多部分请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MultipartBodyBuilder builder = <span class="keyword">new</span> MultipartBodyBuilder（）; builder.part（ <span class="string"><span class="delimiter">“</span> <span class="content">fieldPart</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">fieldValue</span> <span class="delimiter">”</span></span> ）; builder.part（ <span class="string"><span class="delimiter">“</span> <span class="content">filePart</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> FileSystemResource（ <span class="string"><span class="delimiter">“</span> <span class="content">... logo.png</span> <span class="delimiter">”</span></span> ））; builder.part（ <span class="string"><span class="delimiter">“</span> <span class="content">jsonPart</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> Person（ <span class="string"><span class="delimiter">“</span> <span class="content">Jason</span> <span class="delimiter">”</span></span> ））; MultiValueMap &lt; <span class="predefined-type">String</span> ，HttpEntity &lt;？&gt;&gt; parts = builder.build（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下，您不必为每个零件指定<code>Content-Type</code> 。内容类型是根据选择用于序列​​化的<code>HttpMessageConverter</code>自动确定的，或者是基于文件扩展名的<code>Resource</code>的情况。如有必要，您可以通过重载的构建器<code>part</code>方法明确提供要用于每个部件的<code>MediaType</code> 。</p>
</div>
<div class="paragraph">
<p><code>MultiValueMap</code>准备好后，您可以将其传递给<code>RestTemplate</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MultipartBodyBuilder构建器= ...; template.postForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/upload</span> <span class="delimiter">”</span></span> ，builder.build（）， <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>MultiValueMap</code>包含至少一个非String值，也可以表示常规表单数据（即“application / x-www-form-urlencoded”），则不必将<code>Content-Type</code>设置为“multipart /表单数据”。使用确保<code>HttpEntity</code>包装器的<code>MultipartBodyBuilder</code>时总是如此。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rest-async-resttemplate"><a class="anchor" href="#rest-async-resttemplate"></a> 1.10.2。异步RestTemplate</h4>
<div class="paragraph">
<p>不推荐使用<code>AsyncRestTemplate</code> 。对于考虑使用<code>AsyncRestTemplate</code>所有用例，请改用<a href="web-reactive.html#webflux-client">WebClient</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ejb"><a class="anchor" href="#ejb"></a> 2。Enterprise JavaBeans（EJB）集成</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ejb-introduction"><a class="anchor" href="#ejb-introduction"></a> 2.1。介绍</h3>
<div class="paragraph">
<p>作为一个轻量级容器，Spring通常被认为是EJB的替代品。我们相信，对于许多（如果不是大多数）应用程序和用例，Spring作为容器，结合其在事务，ORM和JDBC访问领域的丰富支持功能，是比通过EJB容器和EJB实现等效功能更好的选择。 。</p>
</div>
<div class="paragraph">
<p>但是，重要的是要注意使用Spring并不会阻止您使用EJB。事实上，Spring使得访问EJB以及在其中实现EJB和功能变得更加容易。此外，使用Spring访问EJB提供的服务允许稍后在本地EJB，远程EJB或POJO（普通旧Java对象）变体之间透明地切换这些服务的实现，而不必更改客户端代码。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将了解Spring如何帮助您访问和实现EJB。Spring在访问无状态会话bean（SLSB）时提供了特殊的价值，因此我们将首先讨论这个问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="ejb-access"><a class="anchor" href="#ejb-access"></a> 2.2。访问EJB</h3>
<div class="sect3">
<h4 id="ejb-access-concepts"><a class="anchor" href="#ejb-access-concepts"></a> 2.2.1。概念</h4>
<div class="paragraph">
<p>要在本地或远程无状态会话bean上调用方法，客户端代码通常必须执行JNDI查找以获取（本地或远程）EJB Home对象，然后对该对象使用“create”方法调用以获取实际（本地）或远程）EJB对象。然后在EJB上调用一个或多个方法。</p>
</div>
<div class="paragraph">
<p>为避免重复的低级代码，许多EJB应用程序使用Service Locator和Business Delegate模式。这些比在整个客户端代码中喷涂JNDI查找更好，但是它们通常的实现具有明显的缺点。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常，使用EJB的代码依赖于Service Locator或Business Delegate单例，因此很难进行测试。</p>
</li>
<li>
<p>对于没有业务代表使用的服务定位器模式，应用程序代码仍然必须在EJB主目录上调用create（）方法，并处理生成的异常。因此，它仍然与EJB API和EJB编程模型的复杂性联系在一起。</p>
</li>
<li>
<p>实现业务委托模式通常会导致严重的代码重复，我们必须编写许多方法，只需在EJB上调用相同的方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring方法允许创建和使用代理对象，通常在Spring容器内配置，充当无代码的业务代表。您不需要在手动编码的业务委托中编写另一个服务定位器，另一个JNDI查找或重复方法，除非您实际在此类代码中添加了实际值。</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-local"><a class="anchor" href="#ejb-access-local"></a> 2.2.2。访问本地SLSB</h4>
<div class="paragraph">
<p>假设我们有一个需要使用本地EJB的Web控制器。我们将遵循最佳实践并使用EJB业务方法接口模式，以便EJB的本地接口扩展非EJB特定的业务方法接口。让我们调用这个业务方法接口<code>MyComponent</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">MyComponent</span> {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用业务方法接口模式的主要原因之一是确保本地接口和bean实现类中的方法签名之间的同步是自动的。另一个原因是它后来使我们更容易切换到服务的POJO（普通旧Java对象）实现，如果这样做有意义的话。当然，我们还需要实现本地home接口，并提供实现<code>SessionBean</code>和<code>MyComponent</code>业务方法接口的实现类。现在，我们需要做的唯一Java编码是将Web层控制器连接到EJB实现，即在控制器上公开<code>MyComponent</code>类型的setter方法。这会将引用保存为控制器中的实例变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> MyComponent myComponent; <span class="directive">public</span> <span class="type">void</span> setMyComponent（MyComponent myComponent）{ <span class="local-variable">this</span> .myComponent = myComponent; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们随后可以在控制器中的任何业务方法中使用此实例变量。现在假设我们从Spring容器中获取控制器对象，我们可以（在相同的上下文中）配置一个<code>LocalStatelessSessionProxyFactoryBean</code>实例，该实例将是EJB代理对象。代理的配置以及控制器的<code>myComponent</code>属性的设置是通过配置条目完成的，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myComponent</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ejb.access。LocalStatelessSessionProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ejb / myBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycom。MyComponent</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myController</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycom.myController</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myComponent</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myComponent</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管你没有被迫使用AOP概念来享受结果，但是在Spring AOP框架的帮助下，幕后发生了很多工作。<code>myComponent</code> bean定义为EJB创建代理，该代理实现业务方法接口。EJB本地主目录在启动时被缓存，因此只有一个JNDI查找。每次调用EJB时​​，代理都会调用本地EJB上的<code>classname</code>方法，并在EJB上调用相应的业务方法。</p>
</div>
<div class="paragraph">
<p><code>myController</code> bean定义将控制器类的<code>myComponent</code>属性设置为EJB代理。</p>
</div>
<div class="paragraph">
<p>或者（最好是在很多这样的代理定义的情况下），考虑在Spring的“jee”命名空间中使用<code>&lt;jee:local-slsb&gt;</code>配置元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：local-slsb</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myComponent</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ejb / myBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">business-interface</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.mycom。MyComponent</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myController</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycom.myController</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myComponent</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myComponent</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这种EJB访问机制大大简化了应用程序代码：Web层代码（或其他EJB客户端代码）不依赖于EJB的使用。如果我们想用POJO或模拟对象或其他测试存根替换这个EJB引用，我们可以简单地更改<code>myComponent</code> bean定义而不更改一行Java代码。此外，我们不必编写一行JNDI查找或其他EJB管道代码作为我们的应用程序的一部分。</p>
</div>
<div class="paragraph">
<p>实际应用程序中的基准和经验表明，此方法（涉及目标EJB的反射调用）的性能开销很小，并且在典型使用中通常无法检测到。请记住，我们不希望对EJB进行细粒度调用，因为应用程序服务器中的EJB基础结构会产生相关成本。</p>
</div>
<div class="paragraph">
<p>关于JNDI查找有一点需要注意。在bean容器中，这个类通常最好用作单例（没有理由将它作为原型）。但是，如果该bean容器预先实例化单例（就像各种XML <code>ApplicationContext</code>变体一样），如果在EJB容器加载目标EJB之前加载bean容器，则可能会出现问题。这是因为JNDI查找将在此类的<code>init()</code>方法中执行，然后进行缓存，但EJB尚未绑定到目标位置。解决方案是不预先实例化此工厂对象，但允许在首次使用时创建它。在XML容器中，这是通过<code>lazy-init</code>属性控制的。</p>
</div>
<div class="paragraph">
<p>虽然大多数Spring用户都不会对此感兴趣，但那些使用EJB编程的AOP工作者可能希望查看<code>LocalSlsbInvokerInterceptor</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-remote"><a class="anchor" href="#ejb-access-remote"></a> 2.2.3。访问远程SLSB</h4>
<div class="paragraph">
<p>除了使用<code>SimpleRemoteStatelessSessionProxyFactoryBean</code>或<code>&lt;jee:remote-slsb&gt;</code>配置元素之外，访问远程EJB与访问本地EJB基本相同。当然，无论有没有Spring，远程调用语义都适用;对另一台计算机中另一台虚拟机中的对象的方法调用有时必须在使用场景和故障处理方面区别对待。</p>
</div>
<div class="paragraph">
<p>Spring的EJB客户端支持比非Spring方法增加了一个优势。通常，EJB客户端代码在本地或远程调用EJB之间来回切换是很有问题的。这是因为远程接口方法必须声明它们抛出<code>RemoteException</code> ，而客户端代码必须处理这个，而本地接口方法则不然。为需要移动到远程EJB的本地EJB编写的客户端代码通常必须进行修改以添加对远程异常的处理，并且为需要移动到本地EJB的远程EJB编写的客户端代码可以保持不变但是很多不必要的远程异常处理，或者需要修改以删除该代码。使用Spring远程EJB代理，您可以不在业务方法接口中声明任何抛出的<code>RemoteException</code>并实现EJB代码，具有相同的远程接口，除了它抛出<code>RemoteException</code> ，并依赖代理动态处理这两个接口好像他们是一样的。也就是说，客户端代码不必处理已检查的<code>RemoteException</code>类。在EJB调用期间抛出的任何实际<code>RemoteException</code>都将作为未检查的<code>RemoteAccessException</code>类重新抛出，该类是<code>RuntimeException</code>的子类。然后，可以在本地EJB或远程EJB（甚至普通Java对象）实现之间随意切换目标服务，而无需客户端代码知道或关心。当然，这是可选的;没有什么可以阻止您在业务界面中声明<code>RemoteExceptions</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-ejb2-ejb3"><a class="anchor" href="#ejb-access-ejb2-ejb3"></a> 2.2.4。访问EJB 2.x SLSB与EJB 3 SLSB</h4>
<div class="paragraph">
<p>通过Spring访问EJB 2.x会话Bean和EJB 3会话Bean在很大程度上是透明的。Spring的EJB访问器，包括<code>&lt;jee:local-slsb&gt;</code>和<code>&lt;jee:remote-slsb&gt;</code>工具，在运行时透明地适应实际组件。如果找到（EJB 2.x样式），它们将处理home接口，或者如果没有可用的home接口（EJB 3样式），则执行直接组件调用。</p>
</div>
<div class="paragraph">
<p>注意：对于EJB 3会话Bean，您也可以有效地使用<code>JndiObjectFactoryBean</code> / <code>&lt;jee:jndi-lookup&gt;</code> ，因为那里公开了完全可用的组件引用以进行普通的JNDI查找。定义显式<code>&lt;jee:local-slsb&gt;</code> / <code>&lt;jee:remote-slsb&gt;</code>查找只是提供一致且更明确的EJB访问配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jms"><a class="anchor" href="#jms"></a> 3。JMS（Java消息服务）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jms-introduction"><a class="anchor" href="#jms-introduction"></a> 3.1。介绍</h3>
<div class="paragraph">
<p>Spring提供了一个JMS集成框架，它简化了JMS API的使用，就像Spring对JDBC API的集成一样。</p>
</div>
<div class="paragraph">
<p>JMS可以大致分为两个功能区域，即消息的生成和消费。<code>JmsTemplate</code>类用于消息生成和同步消息接收。对于类似于Java EE的消息驱动bean样式的异步接收，Spring提供了许多消息监听器容器，用于创建消息驱动的POJO（MDP）。Spring还提供了一种创建消息监听器的声明方式。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jms.core</code>包提供了使用JMS的核心功能。它包含JMS模板类，通过处理资源的创建和释放来简化JMS的使用，就像<code>JdbcTemplate</code>为JDBC做的那样。 Spring模板类常见的设计原则是提供辅助方法来执行常见操作，并且为了更复杂的用法，将处理任务的本质委托给用户实现的回调接口。JMS模板遵循相同的设计。这些类为发送消息，同步使用消息以及向用户公开JMS会话和消息生成器提供了各种便利方法。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jms.support</code>包提供了<code>JMSException</code>转换功能。转换将已检查的<code>JMSException</code>层次结构转换为未经检查的异常的镜像层次结构。如果已检查的<code>javax.jms.存在任何特定于提供者的子类<code>javax.jms.JMSException</code> ，此异常包含在未经检查的<code>UncategorizedJmsException</code> 。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jms.support.converter</code>包提供了一个<code>MessageConverter</code>抽象，用于在Java对象和JMS消息之间进行转换。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jms.support.destination</code>包提供了各种管理JMS目标的策略，例如为存储在JNDI中的目标提供服务定位器。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jms.annotation</code>包提供了必要的基础结构，以使用<code>@JmsListener</code>支持注释驱动的侦听器端点。</p>
</div>
<div class="paragraph">
<p>包<code>org.springframework.jms.config</code>提供了<code>jms</code>命名空间的解析器实现，以及用于配置侦听器容器和创建侦听器端点的java配置支持。</p>
</div>
<div class="paragraph">
<p>最后， <code>org.springframework.jms.connection</code>包提供了适用于独立应用程序的<code>ConnectionFactory</code>实现。它还包含Spring的<code>PlatformTransactionManager</code> for JMS（狡猾地命名为<code>JmsTransactionManager</code> ）的实现。这允许将JMS作为事务资源无缝集成到Spring的事务管理机制中。</p>
</div>
</div>
<div class="sect2">
<h3 id="jms-using"><a class="anchor" href="#jms-using"></a> 3.2。使用Spring JMS</h3>
<div class="sect3">
<h4 id="jms-jmstemplate"><a class="anchor" href="#jms-jmstemplate"></a> 3.2.1。JmsTemplate的</h4>
<div class="paragraph">
<p><code>JmsTemplate</code>类是JMS核心包中的中心类。它简化了JMS的使用，因为它在发送或同步接收消息时处理资源的创建和释放。</p>
</div>
<div class="paragraph">
<p>使用<code>JmsTemplate</code>代码只需要实现回调接口，为它们提供明确定义的高级合同。<code>MessageCreator</code>回调接口创建一个消息，给定由<code>JmsTemplate</code>的调用代码提供的<code>Session</code> 。为了允许更复杂地使用JMS API，回调<code>SessionCallback</code>为用户提供了JMS会话，而回调<code>ProducerCallback</code>公开了<code>Session</code>和<code>MessageProducer</code>对。</p>
</div>
<div class="paragraph">
<p>JMS API公开了两种类型的发送方法，一种采用传递模式，优先级和生存时间作为服务质量（QOS）参数，另一种采用不使用默认值的QOS参数。由于<code>JmsTemplate</code>有许多发送方法，因此QOS参数的设置已作为bean属性公开，以避免重复发送方法的数量。同样，使用属性<code>setReceiveTimeout</code>设置同步接收调用的超时值。</p>
</div>
<div class="paragraph">
<p>一些JMS提供程序允许通过<code>ConnectionFactory</code>的配置来管理地设置默认QOS值。这导致对<code>MessageProducer</code>的send方法<code>send(Destination destination, Message message)</code>的调用将使用与JMS规范中指定的值不同的QOS默认值。因此，为了提供对QOS值的一致管理，必须通过将布尔属性<code>isExplicitQosEnabled</code>设置为<code>true</code>来专门启用<code>JmsTemplate</code>以使用其自己的QOS值。</p>
</div>
<div class="paragraph">
<p>为方便起见， <code>JmsTemplate</code>还公开了一个基本的请求 - 回复操作，该操作允许发送消息并等待作为操作的一部分创建的临时队列的回复。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>一旦配置</em> ， <code>JmsTemplate</code>类的实例就是<em>线程安全的</em> 。这很重要，因为这意味着您可以配置<code>JmsTemplate</code>的单个实例，然后将此<em>共享</em>引用安全地注入多个协作者。要清楚， <code>JmsTemplate</code>是有状态的，因为它维护对<code>ConnectionFactory</code>的引用，但是这种状态<em>不是</em>会话状态。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从Spring Framework 4.1开始， <code>JmsMessagingTemplate</code>构建在<code>JmsTemplate</code>之上，并提供与消息传递抽象的集成，即<code>org.springframework.messaging.Message</code> 。这允许您创建要以通用方式发送的消息。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-connections"><a class="anchor" href="#jms-connections"></a> 3.2.2。连接</h4>
<div class="paragraph">
<p><code>JmsTemplate</code>需要引用<code>ConnectionFactory</code> 。<code>ConnectionFactory</code>是JMS规范的一部分，并作为使用JMS的入口点。客户端应用程序将其用作工厂以创建与JMS提供程序的连接，并封装各种配置参数，其中许多是供应商特定的，例如SSL配置选项。</p>
</div>
<div class="paragraph">
<p>在EJB中使用JMS时，供应商提供JMS接口的实现，以便它们可以参与声明式事务管理并执行连接和会话池。为了使用此实现，Java EE容器通常要求您将JMS连接工厂声明为EJB或servlet部署描述符中的<code>resource-ref</code> 。为了确保在EJB中使用<code>JmsTemplate</code>这些功能，客户端应用程序应确保它引用<code>ConnectionFactory</code>的托管实现。</p>
</div>
<div class="sect4">
<h5 id="jms-caching-resources"><a class="anchor" href="#jms-caching-resources"></a>缓存消息传递资源</h5>
<div class="paragraph">
<p>标准API涉及创建许多中间对象。要发送消息，请执行以下“API”步骤</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ConnectionFactory-&gt;连接 - &gt;会话级&gt; MessageProducer-&gt;发</pre>
</div>
</div>
<div class="paragraph">
<p>在ConnectionFactory和Send操作之间，有三个中间对象被创建和销毁。为了优化资源使用并提高性能，提供了<code>ConnectionFactory</code>两个实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="jms-connection-factory"><a class="anchor" href="#jms-connection-factory"></a> SingleConnectionFactory</h5>
<div class="paragraph">
<p>Spring提供了<code>ConnectionFactory</code>接口<code>SingleConnectionFactory</code>的实现，它将在所有<code>createConnection()</code>调用上返回相同的<code>Connection</code> ，并忽略对<code>close()</code>调用。这对于测试和独立环境非常有用，因此可以将相同的连接用于可能跨越任意数量事务的多个<code>JmsTemplate</code>调用。<code>SingleConnectionFactory</code>引用通常来自JNDI的标准<code>ConnectionFactory</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-connection-factory-caching"><a class="anchor" href="#jdbc-connection-factory-caching"></a> CachingConnectionFactory</h5>
<div class="paragraph">
<p>该<code>CachingConnectionFactory</code>扩展的功能<code>SingleConnectionFactory</code> ，并增加了会话，MessageProducter的，和MessageConsumers的缓存。初始高速缓存大小设置为1，使用属性<code>sessionCacheSize</code>增加高速缓存会话的数量。请注意，当会话根据其确认模式进行缓存时，实际缓存会话的数量将大于该数量，因此当<code>sessionCacheSize</code>设置为1时，最多可以有4个缓存会话实例，每个确认模式一个。MessageProducers和MessageConsumers在其拥有的会话中缓存，并在缓存时考虑生产者和使用者的独特属性。MessageProducers根据其目标进行缓存。MessageConsumers基于由destination，selector，noLocal delivery标志和持久订阅名称组成的键进行高速缓存（如果创建持久消费者）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-destinations"><a class="anchor" href="#jms-destinations"></a> 3.2.3。目的地管理</h4>
<div class="paragraph">
<p>目标，如ConnectionFactories，是可以在JNDI中存储和检索的JMS管理对象。配置Spring应用程序上下文时，可以使用JNDI工厂类<code>JndiObjectFactoryBean</code> / <code>&lt;jee:jndi-lookup&gt;</code>对对象对JMS目标的引用执行依赖项注入。但是，如果应用程序中存在大量目标，或者存在JMS提供程序特有的高级目标管理功能，则此策略通常很麻烦。这种高级目标管理的示例是创建动态目的地或支持目的地的分层命名空间。<code>JmsTemplate</code>将目标名称的解析委托给JMS目标对象到<code>DestinationResolver</code>接口的实现。<code>DynamicDestinationResolver</code>是<code>JmsTemplate</code>使用的默认实现，适用于解析动态目标。还提供了<code>JndiDestinationResolver</code> ，它充当JNDI中包含的目标的服务定位器，并且可选地回退到<code>DynamicDestinationResolver</code>包含的行为。</p>
</div>
<div class="paragraph">
<p>通常，JMS应用程序中使用的目标仅在运行时已知，因此在部署应用程序时无法通过管理方式创建。这通常是因为在交互系统组件之间存在共享应用程序逻辑，这些组件根据众所周知的命名约定在运行时创建目标。尽管动态目标的创建不是JMS规范的一部分，但大多数供应商都提供了此功能。使用用户定义的名称创建动态目标，这些名称将它们与临时目标区分开来，并且通常不在JNDI中注册。用于创建动态目标的API因提供商而异，因为与目标关联的属性是特定于供应商的。但是，供应商有时会做出一个简单的实现选择，即忽略JMS规范中的警告，并使用<code>TopicSession</code>方法<code>createTopic(String topicName)</code>或<code>QueueSession</code>方法<code>createQueue(String queueName)</code>来创建具有默认目标属性的新目标。 。根据供应商的实现， <code>DynamicDestinationResolver</code>可能还会创建物理目标，而不是仅解析一个。</p>
</div>
<div class="paragraph">
<p>布尔属性<code>pubSubDomain</code>用于配置<code>JmsTemplate</code> ，了解正在使用的JMS域。默认情况下，此属性的值为false，表示将使用点对点域Queues。<code>JmsTemplate</code>使用的此属性通过<code>DestinationResolver</code>接口的实现确定动态目标解析的行为。</p>
</div>
<div class="paragraph">
<p>您还可以通过属性<code>defaultDestination</code>将<code>JmsTemplate</code>配置为默认目标。默认目标将用于不引用特定目标的发送和接收操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-mdp"><a class="anchor" href="#jms-mdp"></a> 3.2.4。消息侦听器容器</h4>
<div class="paragraph">
<p>EJB世界中JMS消息最常见的用途之一是驱动消息驱动的bean（MDB）。Spring提供了一种解决方案，可以以不将用户绑定到EJB容器的方式创建消息驱动的POJO（MDP）。（有关Spring的MDP支持的详细介绍，请参阅<a href="#jms-asynchronousMessageReception">异步接收：消息驱动的POJO</a> 。）从Spring Framework 4.1开始，可以使用<code>@JmsListener</code>简单地注释端点方法，有关详细信息，请参阅<a href="#jms-annotated">注释驱动的侦听器端点</a> 。</p>
</div>
<div class="paragraph">
<p>消息侦听器容器用于从JMS消息队列接收消息并驱动注入其中的<code>MessageListener</code> 。侦听器容器负责消息接收的所有线程并将其分派到侦听器进行处理。消息监听器容器是MDP和消息传递提供者之间的中介，负责注册接收消息，参与事务，资源获取和释放，异常转换等。这允许您作为应用程序开发人员编写与接收消息（并可能响应消息）相关联的（可能是复杂的）业务逻辑，并将样板JMS基础结构关注委托给框架。</p>
</div>
<div class="paragraph">
<p>Spring包含两个标准的JMS消息监听器容器，每个容器都有其专用的功能集。</p>
</div>
<div class="sect4">
<h5 id="jms-mdp-simple"><a class="anchor" href="#jms-mdp-simple"></a> SimpleMessageListenerContainer一样</h5>
<div class="paragraph">
<p>此消息侦听器容器更简单的两种标准风格。它在启动时创建固定数量的JMS会话和使用者，使用标准JMS <code>MessageConsumer.setMessageListener()</code>方法注册侦听器，并将其保留为JMS提供程序以执行侦听器回调。此变体不允许动态适应运行时需求或参与外部管理的事务。兼容性方面，它非常接近独立JMS规范的精神 - 但通常与Java EE的JMS限制不兼容。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然<code>SimpleMessageListenerContainer</code>不允许参与外部托管事务，但它确实支持本机JMS事务：只需将'sessionTransacted'标志切换为'true'，或者在命名空间中将'acknowledge'属性设置为'transacted'：抛出异常然后，从您的监听器将导致回滚，并重新传递消息。或者，考虑使用“CLIENT_ACKNOWLEDGE”模式，该模式在异常的情况下也提供重新传递，但不使用事务处理的会话，因此不包括事务协议中的任何其他会话操作（例如发送响应消息）。</p>
</div>
<div class="paragraph">
<p><strong>默认的“AUTO_ACKNOWLEDGE”模式不提供适当的可靠性保证。</strong>当侦听器执行失败时，消息可能会丢失（因为提供程序将在侦听器调用后自动确认每条消息，没有异常传播到提供程序）或侦听器容器关闭时（可以通过'acceptMessagesWhileStopping'标志配置） 。确保在可靠性需求的情况下使用事务处理会话，例如，可靠的队列处理和持久的主题订阅。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="jms-mdp-default"><a class="anchor" href="#jms-mdp-default"></a>使用DefaultMessageListenerContainer</h5>
<div class="paragraph">
<p>此消息侦听器容器是大多数情况下使用的容器。与<code>SimpleMessageListenerContainer</code> ，此容器变体允许动态适应运行时需求，并且能够参与外部管理的事务。当使用<code>JtaTransactionManager</code>配置时，每个收到的消息都使用XA事务注册;因此处理可以利用XA事务语义。此侦听器容器在JMS提供程序的低要求，参与外部管理事务的高级功能以及与Java EE环境的兼容性之间取得了良好的平衡。</p>
</div>
<div class="paragraph">
<p>可以自定义容器的缓存级别。请注意，如果未启用缓存，则会为每个邮件接收创建新连接和新会话。将此与高负载的非持久订阅相结合可能会导致消息丢失。在这种情况下，请确保使用适当的缓存级别。</p>
</div>
<div class="paragraph">
<p>当代理发生故障时，此容器还具有可恢复的功能。默认情况下，简单的<code>BackOff</code>实现每5秒重试一次。可以为更细粒度的恢复选项指定自定义<code>BackOff</code>实现，有关示例，请参阅<code>ExponentialBackOff</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与其兄弟<code>SimpleMessageListenerContainer</code> ， <code>DefaultMessageListenerContainer</code>支持本机JMS事务，也允许自定义确认模式。如果您的方案可行，强烈建议使用外部管理的事务：即，如果JVM死亡，您可以偶尔使用重复的消息。业务逻辑中的自定义重复消息检测步骤可以涵盖这种情况，例如以业务实体存在检查或协议表检查的形式。任何此类安排都将比替代方案更有效：使用XA事务包装整个处理（通过使用<code>JtaTransactionManager</code>配置<code>DefaultMessageListenerContainer</code> ），覆盖JMS消息的接收以及消息监听器中业务逻辑的执行（包括数据库操作等）。</p>
</div>
<div class="paragraph">
<p><strong>默认的“AUTO_ACKNOWLEDGE”模式不提供适当的可靠性保证。</strong>当侦听器执行失败时（由于提供程序将在侦听器调用之前自动确认每条消息）或侦听器容器关闭时（可以通过“acceptMessagesWhileStopping”标志配置），消息可能会丢失。确保在可靠性需求的情况下使用事务处理会话，例如，可靠的队列处理和持久的主题订阅。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-tx"><a class="anchor" href="#jms-tx"></a> 3.2.5。交易管理</h4>
<div class="paragraph">
<p>Spring提供了一个<code>JmsTransactionManager</code>来管理单个JMS <code>ConnectionFactory</code>事务。这允许JMS应用程序利用Spring的托管事务功能，如<a href="data-access.html#transaction">事务管理中所述</a> 。<code>JmsTransactionManager</code>执行本地资源事务，将JMS连接/会话对从指定的<code>ConnectionFactory</code>绑定到线程。
<code>JmsTemplate</code>自动检测此类事务资源并对其进行相应操作。</p>
</div>
<div class="paragraph">
<p>在Java EE环境中， <code>ConnectionFactory</code>将池连接和会话，因此这些资源可以跨事务有效地重用。在独立环境中，使用Spring的<code>SingleConnectionFactory</code>将导致共享JMS <code>Connection</code> ，每个事务都有自己独立的<code>Session</code> 。或者，考虑使用特定于提供者的池适配器，例如ActiveMQ的<code>PooledConnectionFactory</code>类。</p>
</div>
<div class="paragraph">
<p><code>JmsTemplate</code>还可以与<code>JtaTransactionManager</code>和支持XA的JMS <code>ConnectionFactory</code>以执行分布式事务。请注意，这需要使用JTA事务管理器以及正确配置XA的ConnectionFactory！（查看Java EE服务器的/ JMS提供程序的文档。）</p>
</div>
<div class="paragraph">
<p>使用JMS API从<code>Connection</code>创建<code>Session</code>时，在托管和非托管事务环境中重用代码可能会造成混淆。这是因为JMS API只有一个工厂方法来创建<code>Session</code> ，它需要事务和确认模式的值。在托管环境中，设置这些值是环境事务基础结构的责任，因此供应商的JMS连接包装器会忽略这些值。在非托管环境中使用<code>JmsTemplate</code> ，可以通过使用属性<code>sessionTransacted</code>和<code>sessionAcknowledgeMode</code>来指定这些值。将<code>PlatformTransactionManager</code>与<code>JmsTemplate</code> ，将始终为模板提供事务性JMS <code>Session</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-sending"><a class="anchor" href="#jms-sending"></a> 3.3。发送消息</h3>
<div class="paragraph">
<p><code>JmsTemplate</code>包含许多发送消息的便捷方法。有一些send方法使用<code>javax.jms.指定目标<code>javax.jms.Destination</code>对象以及使用字符串在JNDI查找中指定Destination</code>对象。不带目标参数的send方法使用默认目标。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.jms。ConnectionFactory</span> ; <span class="keyword">import</span> <span class="include">javax.jms。JMSException</span> ; <span class="keyword">import</span> <span class="include">javax.jms。消息</span> ; <span class="keyword">import</span> <span class="include">javax.jms。队列</span> ; <span class="keyword">import</span> <span class="include">javax.jms。会议</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jms.core。MessageCreator</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jms.core。JmsTemplate</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">JmsQueueSender</span> { <span class="directive">private</span> JmsTemplate jmsTemplate; <span class="directive">私有</span> <span class="predefined-type">队列</span>队列; <span class="directive">public</span> <span class="type">void</span> setConnectionFactory（ConnectionFactory cf）{ <span class="local-variable">this</span> .jmsTemplate = <span class="keyword">new</span> JmsTemplate（cf）; <span class="directive">public</span> <span class="type">void</span> setQueue（ <span class="predefined-type">Queue</span> queue）{ <span class="local-variable">this</span> .queue = queue; <span class="directive">public</span> <span class="type">void</span> simpleSend（）{ <span class="local-variable">this</span> .jmsTemplate.send（ <span class="local-variable">this</span> .queue， <span class="keyword">new</span> MessageCreator（）{ <span class="directive">public</span> Message createMessage（Session session） <span class="directive">throws</span> JMSException { <span class="keyword">return</span> session.createTextMessage（ <span class="string"><span class="delimiter">“</span> <span class="content">hello queue world</span> <span class="delimiter">”</span></span> ）;}}）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例使用<code>MessageCreator</code>回调从提供的<code>Session</code>对象创建文本消息。通过将引用传递给<code>ConnectionFactory</code>来构造<code>JmsTemplate</code> 。作为替代方案，提供了零参数构造函数和<code>connectionFactory</code> ，可用于以JavaBean样式构造实例（使用BeanFactory或纯Java代码）。或者，考虑从Spring的<code>JmsGatewaySupport</code>便捷基类派生，该基类为JMS配置提供预构建的bean属性。</p>
</div>
<div class="paragraph">
<p>方法<code>send(String destinationName, MessageCreator creator)</code>允许您使用目标的字符串名称发送消息。如果这些名称在JNDI中注册，则应将模板的<code>destinationResolver</code>属性设置为<code>JndiDestinationResolver</code>的实例。</p>
</div>
<div class="paragraph">
<p>如果您创建了<code>JmsTemplate</code>并指定了默认目标，则<code>send(MessageCreator c)</code>会向该目标发送一条消息。</p>
</div>
<div class="sect3">
<h4 id="jms-msg-conversion"><a class="anchor" href="#jms-msg-conversion"></a> 3.3.1。使用消息转换器</h4>
<div class="paragraph">
<p>为了便于发送域模型对象， <code>JmsTemplate</code>具有各种发送方法，这些方法将Java对象作为消息数据内容的参数。<code>JmsTemplate</code>的重载方法<code>receiveAndConvert()</code> <code>convertAndSend()</code>和<code>receiveAndConvert()</code>将转换过程委托给<code>MessageConverter</code>接口的实例。此接口定义了一个简单的合约，用于在Java对象和JMS消息之间进行转换。默认实现<code>SimpleMessageConverter</code>支持<code>String</code>和<code>TextMessage</code> ， <code>byte[]</code>和<code>BytesMesssage</code>以及<code>java.util.之间的转换<code>java.util.Map</code>和<code>MapMessage</code> 。通过使用转换器，您和您的应用程序代码可以专注于通过JMS发送或接收的业务对象，而不关心它如何表示为JMS消息的详细信息。</p>
</div>
<div class="paragraph">
<p>沙箱当前包含一个<code>MapMessageConverter</code> ，它使用反射在JavaBean和<code>MapMessage</code>之间进行转换。您可能自己实现的其他流行实现选择是转换器，它使用现有的XML编组软件包（如JAXB，Castor或XStream）来创建表示对象的<code>TextMessage</code> 。</p>
</div>
<div class="paragraph">
<p>为了适应消息的属性，标题和正文的设置，这些属性，标题和正文无法一般地封装在转换器类中， <code>MessagePostProcessor</code>接口允许您在转换消息之后但在发送之前访问消息。下面的示例演示了如何在<code>java.util.之后修改消息头和属性<code>java.util.Map</code>将转换为消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> sendWithConversion（）{ <span class="predefined-type">Map</span> map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> （）; map.put（ <span class="string"><span class="delimiter">“</span> <span class="content">名称</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">标记</span> <span class="delimiter">”</span></span> ）; map.put（ <span class="string"><span class="delimiter">“</span> <span class="content">Age</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> <span class="predefined-type">Integer</span> （ <span class="integer">47</span> ））; jmsTemplate.convertAndSend（ <span class="string"><span class="delimiter">“</span> <span class="content">testQueue</span> <span class="delimiter">”</span></span> ，map， <span class="keyword">new</span> MessagePostProcessor（）{ <span class="directive">public</span> Message postProcessMessage（Message message） <span class="directive">抛出</span> JMSException {message.setIntProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">AccountID</span> <span class="delimiter">”</span></span> ， <span class="integer">1234</span> ）; message.setJMSCorrelationID（ <span class="string"><span class="delimiter">“</span> <span class="content">123-00001</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> message; }}; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会产生以下形式的消息：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MapMessage = {Header = {...标准标题...CorrelationID = {123-00001}}属性= {AccountID = {整数：1234}}字段= {Name = {String：Mark}年龄= {整数：47}}}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-callbacks"><a class="anchor" href="#jms-callbacks"></a> 3.3.2。SessionCallback和ProducerCallback</h4>
<div class="paragraph">
<p>虽然发送操作涵盖了许多常见的使用场景，但有时您希望在JMS <code>Session</code>或<code>MessageProducer</code>上执行多个操作。<code>SessionCallback</code>和<code>ProducerCallback</code>公开JMS <code>Session</code>和<code>Session</code> / <code>MessageProducer</code>对。<code>JmsTemplate</code>上的<code>execute()</code>方法执行这些回调方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-receiving"><a class="anchor" href="#jms-receiving"></a> 3.4。收到消息</h3>
<div class="sect3">
<h4 id="jms-receiving-sync"><a class="anchor" href="#jms-receiving-sync"></a> 3.4.1。同步接收</h4>
<div class="paragraph">
<p>虽然JMS通常与异步处理相关联，但可以同步使用消息。重载的<code>receive(..)</code>方法提供此功能。在同步接收期间，调用线程将阻塞，直到消息可用。这可能是一个危险的操作，因为调用线程可能会无限期地被阻塞。属性<code>receiveTimeout</code>指定接收方在放弃等待消息之前应等待的时间。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-asynchronousMessageReception"><a class="anchor" href="#jms-asynchronousMessageReception"></a> 3.4.2。异步接收：消息驱动的POJO</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring还通过使用<code>@JmsListener</code>注释来支持带注释的侦听器端点，并提供一个开放式基础结构来以编程方式注册端点。这是设置异步接收器的最便捷方式，请参阅<a href="#jms-annotated-support">启用侦听器端点注释</a>以获取更多详细信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以类似于EJB世界中的消息驱动Bean（MDB）的方式，消息驱动的POJO（MDP）充当JMS消息的接收器。MDP上的一个限制（但也参见下面对<code>MessageListenerAdapter</code>类的讨论）是它必须实现<code>javax.jms.MessageListener</code>接口。另请注意，如果您的POJO将在多个线程上接收消息，请务必确保您的实现是线程安全的。</p>
</div>
<div class="paragraph">
<p>以下是MDP的简单实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.jms。JMSException</span> ; <span class="keyword">import</span> <span class="include">javax.jms。消息</span> ; <span class="keyword">import</span> <span class="include">javax.jms。MessageListener</span> ; <span class="keyword">import</span> <span class="include">javax.jms。TextMessage</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleListener</span> <span class="directive">实现</span> MessageListener { <span class="directive">public</span> <span class="type">void</span> onMessage（Message message）{ <span class="keyword">if</span> （message <span class="keyword">instanceof</span> TextMessage）{ <span class="keyword">try</span> { <span class="predefined-type">System</span> .out.println（（（TextMessage）message）.getText（））; } <span class="keyword">catch</span> （JMSException ex）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span> （ex）; } <span class="keyword">else</span> { <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Message必须是TextMessage类型</span> <span class="delimiter">”</span></span> ）; }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦实现了<code>MessageListener</code> ，就可以创建一个消息监听器容器了。</p>
</div>
<div class="paragraph">
<p>下面是一个如何定义和配置Spring附带的消息监听器容器之一的示例（在本例中为<code>DefaultMessageListenerContainer</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 这是消息驱动的POJO（MDP） - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messageListener</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jmsexample。ExampleListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 这是消息监听器容器 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jmsContainer</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jms.listener。DefaultMessageListenerContainer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <strong><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></strong> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关每个实现支持的功能的完整说明，请参阅各种消息侦听器容器的Spring javadoc。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async-session-aware-message-listener"><a class="anchor" href="#jms-receiving-async-session-aware-message-listener"></a> 3.4.3。SessionAwareMessageListener接口</h4>
<div class="paragraph">
<p><code>SessionAwareMessageListener</code>接口是一个特定于Spring的接口，它提供与JMS <code>MessageListener</code>接口类似的契约，但也提供了消息处理方法，可以访问从中接收<code>Message</code>的JMS <code>Session</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.jms.listener</span> ; <span class="directive">公共</span> <span class="type">接口</span> <span class="class">SessionAwareMessageListener</span> { <span class="type">void</span> onMessage（消息消息，会话会话） <span class="directive">抛出</span> JMSException; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果希望MDP能够响应任何收到的消息（使用<code>onMessage(Message, Session)</code>方法中提供的<code>Session</code> ），则可以选择让MDP实现此接口（优先于标准JMS <code>MessageListener</code>接口）。Spring附带的所有消息侦听器容器实现都支持实现<code>MessageListener</code>或<code>SessionAwareMessageListener</code>接口的MDP。实现<code>SessionAwareMessageListener</code>类带有警告，然后通过接口将它们绑定到Spring。是否使用它的选择完全取决于您作为应用程序开发人员或架构师。</p>
</div>
<div class="paragraph">
<p>请注意， <code>SessionAwareMessageListener</code>接口的<code>'onMessage(..)'</code>方法会抛出<code>JMSException</code> 。与标准JMS <code>MessageListener</code>接口相比，使用<code>SessionAwareMessageListener</code>接口时，客户端代码负责处理抛出的任何异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async-message-listener-adapter"><a class="anchor" href="#jms-receiving-async-message-listener-adapter"></a> 3.4.4。的MessageListenerAdapter</h4>
<div class="paragraph">
<p><code>MessageListenerAdapter</code>类是Spring异步消息传递支持的最后一个组件：简而言之，它允许您将几乎<em>任何</em>类公开为MDP（当然有一些约束）。</p>
</div>
<div class="paragraph">
<p>请考虑以下接口定义。请注意，虽然接口既不扩展<code>MessageListener</code>也不扩展<code>SessionAwareMessageListener</code>接口，但它仍然可以通过使用<code>MessageListenerAdapter</code>类用作MDP。还要注意各种消息处理方法如何根据它们可以接收和处理的各种<code>Message</code>类型的<em>内容</em>进行强类型化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MessageDelegate</span> { <span class="type">void</span> handleMessage（ <span class="predefined-type">String</span> message）; <span class="type">void</span> handleMessage（ <span class="predefined-type">Map</span> message）; <span class="type">void</span> handleMessage（ <span class="type">byte</span> <span class="type">[]</span> message）; <span class="type">void</span> handleMessage（ <span class="predefined-type">Serializable</span> message）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultMessageDelegate</span> <span class="directive">实现</span> MessageDelegate { <span class="comment">//为了清晰起见而省略了实现...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特别要注意<code>MessageDelegate</code>接口的上述实现（上面的<code>DefaultMessageDelegate</code>类）根本<em>没有</em> JMS依赖。它确实是一个POJO，我们将通过以下配置进入MDP。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 这是消息驱动的POJO（MDP） - &gt;</span> <strong><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messageListener</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.listener.adapter。MessageListenerAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jmsexample。DefaultMessageDelegate</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ constructor-arg&gt;</span> <span class="tag">&lt;/ bean&gt;</span></strong> <span class="comment">&lt;！ - 这是消息监听器容器...  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jmsContainer</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jms.listener。DefaultMessageListenerContainer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <strong><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></strong> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是另一个只能处理JMS <code>TextMessage</code>消息接收的MDP的示例。注意消息处理方法实际上是如何被称为<code>'receive'</code> （ <code>MessageListenerAdapter</code>中的消息处理方法的名称默认为<code>'handleMessage'</code> ），但它是可配置的（如下所示）。另请注意<code>'receive(..)'</code>方法是如何强类型的，以接收和响应JMS <code>TextMessage</code>消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">TextMessageDelegate</span> { <span class="type">void</span> receive（TextMessage message）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultTextMessageDelegate</span> <span class="directive">实现</span> TextMessageDelegate { <span class="comment">//为了清晰起见而省略了实现...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>话务员<code>MessageListenerAdapter</code>的配置如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">messageListener</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.listener.adapter。MessageListenerAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jmsexample。DefaultTextMessageDelegate</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ constructor-arg&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultListenerMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">receive</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 我们不希望自动消息上下文提取 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageConverter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;null</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果上面的<code>'messageListener'</code>收到<code>TextMessage</code>以外的类型的JMS <code>Message</code> ，则<code>IllegalStateException</code> （并随后吞下）。<code>MessageListenerAdapter</code>类的另一个功能是，如果处理程序方法返回非void值，则能够自动发回响应<code>Message</code> 。考虑接口和类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResponsiveTextMessageDelegate</span> { <span class="comment">//注意返回类型...</span>
    <span class="predefined-type">字符串</span>接收（TextMessage消息）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultResponsiveTextMessageDelegate</span> <span class="directive">实现</span> ResponsiveTextMessageDelegate { <span class="comment">//为了清晰起见而省略了实现...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果上面的<code>DefaultResponsiveTextMessageDelegate</code>与<code>MessageListenerAdapter</code>一起使用，那么从执行<code>'receive(..)'</code>方法返回的任何非null值都将（在默认配置中）转换为<code>TextMessage</code> 。然后，生成的<code>TextMessage</code>将发送到原始<code>Message</code>的JMS Reply-To属性中定义的<code>Destination</code> （如果存在），或<code>MessageListenerAdapter</code>上的默认<code>Destination</code>集（如果已配置）;如果没有<code>Destination</code>被发现那么<code>InvalidDestinationException</code>会被抛出（并请注意，此异常<em>不会</em>被吞噬， <em>它将</em>沿着调用堆栈）。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-tx-participation"><a class="anchor" href="#jms-tx-participation"></a> 3.4.5。处理交易中的消息</h4>
<div class="paragraph">
<p>在事务中调用消息侦听器只需要重新配置侦听器容器。</p>
</div>
<div class="paragraph">
<p>可以通过侦听器容器定义上的<code>sessionTransacted</code>标志简单地激活本地资源事务。然后，每个消息侦听器调用将在活动的JMS事务中运行，并在侦听器执行失败的情况下回滚消息。发送响应消息（通过<code>SessionAwareMessageListener</code> ）将是同一本地事务的一部分，但任何其他资源操作（如数据库访问）将独立运行。这通常需要在侦听器实现中检测重复的消息，包括数据库处理已提交但消息处理无法提交的情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jmsContainer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.listener。DefaultMessageListenerContainer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <strong><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionTransacted</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></strong> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要参与外部管理的事务，您需要配置事务管理器并使用支持外部管理事务的侦听器容器：通常为<code>DefaultMessageListenerContainer</code> 。</p>
</div>
<div class="paragraph">
<p>要为XA事务参与配置消息侦听器容器，您需要配置<code>JtaTransactionManager</code> （默认情况下，它委托给Java EE服务器的事务子系统）。请注意，底层JMS ConnectionFactory需要具备XA功能并且已正确注册到JTA事务协调器！（检查Java EE服务器的JNDI资源配置。）这允许消息接收以及例如数据库访问是同一事务的一部分（具有统一提交语义，代价是XA事务日志开销）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">transactionManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.transaction.jta。JtaTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后你只需要将它添加到我们早期的容器配置中。容器将负责其余部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jmsContainer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.listener。DefaultMessageListenerContainer</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <strong><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></strong> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-jca-message-endpoint-manager"><a class="anchor" href="#jms-jca-message-endpoint-manager"></a> 3.5。支持JCA消息端点</h3>
<div class="paragraph">
<p>从版本2.5开始，Spring还提供对基于JCA的<code>MessageListener</code>容器的支持。<code>JmsMessageEndpointManager</code>将尝试从提供程序的<code>ResourceAdapter</code>类名自动确定<code>ActivationSpec</code>类名。因此，通常可以只提供Spring的通用<code>JmsActivationSpecConfig</code> ，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.listener.endpoint。JmsMessageEndpointManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceAdapter</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceAdapter</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">activationSpecConfig</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jms.listener.endpoint。JmsActivationSpecConfig</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destinationName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myQueue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myMessageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用给定的<code>ActivationSpec</code>对象设置<code>JmsMessageEndpointManager</code> 。<code>ActivationSpec</code>对象也可以来自JNDI查找（使用<code>&lt;jee:jndi-lookup&gt;</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.listener.endpoint。JmsMessageEndpointManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceAdapter</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceAdapter</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">activationSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.apache.activemq.ra。ActiveMQActivationSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destination</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myQueue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destinationType</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">javax.jms。队列</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">messageListener</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myMessageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Spring的<code>ResourceAdapterFactoryBean</code> ，可以在本地配置目标<code>ResourceAdapter</code> ，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">resourceAdapter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。ResourceAdapterFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.apache.activemq.ra。ActiveMQResourceAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tcp：// localhost：61616</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">workManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jca。工作。SimpleTaskWorkManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>指定的<code>WorkManager</code>也可以指向特定于环境的线程池 - 通常通过<code>SimpleTaskWorkManager</code>的“asyncTaskExecutor”属性。如果碰巧使用多个适配器，请考虑为所有<code>ResourceAdapter</code>实例定义共享线程池。</p>
</div>
<div class="paragraph">
<p>在某些环境（例如WebLogic 9或更高版本）中，可以从JNDI获取整个<code>ResourceAdapter</code>对象（使用<code>&lt;jee:jndi-lookup&gt;</code> ）。然后，基于Spring的消息侦听器可以使用服务器的内置<code>WorkManager</code>与服务器托管的<code>ResourceAdapter</code>进行交互。</p>
</div>
<div class="paragraph">
<p>请咨询的Javadoc <code>JmsMessageEndpointManager</code> ， <code>JmsActivationSpecConfig</code>和<code>ResourceAdapterFactoryBean</code>更多的细节。</p>
</div>
<div class="paragraph">
<p>Spring还提供了一个通用的JCA消息端点管理器，它不依赖于JMS： <code>org.springframework.jca.endpoint.GenericMessageEndpointManager</code> 。此组件允许使用任何消息侦听器类型（例如，CCI MessageListener）和任何特定于提供程序的ActivationSpec对象。查看您的JCA提供程序的文档以了解连接器的实际功能，并参考<code>GenericMessageEndpointManager</code>的javadoc以获取特定于Spring的配置详细信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基于JCA的消息端点管理非常类似于EJB 2.1消息驱动的Bean;它使用相同的底层资源提供者合同。与EJB 2.1 MDB一样，JCA提供程序支持的任何消息侦听器接口也可以在Spring上下文中使用。然而，Spring为JMS提供了明确的“便利”支持，因为JMS是与JCA端点管理契约一起使用的最常见的端点API。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jms-annotated"><a class="anchor" href="#jms-annotated"></a> 3.6。注释驱动的侦听器端点</h3>
<div class="paragraph">
<p>异步接收消息的最简单方法是使用带注释的侦听器端点基础结构。简而言之，它允许您将托管bean的方法公开为JMS侦听器端点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> { <span class="annotation">@JmsListener</span> （destination = <span class="string"><span class="delimiter">“</span> <span class="content">myDestination</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> processOrder（ <span class="predefined-type">String</span> data）{...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上示例的想法是每当<code>javax.jms.上有消息可用时<code>javax.jms.Destination</code> “myDestination”，相应地调用<code>processOrder</code>方法（在这种情况下，JMS消息的内容类似于<a href="#jms-receiving-async-message-listener-adapter"><code>MessageListenerAdapter</code></a>提供的内容）。</p>
</div>
<div class="paragraph">
<p>带注释的端点基础结构使用<code>JmsListenerContainerFactory</code>为每个带注释的方法在后台创建一个消息侦听器容器。此类容器未针对应用程序上下文进行注册，但可以使用<code>JmsListenerEndpointRegistry</code> bean轻松定位以进行管理。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@JmsListener</code>是Java 8上的<em>可重复</em>注释，因此可以通过<code>@JmsListener</code>添加额外的<code>@JmsListener</code>声明将多个JMS目标关联到同一方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jms-annotated-support"><a class="anchor" href="#jms-annotated-support"></a> 3.6.1。启用侦听器端点注释</h4>
<div class="paragraph">
<p>为了能够支持<code>@JmsListener</code>添加注释<code>@EnableJms</code>到您的一个<code>@Configuration</code>类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableJms</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> DefaultJmsListenerContainerFactory jmsListenerContainerFactory（）{DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory（）; factory.setConnectionFactory（connectionFactory的（））; factory.setDestinationResolver（DestinationResolver的（））; factory.setSessionTransacted（ <span class="predefined-constant">true</span> ）; factory.setConcurrency（ <span class="string"><span class="delimiter">“</span> <span class="content">3-10</span> <span class="delimiter">”</span></span> ）; <span class="keyword">返回</span>工厂; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，基础结构会查找名为<code>jmsListenerContainerFactory</code>的bean作为工厂用于创建消息侦听器容器的源。在这种情况下，忽略JMS基础结构设置，可以使用3个线程的核心轮询大小和10个线程的最大池大小来调用<code>processOrder</code>方法。</p>
</div>
<div class="paragraph">
<p>可以自定义侦听器容器工厂以使用每个注释，也可以通过实现<code>JmsListenerConfigurer</code>接口来配置显式默认值。只有在没有特定容器工厂的情况下注册了至少一个端点时，才需要默认值。有关完整的详细信息和示例，请参阅javadoc。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢<a href="#jms-namespace">XML配置，请</a>使用<code>&lt;jms:annotation-driven&gt;</code>元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jms：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jmsListenerContainerFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jms.config。DefaultJmsListenerContainerFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destinationResolver</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">destinationResolver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionTransacted</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">并发</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">3-10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-programmatic-registration"><a class="anchor" href="#jms-annotated-programmatic-registration"></a> 3.6.2。程序化端点注册</h4>
<div class="paragraph">
<p><code>JmsListenerEndpoint</code>提供JMS端点的模型，并负责为该模型配置容器。除了<code>JmsListener</code>注释检测到的端点之外，基础结构还允许您以编程方式配置端点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableJms</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">的AppConfig</span> <span class="directive">实现</span> JmsListenerConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureJmsListeners（注册商JmsListenerEndpointRegistrar）{SimpleJmsListenerEndpoint端点= <span class="keyword">新</span> SimpleJmsListenerEndpoint（）; endpoint.setId（ <span class="string"><span class="delimiter">“</span> <span class="content">myJmsEndpoint</span> <span class="delimiter">”</span></span> ）; endpoint.setDestination（ <span class="string"><span class="delimiter">“</span> <span class="content">anotherQueue</span> <span class="delimiter">”</span></span> ）; endpoint.setMessageListener（message  - &gt; { <span class="comment">// processing</span> }）; registrar.registerEndpoint（端点）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用了<code>SimpleJmsListenerEndpoint</code> ，它提供了要调用的实际<code>MessageListener</code> ，但您也可以构建自己的端点变量来描述自定义调用机制。</p>
</div>
<div class="paragraph">
<p>应该注意的是，你也可以完全跳过<code>@JmsListener</code>的使用，只能通过<code>JmsListenerConfigurer</code>编程方式注册你的端点。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-method-signature"><a class="anchor" href="#jms-annotated-method-signature"></a> 3.6.3。带注释的端点方法签名</h4>
<div class="paragraph">
<p>到目前为止，我们一直在端点中注入一个简单的<code>String</code> ，但它实际上可以有一个非常灵活的方法签名。让我们重写它以使用自定义标头注入<code>Order</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> { <span class="annotation">@JmsListener</span> （destination = <span class="string"><span class="delimiter">“</span> <span class="content">myDestination</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> processOrder（Order order， <span class="annotation">@ Header</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">order_type</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> orderType）{...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些是您可以在JMS侦听器端点中注入的主要元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>原始的<code>javax.jms.Message</code>或其任何子类（当然，它提供与传入消息类型匹配）。</p>
</li>
<li>
<p><code>javax.jms.用于可选访问本机JMS API的Session</code> ，例如用于发送自定义回复。</p>
</li>
<li>
<p><code>org.springframework.messaging.Message</code>表示传入的JMS消息。请注意，此消息包含自定义标头和标准标头（由<code>JmsHeaders</code>定义）。</p>
</li>
<li>
<p><code>@Header</code> -annotated方法参数，用于提取特定的标头值，包括标准JMS标头。</p>
</li>
<li>
<p><code>@Headers</code> -annotated参数，也必须可以赋值给<code>java.util.用于访问所有标头的Map</code> 。</p>
</li>
<li>
<p>不是受支持类型之一（即<code>Message</code>和<code>Session</code> ）的非注释元素被认为是有效载荷。您可以通过使用<code>@Payload</code>注释参数来使其明确。您还可以通过添加额外的<code>@Valid</code>来启用验证。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>注入Spring的<code>Message</code>抽象的能力对于从特定于传输的消息中存储的所有信息中受益特别有用，而不依赖于特定于传​​输的API。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@JmsListener</span> （destination = <span class="string"><span class="delimiter">“</span> <span class="content">myDestination</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> processOrder（Message &lt;Order&gt; order）{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultMessageHandlerMethodFactory</code>提供了方法参数的处理，可以进一步自定义它以支持其他方法参数。转换和验证支持也可以在那里定制。</p>
</div>
<div class="paragraph">
<p>例如，如果我们想在处理<code>Order</code>之前确保<code>Order</code>有效，我们可以使用<code>@Valid</code>注释有效负载并按如下方式配置必要的验证器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableJms</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">的AppConfig</span> <span class="directive">实现</span> JmsListenerConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureJmsListeners（注册商JmsListenerEndpointRegistrar）{registrar.setMessageHandlerMethodFactory（myJmsHandlerMethodFactory（））; } <span class="annotation">@Bean</span> <span class="directive">public</span> DefaultMessageHandlerMethodFactory myHandlerMethodFactory（）{DefaultMessageHandlerMethodFactory factory = <span class="keyword">new</span> DefaultMessageHandlerMethodFactory（）; factory.setValidator（myValidator（））; <span class="keyword">返回</span>工厂; }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-response"><a class="anchor" href="#jms-annotated-response"></a> 3.6.4。响应管理</h4>
<div class="paragraph">
<p><a href="#jms-receiving-async-message-listener-adapter">MessageListenerAdapter中</a>的现有支持已经允许您的方法具有非<code>void</code>返回类型。在这种情况下，调用的结果封装在<code>javax.jms.Message</code>在原始消息的<code>JMSReplyTo</code>标头中指定的目标中或在侦听器上配置的默认目标中发送。现在可以使用消息传递抽象的<code>@SendTo</code>注释来设置该默认目标。</p>
</div>
<div class="paragraph">
<p>假设我们的<code>processOrder</code>方法现在应该返回<code>OrderStatus</code> ，可以按如下方式编写它以自动发送响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@JmsListener</span> （destination = <span class="string"><span class="delimiter">“</span> <span class="content">myDestination</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ SendTo</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">status</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> OrderStatus processOrder（Order order）{ <span class="comment">//订单处理</span> <span class="keyword">返回</span>状态; }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您有几个<code>@JmsListener</code> -annotated方法，您还可以在类级别放置<code>@SendTo</code>注释以共享默认回复目标。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您需要以与传输无关的方式设置其他标头，则可以返回<code>Message</code> ，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@JmsListener</span> （destination = <span class="string"><span class="delimiter">“</span> <span class="content">myDestination</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ SendTo</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">status</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Message &lt;OrderStatus&gt; processOrder（Order order）{ <span class="comment">//订单处理</span> <span class="keyword">返回</span> MessageBuilder .withPayload（status）.setHeader（ <span class="string"><span class="delimiter">“</span> <span class="content">code</span> <span class="delimiter">”</span></span> ， <span class="integer">1234</span> ）.build（ ）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要在运行时计算响应目标，则可以将响应封装在<code>JmsResponse</code>实例中，该实例还提供在运行时使用的目标。前面的示例可以重写如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@JmsListener</span> （destination = <span class="string"><span class="delimiter">“</span> <span class="content">myDestination</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> JmsResponse &lt;Message &lt;OrderStatus &gt;&gt; processOrder（Order order）{ <span class="comment">//订单处理</span>消息&lt;OrderStatus&gt; response = MessageBuilder .withPayload（status）.setHeader（ <span class="string"><span class="delimiter">“</span> <span class="content">code</span> <span class="delimiter">”</span></span> ， <span class="integer">1234</span> ）.build （）; <span class="keyword">返回</span> JmsResponse.forQueue（响应， <span class="string"><span class="delimiter">“</span> <span class="content">状态</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果您需要为响应指定一些QoS值（例如优先级或生存时间），则可以相应地配置<code>JmsListenerContainerFactory</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableJms</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> DefaultJmsListenerContainerFactory jmsListenerContainerFactory（）{DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory（）; factory.setConnectionFactory（connectionFactory的（））; QosSettings replyQosSettings = <span class="keyword">new</span> QosSettings（）; replyQosSettings.setPriority（ <span class="integer">2</span> ）; replyQosSettings.setTimeToLive（ <span class="integer">10000</span> ）; factory.setReplyQosSettings（replyQosSettings）; <span class="keyword">返回</span>工厂; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-namespace"><a class="anchor" href="#jms-namespace"></a> 3.7。JMS命名空间支持</h3>
<div class="paragraph">
<p>Spring提供了一个XML命名空间，用于简化JMS配置。要使用JMS名称空间元素，您需要引用JMS模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="error"><strong></strong></span> <span class="error"></span> <span class="attribute-name">xmlns：jms</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/jms</span> <span class="delimiter">”</span></span> <span class="error"><strong></strong></span> <span class="error"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><strong>http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd</strong></span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>命名空间由三个顶级元素组成： <code>&lt;annotation-driven/&gt;</code> ， <code>&lt;listener-container/&gt;</code>和<code>&lt;jca-listener-container/&gt;</code> 。 <code>&lt;annotation-driven</code>允许使用<a href="#jms-annotated">注释驱动的侦听器端点</a> 。 <code>&lt;listener-container/&gt;</code>和<code>&lt;jca-listener-container/&gt;</code>定义共享侦听器容器配置，可能包含<code>&lt;listener/&gt;</code>子元素。以下是两个侦听器的基本配置示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jms：listener-container&gt;</span> <span class="tag">&lt;jms：listener</span> <span class="attribute-name">destination</span> = <span class="string"><span class="delimiter">“</span> <span class="content">queue.orders</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">orderService</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">placeOrder</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jms：listener</span> <span class="attribute-name">destination</span> = <span class="string"><span class="delimiter">“</span> <span class="content">queue.confirmations</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">confirmationLogger</span> <span class="delimiter">”</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">log</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jms：listener-container&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例等同于创建两个不同的侦听器容器bean定义和两个不同的<code>MessageListenerAdapter</code> bean定义，如<a href="#jms-receiving-async-message-listener-adapter">MessageListenerAdapter中所示</a> 。除了上面显示的属性之外， <code>listener</code>元素还可以包含几个可选的属性。下表描述了所有可用属性：</p>
</div>
<table id="jms-namespace-listener-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表3。JMS &lt;listener&gt;元素的属性</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">托管侦听器容器的Bean名称。如果未指定，将自动生成bean名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目的地<em>（必填）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的目标名称，通过<code>DestinationResolver</code>策略解析。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ref <em>（必填）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理程序对象的bean名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要调用的处理程序方法的名称。如果<code>ref</code>指向<code>MessageListener</code>或Spring <code>SessionAwareMessageListener</code> ，则可以省略此属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应目的地</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要向其发送响应消息的默认响应目标的名称。这将在请求消息未携带“JMSReplyTo”字段的情况下应用。此目标的类型将由侦听器容器的“response-destination-type”属性确定。注意：这仅适用于具有返回值的侦听器方法，每个结果对象都将转换为响应消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">订阅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">持久订阅的名称（如果有）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的可选消息选择器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">并发</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要为此侦听器启动的并发会话/使用者数。可以是指示最大数量的简单数字（例如“5”）或指示下限和上限的范围（例如“3-5”）。请注意，指定的最小值只是一个提示，可能会在运行时被忽略。默认值是容器提供的值</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>&lt;listener-container/&gt;</code>元素也接受几个可选属性。这允许自定义各种策略（例如， <code>taskExecutor</code>和<code>destinationResolver</code> ）以及基本JMS设置和资源引用。使用这些属性，可以定义高度自定义的侦听器容器，同时仍然可以从命名空间的便利性中受益。</p>
</div>
<div class="paragraph">
<p>通过指定要通过<code>factory-id</code>属性公开的bean的id，可以将这些设置自动公开为<code>JmsListenerContainerFactory</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jms：listener-container</span> <span class="attribute-name">connection-factory</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">task-executor</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myTaskExecutor</span> <span class="delimiter">”</span></span> <span class="attribute-name">destination-resolver</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDestinationResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">transaction-manager</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myTransactionManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">concurrency</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jms：listener</span> <span class="attribute-name">destination</span> = <span class="string"><span class="delimiter">“</span> <span class="content">queue.orders</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">orderService</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">placeOrder</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jms：listener</span> <span class="attribute-name">destination</span> = <span class="string"><span class="delimiter">”</span> <span class="content">queue.confirmations</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">confirmationLogger</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">log</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jms：listener-container&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了所有可用属性。有关各个属性的更多详细信息，请参阅<code>AbstractMessageListenerContainer</code>的类级别javadoc及其具体子类。javadoc还提供了有关事务选择和消息重新传递方案的讨论。</p>
</div>
<table id="jms-namespace-listener-container-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表4。JMS &lt;listener-container&gt;元素的属性</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">容器型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器容器的类型。可用选项包括： <code>default</code> ， <code>simple</code> ， <code>default102</code>或<code>simple102</code> （默认值为<code>'default'</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">容器类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自定义侦听器容器实现类作为完全限定的类名。根据“container-type”属性，默认为Spring的标准<code>DefaultMessageListenerContainer</code>或<code>SimpleMessageListenerContainer</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">出厂编号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将此元素定义的设置公开为具有指定标识的<code>JmsListenerContainerFactory</code> ，以便它们可以与其他端点一起使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接工厂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对JMS <code>ConnectionFactory</code> bean的引用（默认bean名称为<code>'connectionFactory'</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任务执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对JMS侦听器调用者的Spring <code>TaskExecutor</code>引用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目的地解析</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对<code>DestinationResolver</code>策略的引用，用于解析JMS <code>Destinations</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">消息转换器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对用于将JMS消息转换为侦听器方法参数的<code>MessageConverter</code>策略的引用。默认值是<code>SimpleMessageConverter</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误处理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对<code>ErrorHandler</code>策略的引用，用于处理在执行<code>MessageListener</code>期间可能发生的任何未捕获的异常。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目的地类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的JMS目标类型： <code>queue</code> ， <code>topic</code> ， <code>durableTopic</code> ， <code>sharedTopic</code>或<code>sharedDurableTopic</code> 。这可能会<code>pubSubDomain</code>容器的<code>pubSubDomain</code> ， <code>subscriptionDurable</code>和<code>subscriptionShared</code>属性。默认为<code>queue</code> （即禁用这3个属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应目的地型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的JMS目标类型：“queue”，“topic”。默认值是“destination-type”属性的值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">客户端ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器容器的JMS客户端ID。使用持久订阅时需要指定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">高速缓存</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JMS资源的缓存级别： <code>none</code> ， <code>connection</code> ， <code>session</code> ， <code>consumer</code>或<code>auto</code> 。默认情况下（ <code>auto</code> ），缓存级别实际上将是“使用者”，除非指定了外部事务管理器 - 在这种情况下，有效默认值为<code>none</code> （假设Java EE样式的事务管理，其中给定的ConnectionFactory是XA-意识到池）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">确认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本机JMS确认模式： <code>auto</code> ， <code>client</code> ， <code>dups-ok</code>或<code>transacted</code> 。<code>transacted</code>价值激活本地交易的<code>Session</code> 。或者，指定下面描述的<code>transaction-manager</code>属性。默认为<code>auto</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">交易经理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对外部<code>PlatformTransactionManager</code>引用（通常是基于XA的事务协调器，例如Spring的<code>JtaTransactionManager</code> ）。如果未指定，将使用本机确认（请参阅“确认”属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">并发</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为每个侦听器启动的并发会话/使用者数。可以是指示最大数量的简单数字（例如“5”）或指示下限和上限的范围（例如“3-5”）。请注意，指定的最小值只是一个提示，可能会在运行时被忽略。默认值为1;在主题监听器或队列排序很重要的情况下，将并发性限制为1;考虑将其提升为一般队列。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">预取</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要加载到单个会话中的最大消息数。请注意，提高此数字可能会导致并发消费者的饥饿！</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">接收超时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于接收呼叫的超时（以毫秒为单位）。默认值为<code>1000</code>毫秒（1秒）; <code>-1</code>表示根本没有超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">回退</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定<code>BackOff</code>实例以用于计算恢复尝试之间的间隔。如果<code>BackOffExecution</code>实现返回<code>BackOffExecution#STOP</code> ，则侦听器容器将不再进一步尝试恢复。设置此属性时，将忽略<code>recovery-interval</code>值。默认值为<code>FixedBackOff</code> ，间隔为5000毫秒，即5秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">恢复间隔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定恢复尝试之间的间隔（以毫秒为单位）。以指定间隔创建<code>FixedBackOff</code>便捷方式。有关更多恢复选项，请考虑指定BackOff实例。默认值为5000毫秒，即5秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">相</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此容器应开始和停止的生命周期阶段。此容器越早开始的值越低，它将停止越晚。默认值为<code>Integer.MAX_VALUE</code>表示容器将尽可能晚地启动并尽快停止。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用“jms”模式支持配置基于JCA的侦听器容器非常相似。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jms：jca-listener-container</span> <span class="attribute-name">resource-adapter</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myResourceAdapter</span> <span class="delimiter">”</span></span> <span class="attribute-name">destination-resolver</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDestinationResolver</span> <span class="delimiter">”</span></span> <span class="attribute-name">transaction-manager</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myTransactionManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">concurrency</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jms：listener</span> <span class="attribute-name">destination</span> = <span class="string"><span class="delimiter">“</span> <span class="content">queue.orders</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myMessageListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jms：jca-listener-container&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了JCA变体的可用配置选项：</p>
</div>
<table id="jms-namespace-jca-listener-container-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表5。JMS &lt;jca-listener-container /&gt;元素的属性</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">出厂编号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将此元素定义的设置公开为具有指定标识的<code>JmsListenerContainerFactory</code> ，以便它们可以与其他端点一起使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">资源适配器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对JCA <code>ResourceAdapter</code> bean的引用（默认bean名称为<code>'resourceAdapter'</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">激活规范工厂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对<code>JmsActivationSpecFactory</code>的引用。默认是自动检测JMS提供程序及其<code>ActivationSpec</code>类（请参阅<code>DefaultJmsActivationSpecFactory</code> ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目的地解析</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对<code>DestinationResolver</code>策略的引用，用于解析JMS <code>Destinations</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">消息转换器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对用于将JMS消息转换为侦听器方法参数的<code>MessageConverter</code>策略的引用。默认值是<code>SimpleMessageConverter</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目的地类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的JMS目标类型： <code>queue</code> ， <code>topic</code> ， <code>durableTopic</code> ， <code>sharedTopic</code>或<code>sharedDurableTopic</code> 。这可能会<code>pubSubDomain</code>容器的<code>pubSubDomain</code> ， <code>subscriptionDurable</code>和<code>subscriptionShared</code>属性。默认为<code>queue</code> （即禁用这3个属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应目的地型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的JMS目标类型：“queue”，“topic”。默认值是“destination-type”属性的值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">客户端ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器容器的JMS客户端ID。使用持久订阅时需要指定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">确认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本机JMS确认模式： <code>auto</code> ， <code>client</code> ， <code>dups-ok</code>或<code>transacted</code> 。<code>transacted</code>价值激活本地交易的<code>Session</code> 。或者，指定下面描述的<code>transaction-manager</code>属性。默认为<code>auto</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">交易经理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对Spring <code>JtaTransactionManager</code>或<code>javax.transaction.引用<code>javax.transaction.TransactionManager</code>用于为每个传入消息启动XA事务。如果未指定，将使用本机确认（请参阅“确认”属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">并发</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为每个侦听器启动的并发会话/使用者数。可以是指示最大数量的简单数字（例如“5”）或指示下限和上限的范围（例如“3-5”）。请注意，指定的最小值只是一个提示，并且在使用JCA侦听器容器时通常会在运行时被忽略。默认值为1。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">预取</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要加载到单个会话中的最大消息数。请注意，提高此数字可能会导致并发消费者的饥饿！</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jmx"><a class="anchor" href="#jmx"></a> 4。JMX</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jmx-introduction"><a class="anchor" href="#jmx-introduction"></a> 4.1。介绍</h3>
<div class="paragraph">
<p>Spring中的JMX支持为您提供了将Spring应用程序轻松透明地集成到JMX基础结构中的功能。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">JMX？</div>
<div class="paragraph">
<p>本章不是对JMX的介绍......它并不试图解释为什么人们可能想要使用JMX（或者实际上JMX实际上代表的是什么）的动机。如果您是JMX的新手，请查看本章末尾的<a href="#jmx-resources">更多资源</a> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>具体来说，Spring的JMX支持提供了四个核心功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将<em>任何</em> Spring bean自动注册为JMX MBean</p>
</li>
<li>
<p>一种灵活的机制，用于控制bean的管理界面</p>
</li>
<li>
<p>MBean通过远程JSR-160连接器的声明性暴露</p>
</li>
<li>
<p>本地和远程MBean资源的简单代理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些功能旨在在不将应用程序组件耦合到Spring或JMX接口和类的情况下工作。实际上，在大多数情况下，为了利用Spring JMX功能，您的应用程序类无需了解Spring或JMX。</p>
</div>
</div>
<div class="sect2">
<h3 id="jmx-exporting"><a class="anchor" href="#jmx-exporting"></a> 4.2。将bean导出到JMX</h3>
<div class="paragraph">
<p>Spring的JMX框架中的核心类是<code>MBeanExporter</code> 。该类负责获取Spring bean并使用JMX <code>MBeanServer</code>注册它们。例如，请考虑以下类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.jmx</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">JmxTestBean</span> <span class="directive">实现</span> IJmxTestBean { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="type">诠释</span>年龄; <span class="directive">private</span> <span class="type">boolean</span> isSuperman; <span class="directive">public</span> <span class="type">int</span> getAge（）{ <span class="keyword">return</span> age; <span class="directive">public</span> <span class="type">void</span> setAge（ <span class="type">int</span> age）{ <span class="local-variable">this</span> .age = age; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> name; <span class="directive">public</span> <span class="type">int</span> add（ <span class="type">int</span> x， <span class="type">int</span> y）{ <span class="keyword">return</span> x + y; <span class="directive">public</span> <span class="type">void</span> dontExposeMe（）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span> （）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将此bean的属性和方法公开为MBean的属性和操作，只需在配置文件中配置<code>MBeanExporter</code>类的实例，并传入bean，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 如果要进行导出，则不得懒惰地初始化此bean  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="attribute-name">lazy-init</span> = <span class="string"><span class="delimiter">”</span> <span class="content">false</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt; / bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的配置代码段中的相关bean定义是<code>exporter</code> bean。<code>beans</code>属性告诉<code>MBeanExporter</code>您的哪些bean必须准确地导出到JMX <code>MBeanServer</code> 。在默认配置中， <code>beans</code> <code>Map</code>中每个条目的键用作相应条目值引用的bean的<code>ObjectName</code> 。可以按照<a href="#jmx-naming">控制Bean的ObjectName中的</a>描述更改此行为。</p>
</div>
<div class="paragraph">
<p>使用此配置， <code>testBean</code> bean在<code>ObjectName</code> <code>bean:name=testBean1</code>下公开为MBean <code>bean:name=testBean1</code> 。默认情况下，bean的所有<em>公共</em>属性都作为属性<em>公开</em> ，所有<em>公共</em>方法（从<code>Object</code>类继承的那些<em>公共</em>方法）都作为操作公开。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>MBeanExporter</code>是一个<code>Lifecycle</code> bean（请参阅<a href="core.html#beans-factory-lifecycle-processor">启动和关闭回调</a> ），默认情况下，MBean在应用程序生命周期中尽可能晚地导出。可以通过设置<code>autoStartup</code>标志来配置导出发生的<code>phase</code>或禁用自动注册。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jmx-exporting-mbeanserver"><a class="anchor" href="#jmx-exporting-mbeanserver"></a> 4.2.1。创建MBeanServer</h4>
<div class="paragraph">
<p>上面的配置假定应用程序在一个（并且只有一个） <code>MBeanServer</code>已经运行的环境中运行。在这种情况下，Spring将尝试找到正在运行的<code>MBeanServer</code>并向该服​​务器注册您的bean（如果有的话）。当您的应用程序在具有自己的<code>MBeanServer</code> Tomcat或IBM WebSphere等容器内运行时，此行为很有用。</p>
</div>
<div class="paragraph">
<p>但是，此方法在独立环境中或在不提供<code>MBeanServer</code>的容器内运行时没有用处。要解决此问题，您可以通过添加<code>org.springframework.jmx.support.的实例以声明方式创建<code>MBeanServer</code>实例<code>org.springframework.jmx.support.您的配置的MBeanServerFactoryBean</code>类。您也可以确保特定<code>MBeanServer</code>使用通过设定的值<code>MBeanExporter</code>的<code>server</code>属性设置<code>MBeanServer</code>通过返回的值<code>MBeanServerFactoryBean</code> ;例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mbeanServer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。MBeanServerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 这个bean需要急切预先实例化才能进行导出;这意味着它不能被标记为懒惰初始化 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">exporter</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org .springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">server</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mbeanServer</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的一个实例<code>MBeanServer</code>由创建<code>MBeanServerFactoryBean</code>和被提供给<code>MBeanExporter</code>经由服务器属性。当您提供自己的<code>MBeanServer</code>实例时， <code>MBeanExporter</code>将不会尝试查找正在运行的<code>MBeanServer</code> ，并将使用提供的<code>MBeanServer</code>实例。为了使其正常工作，您必须（当然）在类路径上有一个JMX实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-mbean-server"><a class="anchor" href="#jmx-mbean-server"></a> 4.2.2。重用现有的MBeanServer</h4>
<div class="paragraph">
<p>如果未指定服务器，则<code>MBeanExporter</code>尝试自动检测正在运行的<code>MBeanServer</code> 。这适用于大多数只使用一个<code>MBeanServer</code>实例的环境，但是当存在多个实例时，导出器可能会选择错误的服务器。在这种情况下，应该使用<code>MBeanServer</code> <code>agentId</code>来指示要使用的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mbeanServer</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。MBeanServerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 表示首先查找服务器 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">locateExistingServerIfPossible</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 使用给定的agentId搜索MBeanServer实例 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">agentId</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">MBeanServer_instance_agentId</span></span> <span class="error">&gt;</span> ”/ <span class="error">&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">server</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mbeanServer</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> ...
    <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于现有<code>MBeanServer</code>具有通过查找方法检索的动态（或未知） <code>agentId</code>平台/情况，应使用<a href="core.html#beans-factory-class-static-factory-method">factory-method</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">server</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 自定义MBeanServerLocator  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">platform.package。MBeanServerLocator</span> <span class="delimiter">“</span></span> <span class="attribute-name">factory-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">locateMBeanServer</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 其他bean在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-lazy"><a class="anchor" href="#jmx-exporting-lazy"></a> 4.2.3。延迟初始化的MBean</h4>
<div class="paragraph">
<p>如果使用也配置为延迟初始化的<code>MBeanExporter</code>配置bean，那么<code>MBeanExporter</code>将<em>不会</em>破坏此合同并且将避免实例化bean。相反，它将向<code>MBeanServer</code>注册一个代理，并将推迟从容器中获取bean，直到代理上的第一次调用发生。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-auto"><a class="anchor" href="#jmx-exporting-auto"></a> 4.2.4。自动注册MBean</h4>
<div class="paragraph">
<p>通过<code>MBeanExporter</code>导出并且已经是有效MBean的任何bean都将按原样注册到<code>MBeanServer</code>而无需Spring的进一步干预。的MBean可以通过自动检测<code>MBeanExporter</code>通过设置<code>autodetect</code>属性为<code>true</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">autodetect</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">spring：mbean = true</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx.export。TestDynamicMBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，名为<code>spring:mbean=true</code>的bean已经是一个有效的JMX MBean，将由Spring自动注册。默认情况下，为JMX注册自动检测的bean将其bean名称用作<code>ObjectName</code> 。可以按照<a href="#jmx-naming">控制Bean的ObjectName中</a>详细说明此行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-registration-behavior"><a class="anchor" href="#jmx-exporting-registration-behavior"></a> 4.2.5。控制注册行为</h4>
<div class="paragraph">
<p>考虑Spring <code>MBeanExporter</code>尝试使用<code>ObjectName</code> <code>'bean:name=testBean1'</code>向<code>MBeanServer</code>注册<code>MBean</code>的场景。如果<code>MBean</code>实例已在同一<code>ObjectName</code>下注册，则默认行为将失败（并抛出<code>InstanceAlreadyExistsException</code> ）。</p>
</div>
<div class="paragraph">
<p>可以控制<code>MBean</code>在<code>MBeanServer</code>注册时发生的确切行为。当注册进程发现<code>MBean</code>已经在同一个<code>ObjectName</code>下注册时，Spring的JMX支持允许三种不同的注册行为来控制注册行为。这些注册行为总结在下表中：</p>
</div>
<table id="jmx-registration-behaviors" class="tableblock frame-all grid-all spread">
<caption class="title">表6。注册行为</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注册行为</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGISTRATION_FAIL_ON_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是默认的注册行为。如果<code>MBean</code>实例已在同一<code>ObjectName</code>下注册，则将不会注册正在注册的<code>MBean</code> ，并且将抛出<code>InstanceAlreadyExistsException</code> 。现有<code>MBean</code>不受影响。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGISTRATION_IGNORE_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果<code>MBean</code>实例已在同一<code>ObjectName</code>下注册，则<em>不会</em>注册正在注册的<code>MBean</code> 。现有<code>MBean</code>不受影响，并没有<code>Exception</code>将被抛出。这在多个应用程序想要在共享<code>MBeanServer</code>中共享公共<code>MBean</code>设置中很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGISTRATION_REPLACE_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果<code>MBean</code>实例已在同一<code>ObjectName</code>下注册，则先前注册的现有<code>MBean</code>将被取消注册，新<code>MBean</code>将在其位置注册（新<code>MBean</code>有效替换先前的实例）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以上值在<code>MBeanRegistrationSupport</code>类中定义为常量（ <code>MBeanExporter</code>类派生<code>MBeanExporter</code>超类）。如果要更改默认注册行为，只需将<code>MBeanExporter</code>定义上的<code>registrationBehaviorName</code>属性的值设置为其中一个值。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何实现从默认注册行为到<code>REGISTRATION_REPLACE_EXISTING</code>行为的更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">registrationBehaviorName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">REGISTRATION_REPLACE_EXISTING</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-interface"><a class="anchor" href="#jmx-interface"></a> 4.3。控制bean的管理界面</h3>
<div class="paragraph">
<p>在前面的示例中，您几乎无法控制bean的管理接口;每个导出bean的<em>所有</em> <em>公共</em>属性和方法分别作为JMX属性和操作公开。为了精确控制导出的bean的哪些属性和方法实际上作为JMX属性和操作公开，Spring JMX提供了一个全面且可扩展的机制来控制bean的管理接口。</p>
</div>
<div class="sect3">
<h4 id="jmx-interface-assembler"><a class="anchor" href="#jmx-interface-assembler"></a> 4.3.1。MBeanInfoAssembler接口</h4>
<div class="paragraph">
<p>在幕后， <code>MBeanExporter</code>委托给<code>org.springframework.jmx.export.assembler.MBeanInfoAssembler</code>接口，负责定义正在公开的每个bean的管理接口。默认实现<code>org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</code> ，只是定义了一个公开所有公共属性和方法的管理接口（如前面的例子所示）。Spring提供了<code>MBeanInfoAssembler</code>接口的另外两个实现，允许您使用源级元数据或任意接口控制生成的管理接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-metadata"><a class="anchor" href="#jmx-interface-metadata"></a> 4.3.2。使用源级元数据：Java注释</h4>
<div class="paragraph">
<p>使用<code>MetadataMBeanInfoAssembler</code>您可以使用源级元数据为Bean定义管理接口。元数据的读取由<code>org.springframework.jmx.export.metadata.封装<code>org.springframework.jmx.export.metadata.JmxAttributeSource</code>接口。Spring JMX提供了一个使用Java注释的默认实现，即<code>org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</code> 。<em>必须</em>使用<code>JmxAttributeSource</code>接口的实现实例配置<code>MetadataMBeanInfoAssembler</code> <em>才能</em>使其正常运行（ <em>没有</em>默认值）。</p>
</div>
<div class="paragraph">
<p>要标记要导出到JMX的bean，应使用<code>ManagedResource</code>批注对bean类进行批注。您希望作为操作公开的每个方法都必须使用<code>ManagedOperation</code>注释进行标记，并且您要公开的每个属性都必须使用<code>ManagedAttribute</code>注释进行标记。标记属性时，可以省略getter或setter的注释，以分别创建只写或只读属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>ManagedResource</code>注释bean必须是公共的，以及公开操作或属性的方法。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的示例显示了您<code>JmxTestBean</code>看到的<code>JmxTestBean</code>类的带注释版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.jmx</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jmx.export.annotation。ManagedResource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jmx.export.annotation。ManagedOperation</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jmx.export.annotation。ManagedAttribute</span> ; <span class="annotation">@ManagedResource</span> （objectName = <span class="string"><span class="delimiter">“</span> <span class="content">bean：name = testBean4</span> <span class="delimiter">”</span></span> ，description = <span class="string"><span class="delimiter">“</span> <span class="content">My Managed Bean</span> <span class="delimiter">”</span></span> ，log = <span class="predefined-constant">true</span> ，logFile = <span class="string"><span class="delimiter">“</span> <span class="content">jmx.log</span> <span class="delimiter">”</span></span> ，currencyTimeLimit = <span class="integer">15</span> ，persistPolicy = <span class="string"><span class="delimiter">“</span> <span class="content">OnUpdate</span> <span class="delimiter">”</span></span> ，persistPeriod = <span class="integer">200</span> ，persistLocation = <span class="string"><span class="delimiter">“</span> <span class="content">foo</span> <span class="delimiter">“</span></span> ，persistName = <span class="string"><span class="delimiter">”</span> <span class="content">bar</span> <span class="delimiter">“</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AnnotationTestBean</span> <span class="directive">实现</span> IJmxTestBean { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="type">诠释</span>年龄; <span class="annotation">@ManagedAttribute</span> （description = <span class="string"><span class="delimiter">“</span> <span class="content">Age Attribute</span> <span class="delimiter">”</span></span> ，currencyTimeLimit = <span class="integer">15</span> ） <span class="directive">public</span> <span class="type">int</span> getAge（）{ <span class="keyword">return</span> age; <span class="directive">public</span> <span class="type">void</span> setAge（ <span class="type">int</span> age）{ <span class="local-variable">this</span> .age = age; } <span class="annotation">@ManagedAttribute</span> （description = <span class="string"><span class="delimiter">“</span> <span class="content">The Name Attribute</span> <span class="delimiter">”</span></span> ，currencyTimeLimit = <span class="integer">20</span> ，defaultValue = <span class="string"><span class="delimiter">“</span> <span class="content">bar</span> <span class="delimiter">”</span></span> ，persistPolicy = <span class="string"><span class="delimiter">“</span> <span class="content">OnUpdate</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .name = name; } <span class="annotation">@ManagedAttribute</span> （defaultValue = <span class="string"><span class="delimiter">“</span> <span class="content">foo</span> <span class="delimiter">”</span></span> ，persistPeriod = <span class="integer">300</span> ） <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> name; } <span class="annotation">@ManagedOperation</span> （description = <span class="string"><span class="delimiter">“</span> <span class="content">添加两个数字</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ManagedOperationParameters</span> （{@ <span class="annotation">ManagedOperationParameter</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">x</span> <span class="delimiter">”</span></span> ，description = <span class="string"><span class="delimiter">“</span> <span class="content">第一个数字</span> <span class="delimiter">”</span></span> ），@ <span class="annotation">ManvenOperationParameter</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">y</span> <span class="delimiter">”</span></span> ，description = <span class="string"><span class="delimiter">“</span> <span class="content">第二个数字</span> <span class="delimiter">”）</span></span> ）}） <span class="directive">public</span> <span class="type">int</span> add（ <span class="type">int</span> x， <span class="type">int</span> y）{ <span class="keyword">return</span> x + y; <span class="directive">public</span> <span class="type">void</span> dontExposeMe（）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span> （）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以看到<code>JmxTestBean</code>类使用<code>ManagedResource</code>注释进行标记，并且此<code>ManagedResource</code>注释使用一组属性进行配置。这些属性可用于配置<code>MBeanExporter</code>生成的MBean的各个方面，稍后将在标题为<a href="#jmx-interface-metadata-types">源级元数据类型的</a>部分中进行更详细的说明。</p>
</div>
<div class="paragraph">
<p>您还会注意到<code>age</code>和<code>name</code>属性都使用<code>ManagedAttribute</code>注释进行注释，但在<code>age</code>属性的情况下，只标记了getter。这将导致这两个属性作为属性包含在管理界面中，但<code>age</code>属性将是只读的。</p>
</div>
<div class="paragraph">
<p>最后，你会发现，在<code>add(int, int)</code>方法被打上<code>ManagedOperation</code>属性而<code>dontExposeMe()</code>方法是没有的。这将导致管理接口在使用<code>MetadataMBeanInfoAssembler</code>时仅包含一个操作<code>add(int, int)</code> 。</p>
</div>
<div class="paragraph">
<p>下面的配置显示了如何配置<code>MBeanExporter</code>以使用<code>MetadataMBeanInfoAssembler</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。的MBeanExporter</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">汇编</span> <span class="delimiter"><span class="attribute-name">“REF</span></span></span> <span class="string"><span class="delimiter">=”</span> <span class="content">汇编</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">namingStrategy</span> <span class="delimiter"><span class="attribute-name">“REF</span></span></span> <span class="string"><span class="delimiter">=”</span> <span class="content">namingStrategy</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">自动检测</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=”</span> <span class="content">真</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;/豆&gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jmxAttributeSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export.annotation。AnnotationJmxAttributeSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 将使用注释元数据创建管理接口 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">assembler</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx.export.assembler。MetadataMBeanInfoAssembler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">attributeSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jmxAttributeSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 将从注释中选取ObjectName  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework。 jmx.export.naming。MetadataNamingStrategy</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">attributeSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jmxAttributeSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx。AnnotationTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以看到<code>MetadataMBeanInfoAssembler</code> bean已使用<code>AnnotationJmxAttributeSource</code>类的实例进行配置，并通过汇编程序属性传递给<code>MBeanExporter</code> 。这就是利用面向Spring的MBean的元数据驱动管理接口所需的全部内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-metadata-types"><a class="anchor" href="#jmx-interface-metadata-types"></a> 4.3.3。源级元数据类型</h4>
<div class="paragraph">
<p>以下源级别元数据类型可用于Spring JMX：</p>
</div>
<table id="jmx-metadata-types" class="tableblock frame-all grid-all spread">
<caption class="title">表7。源级元数据类型</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">目的</th>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">注释类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">将<code>Class</code>所有实例标记为JMX托管资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedResource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">将方法标记为JMX操作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedOperation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">将getter或setter标记为JMX属性的一半</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法（只有getter和setter）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义操作参数的描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedOperationParameter</code>和<code>@ManagedOperationParameters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下配置参数可用于这些源级元数据类型：</p>
</div>
<table id="jmx-metadata-parameters" class="tableblock frame-all grid-all spread">
<caption class="title">表8。源级元数据参数</caption>
<colgroup>
<col style="width:20%">
<col style="width:60%">
<col style="width:20%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">适用于</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>对象名</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由<code>MetadataNamingStrategy</code>用于确定受管资源的<code>ObjectName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>描述</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置资源，属性或操作的友好描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code> ， <code>ManagedAttribute</code> ， <code>ManagedOperation</code> ， <code>ManagedOperationParameter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的currencyTimeLimit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>currencyTimeLimit</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code> ， <code>ManagedAttribute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>默认值</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>defaultValue</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedAttribute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>日志</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>log</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>日志文件</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>logFile</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>persistPolicy</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistPeriod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>persistPeriod</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>persistLocation</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置<code>persistName</code>描述符字段的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource为</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>名称</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置操作参数的显示名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedOperationParameter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>指数</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置操作参数的索引</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedOperationParameter</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="jmx-interface-autodetect"><a class="anchor" href="#jmx-interface-autodetect"></a> 4.3.4。AutodetectCapableMBeanInfoAssembler接口</h4>
<div class="paragraph">
<p>为了进一步简化配置，Spring引入了<code>AutodetectCapableMBeanInfoAssembler</code>接口，该接口扩展了<code>MBeanInfoAssembler</code>接口，以添加对MBean资源自动检测的支持。如果您使用<code>AutodetectCapableMBeanInfoAssembler</code>的实例配置<code>MBeanExporter</code> ，则允许对包含Bean以“暴露”到JMX进行“投票”。</p>
</div>
<div class="paragraph">
<p>开箱即用， <code>AutodetectCapableMBeanInfo</code>接口的唯一实现是<code>MetadataMBeanInfoAssembler</code> ，它将投票包含任何标记有<code>ManagedResource</code>属性的bean。在这种情况下，默认方法是使用bean名称作为<code>ObjectName</code> ，这将产生如下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 注意这里没有显式配置'beans' - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">autodetect</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">assembler</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">assembler</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">assembler</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx .export.assembler。MetadataMBeanInfoAssembler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">attributeSource</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx.export.annotation。AnnotationJmxAttributeSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在此配置中，没有bean传递给<code>MBeanExporter</code> ;但是， <code>JmxTestBean</code>仍将被注册，因为它标记有<code>ManagedResource</code>属性， <code>MetadataMBeanInfoAssembler</code>检测到这一点并投票包含它。这种方法的唯一问题是<code>JmxTestBean</code>的名称现在具有商业含义。您可以通过更改<a href="#jmx-naming">控件Bean的ObjectName中</a>定义的<code>ObjectName</code>创建的默认行为来解决此问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-java"><a class="anchor" href="#jmx-interface-java"></a> 4.3.5。使用Java接口定义管理接口</h4>
<div class="paragraph">
<p>除了<code>MetadataMBeanInfoAssembler</code> ，Spring还包括<code>InterfaceBasedMBeanInfoAssembler</code> ，它允许您根据接口集合中定义的方法集约束公开的方法和属性。</p>
</div>
<div class="paragraph">
<p>尽管公开MBean的标准机制是使用接口和简单的命名方案，但<code>InterfaceBasedMBeanInfoAssembler</code>通过消除对命名约定的需要来扩展此功能，允许您使用多个接口并且无需bean来实现MBean接口。</p>
</div>
<div class="paragraph">
<p>请考虑此接口，该接口用于为您<code>JmxTestBean</code>看到的<code>JmxTestBean</code>类定义管理接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">IJmxTestBean</span> { <span class="directive">public</span> <span class="type">int</span> add（ <span class="type">int</span> x， <span class="type">int</span> y）; <span class="directive">public</span> <span class="type">long</span> myOperation（）; <span class="directive">public</span> <span class="type">int</span> getAge（）; <span class="directive">public</span> <span class="type">void</span> setAge（ <span class="type">int</span> age）; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="predefined-type">String</span> name）; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>此接口定义将作为JMX MBean上的操作和属性公开的方法和属性。下面的代码显示了如何配置Spring JMX以将此接口用作管理接口的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean5</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">assembler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export.assembler。InterfaceBasedMBeanInfoAssembler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedInterfaces</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> org.springframework.jmx。IJmxTestBean <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以看到<code>InterfaceBasedMBeanInfoAssembler</code>被配置为在为任何bean构建管理接口时使用<code>IJmxTestBean</code>接口。要明白，在处理豆是很重要的<code>InterfaceBasedMBeanInfoAssembler</code>实现用于生成JMX管理接口的接口<em>不是</em>必需的。</p>
</div>
<div class="paragraph">
<p>在上面的例子中， <code>IJmxTestBean</code>接口用于构造所有bean的所有管理接口。在许多情况下，这不是所需的行为，您可能希望为不同的bean使用不同的接口。在这种情况下，你可以通过<code>InterfaceBasedMBeanInfoAssembler</code>一个<code>Properties</code>通过实例<code>interfaceMappings</code>财产，其中每一条目的关键是bean的名字和每个条目的值是一个逗号分隔的接口名称的列表，以用于该豆。</p>
</div>
<div class="paragraph">
<p>如果没有通过<code>managedInterfaces</code>或<code>interfaceMappings</code>属性指定管理接口，那么<code>InterfaceBasedMBeanInfoAssembler</code>将反映bean并使用该bean实现的所有接口来创建管理接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-methodnames"><a class="anchor" href="#jmx-interface-methodnames"></a> 4.3.6。使用MethodNameBasedMBeanInfoAssembler</h4>
<div class="paragraph">
<p><code>MethodNameBasedMBeanInfoAssembler</code>允许您指定将作为属性和操作公开给JMX的方法名称列表。下面的代码显示了此示例配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean5</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">assembler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export.assembler。MethodNameBasedMBeanInfoAssembler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedMethods</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> add，myOperation，getName，setName，getAge <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以看到方法<code>add</code>和<code>myOperation</code>将作为JMX操作公开， <code>getName()</code> ， <code>setName(String)</code>和<code>getAge()</code>将作为JMX属性的适当一半公开。在上面的代码中，方法映射适用于暴露给JMX的bean。要在bean-by-bean的基础上控制方法暴露，请使用<code>MethodNameMBeanInfoAssembler</code>的<code>methodMappings</code>属性将bean名称映射到方法名称列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-naming"><a class="anchor" href="#jmx-naming"></a> 4.4。控制bean的ObjectNames</h3>
<div class="paragraph">
<p>在幕后， <code>MBeanExporter</code>委托<code>ObjectNamingStrategy</code>的实现来为它正在注册的每个bean获取<code>ObjectName</code> 。默认情况下，默认实现<code>KeyNamingStrategy</code>将使用<code>beans</code> <code>Map</code>的键作为<code>ObjectName</code> 。此外， <code>KeyNamingStrategy</code>可以将<code>beans</code> <code>Map</code>的键<code>Map</code>到<code>Properties</code>文件（或多个文件）中的条目以解析<code>ObjectName</code> 。除了<code>KeyNamingStrategy</code> ，Spring还提供了两个额外的<code>ObjectNamingStrategy</code>实现： <code>IdentityNamingStrategy</code> ，它基于bean的JVM身份构建<code>ObjectName</code> ，以及使用源级元数据获取<code>ObjectName</code>的<code>MetadataNamingStrategy</code> 。</p>
</div>
<div class="sect3">
<h4 id="jmx-naming-properties"><a class="anchor" href="#jmx-naming-properties"></a> 4.4.1。从属性中读取ObjectNames</h4>
<div class="paragraph">
<p>您可以配置自己的<code>KeyNamingStrategy</code>实例，并将其配置为从<code>Properties</code>实例读取<code>ObjectName</code> ，而不是使用bean密钥。<code>KeyNamingStrategy</code>将尝试使用与bean密钥对应的密钥在<code>Properties</code>查找条目。如果未找到任何条目或者<code>Properties</code>实例为<code>null</code>则使用bean密钥本身。</p>
</div>
<div class="paragraph">
<p>下面的代码显示了<code>KeyNamingStrategy</code>的示例配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx .export.naming。KeyNamingStrategy</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappings</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> bean：name = testBean1 <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappingLocations</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> names1.properties，names2.properties <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里， <code>KeyNamingStrategy</code>一个实例配置了一个<code>Properties</code>实例，该实例是从映射属性定义的<code>Properties</code>实例和位于由mappings属性定义的路径中的属性文件合并而来的。在此配置中， <code>testBean</code> bean将被赋予<code>ObjectName</code> <code>bean:name=testBean1</code>因为这是<code>Properties</code>实例中具有与bean键对应的键的条目。</p>
</div>
<div class="paragraph">
<p>如果找不到<code>Properties</code>实例中的条目，则将bean键名称用作<code>ObjectName</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-naming-metadata"><a class="anchor" href="#jmx-naming-metadata"></a> 4.4.2。使用MetadataNamingStrategy</h4>
<div class="paragraph">
<p>本<code>MetadataNamingStrategy</code>使用<code>objectName</code>的财产<code>ManagedResource</code>每个bean的属性来创建<code>ObjectName</code> 。下面的代码显示了<code>MetadataNamingStrategy</code>的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">namingStrategy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx .export.naming。MetadataNamingStrategy</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">attributeSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">attributeSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">attributeSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx.export.annotation。AnnotationJmxAttributeSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有<code>objectName</code>已被设置用于<code>ManagedResource</code>属性，那么一个<code>ObjectName</code>将具有以下格式创建的<em>：[完全合格的包名称]：类型= [短类名]，名称= [豆名称]。</em>例如，以下bean的生成的<code>ObjectName</code>将是： <em>com.foo</em> ： <em>type = MyClass，name = myBean</em> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.foo。MyClass</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-context-mbeanexport"><a class="anchor" href="#jmx-context-mbeanexport"></a> 4.4.3。配置基于MBean导出的注释</h4>
<div class="paragraph">
<p>如果您更喜欢使用<a href="#jmx-interface-metadata">基于注释的方法</a>来定义管理接口，那么可以使用<code>MBeanExporter</code>的便捷子类： <code>AnnotationMBeanExporter</code> 。定义此子类的实例时，不再需要<code>namingStrategy</code> ， <code>assembler</code>和<code>attributeSource</code>配置，因为它将始终使用基于标准Java注释的元数据（自动检测也始终启用）。实际上， <code>@Configuration</code> <code>@EnableMBeanExport</code> <code>@Configuration</code>注释支持更简单的语法，而不是定义<code>MBeanExporter</code> bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableMBeanExport</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您更喜欢基于XML的配置，则<code>'context:mbean-export'</code>元素用于相同的目的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context：mbean-export</span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如有必要，您可以提供对特定MBean <code>server</code>的引用， <code>defaultDomain</code>属性（ <code>AnnotationMBeanExporter</code>的属性）接受生成的MBean“ObjectNames”域的备用值。这将用于代替完全限定的包名称，如上一节<a href="#jmx-naming-metadata">MetadataNamingStrategy中所述</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EnableMBeanExport</span> （server = <span class="string"><span class="delimiter">“</span> <span class="content">myMBeanServer</span> <span class="delimiter">”</span></span> ，defaultDomain = <span class="string"><span class="delimiter">“</span> <span class="content">myDomain</span> <span class="delimiter">”</span></span> ） <span class="annotation">@</span> <span class="string"><span class="content">Configuration</span></span> ContextConfiguration {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context：mbean-export</span> <span class="attribute-name">server</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myMBeanServer</span> <span class="delimiter">”</span></span> <span class="attribute-name">default-domain</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDomain</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不要将基于接口的AOP代理与bean类中的JMX注释的自动检测结合使用。基于接口的代理“隐藏”目标类，它也隐藏了JMX托管资源注释。因此，在这种情况下使用目标类代理：通过在<code>&lt;aop:config/&gt;</code> ， <code>&lt;tx:annotation-driven/&gt;</code>等设置'proxy-target-class'标志，否则，您的JMX bean可能会被忽略在启动时......</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-jsr160"><a class="anchor" href="#jmx-jsr160"></a> 4.5。JSR-160连接器</h3>
<div class="paragraph">
<p>对于远程访问，Spring JMX模块在<code>org.springframework.jmx.support</code>包中提供了两个<code>FactoryBean</code>实现，用于创建服务器端和客户端连接器。</p>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-server"><a class="anchor" href="#jmx-jsr160-server"></a> 4.5.1。服务器端连接器</h4>
<div class="paragraph">
<p>要让Spring JMX创建，启动并公开JSR-160 <code>JMXConnectorServer</code>使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serverConnector</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。ConnectorServerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>ConnectorServerFactoryBean</code>创建一个绑定到<code>"service:jmx:jmxmp://localhost:9875"</code>的<code>JMXConnectorServer</code> 。因此， <code>serverConnector</code> bean通过localhost，端口9875上的JMXMP协议将本地<code>MBeanServer</code>公开给客户端。请注意，JSR 160规范将JMXMP协议标记为可选：目前，主要的开源JMX实现MX4J和JDK提供的实现<em>不</em>支持JMXMP。</p>
</div>
<div class="paragraph">
<p>要指定另一个URL并使用<code>MBeanServer</code>注册<code>JMXConnectorServer</code>本身，请分别使用<code>serviceUrl</code>和<code>ObjectName</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serverConnector</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。ConnectorServerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connector：name = rmi</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service：jmx：rmi：// localhost / jndi / rmi：// localhost：1099 / myconnector</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果设置了<code>ObjectName</code>属性，Spring将自动将连接器注册到该<code>ObjectName</code>下的<code>MBeanServer</code> 。下面的示例显示了在创建JMXConnector时可以传递给<code>ConnectorServerFactoryBean</code>的完整参数集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serverConnector</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。ConnectorServerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connector：name = iiop</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service：jmx：iiop：// localhost / jndi / iiop：// localhost：900 / myconnector</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">threaded</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">daemon</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">environment</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someKey</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someValue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，使用基于RMI的连接器时，需要启动查找服务（tnameserv或rmiregistry）才能完成名称注册。如果您使用Spring通过RMI为您导出远程服务，那么Spring已经构建了一个RMI注册表。如果没有，您可以使用以下配置片段轻松启动注册表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">registry</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.remoting.rmi。RmiRegistryFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">port</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1099</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-client"><a class="anchor" href="#jmx-jsr160-client"></a> 4.5.2。客户端连接器</h4>
<div class="paragraph">
<p>要创建<code>MBeanServerConnection</code>到远程的JSR160 <code>MBeanServer</code>使用<code>MBeanServerConnectionFactoryBean</code> ，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">clientConnector</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。MBeanServerConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service：jmx：rmi：// localhost / jndi / rmi：// localhost：1099 / jmxrmi</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-protocols"><a class="anchor" href="#jmx-jsr160-protocols"></a> 4.5.3。JMX over Hessian或SOAP</h4>
<div class="paragraph">
<p>JSR-160允许扩展客户端和服务器之间的通信方式。上面的示例使用JSR-160规范（IIOP和JRMP）和（可选）JMXMP所需的基于RMI的强制实现。通过使用其他提供程序或JMX实现（例如<a href="http://mx4j.sourceforge.net">MX4J</a> ），您可以利用SOAP或Hessian等协议优先于简单的HTTP或SSL等：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serverConnector</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。ConnectorServerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">objectName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connector：name = burlap</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service：jmx：burlap：// localhost：9874</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述示例的情况下，使用MX4J 3.0.0;有关更多信息，请参阅官方MX4J文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-proxy"><a class="anchor" href="#jmx-proxy"></a> 4.6。通过代理访问MBean</h3>
<div class="paragraph">
<p>Spring JMX允许您创建代理，将代理重新路由到在本地或远程<code>MBeanServer</code>注册的<code>MBeanServer</code> 。这些代理为您提供了一个标准的Java接口，您可以通过它与MBean进行交互。下面的代码显示了如何为在本地<code>MBeanServer</code>运行的MBean配置代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">proxy</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.access。MBeanProxyFactoryBean</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">对象名</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=”</span> <span class="content">豆：名称= testBean这个</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">proxyInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=”</span> <span class="content">org.springframework.jmx。IJmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以看到为在<code>ObjectName</code>下注册的MBean创建了一个代理： <code>bean:name=testBean</code> 。代理将实现的接口集由<code>proxyInterfaces</code>属性控制，并且将这些接口上的方法和属性映射到MBean上的操作和属性的规则与<code>InterfaceBasedMBeanInfoAssembler</code>使用的规则相同。</p>
</div>
<div class="paragraph">
<p><code>MBeanProxyFactoryBean</code>可以为任何可通过<code>MBeanServerConnection</code>访问的MBean创建代理。默认情况下，本地<code>MBeanServer</code>查找和使用，但是你可以重写这一点，并提供<code>MBeanServerConnection</code>指向远程<code>MBeanServer</code> ，为了适应指向远程MBean的代理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">clientConnector</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.support。MBeanServerConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceUrl</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">service：jmx：rmi：// remotehost：9875</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">proxy</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx.access。MBeanProxyFactoryBean</span> <span class="delimiter"><span class="tag">“&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">对象名</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=”</span> <span class="content">豆：名称= testBean这个</span> <span class="delimiter"><span class="tag">“/&gt;</span></span></span> <span class="tag">&lt;属性</span> <span class="attribute-name">名</span> <span class="string"><span class="delimiter">=”</span> <span class="content">proxyInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">值</span> <span class="string"><span class="delimiter">=”</span> <span class="content">org.springframework.jmx。IJmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">server</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">clientConnector</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以看到我们使用<code>MBeanServerConnection</code>创建指向远程计算机的<code>MBeanServerConnectionFactoryBean</code> 。然后，此<code>MBeanServerConnection</code>通过<code>server</code>属性传递给<code>MBeanProxyFactoryBean</code> 。则创建转发所有调用到代理<code>MBeanServer</code>通过这个<code>MBeanServerConnection</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="jmx-notifications"><a class="anchor" href="#jmx-notifications"></a> 4.7。通知</h3>
<div class="paragraph">
<p>Spring的JMX产品包括对JMX通知的全面支持。</p>
</div>
<div class="sect3">
<h4 id="jmx-notifications-listeners"><a class="anchor" href="#jmx-notifications-listeners"></a> 4.7.1。注册通知的侦听器</h4>
<div class="paragraph">
<p>Spring的JMX支持使得可以很容易地向任意数量的MBean注册任意数量的<code>NotificationListeners</code> （这包括由Spring的<code>MBeanExporter</code>导出的MBean和通过其他机制注册的MBean）。作为示例，考虑每当目标MBean的属性改变时希望（通过<code>Notification</code> ） <code>Notification</code>的场景。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">com.example</span> ; <span class="keyword">导入</span> <span class="include">javax.management。AttributeChangeNotification</span> ; <span class="keyword">导入</span> <span class="include">javax.management。通知</span> ; <span class="keyword">导入</span> <span class="include">javax.management。NotificationFilter</span> ; <span class="keyword">导入</span> <span class="include">javax.management。NotificationListener</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">ConsoleLoggingNotificationListener</span> <span class="directive">实现</span> <span class="predefined-type">NotificationListener</span> ， <span class="predefined-type">NotificationFilter</span> { <span class="directive">public</span> <span class="type">void</span> handleNotification（ <span class="predefined-type">Notification</span> notification， <span class="predefined-type">Object</span> handback）{ <span class="predefined-type">System</span> .out.println（notification）; <span class="predefined-type">System</span> .out.println（handback）; <span class="directive">public</span> <span class="type">boolean</span> isNotificationEnabled（ <span class="predefined-type">Notification</span> notification）{ <span class="keyword">return</span> <span class="predefined-type">AttributeChangeNotification</span> .class.isAssignableFrom（notification.getClass（））; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">notificationListenerMappings</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。ConsoleLoggingNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ entry&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过上述配置，每次从目标MBean（ <code>bean:name=testBean1</code> ）广播JMX <code>Notification</code> ，将通知通过<code>notificationListenerMappings</code>属性注册为侦听器的<code>ConsoleLoggingNotificationListener</code> bean。然后， <code>ConsoleLoggingNotificationListener</code> bean可以采取它认为适当的任何操作来响应<code>Notification</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以使用直接bean名称作为导出的bean和侦听器之间的链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">notificationListenerMappings</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content"><em>testBean</em></span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。ConsoleLoggingNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ entry&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content"><em>testBean</em></span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果想要为封闭的<code>MBeanExporter</code>导出的所有bean注册单个<code>NotificationListener</code>实例，可以使用特殊通配符<code>'*'</code> （无引号）作为<code>notificationListenerMappings</code>属性映射中的条目的键;例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">notificationListenerMappings</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。ConsoleLoggingNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ entry&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要执行逆操作（即，针对MBean注册多个不同的侦听器），则必须使用<code>notificationListeners</code>列表属性（并优先使用<code>notificationListenerMappings</code>属性）。这一次，而不是简单地配置一个<code>NotificationListener</code>的一个MBean，一个配置<code>NotificationListenerBean</code>实例......一个<code>NotificationListenerBean</code>封装了<code>NotificationListener</code>和<code>ObjectName</code> （或<code>ObjectNames</code> ），这是要针对在注册<code>MBeanServer</code> 。<code>NotificationListenerBean</code>还封装了许多其他属性，例如<code>NotificationFilter</code>和可在高级JMX通知方案中使用的任意handback对象。</p>
</div>
<div class="paragraph">
<p>使用<code>NotificationListenerBean</code>实例时的配置与之前介绍的实例没有太大的不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">notificationListeners</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。NotificationListenerBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.example。ConsoleLoggingNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ constructor-arg&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappedObjectNames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> bean：name = testBean1 <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt; / property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">testBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例等同于第一个通知示例。让我们假设那时，我们希望每一次得到一个回传对象<code>Notification</code>上升，此外，我们想给过滤掉无关的<code>Notifications</code>通过提供一个<code>NotificationFilter</code> 。（有关回传对象的完整讨论，以及<code>NotificationFilter</code>确切内容，请参考标题为“JMX通知模型”的JMX规范（1.2）部分。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exporter</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jmx.export。MBeanExporter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beans</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean1</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bean：name = testBean2</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean2</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">notificationListeners</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx.export。NotificationListenerBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customerNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappedObjectNames</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="comment">&lt;！ - 处理来自两个不同MBean的通知 - &gt;</span> <span class="tag">&lt;value&gt;</span> bean：name = testBean1 <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> bean：name = testBean2 <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">handback</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java.lang。String</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">这可以是任何东西......</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">notificationFilter</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customerNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 实现NotificationListener和NotificationFilter接口 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">customerNotificationListener</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.example。ConsoleLoggingNotificationListener</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean1</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">100</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">testBean2</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jmx 。JmxTestBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">name</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ANTHER TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">age</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">200</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-notifications-publishing"><a class="anchor" href="#jmx-notifications-publishing"></a> 4.7.2。发布通知</h4>
<div class="paragraph">
<p>Spring不仅支持注册接收<code>Notifications</code> ，还支持发布<code>Notifications</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，此部分实际上仅与通过<code>MBeanExporter</code>公开为MBean的Spring托管bean相关;任何现有的，用户定义的MBean都应使用标准JMX API进行通知发布。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring的JMX通知发布支持中的关键接口是<code>NotificationPublisher</code>接口（在<code>org.springframework.jmx.export.notification</code>包中定义）。任何将通过<code>MBeanExporter</code>实例导出为MBean的bean都可以实现相关的<code>NotificationPublisherAware</code>接口以获取对<code>NotificationPublisher</code>实例的访问权限。<code>NotificationPublisherAware</code>接口只是通过一个简单的setter方法向实现bean提供<code>NotificationPublisher</code>实例，然后bean可以使用它来发布<code>Notifications</code> 。</p>
</div>
<div class="paragraph">
<p>正如中的javadoc说<code>NotificationPublisher</code>类，管理那些通过发布事件豆<code>NotificationPublisher</code>机制是<em>不</em>负责任何通知监听器的状态管理和... Spring的JMX支持将处理所有的JMX架构问题的照顾。所有人都需要这样做，因为应用程序开发人员实现<code>NotificationPublisherAware</code>接口并使用提供的<code>NotificationPublisher</code>实例开始发布事件。请注意，在使用<code>MBeanServer</code>注册托管bean <em>之后</em> ，将设置<code>NotificationPublisher</code> 。</p>
</div>
<div class="paragraph">
<p>使用<code>NotificationPublisher</code>实例非常简单......只需创建一个JMX <code>Notification</code>实例（或适当的<code>Notification</code>子类的实例），使用与要发布的事件相关的数据填充通知，然后调用<code>sendNotification(Notification)</code>实例上的<code>NotificationPublisher</code> ，传入<code>Notification</code> 。</p>
</div>
<div class="paragraph">
<p>下面是一个简单的例子......在这种情况下，每次调用<code>add(int, int)</code>操作时， <code>JmxTestBean</code>导出实例都将发布<code>NotificationEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">org.springframework.jmx</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jmx.export.notification。NotificationPublisherAware</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jmx.export.notification。NotificationPublisher</span> ; <span class="keyword">导入</span> <span class="include">javax.management。通知</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">JmxTestBean</span> <span class="directive">实现</span> IJmxTestBean，NotificationPublisherAware { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私人</span> <span class="type">诠释</span>年龄; <span class="directive">private</span> <span class="type">boolean</span> isSuperman; <span class="directive">私人</span> NotificationPublisher出版商; <span class="comment">//为清晰起见省略了其他getter和setter</span> <span class="directive">public</span> <span class="type">int</span> add（ <span class="type">int</span> x， <span class="type">int</span> y）{ <span class="type">int</span> answer = x + y; <span class="local-variable">这个</span> .publisher.sendNotification（ <span class="keyword">新的</span> <span class="predefined-type">通知</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">添加</span> <span class="delimiter">”</span></span> ， <span class="local-variable">这个</span> ， <span class="integer">0</span> ））; <span class="keyword">返回</span>的答案; <span class="directive">public</span> <span class="type">void</span> dontExposeMe（）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span> （）; <span class="directive">public</span> <span class="type">void</span> setNotificationPublisher（NotificationPublisher notificationPublisher）{ <span class="local-variable">this</span> .publisher = notificationPublisher; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>NotificationPublisher</code>接口和使其全部工作的机制是Spring的JMX支持的一个更好的功能。然而，它确实带有将类与Spring和JMX耦合的价格标签;和往常一样，这里的建议是务实的......如果你需要<code>NotificationPublisher</code>提供的功能，你可以接受与Spring和JMX的耦合，那么就这样做。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-resources"><a class="anchor" href="#jmx-resources"></a> 4.8。更多资源</h3>
<div class="paragraph">
<p>本节包含有关JMX的更多资源的链接。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Oracle的<a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX主页</a></p>
</li>
<li>
<p><a href="http://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html">JMX规范</a> （JSR-000003）</p>
</li>
<li>
<p><a href="http://jcp.org/aboutJava/communityprocess/final/jsr160/index.html">JMX远程API规范</a> （JSR-000160）</p>
</li>
<li>
<p><a href="http://mx4j.sourceforge.net/">MX4J主页</a> （各种JMX规范的开源实现）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cci"><a class="anchor" href="#cci"></a> 5。JCA CCI</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="cci-introduction"><a class="anchor" href="#cci-introduction"></a> 5.1。介绍</h3>
<div class="paragraph">
<p>Java EE提供了一个规范来标准化对企业信息系统（EIS）的访问：JCA（Java EE连接器体系结构）。该规范分为几个不同的部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>连接器提供程序必须实现的SPI（服务提供程序接口）。这些接口构成可以部署在Java EE应用程序服务器上的资源适配器。在这种情况下，服务器管理连接池，事务和安全性（托管模式）。应用程序服务器还负责管理客户端应用程序外部的配置。连接器也可以在没有应用服务器的情况下使用;在这种情况下，应用程序必须直接配置它（非托管模式）。</p>
</li>
<li>
<p>应用程序可用于与连接器交互并因此与EIS通信的CCI（通用客户端接口）。还提供了用于本地事务划分的API。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring CCI支持的目的是提供以典型Spring风格访问CCI连接器的类，利用Spring Framework的一般资源和事务管理工具。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>连接器的客户端一直不使用CCI。某些连接器公开自己的API，仅提供JCA资源适配器以使用Java EE容器的系统协定（连接池，全局事务，安全性）。Spring不为这种特定于连接器的API提供特殊支持。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cci-config"><a class="anchor" href="#cci-config"></a> 5.2。配置CCI</h3>
<div class="sect3">
<h4 id="cci-config-connector"><a class="anchor" href="#cci-config-connector"></a> 5.2.1。连接器配置</h4>
<div class="paragraph">
<p>使用JCA CCI的基本资源是<code>ConnectionFactory</code>接口。使用的连接器必须提供此接口的实现。</p>
</div>
<div class="paragraph">
<p>要使用连接器，可以将其部署在应用程序服务器上，并从服务器的JNDI环境（托管模式）获取<code>ConnectionFactory</code> 。连接器必须打包为RAR文件（资源适配器归档文件）并包含<code>ra.xml</code>文件以描述其部署特征。部署资源时指定资源的实际名称。要在Spring中访问它，只需使用Spring的<code>JndiObjectFactoryBean</code> / <code>&lt;jee:jndi-lookup&gt;</code>按其JNDI名称获取工厂。</p>
</div>
<div class="paragraph">
<p>使用连接器的另一种方法是将其嵌入应用程序（非托管模式），而不是使用应用程序服务器来部署和配置它。Spring提供了通过提供的<code>FactoryBean</code> （ <code>LocalConnectionFactoryBean</code> ）将连接器配置为bean的可能性。通过这种方式，您只需要类路径中的连接器库（不需要RAR文件，也不需要<code>ra.xml</code>描述符）。必要时，必须从连接器的RAR文件中提取库。</p>
</div>
<div class="paragraph">
<p>一旦您有权访问<code>ConnectionFactory</code>实例，就可以将其注入到组件中。这些组件可以针对普通CCI API进行编码，也可以利用Spring的CCI访问支持类（例如<code>CciTemplate</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在非托管模式下使用连接器时，不能使用全局事务，因为资源从未在当前线程的当前全局事务中登记/退出。资源根本不知道可能正在运行的任何全局Java EE事务。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cci-config-connectionfactory"><a class="anchor" href="#cci-config-connectionfactory"></a> 5.2.2。Spring中的ConnectionFactory配置</h4>
<div class="paragraph">
<p>为了建立与EIS的<code>ConnectionFactory</code> ，如果您处于托管模式，则需要从应用程序服务器获取<code>ConnectionFactory</code> ，如果您处于非托管模式，则需要直接从Spring获取。</p>
</div>
<div class="paragraph">
<p>在托管模式下，您从JNDI访问<code>ConnectionFactory</code> ;其属性将在应用程序服务器中配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eis / cicseci</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在非托管模式下，必须将要在Spring配置中使用的<code>ConnectionFactory</code>配置为JavaBean。<code>LocalConnectionFactoryBean</code>类提供此安​​装样式，传入连接器的<code>ManagedConnectionFactory</code>实现，公开应用程序级CCI <code>ConnectionFactory</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciManagedConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.ibm.connector2.cics。ECIManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TXSERIES</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tcp：// localhost /</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">portNumber</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">2006</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。LocalConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">eciManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您无法直接实例化特定的<code>ConnectionFactory</code> 。您需要为连接器完成<code>ManagedConnectionFactory</code>接口的相应实现。该接口是JCA SPI规范的一部分。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cci-config-cci-connections"><a class="anchor" href="#cci-config-cci-connections"></a> 5.2.3。配置CCI连接</h4>
<div class="paragraph">
<p>JCA CCI允许开发人员使用<code>ConnectionSpec</code>器的<code>ConnectionSpec</code>实现配置与EIS的连接。要配置其属性，需要使用专用适配器<code>ConnectionSpecConnectionFactoryAdapter</code>包装目标连接工厂。因此，可以使用属性<code>connectionSpec</code> （作为内部bean）配置专用<code>ConnectionSpec</code> 。</p>
</div>
<div class="paragraph">
<p>此属性不是必需的，因为CCI <code>ConnectionFactory</code>接口定义了两种不同的方法来获取CCI连接。某些<code>ConnectionSpec</code>属性通常可以在应用程序服务器（在托管模式下）或相应的本地<code>ManagedConnectionFactory</code>实现中进行配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">ConnectionFactory</span> <span class="directive">实现</span> <span class="predefined-type">Serializable</span> ， <span class="predefined-type">Referenceable</span> {...Connection getConnection（） <span class="directive">抛出</span> ResourceException; <span class="predefined-type">Connection</span> getConnection（ConnectionSpec connectionSpec） <span class="directive">抛出</span> ResourceException; ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring提供了一个<code>ConnectionSpecConnectionFactoryAdapter</code> ，它允许指定一个<code>ConnectionSpec</code>实例，用于给定工厂的所有操作。如果指定了适配器的<code>connectionSpec</code>属性，那么适配器将使用带有<code>ConnectionSpec</code>参数的<code>getConnection</code>变量，否则使用不带参数的变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.sun.connector.cciblackbox。CciLocalTxManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：hsqldb：hsql：// localhost：9001</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.hsqldb.jdbcDriver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。LocalConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jca.cci.connection。ConnectionSpecConnectionFactoryAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.sun.connector.cciblackbox。CciConnectionSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">user</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sa</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">password</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-config-single-connection"><a class="anchor" href="#cci-config-single-connection"></a> 5.2.4。使用单个CCI连接</h4>
<div class="paragraph">
<p>如果您想使用单个CCI连接，Spring会提供另一个<code>ConnectionFactory</code>适配器来管理它。<code>SingleConnectionFactory</code>适配器类将懒惰地打开单个连接，并在应用程序关闭时销毁此bean时将其关闭。此类将公开相应行为的特殊<code>Connection</code>代理，它们共享相同的底层物理连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciManagedConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.ibm.connector2.cics。ECIManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TEST</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tcp：// localhost /</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">portNumber</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">2006</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">targetEciConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。LocalConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">eciManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">eciConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jca.cci.connection。SingleConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetEciConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此<code>ConnectionFactory</code>适配器无法直接使用<code>ConnectionSpec</code>进行配置。使用中间<code>ConnectionSpecConnectionFactoryAdapter</code>的<code>SingleConnectionFactory</code>会谈，如果你需要一个特定的单一连接到<code>ConnectionSpec</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cci-using"><a class="anchor" href="#cci-using"></a> 5.3。使用Spring的CCI访问支持</h3>
<div class="sect3">
<h4 id="cci-record-creator"><a class="anchor" href="#cci-record-creator"></a> 5.3.1。记录转换</h4>
<div class="paragraph">
<p>JCA CCI支持的目标之一是为操作CCI记录提供便利的设施。开发人员可以指定策略来​​创建记录并从记录中提取数据，以便与Spring的<code>CciTemplate</code> 。如果您不想直接在应用程序中使用记录，以下接口将配置策略以使用输入和输出记录。</p>
</div>
<div class="paragraph">
<p>为了创建输入<code>Record</code> ，开发人员可以使用<code>RecordCreator</code>接口的专用实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">RecordCreator</span> {Record createRecord（RecordFactory recordFactory） <span class="directive">抛出</span> ResourceException，DataAccessException; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>createRecord(..)</code>方法接收<code>RecordFactory</code>实例作为参数，它对应于所<code>RecordFactory</code>的<code>ConnectionFactory</code>的<code>RecordFactory</code> 。此引用可用于创建<code>IndexedRecord</code>或<code>MappedRecord</code>实例。以下示例显示如何使用<code>RecordCreator</code>接口和索引/映射记录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyRecordCreator</span> <span class="directive">实现</span> RecordCreator { <span class="directive">public</span> Record createRecord（RecordFactory recordFactory） <span class="directive">throws</span> ResourceException {IndexedRecord input = recordFactory.createIndexedRecord（ <span class="string"><span class="delimiter">“</span> <span class="content">input</span> <span class="delimiter">”</span></span> ）; input.add（ <span class="keyword">new</span> <span class="predefined-type">Integer</span> （id））; <span class="keyword">返回</span>输入; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出<code>Record</code>可用于从EIS接收数据。因此， <code>RecordExtractor</code>接口的特定实现可以传递给Spring的<code>CciTemplate</code>用于从输出<code>Record</code>提取数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">RecordExtractor</span> { <span class="predefined-type">Object</span> extractData（Record record） <span class="directive">抛出</span> ResourceException， <span class="exception">SQLException</span> ，DataAccessException; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>RecordExtractor</code>接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyRecordExtractor</span> <span class="directive">实现</span> RecordExtractor { <span class="directive">public</span> <span class="predefined-type">Object</span> extractData（Record record） <span class="directive">抛出</span> ResourceException {CommAreaRecord commAreaRecord =（CommAreaRecord）记录; <span class="predefined-type">String</span> str = <span class="keyword">new</span> <span class="predefined-type">String</span> （commAreaRecord.toByteArray（））; <span class="predefined-type">串</span> FIELD1 = <span class="integer"><span class="integer">string.substring（0，6）;</span></span> <span class="predefined-type">串</span> FIELD2 = <span class="integer"><span class="integer">string.substring（6,1）;</span></span> <span class="keyword">返回</span> <span class="keyword">new</span> OutputObject（ <span class="predefined-type">Long</span> .parseLong（field1），field2）; }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-using-template"><a class="anchor" href="#cci-using-template"></a> 5.3.2。CciTemplate</h4>
<div class="paragraph">
<p><code>CciTemplate</code>是核心CCI支持包（ <code>org.springframework.jca.cci.core</code> ）的核心类。它简化了CCI的使用，因为它处理资源的创建和释放。这有助于避免常见错误，例如忘记始终关闭连接。它关注连接和交互对象的生命周期，让应用程序代码专注于从应用程序数据生成输入记录并从输出记录中提取应用程序数据。</p>
</div>
<div class="paragraph">
<p>JCA CCI规范定义了两种不同的方法来调用EIS上的操作。 CCI <code>Interaction</code>接口提供两个执行方法签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">javax</span> .resource.cci。互动{...boolean execute（InteractionSpec规范，记录输入，记录输出） <span class="directive">抛出</span> ResourceException;记录执行（InteractionSpec规范，记录输入） <span class="directive">抛出</span> ResourceException; ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据调用的模板方法， <code>CciTemplate</code>将知道在交互时调用哪个<code>execute</code>方法。无论如何，正确初始化的<code>InteractionSpec</code>实例是必需的。</p>
</div>
<div class="paragraph">
<p><code>CciTemplate.execute(..)</code>可以通过两种方式使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用直接<code>Record</code>参数。在这种情况下，您只需要传入CCI输入记录，返回的对象就是相应的CCI输出记录。</p>
</li>
<li>
<p>使用应用程序对象，使用记录映射。在这种情况下，您需要提供相应的<code>RecordCreator</code>和<code>RecordExtractor</code>实例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用第一种方法，将使用以下模板方法。这些方法直接对应于<code>Interaction</code>接口上的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CciTemplate</span> <span class="directive">实现</span> CciOperations { <span class="directive">public</span> Record execute（InteractionSpec spec，Record inputRecord） <span class="directive">抛出</span> DataAccessException {...<span class="directive">public</span> <span class="type">void</span> execute（InteractionSpec spec，Record inputRecord，Record outputRecord） <span class="directive">抛出</span> DataAccessException {...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用第二种方法，我们需要将记录创建和记录提取策略指定为参数。使用的接口是上一节中有关记录转换的描述。相应的<code>CciTemplate</code>方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CciTemplate</span> <span class="directive">实现</span> CciOperations { <span class="directive">public</span> Record execute（InteractionSpec spec，RecordCreator inputCreator） <span class="directive">抛出</span> DataAccessException { <span class="comment">// ...</span><span class="directive">public</span> <span class="predefined-type">Object</span> execute（InteractionSpec spec，Record inputRecord，RecordExtractor outputExtractor） <span class="directive">抛出</span> DataAccessException { <span class="comment">// ...</span><span class="directive">public</span> <span class="predefined-type">Object</span> execute（InteractionSpec规范，RecordCreator创建者，RecordExtractor提取器） <span class="directive">抛出</span> DataAccessException { <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非在模板上设置了<code>outputRecordCreator</code>属性（参见下一节），否则每个方法都将使用两个参数调用CCI <code>Interaction</code>的相应<code>execute</code>方法： <code>InteractionSpec</code>和input <code>Record</code> ，接收输出<code>Record</code>作为返回值。</p>
</div>
<div class="paragraph">
<p><code>CciTemplate</code>还提供了通过其<code>createIndexRecord(..)</code>和<code>createMappedRecord(..)</code>方法在<code>RecordCreator</code>实现之外创建<code>IndexRecord</code>和<code>MappedRecord</code>方法。这可以在DAO实现中用于创建<code>Record</code>实例以传递到相应的<code>CciTemplate.execute(..)</code>方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CciTemplate</span> <span class="directive">实现</span> CciOperations { <span class="directive">public</span> IndexedRecord createIndexedRecord（ <span class="predefined-type">String</span> name） <span class="directive">抛出</span> DataAccessException {...<span class="directive">public</span> MappedRecord createMappedRecord（ <span class="predefined-type">String</span> name） <span class="directive">抛出</span> DataAccessException {...}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-using-dao"><a class="anchor" href="#cci-using-dao"></a> 5.3.3。DAO支持</h4>
<div class="paragraph">
<p>Spring的CCI支持为DAO提供了一个抽象类，支持注入<code>ConnectionFactory</code>或<code>CciTemplate</code>实例。该类的名称是<code>CciDaoSupport</code> ：它提供了简单的<code>setConnectionFactory</code>和<code>setCciTemplate</code>方法。在内部，此类将为传入的<code>ConnectionFactory</code>创建<code>CciTemplate</code>实例，并将其公开给子类中的具体数据访问实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CciDaoSupport</span> { <span class="directive">public</span> <span class="type">void</span> setConnectionFactory（ConnectionFactory connectionFactory）{ <span class="comment">// ...</span><span class="directive">public</span> ConnectionFactory getConnectionFactory（）{ <span class="comment">// ...</span><span class="directive">public</span> <span class="type">void</span> setCciTemplate（CciTemplate cciTemplate）{ <span class="comment">// ...</span><span class="directive">public</span> CciTemplate getCciTemplate（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="automatic-output-generation"><a class="anchor" href="#automatic-output-generation"></a> 5.3.4。自动输出记录生成</h4>
<div class="paragraph">
<p>如果使用的连接器仅支持使用输入和输出记录作为参数的<code>Interaction.execute(..)</code>方法（也就是说，它需要传入所需的输出记录而不是返回适当的输出记录），则可以设置<code>outputRecordCreator</code> <code>CciTemplate</code>属性，用于在收到响应时自动生成由JCA连接器填充的输出记录。然后该记录将返回给模板的调用者。</p>
</div>
<div class="paragraph">
<p>此属性只保存<code>RecordCreator</code>接口的实现，用于此目的。<code>RecordCreator</code>接口已在<a href="#cci-record-creator">Record转换中</a>讨论过。必须在<code>CciTemplate</code>上直接指定<code>outputRecordCreator</code>属性。这可以在应用程序代码中完成，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cciTemplate.setOutputRecordCreator（ <span class="keyword">new</span> EciOutputRecordCreator（））;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者（推荐）在Spring配置中，如果<code>CciTemplate</code>配置为专用bean实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciOutputRecordCreator</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eci。EciOutputRecordCreator</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cciTemplate</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jca.cci.core。CciTemplate</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">eciConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">outputRecordCreator</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">eciOutputRecordCreator</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于<code>CciTemplate</code>类是线程安全的，因此通常将其配置为共享实例。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="template-summary"><a class="anchor" href="#template-summary"></a> 5.3.5。概要</h4>
<div class="paragraph">
<p>下表总结了<code>CciTemplate</code>类的机制以及在CCI <code>Interaction</code>接口上调用的相应方法：</p>
</div>
<table id="cci-interaction-execute-methods" class="tableblock frame-all grid-all spread">
<caption class="title">表9。使用交互执行方法</caption>
<colgroup>
<col style="width:42.8571%">
<col style="width:14.2857%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">CciTemplate方法签名</th>
<th class="tableblock halign-left valign-top">CciTemplate outputRecordCreator属性</th>
<th class="tableblock halign-left valign-top">在CCI Interaction上调用的execute方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔执行（InteractionSpec，Record，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，RecordCreator）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，RecordCreator）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record，RecordExtractor）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record，RecordExtractor）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，RecordCreator，RecordExtractor）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，RecordCreator，RecordExtractor）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">void execute（InteractionSpec，Record，Record）</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="cci-straight"><a class="anchor" href="#cci-straight"></a> 5.3.6。直接使用CCI连接和交互</h4>
<div class="paragraph">
<p><code>CciTemplate</code>还提供了直接使用CCI连接和交互的可能性，与<code>JdbcTemplate</code>和<code>JmsTemplate</code>方式相同。例如，当您想要在CCI连接或交互上执行多个操作时，这非常有用。</p>
</div>
<div class="paragraph">
<p><code>ConnectionCallback</code>接口提供CCI <code>Connection</code>作为参数，以便对其执行自定义操作，以及创建<code>Connection</code>的CCI <code>ConnectionFactory</code> 。例如，后者可用于获取关联的<code>RecordFactory</code>实例并创建索引/映射记录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ConnectionCallback</span> { <span class="predefined-type">Object</span> doInConnection（ <span class="predefined-type">Connection</span> connection，ConnectionFactory connectionFactory） <span class="directive">抛出</span> ResourceException， <span class="exception">SQLException</span> ，DataAccessException; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>InteractionCallback</code>接口提供CCI <code>Interaction</code> ，以便对其执行自定义操作，以及相应的CCI <code>ConnectionFactory</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InteractionCallback</span> { <span class="predefined-type">Object</span> doInInteraction（Interaction interaction，ConnectionFactory connectionFactory） <span class="directive">抛出</span> ResourceException， <span class="exception">SQLException</span> ，DataAccessException; }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>InteractionSpec</code>对象可以在多个模板调用之间共享，也可以在每个回调方法中新创建。这完全取决于DAO的实现。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cci-template-example"><a class="anchor" href="#cci-template-example"></a> 5.3.7。CciTemplate用法示例</h4>
<div class="paragraph">
<p>在本节中，将显示<code>CciTemplate</code>的使用情况，以使用IBM CICS ECI连接器访问具有ECI模式的CICS。</p>
</div>
<div class="paragraph">
<p>首先，必须对CCI <code>InteractionSpec</code>进行一些初始化，以指定要访问的CICS程序以及如何与之交互。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ECIInteractionSpec interactionSpec = <span class="keyword">new</span> ECIInteractionSpec（）; interactionSpec.setFunctionName（ <span class="string"><span class="delimiter">“</span> <span class="content">MYPROG</span> <span class="delimiter">”</span></span> ）; interactionSpec.setInteractionVerb（ECIInteractionSpec.SYNC_SEND_RECEIVE）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后程序可以通过Spring的模板使用CCI，并指定自定义对象和CCI <code>Records</code>之间的映射。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyDaoImpl</span> <span class="directive">扩展</span> CciDaoSupport <span class="directive">实现</span> MyDao { <span class="directive">public</span> OutputObject getData（InputObject input）{ECIInteractionSpec interactionSpec = ...; OutputObject output =（ <span class="predefined-type">ObjectOutput</span> ）getCciTemplate（）。execute（interactionSpec， <span class="keyword">new</span> RecordCreator（）{ <span class="directive">public</span> Record createRecord（RecordFactory recordFactory） <span class="directive">抛出</span> ResourceException { <span class="keyword">return</span> <span class="keyword">new</span> CommAreaRecord（input.toString（）。getBytes（））;}}， <span class="keyword">new</span> RecordExtractor（ ）{ <span class="directive">公共</span> <span class="predefined-type">对象</span> ExtractData由（记录记录） <span class="directive">抛出</span> ResourceException {CommAreaRecord commAreaRecord =（CommAreaRecord）记录; <span class="predefined-type">字符串</span> str = <span class="keyword">新</span> <span class="predefined-type">字符串</span> （commAreaRecord.toByteArray（））; <span class="predefined-type">字符串</span>字段1 = <span class="integer"><span class="integer">string.substring（0，6）;</span></span> <span class="predefined-type">字符串</span> FIELD2 =字符串。子<span class="integer"><span class="integer">（6,1）;</span></span> <span class="keyword">新</span> <span class="keyword">返回</span> OutputObject（ <span class="predefined-type">龙</span> .parseLong（FIELD1），FIELD2）;}}）; <span class="keyword">返回</span>输出; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，回调可用于直接在CCI连接或交互上工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyDaoImpl</span> <span class="directive">扩展</span> CciDaoSupport <span class="directive">实现</span> MyDao { <span class="directive">public</span> OutputObject getData（InputObject input）{ <span class="predefined-type">ObjectOutput</span> output =（ <span class="predefined-type">ObjectOutput</span> ）getCciTemplate（）。execute（ <span class="keyword">new</span> ConnectionCallback（）{ <span class="directive">public</span> <span class="predefined-type">Object</span> doInConnection（ <span class="predefined-type">Connection</span> connection，ConnectionFactory factory） <span class="directive">throws</span> ResourceException { <span class="comment">//做某事...</span>}}; } <span class="keyword">return</span> output; }}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用<code>ConnectionCallback</code> ，所使用的<code>Connection</code>将由<code>CciTemplate</code>管理和关闭，但在连接上创建的任何交互都必须由回调实现进行管理。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于更具体的回调，您可以实现<code>InteractionCallback</code> 。在这种情况下，传入的<code>Interaction</code>将由<code>CciTemplate</code>管理和关闭。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyDaoImpl</span> <span class="directive">扩展</span> CciDaoSupport <span class="directive">实现</span> MyDao { <span class="directive">public</span> <span class="predefined-type">String</span> getData（ <span class="predefined-type">String</span> input）{ECIInteractionSpec interactionSpec = ...; <span class="predefined-type">String</span> output =（ <span class="predefined-type">String</span> ）getCciTemplate（）。execute（interactionSpec， <span class="keyword">new</span> InteractionCallback（）{ <span class="directive">public</span> <span class="predefined-type">Object</span> doInInteraction（Interaction interaction，ConnectionFactory factory） <span class="directive">throws</span> ResourceException {Record input = <span class="keyword">new</span> CommAreaRecord（inputString.getBytes（））; Record output = <span class="keyword">new</span> CommAreaRecord （）; interaction.execute（holder.getInteractionSpec（），input，output）; <span class="keyword">返回</span> <span class="keyword">new</span> <span class="predefined-type">String</span> （output.toByteArray（））;}}）; <span class="keyword">返回</span>输出; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于上面的示例，所涉及的Spring bean的相应配置在非托管模式下可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.ibm.connector2.cics。ECIManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TXSERIES</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">local：</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">CICSUSER</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">CICS</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。LocalConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">component</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mypackage。MyDaoImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在托管模式下（即在Java EE环境中），配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eis / cicseci</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">component</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">MyDaoImpl</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt; /豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cci-object"><a class="anchor" href="#cci-object"></a> 5.4。将CCI访问建模为操作对象</h3>
<div class="paragraph">
<p><code>org.springframework.jca.cci.object</code>包中包含支持类，允许您以不同的方式访问EIS：通过可重用的操作对象，类似于Spring的JDBC操作对象（请参阅JDBC章节）。这通常会封装CCI API：应用程序级输入对象将传递给操作对象，因此它可以构造输入记录，然后将接收到的记录数据转换为应用程序级输出对象并返回它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种方法在内部基于<code>CciTemplate</code>类和<code>RecordCreator</code> / <code>RecordExtractor</code>接口，重用Spring的核心CCI支持机制。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="cci-object-mapping-record"><a class="anchor" href="#cci-object-mapping-record"></a> 5.4.1。MappingRecordOperation</h4>
<div class="paragraph">
<p><code>MappingRecordOperation</code>基本上执行与<code>CciTemplate</code>相同的工作，但将特定的预配置操作表示为对象。它提供了两种模板方法来指定如何将输入对象转换为输入记录，以及如何将输出记录转换为输出对象（记录映射）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>createInputRecord(..)</code>指定如何将输入对象转换为输入<code>Record</code></p>
</li>
<li>
<p><code>extractOutputData(..)</code>指定如何从输出<code>Record</code>提取输出对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下是这些方法的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="directive">抽象</span> <span class="type">类</span> <span class="class">MappingRecordOperation</span> <span class="directive">扩展了</span> EisOperation {...protected <span class="directive">abstract</span> Record createInputRecord（RecordFactory recordFactory， <span class="predefined-type">Object</span> inputObject） <span class="directive">抛出</span> ResourceException，DataAccessException { <span class="comment">// ...</span><span class="directive">protected</span> <span class="directive">abstract</span> <span class="predefined-type">Object</span> extractOutputData（Record outputRecord） <span class="directive">抛出</span> ResourceException， <span class="exception">SQLException</span> ，DataAccessException { <span class="comment">// ...</span>} ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此后，为了执行EIS操作，您需要使用单个execute方法，传入应用程序级输入对象并接收应用程序级输出对象，结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="directive">抽象</span> <span class="type">类</span> <span class="class">MappingRecordOperation</span> <span class="directive">扩展了</span> EisOperation {...public <span class="predefined-type">Object</span> execute（ <span class="predefined-type">Object</span> inputObject） <span class="directive">抛出</span> DataAccessException {} ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，与<code>CciTemplate</code>类相反，此<code>execute(..)</code>方法没有<code>InteractionSpec</code>作为参数。相反， <code>InteractionSpec</code>是操作的全局。必须使用以下构造函数来实例化具有特定<code>InteractionSpec</code>的操作对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">InteractionSpec spec = ...; MyMappingRecordOperation eisOperation = <span class="keyword">new</span> MyMappingRecordOperation（getConnectionFactory（），spec）; ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-object-mapping-comm-area"><a class="anchor" href="#cci-object-mapping-comm-area"></a> 5.4.2。MappingCommAreaOperation</h4>
<div class="paragraph">
<p>某些连接器使用基于COMMAREA的记录，该记录表示包含要发送到EIS的参数和由其返回的数据的字节数组。Spring提供了一个特殊的操作类，用于直接在COMMAREA而不是记录上工作。<code>MappingCommAreaOperation</code>类扩展了<code>MappingRecordOperation</code>类，以提供这种特殊的COMMAREA支持。它隐式使用<code>CommAreaRecord</code>类作为输入和输出记录类型，并提供两种新方法将输入对象转换为输入COMMAREA，将输出COMMAREA转换为输出对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="directive">抽象</span> <span class="type">类</span> <span class="class">MappingCommAreaOperation</span> <span class="directive">扩展</span> MappingRecordOperation {...protected <span class="directive">abstract</span> <span class="type">byte</span> <span class="type">[]</span> objectToBytes（ <span class="predefined-type">Object</span> inObject） <span class="directive">抛出</span> <span class="exception">IOException</span> ，DataAccessException; <span class="directive">protected</span> <span class="directive">abstract</span> <span class="predefined-type">Object</span> bytesToObject（ <span class="type">byte</span> <span class="type">[]</span> bytes） <span class="directive">抛出</span> <span class="exception">IOException</span> ，DataAccessException; ...}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-automatic-record-gen"><a class="anchor" href="#cci-automatic-record-gen"></a> 5.4.3。自动输出记录生成</h4>
<div class="paragraph">
<p>由于每个<code>MappingRecordOperation</code>子类都在内部基于CciTemplate，因此可以使用与<code>CciTemplate</code>一样自动生成输出记录的相同方法。每个操作对象都提供相应的<code>setOutputRecordCreator(..)</code>方法。有关详细信息，请参阅<a href="#automatic-output-generation">自动输出记录生成</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cci-object-summary"><a class="anchor" href="#cci-object-summary"></a> 5.4.4。概要</h4>
<div class="paragraph">
<p>操作对象方法以与<code>CciTemplate</code>类相同的方式使用记录。</p>
</div>
<table id="cci-interaction-methods" class="tableblock frame-all grid-all spread">
<caption class="title">表10。使用交互执行方法</caption>
<colgroup>
<col style="width:42.8571%">
<col style="width:14.2857%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">MappingRecordOperation方法签名</th>
<th class="tableblock halign-left valign-top">MappingRecordOperation outputRecordCreator属性</th>
<th class="tableblock halign-left valign-top">在CCI Interaction上调用的execute方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">对象执行（对象）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录执行（InteractionSpec，Record）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">对象执行（对象）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔执行（InteractionSpec，Record，Record）</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="cci-objects-mappring-record-example"><a class="anchor" href="#cci-objects-mappring-record-example"></a> 5.4.5。MappingRecordOperation用法示例</h4>
<div class="paragraph">
<p>在本节中，将显示<code>MappingRecordOperation</code>的用法，以使用Blackbox CCI连接器访问数据库。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此连接器的原始版本由Oracle提供的Java EE SDK（版本1.3）提供。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先，必须对CCI <code>InteractionSpec</code>进行一些初始化，以指定要执行的SQL请求。在此示例中，我们直接定义将请求的参数转换为CCI记录的方式以及将CCI结果记录转换为<code>Person</code>类的实例的方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonMappingOperation</span> <span class="directive">extends</span> MappingRecordOperation { <span class="directive">public</span> PersonMappingOperation（ConnectionFactory connectionFactory）{setConnectionFactory（connectionFactory）; CciInteractionSpec interactionSpec = <span class="keyword">new</span> CciConnectionSpec（）; interactionSpec.setSql（ <span class="string"><span class="delimiter">“</span> <span class="content">select * from person where person_id =？</span><span class="delimiter">“</span></span> ）; setInteractionSpec（interactionSpec）;} <span class="directive">protected</span> Record createInputRecord（RecordFactory recordFactory， <span class="predefined-type">Object</span> inputObject） <span class="directive">throws</span> ResourceException { <span class="predefined-type">Integer</span> id =（ <span class="predefined-type">Integer</span> ）inputObject; IndexedRecord input = recordFactory.createIndexedRecord（ <span class="string"><span class="delimiter">”</span> <span class="content">input</span> <span class="delimiter">“</span></span> ）; input.add（ <span class="keyword">new</span> <span class="predefined-type">Integer</span> （id） ）;; <span class="keyword">返回</span>输入;} <span class="directive">protected</span> <span class="predefined-type">Object</span> extractOutputData（Record outputRecord） <span class="directive">抛出</span> ResourceException， <span class="exception">SQLException</span> { <span class="predefined-type">ResultSet</span> rs =（ <span class="predefined-type">ResultSet</span> ）outputRecord; Person person = <span class="predefined-constant">null</span> ; <span class="keyword">if</span> （rs.next（））{Person person = <span class="keyword">new</span> Person（）; person .setId（rs.getInt（ <span class="string"><span class="delimiter">“</span> <span class="content">person_id</span> <span class="delimiter">”</span></span> ））; person.setLastName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">person_last_name</span> <span class="delimiter">”</span></span> ））; person.setFirstName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">person_first_name</span> <span class="delimiter">”</span></span> ））;} <span class="keyword">return</span> person;}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后应用程序可以执行操作对象，并将人员标识符作为参数。请注意，操作对象可以设置为共享实例，因为它是线程安全的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyDaoImpl</span> <span class="directive">扩展</span> CciDaoSupport <span class="directive">实现</span> MyDao { <span class="directive">public</span> Person getPerson（ <span class="type">int</span> id）{PersonMappingOperation query = <span class="keyword">new</span> PersonMappingOperation（getConnectionFactory（））;人员=（人）query.execute（ <span class="keyword">new</span> <span class="predefined-type">Integer</span> （id））; <span class="keyword">回报</span>者; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在非托管模式下，Spring bean的相应配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.sun.connector.cciblackbox。CciLocalTxManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：hsqldb：hsql：// localhost：9001</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.hsqldb.jdbcDriver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。LocalConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jca.cci.connection。ConnectionSpecConnectionFactoryAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.sun.connector.cciblackbox。CciConnectionSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">user</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sa</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">password</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">component</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">MyDaoImpl</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在托管模式下（即在Java EE环境中），配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eis / blackbox</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.cci.connection。ConnectionSpecConnectionFactoryAdapter</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.sun.connector.cciblackbox。CciConnectionSpec</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">user</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sa</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">password</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">component</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">MyDaoImpl</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-objects-mapping-comm-area-example"><a class="anchor" href="#cci-objects-mapping-comm-area-example"></a> 5.4.6。MappingCommAreaOperation用法示例</h4>
<div class="paragraph">
<p>在本节中，将显示<code>MappingCommAreaOperation</code>的用法：使用IBM CICS ECI连接器以ECI模式访问CICS。</p>
</div>
<div class="paragraph">
<p>首先，需要初始化CCI <code>InteractionSpec</code>以指定要访问的CICS程序以及如何与之交互。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">EciMappingOperation</span> <span class="directive">extends</span> MappingCommAreaOperation { <span class="directive">public</span> EciMappingOperation（ConnectionFactory connectionFactory， <span class="predefined-type">String</span> programName）{setConnectionFactory（connectionFactory）; ECIInteractionSpec interactionSpec = <span class="keyword">new</span> ECIInteractionSpec（），interactionSpec.setFunctionName（programName）; interactionSpec.setInteractionVerb（ECIInteractionSpec.SYNC_SEND_RECEIVE）; interactionSpec.setCommareaLength（ <span class="integer">30</span> ）; setInteractionSpec（的InteractionSpec）; setOutputRecordCreator（ <span class="keyword">new</span> EciOutputRecordCreator（））; <span class="directive">私有</span> <span class="directive">静态</span> <span class="type">类</span> <span class="class">EciOutputRecordCreator</span> <span class="directive">实现</span> RecordCreator { <span class="directive">public</span> Record createRecord（RecordFactory recordFactory） <span class="directive">throws</span> ResourceException { <span class="keyword">return</span> <span class="keyword">new</span> CommAreaRecord（）; }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以对抽象的<code>EciMappingOperation</code>类进行子类化，以指定自定义对象和<code>Records</code>之间的映射。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyDaoImpl</span> <span class="directive">扩展</span> CciDaoSupport <span class="directive">实现</span> MyDao { <span class="directive">public</span> OutputObject getData（ <span class="predefined-type">Integer</span> id）{EciMappingOperation query = <span class="keyword">new</span> EciMappingOperation（getConnectionFactory（）， <span class="string"><span class="delimiter">“</span> <span class="content">MYPROG</span> <span class="delimiter">”</span></span> ）{ <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">byte</span> <span class="type">[]</span> objectToBytes（ <span class="predefined-type">Object</span> inObject） <span class="directive">throws</span> <span class="exception">IOException</span> { <span class="predefined-type">Integer</span> id =（ <span class="predefined-type">Integer</span> ） inObject; <span class="keyword">return</span> <span class="predefined-type">String</span> .valueOf（id）; <span class="directive">protected</span> <span class="directive">abstract</span> <span class="predefined-type">Object</span> bytesToObject（ <span class="type">byte</span> <span class="type">[]</span> bytes） <span class="directive">抛出</span> <span class="exception">IOException</span> ; <span class="predefined-type">String</span> str = <span class="keyword">new</span> <span class="predefined-type">String</span> （bytes）; <span class="predefined-type">串</span> FIELD1 = <span class="integer"><span class="integer">str.substring（0，6）;</span></span> <span class="predefined-type">串</span> FIELD2 = <span class="integer"><span class="integer">str.substring（6,1）;</span></span> <span class="predefined-type">串</span>字段3 = <span class="integer"><span class="integer">str.substring（7,1）;</span></span> <span class="keyword">返回</span> <span class="keyword">新的</span> OutputObject（field1，field2，field3）; }}; <span class="keyword">return</span> （OutputObject）query.execute（ <span class="keyword">new</span> <span class="predefined-type">Integer</span> （id））; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在非托管模式下，Spring bean的相应配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.ibm.connector2.cics。ECIManagedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serverName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">TXSERIES</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionURL</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">local：</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">CICSUSER</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">CICS</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.support。LocalConnectionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">managedConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">component</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">MyDaoImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在托管模式下（即在Java EE环境中），配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eis / cicseci</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">component</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">MyDaoImpl</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">connectionFactory</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt; /豆&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cci-tx"><a class="anchor" href="#cci-tx"></a> 5.5。交易</h3>
<div class="paragraph">
<p>JCA为资源适配器指定了几个级别的事务支持。资源适配器支持的事务类型在其<code>ra.xml</code>文件中指定。基本上有三个选项：none（例如，使用CICS EPI连接器），本地事务（例如使用CICS ECI连接器），全局事务（例如使用IMS连接器）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;connector&gt;</span> <span class="tag">&lt;resourceadapter&gt;</span> <span class="comment">&lt;！ -  &lt;transaction-support&gt; NoTransaction &lt;/ transaction-support&gt;  - &gt;</span> <span class="comment">&lt;！ -  &lt;transaction-support&gt; LocalTransaction &lt;/ transaction-support&gt;  - &gt;</span> <span class="tag">&lt;transaction-support&gt;</span> XATransaction <span class="tag">&lt;/ transaction-support&gt;</span> <span class="tag">&lt;resourceadapter&gt;</span> <span class="tag">&lt;connector&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于全局事务，您可以使用Spring的通用事务基础结构来划分事务，使用<code>JtaTransactionManager</code>作为后端（委托给下面的Java EE服务器的分布式事务协调器）。</p>
</div>
<div class="paragraph">
<p>对于单个CCI <code>ConnectionFactory</code>上的本地事务，Spring为CCI提供了一个特定的事务管理策略，类似于JDBC的<code>DataSourceTransactionManager</code> 。 CCI API定义了本地事务对象和相应的本地事务划分方法。Spring的<code>CciLocalTransactionManager</code>执行这样的本地CCI事务，完全符合Spring的通用<code>PlatformTransactionManager</code>抽象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciConnectionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eis / cicseci</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">eciTransactionManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jca.cci.connection。CciLocalTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">connectionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">eciConnectionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>两种事务策略都可以与Spring的任何事务划分工具一起使用，无论是声明性的还是编程式的。这是Spring的通用<code>PlatformTransactionManager</code>抽象的结果，它将事务划分与实际执行策略分离。只需根据需要在<code>JtaTransactionManager</code>和<code>CciLocalTransactionManager</code>之间切换，保持您的事务划分按原样。</p>
</div>
<div class="paragraph">
<p>有关Spring的事务处理设施的更多信息，请参阅“ <a href="data-access.html#transaction">事务管理</a> ”一章。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mail"><a class="anchor" href="#mail"></a> 6。电子邮件</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="mail-introduction"><a class="anchor" href="#mail-introduction"></a> 6.1。介绍</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">库依赖项</div>
<div class="paragraph">
<p>以下JAR需要位于应用程序的类路径中才能使用Spring Framework的电子邮件库。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://java.net/projects/javamail/pages/Home">JavaMail</a>库</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该库可在Web上免费获取 - 例如，在Maven Central中以<code>com.sun.mail:javax.mail</code> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Framework提供了一个有用的实用程序库，用于发送电子邮件，保护用户免受底层邮件系统的细节影响，并负责代表客户端进行低级资源处理。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.mail</code>包是Spring Framework电子邮件支持的根级包。发送电子邮件的中央界面是<code>MailSender</code>界面;简单的值对象封装了简单邮件的属性，例如<em>from</em>和<em>to</em> （以及许多其他的）是<code>SimpleMailMessage</code>类。此程序包还包含已检查异常的层次结构，这些异常提供了较低级别邮件系统异常的更高级别的抽象，根异常为<code>MailException</code> 。有关富邮件异常层次结构的更多信息，请参阅javadocs。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.mail.javamail.JavaMailSender</code>接口向<code>MailSender</code>接口（从中继承）添加了专门的<em>JavaMail</em>功能，例如MIME消息支持。<code>JavaMailSender</code>还提供了一个回调接口，用于准备一个名为<code>org.springframework.mail.javamail.的“MimeMessage” <code>org.springframework.mail.javamail.MimeMessagePreparator</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="mail-usage"><a class="anchor" href="#mail-usage"></a> 6.2。用法</h3>
<div class="paragraph">
<p>我们假设有一个名为<code>OrderManager</code>的业务接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">OrderManager</span> { <span class="type">void</span> placeOrder（Order order）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还假设需要说明需要生成带有订单号的电子邮件消息并将其发送给放置相关订单的客户。</p>
</div>
<div class="sect3">
<h4 id="mail-usage-simple"><a class="anchor" href="#mail-usage-simple"></a> 6.2.1。基本MailSender和SimpleMailMessage用法</h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.mail。MailException</span> ; <span class="keyword">import</span> <span class="include">org.springframework.mail。MailSender</span> ; <span class="keyword">import</span> <span class="include">org.springframework.mail。SimpleMailMessage</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleOrderManager</span> <span class="directive">实现</span> OrderManager { <span class="directive">private</span> MailSender mailSender; <span class="directive">private</span> SimpleMailMessage templateMessage; <span class="directive">public</span> <span class="type">void</span> setMailSender（MailSender mailSender）{ <span class="local-variable">this</span> .mailSender = mailSender; <span class="directive">public</span> <span class="type">void</span> setTemplateMessage（SimpleMailMessage templateMessage）{ <span class="local-variable">this</span> .templateMessage = templateMessage; } <span class="directive">public</span> <span class="type">void</span> placeOrder（Order order）{ <span class="comment">//进行业务计算......</span>

        <span class="comment">//致电协作者以保留订单...</span>

        <span class="comment">//创建模板消息的线程安全“副本”并自定义它</span> SimpleMailMessage msg = <span class="keyword">new</span> SimpleMailMessage（ <span class="local-variable">this</span> .templateMessage）; msg.setTo（order.getCustomer（）getEmailAddress（））; msg.setText（ <span class="string"><span class="delimiter">“</span> <span class="content">亲爱的</span> <span class="delimiter">”</span></span> + order.getCustomer（）。getFirstName（）+ order.getCustomer（）。getLastName（）+ <span class="string"><span class="delimiter">“</span> <span class="content">，感谢您下订单。您的订单号是</span> <span class="delimiter">“</span></span> + order.getOrderNumber（））; <span class="keyword">尝试</span> { <span class="local-variable">this</span> .mailSender.send（msg）;} <span class="keyword">catch</span> （MailException ex）{ <span class="comment">//只需登录并继续...</span>
            <span class="predefined-type">System</span> .err.println（ex.getMessage（））; }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下面找到上面代码的bean定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mailSender</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.mail.javamail。JavaMailSenderImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">host</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mail.mycompany.com</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 这是我们可以使用默认状态预加载的模板消息 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">templateMessage</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.mail。SimpleMailMessage</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">from</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">customerservice@mycompany.com</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">subject</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">您的订单</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">orderManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.mycompany.businessapp.support。SimpleOrderManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mailSender</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mailSender</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">templateMessage</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">templateMessage</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-usage-mime"><a class="anchor" href="#mail-usage-mime"></a> 6.2.2。使用JavaMailSender和MimeMessagePreparator</h4>
<div class="paragraph">
<p>这是使用<code>MimeMessagePreparator</code>回调接口的<code>OrderManager</code>另一个实现。请注意，在这种情况下， <code>mailSender</code>属性的类型为<code>JavaMailSender</code>以便我们能够使用JavaMail <code>MimeMessage</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.mail。消息</span> ; <span class="keyword">import</span> <span class="include">javax.mail。MessagingException</span> ; <span class="keyword">import</span> <span class="include">javax.mail.internet。InternetAddress</span> ; <span class="keyword">import</span> <span class="include">javax.mail.internet。MimeMessage</span> ; <span class="keyword">import</span> <span class="include">javax.mail.internet。MimeMessage</span> ; <span class="keyword">import</span> <span class="include">org.springframework.mail。MailException</span> ; <span class="keyword">import</span> <span class="include">org.springframework.mail.javamail。JavaMailSender</span> ; <span class="keyword">import</span> <span class="include">org.springframework.mail.javamail。MimeMessagePreparator</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleOrderManager</span> <span class="directive">实现</span> OrderManager { <span class="directive">private</span> JavaMailSender mailSender; <span class="directive">public</span> <span class="type">void</span> setMailSender（JavaMailSender mailSender）{ <span class="local-variable">this</span> .mailSender = mailSender; } <span class="directive">public</span> <span class="type">void</span> placeOrder（ <span class="directive">final</span> Order order）{ <span class="comment">//进行业务计算......</span>
        <span class="comment">//致电协作者以保留订单...</span>MimeMessagePreparator前缀= <span class="keyword">new</span> MimeMessagePreparator（）{ <span class="directive">public</span> <span class="type">void</span> prepare（MimeMessage mimeMessage） <span class="directive">抛出</span> <span class="exception">异常</span> {mimeMessage.setRecipient（消息。RecipientType。TO， <span class="keyword">新的</span> InternetAddress（order.getCustomer（）。getEmailAddress（）））; mimeMessage.setFrom（ <span class="keyword">new</span> InternetAddress（ <span class="string"><span class="delimiter">“</span> <span class="content">mail@mycompany.com</span> <span class="delimiter">”</span></span> ））; mimeMessage.setText（ <span class="string"><span class="delimiter">“</span> <span class="content">亲爱的</span> <span class="delimiter">”</span></span> + order.getCustomer（）。getFirstName（）+ <span class="string"><span class="delimiter">“</span> <span class="content"> </span> <span class="delimiter">“</span></span> + order.getCustomer（）。getLastName（）+ <span class="string"><span class="delimiter">”</span> <span class="content">，感谢您的订单。</span> <span class="delimiter">“</span></span> + <span class="string"><span class="delimiter">”</span> <span class="content">您的订单号是</span> <span class="delimiter">“</span></span> + order.getOrderNumber（）+ <span class="string"><span class="delimiter">”</span> <span class="content">。</span> <span class="delimiter">“</span></span> ）;}}; <span class="keyword">尝试</span> { <span class="local-variable">this</span> .mailSender.send（preprator）;} <span class="keyword">catch</span> （MailException ex）{ <span class="comment">//只需登录并继续...</span>
            <span class="predefined-type">System</span> .err.println（ex.getMessage（））; }}}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>邮件代码是一个横切关注点，很可能是重构为<a href="core.html#aop">自定义Spring AOP方面</a>的候选者，然后可以在<code>OrderManager</code>目标上的适当连接点执行。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Framework的邮件支持附带标准的JavaMail实现。有关更多信息，请参阅相关的javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mail-javamail-mime"><a class="anchor" href="#mail-javamail-mime"></a> 6.3。使用JavaMail MimeMessageHelper</h3>
<div class="paragraph">
<p>在处理JavaMail消息时非常方便的类是<code>org.springframework.mail.javamail.MimeMessageHelper</code>类，它使您不必使用详细的JavaMail API。使用<code>MimeMessageHelper</code>可以非常轻松地创建<code>MimeMessage</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//当然你会在任何真实案例中使用DI</span> JavaMailSenderImpl sender = <span class="keyword">new</span> JavaMailSenderImpl（）; sender.setHost（ <span class="string"><span class="delimiter">“</span> <span class="content">mail.host.com</span> <span class="delimiter">”</span></span> ）; MimeMessage message = sender.createMimeMessage（）; MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper（message）; helper.setTo（ <span class="string"><span class="delimiter">“</span> <span class="content">test@host.com</span> <span class="delimiter">”</span></span> ）; helper.setText（ <span class="string"><span class="delimiter">“</span> <span class="content">感谢您的订购！</span><span class="delimiter">“</span></span> ）; sender.send（message）;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="mail-javamail-mime-attachments"><a class="anchor" href="#mail-javamail-mime-attachments"></a> 6.3.1。发送附件和内联资源</h4>
<div class="paragraph">
<p>多部分电子邮件消息允许附件和内联资源。内联资源的示例可能是您要在邮件中使用的图像或样式表，但您不希望将其显示为附件。</p>
</div>
<div class="sect4">
<h5 id="mail-javamail-mime-attachments-attachment"><a class="anchor" href="#mail-javamail-mime-attachments-attachment"></a>附件</h5>
<div class="paragraph">
<p>以下示例显示如何使用<code>MimeMessageHelper</code>发送电子邮件以及单个JPEG图像附件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">JavaMailSenderImpl sender = <span class="keyword">new</span> JavaMailSenderImpl（）; sender.setHost（ <span class="string"><span class="delimiter">“</span> <span class="content">mail.host.com</span> <span class="delimiter">”</span></span> ）; MimeMessage message = sender.createMimeMessage（）; <span class="comment">//使用true标志表示你需要一个多部分消息</span> MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper（message， <span class="predefined-constant">true</span> ）; helper.setTo（ <span class="string"><span class="delimiter">“</span> <span class="content">test@host.com</span> <span class="delimiter">”</span></span> ）; helper.setText（ <span class="string"><span class="delimiter">“</span> <span class="content">查看此图片！</span><span class="delimiter">“</span></span> ）; <span class="comment">//让我们附上臭名昭着的Windows示例文件（这次复制到c：/）</span> FileSystemResource file = <span class="keyword">new</span> FileSystemResource（ <span class="keyword">new</span> <span class="predefined-type">File</span> （ <span class="string"><span class="delimiter">”</span> <span class="content">c：/Sample.jpg</span> <span class="delimiter">“</span></span> ））; helper.addAttachment（ <span class="string"><span class="delimiter">”</span> <span class="content">CoolImage.jpg</span> <span class="delimiter">“</span></span> ，file）; sender.send（message）;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mail-javamail-mime-attachments-inline"><a class="anchor" href="#mail-javamail-mime-attachments-inline"></a>内联资源</h5>
<div class="paragraph">
<p>以下示例说明如何使用<code>MimeMessageHelper</code>发送电子邮件以及内嵌图像。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">JavaMailSenderImpl sender = <span class="keyword">new</span> JavaMailSenderImpl（）; sender.setHost（ <span class="string"><span class="delimiter">“</span> <span class="content">mail.host.com</span> <span class="delimiter">”</span></span> ）; MimeMessage message = sender.createMimeMessage（）; <span class="comment">//使用true标志表示你需要一个多部分消息</span> MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper（message， <span class="predefined-constant">true</span> ）; helper.setTo（ <span class="string"><span class="delimiter">“</span> <span class="content">test@host.com</span> <span class="delimiter">”</span></span> ）; <span class="comment">//使用true标志来指示包含的文本是HTML</span> helper.setText（ <span class="string"><span class="delimiter">“</span> <span class="content">&lt;html&gt; &lt;body&gt; &lt;img src ='cid：identifier1234'&gt; &lt;/ body&gt; &lt;/ html&gt;</span> <span class="delimiter">”</span></span> ， <span class="predefined-constant">true</span> ）; <span class="comment">//让我们包含臭名昭着的Windows示例文件（这次复制到c：/）</span> FileSystemResource res = <span class="keyword">new</span> FileSystemResource（ <span class="keyword">new</span> <span class="predefined-type">File</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">c：/Sample.jpg</span> <span class="delimiter">”</span></span> ））; helper.addInline（ <span class="string"><span class="delimiter">“</span> <span class="content">identifier1234</span> <span class="delimiter">”</span></span> ，res）; sender.send（消息）;</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用指定的<code>Content-ID</code> （上例中的<code>identifier1234</code> ）将内联资源添加到<code>MimeMessage</code> 。添加文本和资源的顺序<em>非常</em>重要。一定<em>要先添加文本</em> ，然后再<em>添加</em>资源。如果你反过来这样做，它将无法正常工作！</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-templates"><a class="anchor" href="#mail-templates"></a> 6.3.2。使用模板库创建电子邮件内容</h4>
<div class="paragraph">
<p>前面示例中的代码使用诸如<code>message.setText(..)</code>类的方法调用显式创建了电子邮件消息的内容。这对于简单的情况很好，并且在上述示例的上下文中是可以的，其目的是向您展示API的基础知识。</p>
</div>
<div class="paragraph">
<p>但是，在典型的企业应用程序中，出于多种原因，您不会使用上述方法创建电子邮件的内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Java代码创建基于HTML的电子邮件内容非常繁琐且容易出错</p>
</li>
<li>
<p>显示逻辑和业务逻辑之间没有明确的区别</p>
</li>
<li>
<p>更改电子邮件内容的显示结构需要编写Java代码，重新编译，重新部署......</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，解决这些问题的方法是使用诸如FreeMarker之类的模板库来定义电子邮件内容的显示结构。这使您的代码仅负责创建要在电子邮件模板中呈现的数据并发送电子邮件。当您的电子邮件内容变得相当复杂时，这绝对是一种最佳实践，而Spring Framework的FreeMarker支持类变得非常容易。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scheduling"><a class="anchor" href="#scheduling"></a> 7。任务执行和调度</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="scheduling-introduction"><a class="anchor" href="#scheduling-introduction"></a> 7.1。介绍</h3>
<div class="paragraph">
<p>Spring Framework分别使用<code>TaskExecutor</code>和<code>TaskScheduler</code>接口提供异步执行和任务调度的抽象。Spring还具有支持线程池或在应用程序服务器环境中委托给CommonJ的接口的实现。最终，在公共接口背后使用这些实现抽象出了Java SE 5，Java SE 6和Java EE环境之间的差异。</p>
</div>
<div class="paragraph">
<p>Spring还提供了集成类，用于支持使用<code>Timer</code> （自1.3以来的JDK的一部分）和Quartz Scheduler（ <a href="http://quartz-scheduler.org" class="bare">http://quartz-scheduler.org</a> ）进行调度。这两个调度程序都是使用<code>FactoryBean</code>设置的，它们分别具有对<code>Timer</code>或<code>Trigger</code>实例的可选引用。此外，还提供了Quartz Scheduler和<code>Timer</code>的便捷类，它允许您调用现有目标对象的方法（类似于正常的<code>MethodInvokingFactoryBean</code>操作）。</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-executor"><a class="anchor" href="#scheduling-task-executor"></a> 7.2。Spring TaskExecutor抽象</h3>
<div class="paragraph">
<p>执行程序是线程池概念的JDK名称。“执行程序”命名是由于无法保证底层实现实际上是一个池;执行程序可以是单线程甚至是同步的。Spring的抽象隐藏了Java SE和Java EE环境之间的实现细节。</p>
</div>
<div class="paragraph">
<p>Spring的<code>TaskExecutor</code>接口与<code>java.util.concurrent.相同<code>java.util.concurrent.Executor</code>界面。事实上，最初，它存在的主要原因是在使用线程池时抽象出对Java 5的需求。该接口具有单个方法<code>execute(Runnable task)</code> ，该方法基于线程池的语义和配置接受要执行的任务。</p>
</div>
<div class="paragraph">
<p>最初创建<code>TaskExecutor</code>是为了给其他Spring组件提供所需的线程池抽象。诸如<code>ApplicationEventMulticaster</code> ，JMS的<code>AbstractMessageListenerContainer</code>和Quartz集成之类的组件都使用<code>TaskExecutor</code>抽象来池化线程。但是，如果您的bean需要线程池行为，则可以根据自己的需要使用此抽象。</p>
</div>
<div class="sect3">
<h4 id="scheduling-task-executor-types"><a class="anchor" href="#scheduling-task-executor-types"></a> 7.2.1。TaskExecutor类型</h4>
<div class="paragraph">
<p>Spring发行版中包含许多预构建的<code>TaskExecutor</code>实现。很有可能，你永远不需要实现自己的。常见的开箱即用变体是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SyncTaskExecutor</code>此实现不会异步执行调用。相反，每次调用都在调用线程中进行。它主要用于不需要多线程的情况，例如简单的测试用例。</p>
</li>
<li>
<p><code>SimpleAsyncTaskExecutor</code>此实现不重用任何线程，而是为每次调用启动一个新线程。但是，它确实支持并发限制，该限制将阻止超出限制的任何调用，直到释放插槽为止。如果您正在寻找真正的池，请参阅下面的<code>ThreadPoolTaskExecutor</code> 。</p>
</li>
<li>
<p><code>ConcurrentTaskExecutor</code>此实现是<code>java.util.concurrent.的适配器<code>java.util.concurrent.Executor</code>实例。还有一个替代方案<code>ThreadPoolTaskExecutor</code> ，它将<code>Executor</code>配置参数公开为bean属性。很少需要直接使用<code>ConcurrentTaskExecutor</code> ，但如果<code>ThreadPoolTaskExecutor</code>不够灵活，无法满足您的需求，那么<code>ConcurrentTaskExecutor</code>是另一种选择。</p>
</li>
<li>
<p><code>ThreadPoolTaskExecutor</code>此实现是最常用的实现。它公开了bean属性以配置<code>java.util.concurrent.ThreadPoolExecutor</code>并将其包装在<code>TaskExecutor</code> 。如果你需要适应不同种类的<code>java.util.concurrent.Executor</code> ，建议您使用<code>ConcurrentTaskExecutor</code> 。</p>
</li>
<li>
<p><code>WorkManagerTaskExecutor</code>此实现使用CommonJ <code>WorkManager</code>作为其后备服务提供程序，并且是在Spring应用程序上下文中在WebLogic / WebSphere上设置基于CommonJ的线程池集成的中心便利类。</p>
</li>
<li>
<p><code>DefaultManagedTaskExecutor</code>此实现在JSR-236兼容的运行时环境（例如Java EE 7+应用程序服务器）中使用JNDI获取的<code>ManagedExecutorService</code> ，为此目的替换CommonJ WorkManager。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-executor-usage"><a class="anchor" href="#scheduling-task-executor-usage"></a> 7.2.2。使用TaskExecutor</h4>
<div class="paragraph">
<p>Spring的<code>TaskExecutor</code>实现用作简单的JavaBeans。在下面的示例中，我们定义了一个使用<code>ThreadPoolTaskExecutor</code>异步打印出一组消息的bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.core.task。TaskExecutor</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">TaskExecutorExample</span> { <span class="directive">private</span> <span class="type">class</span> <span class="class">MessagePrinterTask</span> <span class="directive">实现</span> <span class="predefined-type">Runnable</span> { <span class="directive">private</span> <span class="predefined-type">String</span> message; <span class="directive">public</span> MessagePrinterTask（ <span class="predefined-type">String</span> message）{ <span class="local-variable">this</span> .message = message; } <span class="directive">public</span> <span class="type">void</span> run（）{ <span class="predefined-type">System</span> .out.println（message）; <span class="directive">private</span> TaskExecutor taskExecutor; <span class="directive">public</span> TaskExecutorExample（TaskExecutor taskExecutor）{ <span class="local-variable">this</span> .taskExecutor = taskExecutor; <span class="directive">public</span> <span class="type">void</span> printMessages（）{ <span class="keyword">for</span> （ <span class="type">int</span> i = <span class="integer">0</span> ; i &lt; <span class="integer">25</span> ; i ++）{taskExecutor.execute（ <span class="keyword">new</span> MessagePrinterTask（ <span class="string"><span class="delimiter">“</span> <span class="content">Message</span> <span class="delimiter">”</span></span> + i））; }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，您不是从池中检索线程并自行执行，而是将<code>Runnable</code>添加到队列中， <code>TaskExecutor</code>使用其内部规则来决定何时执行任务。</p>
</div>
<div class="paragraph">
<p>要配置<code>TaskExecutor</code>将使用的规则，已公开简单的bean属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">taskExecutor</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling.concurrent。ThreadPoolTask​​Executor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">corePoolSize</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">5</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">maxPoolSize</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">queueCapacity</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">25</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt; bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">taskExecutorExample</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">TaskExecutorExample</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">taskExecutor</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-scheduler"><a class="anchor" href="#scheduling-task-scheduler"></a> 7.3。Spring TaskScheduler抽象</h3>
<div class="paragraph">
<p>除了<code>TaskExecutor</code>抽象之外，Spring 3.0还引入了一个<code>TaskScheduler</code> ，它具有各种方法，可以在将来的某个时刻调度任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">TaskScheduler</span> { <span class="predefined-type">ScheduledFuture</span> schedule（ <span class="predefined-type">Runnable</span> task，Trigger trigger）; <span class="predefined-type">ScheduledFuture</span> schedule（ <span class="predefined-type">Runnable</span> task，Instant startTime）; <span class="predefined-type">ScheduledFuture</span> schedule（ <span class="predefined-type">Runnable</span> task， <span class="predefined-type">Date</span> startTime）; <span class="predefined-type">ScheduledFuture</span> scheduleAtFixedRate（ <span class="predefined-type">Runnable</span> task，Instant startTime， <span class="predefined-type">Duration</span> period）; <span class="predefined-type">ScheduledFuture</span> scheduleAtFixedRate（ <span class="predefined-type">Runnable</span> task， <span class="predefined-type">Date</span> startTime， <span class="type">long</span> period）; <span class="predefined-type">ScheduledFuture</span> scheduleAtFixedRate（ <span class="predefined-type">Runnable</span> task， <span class="predefined-type">Duration</span> period）; <span class="predefined-type">ScheduledFuture</span> scheduleAtFixedRate（ <span class="predefined-type">Runnable</span> task， <span class="type">long</span> period）; <span class="predefined-type">ScheduledFuture</span> scheduleWithFixedDelay（ <span class="predefined-type">Runnable</span> task，Instant startTime， <span class="predefined-type">Duration</span> delay）; <span class="predefined-type">ScheduledFuture</span> scheduleWithFixedDelay（ <span class="predefined-type">Runnable</span> task， <span class="predefined-type">Date</span> startTime， <span class="type">long</span> delay）; <span class="predefined-type">ScheduledFuture</span> scheduleWithFixedDelay（ <span class="predefined-type">Runnable</span> task， <span class="predefined-type">Duration</span> delay）; <span class="predefined-type">ScheduledFuture</span> scheduleWithFixedDelay（ <span class="predefined-type">Runnable</span> task， <span class="type">long</span> delay）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>最简单的方法是名为'schedule'的方法，它只采用<code>Runnable</code>和<code>Date</code> 。这将导致任务在指定时间后运行一次。所有其他方法都能够安排任务重复运行。固定速率和固定延迟方法用于简单的定期执行，但接受触发的方法更灵活。</p>
</div>
<div class="sect3">
<h4 id="scheduling-trigger-interface"><a class="anchor" href="#scheduling-trigger-interface"></a> 7.3.1。触发界面</h4>
<div class="paragraph">
<p><code>Trigger</code>接口基本上受JSR-236的启发，从Spring 3.0开始，它尚未正式实现。<code>Trigger</code>的基本思想是可以基于过去的执行结果或甚至任意条件来确定执行时间。如果这些确定确实考虑了前面执行的结果，则该信息在<code>TriggerContext</code>可用。<code>Trigger</code>界面本身非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Trigger</span> { <span class="predefined-type">Date</span> nextExecutionTime（TriggerContext triggerContext）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>TriggerContext</code>是最重要的部分。它封装了所有相关数据，如有必要，将来可以进行扩展。<code>TriggerContext</code>是一个接口（默认情况下使用<code>SimpleTriggerContext</code>实现）。在这里，您可以看到<code>Trigger</code>实现可用的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">TriggerContext</span> { <span class="predefined-type">Date</span> lastScheduledExecutionTime（）; <span class="predefined-type">Date</span> lastActualExecutionTime（）; <span class="predefined-type">Date</span> lastCompletionTime（）; }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-trigger-implementations"><a class="anchor" href="#scheduling-trigger-implementations"></a> 7.3.2。触发器实现</h4>
<div class="paragraph">
<p>Spring提供了两个<code>Trigger</code>接口的实现。最有趣的是<code>CronTrigger</code> 。它支持基于cron表达式调度任务。例如，以下任务计划在每小时过去15分钟后运行，但仅在工作日的9到5个“营业时间”运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">scheduler.schedule（task， <span class="keyword">new</span> CronTrigger（ <span class="string"><span class="delimiter">“</span> <span class="content">0 15 9-17 * * MON-FRI</span> <span class="delimiter">”</span></span> ））;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个开箱即用的实现是<code>PeriodicTrigger</code> ，它接受固定周期，可选的初始延迟值和布尔值，以指示周期是应该被解释为固定速率还是固定延迟。由于<code>TaskScheduler</code>接口已经定义了以固定速率或固定延迟来调度任务的方法，因此应尽可能直接使用这些方法。<code>PeriodicTrigger</code>实现的值是它可以在依赖于<code>Trigger</code>抽象的组件中使用。例如，允许定期触发，基于cron的触发器甚至自定义触发器实现可以互换使用可能是方便的。这样的组件可以利用依赖性注入，以便可以在外部配置这样的<code>Triggers</code> ，从而容易地修改或扩展。</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-scheduler-implementations"><a class="anchor" href="#scheduling-task-scheduler-implementations"></a> 7.3.3。TaskScheduler实现</h4>
<div class="paragraph">
<p>与Spring的<code>TaskExecutor</code>抽象一样， <code>TaskScheduler</code>安排的主要好处是应用程序的调度需求与部署环境分离。在部署到不应由应用程序本身直接创建线程的应用程序服务器环境时，此抽象级别尤其重要。对于这样的场景，Spring提供了一个<code>TimerManagerTaskScheduler</code>委托给WebLogic / WebSphere上的CommonJ TimerManager，以及一个更新的<code>DefaultManagedTaskScheduler</code>委托给Java EE 7+环境中的JSR-236 <code>ManagedScheduledExecutorService</code> ，两者通常都配置了JNDI查找。</p>
</div>
<div class="paragraph">
<p>每当外部线程管理不是必需的时候，更简单的替代方案是应用程序中的本地<code>ScheduledExecutorService</code>设置，可以通过Spring的<code>ConcurrentTaskScheduler</code>进行调整。为方便起见，Spring还提供了一个<code>ThreadPoolTaskScheduler</code> ，它在内部委托给<code>ScheduledExecutorService</code> ，提供沿<code>ThreadPoolTaskExecutor</code>行的常见bean样式配置。这些变体适用于宽松应用程序服务器环境中的本地嵌入式线程池设置，特别是在Tomcat和Jetty上。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-annotation-support"><a class="anchor" href="#scheduling-annotation-support"></a> 7.4。调度和异步执行的注释支持</h3>
<div class="paragraph">
<p>Spring为任务调度和异步方法执行提供注释支持。</p>
</div>
<div class="sect3">
<h4 id="scheduling-enable-annotation-support"><a class="anchor" href="#scheduling-enable-annotation-support"></a> 7.4.1。启用计划注释</h4>
<div class="paragraph">
<p>要启用对<code>@Scheduled</code>和<code>@Async</code>注释的支持，请将<code>@EnableScheduling</code>和<code>@EnableAsync</code>添加到您的<code>@Configuration</code>类之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableAsync</span> <span class="annotation">@EnableScheduling</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以自由选择适合您应用的相关注释。例如，如果您只需要支持<code>@Scheduled</code> ，则只需省略<code>@EnableAsync</code> 。对于更细粒度的控制，您还可以实现<code>SchedulingConfigurer</code>和/或<code>AsyncConfigurer</code>接口。有关完整详细信息，请参阅javadocs。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢XML配置，请使用<code>&lt;task:annotation-driven&gt;</code>元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;task：annotation-driven</span> <span class="attribute-name">executor</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myExecutor</span> <span class="delimiter">”</span></span> <span class="attribute-name">scheduler</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myScheduler</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;task：executor</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myExecutor</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">5</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;task：scheduler</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myScheduler</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，上述XML提供了一个执行程序引用，用于处理与带有<code>@Async</code>注释的方法相对应的任务，并提供了调度程序引用来管理使用<code>@Scheduled</code>注释的方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>处理<code>@Async</code>注释的默认建议模式是“proxy”，它允许仅通过代理拦截调用;同一类中的本地调用不能以这种方式截获。对于更高级的拦截模式，请考虑结合编译时或加载时编织切换到“aspectj”模式。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-scheduled"><a class="anchor" href="#scheduling-annotation-support-scheduled"></a> 7.4.2。@Scheduled注释</h4>
<div class="paragraph">
<p><code>@Scheduled</code>注释可以与触发器元数据一起添加到方法中。例如，以固定延迟每5秒调用以下方法，这意味着将从每个前一次调用的完成时间开始测量该时间段。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scheduled</span> （fixedDelay = <span class="integer">5000</span> ） <span class="directive">public</span> <span class="type">void</span> doSomething（）{ <span class="comment">//应定期执行的内容</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要固定费率执行，只需更改注释中指定的属性名称即可。在每次调用的连续开始时间之间测量的每5秒执行以下操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scheduled</span> （fixedRate = <span class="integer">5000</span> ） <span class="directive">public</span> <span class="type">void</span> doSomething（）{ <span class="comment">//应该定期执行的东西</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于固定延迟和固定速率任务，可以指定初始延迟，指示在第一次执行该方法之前等待的毫秒数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scheduled</span> （initialDelay = <span class="integer">1000</span> ，fixedRate = <span class="integer">5000</span> ） <span class="directive">public</span> <span class="type">void</span> doSomething（）{ <span class="comment">//应定期执行的内容</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果简单的周期性调度不够表达，则可以提供cron表达式。例如，以下内容仅在工作日执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scheduled</span> （cron = <span class="string"><span class="delimiter">“</span> <span class="content">* / 5 * * * * MON-FRI</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> doSomething（）{ <span class="comment">//应该只在工作日执行的事情</span> }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您还可以使用<code>zone</code>属性指定解析cron表达式的时区。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请注意，要调度的方法必须具有void返回值，并且不得指望任何参数。如果该方法需要与Application Context中的其他对象进行交互，则通常会通过依赖注入提供这些对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.3开始，任何范围的bean都支持<code>@Scheduled</code>方法。</p>
</div>
<div class="paragraph">
<p>确保您没有在运行时初始化同一<code>@Scheduled</code>注释类的多个实例，除非您确实要为每个此类实例安排回调。与此相关，请确保不对使用<code>@Scheduled</code>注释的bean类使用<code>@Configurable</code> ，并将其注册为带有容器的常规Spring bean：否则将获得双初始化，一次通过容器，一次通过<code>@Configurable</code>方面，每个<code>@Scheduled</code>方法的结果被调用两次。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-async"><a class="anchor" href="#scheduling-annotation-support-async"></a> 7.4.3。@Async注释</h4>
<div class="paragraph">
<p>可以在方法上提供<code>@Async</code>注释，以便异步调用该方法。换句话说，调用者将在调用时立即返回，并且该方法的实际执行将发生在已提交给Spring <code>TaskExecutor</code> 。在最简单的情况下，注释可以应用于<code>void</code> recurning方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Async</span> <span class="type">void</span> doSomething（）{ <span class="comment">//这将以异步方式执行</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>与使用<code>@Scheduled</code>注释注释的方法不同，这些方法可以使用参数，因为它们将在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。例如，以下是<code>@Async</code>注释的合法应用程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Async</span> <span class="type">void</span> doSomething（ <span class="predefined-type">String</span> s）{ <span class="comment">//这将以异步方式执行</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至可以异步调用返回值的方法。但是，这些方法需要具有<code>Future</code>类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用Future上的<code>get()</code>之前执行其他任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Async</span> <span class="predefined-type">Future</span> &lt; <span class="predefined-type">String</span> &gt; <span class="annotation">returnSomething</span> （ <span class="type">int</span> i）{ <span class="comment">//这将以异步方式执行</span> }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Async</code>方法不仅可以声明一个常规的<code>java.util.concurrent.Future</code>返回类型还有Spring的<code>org.springframework.util.concurrent.ListenableFuture</code>或者从Spring 4.2开始，JDK 8的<code>java.util.concurrent.CompletableFuture</code> ：用于与异步任务进行更丰富的交互，并通过进一步的处理步骤立即进行组合。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Async</code>不能与生命周期回调一起使用，例如<code>@PostConstruct</code> 。要异步初始化Spring bean，您当前必须使用单独的初始化Spring bean，然后在目标上调用<code>@Async</code>注释的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SampleBeanImpl</span> <span class="directive">实现</span> SampleBean { <span class="annotation">@Async</span> <span class="type">void</span> doSomething（）{ <span class="comment">// ...</span><span class="directive">public</span> <span class="type">class</span> <span class="class">SampleBeanInitializer</span> { <span class="directive">private</span> <span class="directive">final</span> SampleBean bean; <span class="directive">public</span> SampleBeanInitializer（SampleBean bean）{ <span class="local-variable">this</span> .bean = bean; } <span class="annotation">@PostConstruct</span> <span class="directive">public</span> <span class="type">void</span> initialize（）{bean.doSomething（）; }}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Async</code>没有直接的XML等价物，因为这些方法应该首先设计用于异步执行，而不是外部重新声明为异步。但是，您可以使用Spring AOP手动设置Spring的<code>AsyncExecutionInterceptor</code> ，并结合自定义切入点。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-qualification"><a class="anchor" href="#scheduling-annotation-support-qualification"></a> 7.4.4。使用@Async执行者资格</h4>
<div class="paragraph">
<p>默认情况下，在方法上指定<code>@Async</code>时，将使用的执行程序是提供给“注释驱动”元素的执行程序，如上所述。但是，当需要指示在执行给定方法时应使用非默认执行程序时，可以使用<code>@Async</code>批注的<code>value</code>属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Async</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">otherExecutor</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> doSomething（ <span class="predefined-type">String</span> s）{ <span class="comment">//这将由“otherExecutor”异步执行</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，“otherExecutor”可以是Spring容器中任何<code>Executor</code> bean的名称，也可以是与任何<code>Executor</code>关联的<em>限定符</em>的名称，例如，使用<code>&lt;qualifier&gt;</code>元素或Spring的<code>@Qualifier</code>注释指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-exception"><a class="anchor" href="#scheduling-annotation-support-exception"></a> 7.4.5。使用@Async进行异常管理</h4>
<div class="paragraph">
<p>当<code>@Async</code>方法具有<code>Future</code>类型的返回值，它是易于管理这是该法的执行，因为这期间异常抛出调用时，将引发异常<code>get</code>在<code>Future</code>结果。但是，对于void返回类型，异常未被捕获且无法传输。对于这些情况，可以提供<code>AsyncUncaughtExceptionHandler</code>来处理此类异常。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyAsyncUncaughtExceptionHandler</span> <span class="directive">实现</span> AsyncUncaughtExceptionHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> <span class="predefined-type">handleUncaughtException（Throwable的</span>前， <span class="predefined-type">方法</span>方法， <span class="predefined-type">对象</span> ... <span class="comment">PARAMS）{//处理异常</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，只记录异常。可以<em>通过</em> <code>AsyncConfigurer</code>或<code>task:annotation-driven</code> XML元素定义自定义<code>AsyncUncaughtExceptionHandler</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-namespace"><a class="anchor" href="#scheduling-task-namespace"></a> 7.5。任务名称空间</h3>
<div class="paragraph">
<p>从Spring 3.0开始，有一个用于配置<code>TaskExecutor</code>和<code>TaskScheduler</code>实例的XML命名空间。它还提供了一种方便的方法来配置要使用触发器安排的任务。</p>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-scheduler"><a class="anchor" href="#scheduling-task-namespace-scheduler"></a> 7.5.1。'scheduler'元素</h4>
<div class="paragraph">
<p>以下元素将创建具有指定线程池大小的<code>ThreadPoolTaskScheduler</code>实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;task：scheduler</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">scheduler</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为'id'属性提供的值将用作池中线程名称的前缀。'scheduler'元素相对简单。如果未提供“pool-size”属性，则默认线程池将只有一个线程。调度程序没有其他配置选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-executor"><a class="anchor" href="#scheduling-task-namespace-executor"></a> 7.5.2。'executor'元素</h4>
<div class="paragraph">
<p>以下将创建一个<code>ThreadPoolTaskExecutor</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;task：executor</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">executor</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与上面的调度程序一样，为“id”属性提供的值将用作池中线程名称的前缀。就池大小而言，'executor'元素支持比'scheduler'元素更多的配置选项。首先， <code>ThreadPoolTaskExecutor</code>的线程池本身更易于配置。执行程序的线程池可能具有不同的<em>核心</em>值和<em>最大</em>大小，而不仅仅是单个大小。如果提供单个值，则执行程序将具有固定大小的线程池（核心和最大大小相同）。但是，'executor'元素的'pool-size'属性也接受“min-max”形式的范围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;task：executor</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">executorWithPoolSizeRange</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">5-25</span> <span class="delimiter">”</span></span> <span class="attribute-name">queue-capacity</span> = <span class="string"><span class="delimiter">“</span> <span class="content">100</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从该配置中可以看出，还提供了“队列容量”值。还应根据执行程序的队列容量来考虑线程池的配置。有关池大小和队列容量之间关系的完整描述，请参阅<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>的文档。主要思想是，当提交任务时，如果活动线程的数量当前小于核心大小，则执行程序将首先尝试使用空闲线程。如果已达到核心大小，则只要尚未达到其容量，任务就会添加到队列中。只有到那时，如果队列的容量<em>已经</em>达到，将执行程序创建一个新线程超出芯尺寸。如果还达到了最大大小，则执行程序将拒绝该任务。</p>
</div>
<div class="paragraph">
<p>默认情况下，队列是<em>无限制的</em> ，但这很少是所需的配置，因为如果在所有池线程忙的情况下将足够的任务添加到该队列，则可能导致<code>OutOfMemoryErrors</code> 。此外，如果队列是无界的，那么最大大小根本没有影响。由于执行器将始终在创建超出核心大小的新线程之前尝试队列，因此队列必须具有有限的容量，以使线程池增长超出核心大小（这就是为什么<em>固定大小的</em>池是使用时唯一合理的情况一个无限的队列）。</p>
</div>
<div class="paragraph">
<p>稍后，我们将回顾保持活动设置的效果，这增加了在提供池大小配置时要考虑的另一个因素。首先，如上所述，让我们考虑一个任务被拒绝的情况。默认情况下，当任务被拒绝时，线程池执行程序将抛出<code>TaskRejectedException</code> 。但是，拒绝策略实际上是可配置的。使用默认拒绝策略（ <code>AbortPolicy</code>实现）时会抛出异常。对于可以在高负载下跳过某些任务的应用程序，可以配置<code>DiscardPolicy</code>或<code>DiscardOldestPolicy</code> 。另一个适用于需要在高负载下限制提交的任务的应用程序的选项是<code>CallerRunsPolicy</code> 。该策略不会抛出异常或丢弃任务，而只是强制调用submit方法的线程自己运行任务。这个想法是这样的调用者在运行该任务时会很忙，并且不能立即提交其他任务。因此，它提供了一种简单的方法来限制传入的负载，同时保持线程池和队列的限制。通常，这允许执行程序“赶上”它正在处理的任务，从而释放队列，池中或两者中的一些容量。可以从'executor'元素上'rejection-policy'属性的可用值枚举中选择任何这些选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;task：executor</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">executorWithCallerRunsPolicy</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">5-25</span> <span class="delimiter">”</span></span> <span class="attribute-name">queue-capacity</span> = <span class="string"><span class="delimiter">“</span> <span class="content">100</span> <span class="delimiter">”</span></span> <span class="attribute-name">rejection-policy</span> = <span class="string"><span class="delimiter">“</span> <span class="content">CALLER_RUNS</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后， <code>keep-alive</code>设置确定线程在终止之前可以保持空闲的时间限制（以秒为单位）。如果池中当前有多个线程核心数，则在等待这段时间而不处理任务后，多余的线程将被终止。时间值为零将导致多余线程在执行任务后立即终止，而不会在任务队列中保留后续工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;task：executor</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">executorWithKeepAlive</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">5-25</span> <span class="delimiter">”</span></span> <span class="attribute-name">keep-alive</span> = <span class="string"><span class="delimiter">“</span> <span class="content">120</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-scheduled-tasks"><a class="anchor" href="#scheduling-task-namespace-scheduled-tasks"></a> 7.5.3。'scheduled-tasks'元素</h4>
<div class="paragraph">
<p>Spring的任务命名空间最强大的功能是支持在Spring Application Context中配置要安排的任务。这遵循类似于Spring中的其他“方法调用者”的方法，例如由JMS名称空间提供的用于配置消息驱动的POJO的方法。基本上，“ref”属性可以指向任何Spring管理的对象，“method”属性提供要在该对象上调用的方法的名称。这是一个简单的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;任务：调度任务</span> <span class="attribute-name">调度</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“myScheduler”&gt;</span></span></span></span></span> <span class="tag">&lt;任务：调度</span> <span class="attribute-name">REF</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“beanA”</span></span></span></span> <span class="attribute-name">方法</span> = <span class="string"><span class="delimiter">“</span> <span class="content">了<span class="delimiter">methodA”</span></span></span> <span class="attribute-name">固定延迟</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“5000”/&gt;</span></span></span></span></span> <span class="tag">&lt;/任务：调度任务&gt;</span> <span class="tag">&lt;任务：调度器</span> <span class="attribute-name">ID</span> <span class="string"><span class="delimiter">=“</span> <span class="content">myScheduler</span> <span class="delimiter">“</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">”</span> <span class="content">10</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，调度程序由外部元素引用，每个单独的任务都包含其触发器元数据的配置。在前面的示例中，该元数据定义了具有固定延迟的周期性触发器，该延迟指示在每个任务执行完成后等待的毫秒数。另一个选项是“固定速率”，表示无论先前执行多长时间，该方法应执行的频率。另外，对于固定延迟和固定速率任务，可以指定“初始延迟”参数，该参数指示在第一次执行该方法之前等待的毫秒数。为了更多控制，可以提供“cron”属性。以下是演示这些其他选项的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;任务：调度任务</span> <span class="attribute-name">调度</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“myScheduler”&gt;</span></span></span></span></span> <span class="tag">&lt;任务：调度</span> <span class="attribute-name">REF</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“beanA”</span></span></span></span> <span class="attribute-name">方法</span> = <span class="string"><span class="delimiter">“</span> <span class="content">了<span class="delimiter">methodA”</span></span></span> <span class="attribute-name">固定延迟</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“5000”</span></span></span></span> <span class="attribute-name">初始延迟</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“1000”/&gt;</span></span></span></span></span> <span class="tag">&lt;任务：调度</span> <span class="attribute-name">REF</span> <span class="string"><span class="delimiter"><span class="content">=“beanB</span></span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">methodB</span> <span class="delimiter">“</span></span> <span class="attribute-name">fixed-rate</span> = <span class="string"><span class="delimiter">”</span> <span class="content">5000</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;task：scheduled</span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">beanC</span> <span class="delimiter">“</span></span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">methodC</span> <span class="delimiter">“</span></span> <span class="attribute-name">cron</span> = <span class="string"><span class="delimiter">”</span> <span class="content">* / 5 * * * * MON-FRI</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ task：scheduled -tasks&gt;</span> <span class="tag">&lt;task：scheduler</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myScheduler</span> <span class="delimiter">”</span></span> <span class="attribute-name">pool-size</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-quartz"><a class="anchor" href="#scheduling-quartz"></a> 7.6。使用Quartz Scheduler</h3>
<div class="paragraph">
<p>Quartz使用<code>Trigger</code> ， <code>Job</code>和<code>JobDetail</code>对象来实现各种作业的调度。有关Quartz背后的基本概念，请查看<a href="http://quartz-scheduler.org" class="bare">http://quartz-scheduler.org</a> 。为方便起见，Spring提供了几个类，简化了基于Spring的应用程序中Quartz的使用。</p>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-jobdetail"><a class="anchor" href="#scheduling-quartz-jobdetail"></a> 7.6.1。使用JobDetailFactoryBean</h4>
<div class="paragraph">
<p>Quartz <code>JobDetail</code>对象包含运行作业所需的所有信息。Spring提供了一个<code>JobDetailFactoryBean</code> ，它为XML配置提供了bean样式的属性。我们来看一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleJob</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling.quartz。JobDetailFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jobClass</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">example。ExampleJob</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jobDataAsMap</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">timeout</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">5</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>作业详细信息配置包含运行作业所需的所有信息（ <code>ExampleJob</code> ）。超时在作业数据映射中指定。作业数据映射可通过<code>JobExecutionContext</code> （在执行时传递给您）获得，但<code>JobDetail</code>也从映射到作业实例属性的作业数据中获取其属性。因此，在这种情况下，如果<code>ExampleJob</code>包含名为<code>timeout</code>的bean属性，则<code>JobDetail</code>将自动应用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包装</span> <span class="namespace">示例</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">ExampleJob中</span> <span class="directive">扩展</span> QuartzJobBean { <span class="directive">私人</span> <span class="type">诠释</span>超时; <span class="comment">/ ** *使用JobDetailFactoryBean（5）* /</span> <span class="directive">public</span> <span class="type">void</span> setTimeout（ <span class="type">int</span> timeout）{ <span class="local-variable">this</span> .timeout = timeout;中<span class="comment">的值实例化了ExampleJob后调用的Setter</span> } <span class="directive">protected</span> <span class="type">void</span> executeInternal（JobExecutionContext ctx） <span class="directive">抛出</span> JobExecutionException { <span class="comment">//执行实际工作</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，您也可以使用作业数据图中的所有其他属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用<code>name</code>和<code>group</code>属性，您可以分别修改作业的名称和组。默认情况下，作业的名称与<code>JobDetailFactoryBean</code>的bean名称匹配（在上面的示例中，这是<code>exampleJob</code> ）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-method-invoking-job"><a class="anchor" href="#scheduling-quartz-method-invoking-job"></a> 7.6.2。使用MethodInvokingJobDetailFactoryBean</h4>
<div class="paragraph">
<p>通常，您只需要在特定对象上调用方法。使用<code>MethodInvokingJobDetailFactoryBean</code>可以完成以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jobDetail</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling.quartz。MethodInvokingJobDetailFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetObject</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">exampleBusinessObject</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">doIt</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的例子将导致在<code>doIt</code>方法上<code>exampleBusinessObject</code>方法（见下文）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBusinessObject</span> { <span class="comment">//属性和协作者</span> <span class="directive">public</span> <span class="type">void</span> doIt（）{ <span class="comment">//执行实际工作</span> }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">exampleBusinessObject</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">examples。ExampleBusinessObject</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用<code>MethodInvokingJobDetailFactoryBean</code> ，您不需要创建仅调用方法的单行作业，而只需创建实际的业务对象并连接详细信息对象。</p>
</div>
<div class="paragraph">
<p>默认情况下，Quartz Jobs是无状态的，导致作业相互干扰的可能性。如果为同一<code>JobDetail</code>指定两个触发器，则可能在第一个作业完成之前，第二个作业将启动。如果<code>JobDetail</code>类实现<code>Stateful</code>接口，则不会发生这种情况。第二个作业在第一个作业完成之前不会开始。要使<code>MethodInvokingJobDetailFactoryBean</code>产生的作业非并发，请将<code>concurrent</code>标志设置为<code>false</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jobDetail</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling.quartz。MethodInvokingJobDetailFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetObject</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">exampleBusinessObject</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">doIt</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">concurrent</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">false</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，作业将以并发方式运行。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-cron"><a class="anchor" href="#scheduling-quartz-cron"></a> 7.6.3。使用触发器和SchedulerFactoryBean连接作业</h4>
<div class="paragraph">
<p>我们已经创建了工作细节和工作。我们还回顾了允许您在特定对象上调用方法的便捷bean。当然，我们仍然需要自己安排工作。这是使用触发器和<code>SchedulerFactoryBean</code> 。Quartz中提供了几个触发器，Spring提供了两个带有方便默认值的Quartz <code>FactoryBean</code>实现： <code>CronTriggerFactoryBean</code>和<code>SimpleTriggerFactoryBean</code> 。</p>
</div>
<div class="paragraph">
<p>需要安排触发器。Spring提供了一个<code>SchedulerFactoryBean</code> ，它公开了要设置为属性的触发器。<code>SchedulerFactoryBean</code>使用这些触发器调度实际作业。</p>
</div>
<div class="paragraph">
<p>以下是几个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simpleTrigger</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling.quartz。SimpleTriggerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 请参阅上面调用作业的方法示例 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jobDetail</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jobDetail</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  10秒 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">startDelay</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">10000</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 每50秒重复一次 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">repeatInterval</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">50000</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cronTrigger</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling。石英。CronTriggerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jobDetail</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">exampleJob</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 每天早上6点运行 - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cronExpression</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">0 0 6 * *？</span><span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们设置了两个触发器，一个每50秒运行一次，启动延迟为10秒，每天早上6点运行一次。要完成所有操作，我们需要设置<code>SchedulerFactoryBean</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.scheduling.quartz。SchedulerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">triggers</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cronTrigger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">simpleTrigger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以为<code>SchedulerFactoryBean</code>设置更多属性，例如作业详细信息使用的日历，自定义Quartz的属性等。有关详细信息，请查看<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html"><code>SchedulerFactoryBean</code> javadocs</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cache"><a class="anchor" href="#cache"></a> 8。缓存抽象</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="cache-introduction"><a class="anchor" href="#cache-introduction"></a> 8.1。介绍</h3>
<div class="paragraph">
<p>从3.1版开始，Spring Framework提供了对现有Spring应用程序透明地添加缓存的支持。与<a href="data-access.html#transaction">事务</a>支持类似，缓存抽象允许一致地使用各种缓存解决方案，而对代码的影响最小。</p>
</div>
<div class="paragraph">
<p>从Spring 4.1开始，通过<a href="#cache-jsr-107">JSR-107注释</a>和更多自定义选项的支持，缓存抽象得到了显着改进。</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-strategies"><a class="anchor" href="#cache-strategies"></a> 8.2。理解缓存抽象</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">缓存与缓冲区</div>
<div class="paragraph">
<p>术语“缓冲区”和“缓存”倾向于可互换使用;但请注意它们代表不同的东西。传统上，缓冲区用作快速和慢速实体之间的数据的中间临时存储。由于一方必须<em>等待</em>另一方影响性能，缓冲区通过允许整个数据块一次移动而不是小块来缓解这种情况。数据仅从缓冲区写入和读取一次。此外，缓冲区对于至少知道它的一方是<em>可见</em>的。</p>
</div>
<div class="paragraph">
<p>另一方面，隐藏的缓存是隐藏的，并且任何一方都不知道发生了缓存。它也可以提高性能，但可以通过快速方式多次读取相同的数据来实现。</p>
</div>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache">这里</a>可以找到对两者之间差异的进一步解释。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>从根本上说，抽象将缓存应用于Java方法，从而减少了基于缓存中可用信息的执行次数。也就是说，每次调用<em>目标</em>方法时，抽象都将应用缓存行为，检查该方法是否已针对给定参数执行。如果有，则返回缓存的结果而不必执行实际的方法;如果没有，则执行方法，将结果缓存并返回给用户，以便下次调用该方法时，返回缓存的结果。这样，昂贵的方法（无论是CPU还是IO绑定）只能对给定的一组参数执行一次，并且重用结果而不必再次实际执行该方法。缓存逻辑是透明应用的，不会对调用者造成任何干扰。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>显然，这种方法仅适用于保证为给定输入（或参数）返回相同输出（结果）的方法，无论它执行多少次。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其他与缓存相关的操作由抽象提供，例如更新缓存内容或删除所有条目之一的能力。如果缓存处理可在应用程序过程中发生变化的数据，则这些非常有用。</p>
</div>
<div class="paragraph">
<p>就像Spring Framework中的其他服务一样，缓存服务是一种抽象（不是缓存实现），需要使用实际存储来存储缓存数据 - 也就是说，抽象使开发人员不必编写缓存逻辑但不提供实际的商店。这种抽象由<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口。</p>
</div>
<div class="paragraph">
<p>这个抽象<a href="#cache-store-configuration">的一些实现</a>是开箱即用的：JDK <code>java.util.concurrent.基于ConcurrentMap</code>的缓存， <a href="http://ehcache.org/">Ehcache 2.x</a> ，Gemfire缓存，符合<a href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a>和JSR-107的缓存（例如Ehcache 3.x）。有关<a href="#cache-plug">插入</a>其他缓存存储/提供程序的更多信息，请参阅<a href="#cache-plug">插入不同的后端缓存</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>缓存抽象没有对多线程和多进程环境的特殊处理，因为这些功能由缓存实现处理。 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您有多进程环境（即部署在多个节点上的应用程序），则需要相应地配置缓存提供程序。根据您的使用情况，多个节点上相同数据的副本可能已足够，但如果您在应用程序过程中更改数据，则可能需要启用其他传播机制。</p>
</div>
<div class="paragraph">
<p>缓存特定项目直接等效于通过编程缓存交互找到的典型的get-if-not-found-then-proceed-put-finally代码块：没有应用锁定，并且多个线程可能尝试加载相同的项目同时。这同样适用于逐出：如果多个线程试图同时更新或逐出数据，则可以使用陈旧数据。某些缓存提供程序提供该区域的高级功能，请参阅您正在使用的缓存提供程序的文档以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>要使用缓存抽象，开发人员需要注意两个方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>缓存声明 - 确定需要缓存的方法及其策略</p>
</li>
<li>
<p>缓存配置 - 存储和读取数据的后备缓存</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="cache-annotations"><a class="anchor" href="#cache-annotations"></a> 8.3。基于声明注释的缓存</h3>
<div class="paragraph">
<p>对于缓存声明，抽象提供了一组Java注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Cacheable</code>触发缓存填充</p>
</li>
<li>
<p><code>@CacheEvict</code>触发缓存驱逐</p>
</li>
<li>
<p><code>@CachePut</code>更新缓存而不会干扰方法执行</p>
</li>
<li>
<p><code>@Caching</code>重新组合要在方法上应用的多个缓存操作</p>
</li>
<li>
<p><code>@CacheConfig</code>在类级别共享一些常见的缓存相关设置</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们仔细看看每个注释：</p>
</div>
<div class="sect3">
<h4 id="cache-annotations-cacheable"><a class="anchor" href="#cache-annotations-cacheable"></a> 8.3.1。@Cacheable注释</h4>
<div class="paragraph">
<p>顾名思义， <code>@Cacheable</code>用于划分可缓存的方法 - 即，将结果存储到缓存中的方法，以便在后续调用（具有相同的参数）时，返回缓存中的值而不必实际执行该方法。在最简单的形式中，注释声明需要与注释方法关联的缓存的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">书籍</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="predefined-type">书籍</span> findBook（ISBN isbn）{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码片段中，方法<code>findBook</code>与名为<code>books</code>的缓存相关联。每次调用该方法时，都会检查缓存以查看调用是否已经执行且不必重复。虽然在大多数情况下，只声明了一个缓存，但注释允许指定多个名称，以便使用多个缓存。在这种情况下，将在执行方法之前检查每个缓存 - 如果至少有一个缓存被命中，则将返回关联的值：</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>即使没有实际执行缓存的方法，所有其他不包含该值的缓存也将更新。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">books</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">isbns</span> <span class="delimiter">”</span></span> }） <span class="directive">公共</span> <span class="predefined-type">书籍</span> findBook（ISBN isbn）{...}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-default-key"><a class="anchor" href="#cache-annotations-cacheable-default-key"></a>默认密钥生成</h5>
<div class="paragraph">
<p>由于高速缓存本质上是键值存储，因此需要将高速缓存方法的每次调用转换为适合高速缓存访​​问的密钥。开箱即用，缓存抽象使用基于以下算法的简单<code>KeyGenerator</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果没有给出参数，则返回<code>SimpleKey.EMPTY</code> 。</p>
</li>
<li>
<p>如果只给出一个参数，则返回该实例。</p>
</li>
<li>
<p>如果给出了更多的参数，则返回包含所有参数的<code>SimpleKey</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法适用于大多数用例;只要参数具有<em>自然键</em>并实现有效的<code>hashCode()</code>和<code>equals()</code>方法。如果不是这样，则需要改变策略。</p>
</div>
<div class="paragraph">
<p>要提供不同的<em>默认</em>密钥生成器，需要实现<code>org.springframework.cache.interceptor.KeyGenerator</code>接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>随着Spring 4.0的发布，默认密钥生成策略发生了变化。早期版本的Spring使用了密钥生成策略，对于多个关键参数，只考虑参数的<code>hashCode()</code>而不是<code>equals()</code> ;这可能会导致意外的键碰撞（参见<a href="https://jira.spring.io/browse/SPR-10237">SPR-10237</a>的背景信息）。新的'SimpleKeyGenerator'在这种情况下使用复合键。</p>
</div>
<div class="paragraph">
<p>如果要继续使用以前的密钥策略，可以配置已弃用的<code>org.springframework.cache.interceptor.DefaultKeyGenerator</code>类或创建基于哈希的自定义“KeyGenerator”实现。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-key"><a class="anchor" href="#cache-annotations-cacheable-key"></a>自定义密钥生成声明</h5>
<div class="paragraph">
<p>由于缓存是通用的，因此目标方法很可能具有各种签名，这些签名无法简单地映射到缓存结构之上。当目标方法具有多个参数时，这往往变得明显，其中只有一些参数适合于缓存（而其余参数仅由方法逻辑使用）。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable（</span> <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”）</span></span> <span class="directive">公开</span> <span class="predefined-type">书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> includeUsed）</code></pre>
</div>
</div>
<div class="paragraph">
<p>乍一看，虽然两个<code>boolean</code>参数影响了书的发现方式，但它们对缓存没有用处。如果两个中只有一个重要而另一个不重要，那么还有什么呢？</p>
</div>
<div class="paragraph">
<p>对于这种情况， <code>@Cacheable</code>注释允许用户通过其<code>key</code>属性指定密钥的生成方式。开发人员可以使用<a href="core.html#expressions">SpEL</a>选择感兴趣的参数（或其嵌套属性），执行操作甚至调用任意方法，而无需编写任何代码或实现任何接口。这是<a href="#cache-annotations-cacheable-default-key">默认生成器</a>的推荐方法，因为随着代码库的增长，签名方法往往会有很大差异;虽然默认策略可能适用于某些方法，但它很少适用于所有方法。</p>
</div>
<div class="paragraph">
<p>下面是各种SpEL声明的一些示例 - 如果您不熟悉它，请自己帮忙并阅读<a href="core.html#expressions">Spring Expression Language</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span> <strong>关键= <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“#isbn”）</span></span></span></span></strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> <span class="annotation">includeUsed）@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span> <strong>关键= <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“＃isbn.rawNumber”）</span></span></span></span></strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook （ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> <span class="annotation">includeUsed）@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span> <strong>关键= <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“T（SOMETYPE）.hash（#isbn）”）</span></span></span></span></strong> <span class="directive">公开</span> <span class="predefined-type">书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> includeUsed）</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的片段显示了选择某个参数，其属性之一甚至是任意（静态）方法是多么容易。</p>
</div>
<div class="paragraph">
<p>如果负责生成密钥的算法过于具体或需要共享，则可以在操作中定义自定义<code>keyGenerator</code> 。为此，请指定要使用的<code>KeyGenerator</code> bean实现的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span> <strong>的KeyGenerator = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“myKeyGenerator”）</span></span></span></span></strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> includeUsed）</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>key</code>和<code>keyGenerator</code>参数是互斥的，指定两者的操作将导致异常。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-default-cache-resolver"><a class="anchor" href="#cache-annotations-cacheable-default-cache-resolver"></a>默认缓存分辨率</h5>
<div class="paragraph">
<p>开箱即用，缓存抽象使用一个简单的<code>CacheResolver</code> ，它使用配置的<code>CacheManager</code>检索在操作级别定义的缓存。</p>
</div>
<div class="paragraph">
<p>要提供不同的<em>默认</em>缓存解析器，需要实现<code>org.springframework.cache.interceptor.CacheResolver</code>接口。</p>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-cache-resolver"><a class="anchor" href="#cache-annotations-cacheable-cache-resolver"></a>自定义缓存分辨率</h5>
<div class="paragraph">
<p>默认缓存分辨率非常适合使用单个<code>CacheManager</code>且没有复杂缓存分辨率要求的应用程序。</p>
</div>
<div class="paragraph">
<p>对于使用多个缓存管理器的应用程序，可以将<code>cacheManager</code>设置为按操作使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span> <strong>的CacheManager = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“anotherCacheManager”）</span></span></span></span></strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号）{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以以与<a href="#cache-annotations-cacheable-key">密钥生成</a>类似的方式完全替换<code>CacheResolver</code> 。为每个缓存操作请求解析，使实现有机会根据运行时参数实际解析要使用的缓存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@Cacheable（cacheResolver</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“runtimeCacheResolver”）</span></span></span></span></strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号）{...}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring 4.1开始，缓存注释的<code>value</code>属性不再是必需的，因为无论注释的内容如何， <code>CacheResolver</code>都可以提供此特定信息。</p>
</div>
<div class="paragraph">
<p>与<code>key</code>和<code>keyGenerator</code>类似， <code>cacheManager</code>和<code>cacheResolver</code>参数是互斥的，并且指定这两者的操作将导致异常，因为<code>CacheResolver</code>实现将忽略自定义<code>CacheManager</code> 。这可能不是你所期望的。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-synchronized"><a class="anchor" href="#cache-annotations-cacheable-synchronized"></a>同步缓存</h5>
<div class="paragraph">
<p>在多线程环境中，可能会为同一参数同时调用某些操作（通常在启动时）。默认情况下，缓存抽象不会锁定任何内容，并且可能会多次计算相同的值，从而破坏了缓存的目的。</p>
</div>
<div class="paragraph">
<p>对于这些特定情况， <code>sync</code>属性可用于指示底层缓存提供程序在计算值时<em>锁定</em>缓存条目。因此，只有一个线程忙于计算该值，而其他线程将被阻塞，直到该条目在缓存中更新为止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">foos</span> <span class="delimiter">”</span></span> ， <strong>sync = <span class="predefined-constant">true</span></strong> ） <span class="directive">public</span> Foo executeExpensiveOperation（ <span class="predefined-type">String</span> id）{...}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这是一个可选功能，您最喜欢的缓存库可能不支持它。核心框架提供的所有<code>CacheManager</code>实现都支持它。有关更多详细信息，请查看缓存提供程序的文档。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-condition"><a class="anchor" href="#cache-annotations-cacheable-condition"></a>有条件的缓存</h5>
<div class="paragraph">
<p>有时，方法可能不适合一直缓存（例如，它可能取决于给定的参数）。缓存注释通过<code>condition</code>参数支持此类功能，该参数采用被评估为<code>true</code>或<code>false</code>的<code>SpEL</code>表达式。如果为<code>true</code> ，则缓存该方法 - 如果不是，则其行为就像该方法未缓存一样，无论缓存中的值是什么，或者使用哪些参数，都会执行该方法。一个简单示例 - 仅当参数<code>name</code>的长度小于32时，才会缓存以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">book</span> <span class="delimiter">”</span></span> ， <strong>condition = <span class="string"><span class="delimiter">“</span> <span class="content">＃name.length（）&lt;32</span> <span class="delimiter">”</span></span></strong> ） <span class="directive">public</span> <span class="predefined-type">Book</span> findBook（ <span class="predefined-type">String</span> name）</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外， <code>condition</code>参数， <code>unless</code>参数可用于否决向缓存添加值。与<code>condition</code>不同， <code>unless</code>在调用方法<em>之后</em>计算表达式。扩展前一个示例 - 也许我们只想缓存平装书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">book</span> <span class="delimiter">”</span></span> ，condition = <span class="string"><span class="delimiter">“</span> <span class="content">＃name.length（）&lt;32</span> <span class="delimiter">”</span></span> ， <strong>除非= <span class="string"><span class="delimiter">“</span> <span class="content">＃result.hardback</span> <span class="delimiter">”</span></span></strong> ） <span class="directive">public</span> <span class="predefined-type">Book</span> findBook（ <span class="predefined-type">String</span> name）</code></pre>
</div>
</div>
<div class="paragraph">
<p>缓存抽象支持<code>java.util.Optional</code> ，仅在其存在时将其内容用作缓存值。 <code>#result</code>总是引用业务实体，从不在受支持的包装器上，因此可以按如下方式重写上一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">book</span> <span class="delimiter">”</span></span> ，condition = <span class="string"><span class="delimiter">“</span> <span class="content">＃name.length（）&lt;32</span> <span class="delimiter">”</span></span> ， <strong>除非= <span class="string"><span class="delimiter">“</span> <span class="content">＃result？.hardback</span> <span class="delimiter">”</span></span></strong> ） <span class="directive">public</span>可选&lt; <span class="predefined-type">Book</span> &gt; findBook（ <span class="predefined-type">String</span> name）</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>result</code>仍然是指<code>Book</code>而非<code>Optional</code> 。由于它可能为<code>null</code> ，我们应该使用安全导航操作符。</p>
</div>
</div>
<div class="sect4">
<h5 id="cache-spel-context"><a class="anchor" href="#cache-spel-context"></a>可用缓存SpEL评估上下文</h5>
<div class="paragraph">
<p>每个<code>SpEL</code>表达式再次评估专用<a href="core.html#expressions-language-ref"><code>context</code></a> 。除了构建参数之外，框架还提供专用的缓存相关元数据，例如参数名称。下一个表列出了可用于上下文的项目，因此可以将它们用于键和条件计算：</p>
</div>
<table id="cache-spel-context-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表11。缓存SpEL可用的元数据</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">位置</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要调用的方法的名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.methodName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被调用的方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.method.name</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目标</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正在调用的目标对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.target</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">targetClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被调用的目标的类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.targetClass</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARGS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于调用目标的参数（作为数组）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.args [0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">高速缓存</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行当前方法的高速缓存的集合</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃root.caches [0]。名称</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>参数名称</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估背景</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何方法参数的名称。如果由于某种原因名称不可用（例如，没有调试信息），参数名称也可以在<code>#a&lt;#arg&gt;</code>下<em>获得</em> ，其中<em>#arg</em>代表参数索引（从0开始）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#iban</code>或<code>#a0</code> （也可以使用<code>#p0</code>或<code>#p&lt;#arg&gt;</code>表示法作为别名）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估背景</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法调用的结果（要缓存的值）。只适用于<code>unless</code>表达式， <code>cache put</code>表达式（计算<code>key</code> ），或<code>cache evict</code>表达式（当<code>beforeInvocation</code>是<code>false</code> ）。对于受支持的包装器（如<code>Optional</code> ， <code>#result</code>引用实际对象，而不是包装器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＃结果</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-put"><a class="anchor" href="#cache-annotations-put"></a> 8.3.2。@CachePut注释</h4>
<div class="paragraph">
<p>对于需要在不干扰方法执行的情况下更新缓存的情况，可以使用<code>@CachePut</code>批注。也就是说，该方法将始终执行并将其结果放入缓存中（根据<code>@CachePut</code>选项）。它支持与<code>@Cacheable</code>相同的选项，应该用于缓存填充而不是方法流优化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CachePut</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">book</span> <span class="delimiter">”</span></span> ，key = <span class="string"><span class="delimiter">“</span> <span class="content">＃</span></span> isbn <span class="string"><span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="predefined-type">图书</span>更新<span class="predefined-type">书</span> （ISBN isbn，BookDescriptor描述符）</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，通常强烈建议不要在同一方法上使用<code>@CachePut</code>和<code>@Cacheable</code>注释，因为它们具有不同的行为。虽然后者导致通过使用缓存跳过方法执行，但前者强制执行以执行缓存更新。这会导致意外的行为，并且除了特定的角落情况（例如注释具有将它们彼此排除的条件）之外，应该避免这种声明。另请注意，此类条件不应依赖于结果对象（即<code>#result</code>变量），因为这些条件已经过验证，以确认排除。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-evict"><a class="anchor" href="#cache-annotations-evict"></a> 8.3.3。@CacheEvict注释</h4>
<div class="paragraph">
<p>缓存抽象不仅允许缓存存储的填充，还允许驱逐。此过程对于从缓存中删除陈旧或未使用的数据非常有用。与<code>@Cacheable</code> ，注释<code>@CacheEvict</code>划分了执行缓存<em>逐出的</em>方法，即用作从缓存中删除数据的触发器的方法。就像它的兄弟一样， <code>@CacheEvict</code>需要指定受操作影响的一个（或多个）缓存，允许指定自定义缓存和密钥解析或条件，但此外，还有一个额外的参数<code>allEntries</code> ，它指示缓存是否 -需要执行广泛的驱逐，而不仅仅是一个条目（基于密钥）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CacheEvict</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">books</span> <span class="delimiter">”</span></span> ， <strong>allEntries = <span class="predefined-constant">true</span></strong> ） <span class="directive">public</span> <span class="type">void</span> <strong>loadBooks</strong> （ <span class="predefined-type">InputStream</span> batch）</code></pre>
</div>
</div>
<div class="paragraph">
<p>当需要清除整个缓存区域时，此选项会派上用场 - 而不是逐出每个条目（这会花费很长时间，因为效率低），所有条目都会在一个操作中被删除，如上所示。请注意，框架将忽略此方案中指定的任何键，因为它不适用（整个缓存不仅仅被逐出一个条目）。</p>
</div>
<div class="paragraph">
<p>还可以指示驱逐是在（默认）之后还是在方法通过<code>beforeInvocation</code>属性执行之前发生的。前者提供与其他注释相同的语义 - 一旦方法成功完成，就会执行缓存上的操作（在本例中为逐出）。如果该方法未执行（因为它可能被缓存）或抛出异常，则不会发生逐出。后者（ <code>beforeInvocation=true</code> ）导致驱逐始终在调用方法之前发生 - 这在驱逐不需要与方法结果相关联的情况下很有用。</p>
</div>
<div class="paragraph">
<p>重要的是要注意void方法可以与<code>@CacheEvict</code>一起使用 - 因为方法充当触发器，返回值被忽略（因为它们不与缓存交互） - 这不是<code>@Cacheable</code>添加/的情况将数据更新到缓存中，因此需要结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-caching"><a class="anchor" href="#cache-annotations-caching"></a> 8.3.4。@Caching注释</h4>
<div class="paragraph">
<p>有些情况下需要指定相同类型的多个注释，例如<code>@CacheEvict</code>或<code>@CachePut</code> ，例如因为条件或键表达式在不同的缓存之间是不同的。<code>@Caching</code>允许在同一方法上使用多个嵌套<code>@Cacheable</code> ， <code>@CachePut</code>和<code>@CacheEvict</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Caching</span> （evict = { <span class="annotation">@CacheEvict</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">primary</span> <span class="delimiter">”</span></span> ）， <span class="annotation">@ CacheEvict</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">secondary</span> <span class="delimiter">”</span></span> ，key = <span class="string"><span class="delimiter">“</span> <span class="content">＃p0</span> <span class="delimiter">”</span></span> ）}） <span class="directive">public</span> <span class="predefined-type">Book</span> importBooks（ <span class="predefined-type">String</span> deposit， <span class="predefined-type">Date</span> date）</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-config"><a class="anchor" href="#cache-annotations-config"></a> 8.3.5。@CacheConfig注释</h4>
<div class="paragraph">
<p>到目前为止，我们已经看到缓存操作提供了许多自定义选项，这些可以在操作的基础上设置。但是，如果某些自定义选项适用于该类的所有操作，则可能需要进行一些繁琐的配置。例如，指定用于类的每个高速缓存操作的高速缓存的名称可以由单个类级别定义替换。这就是<code>@CacheConfig</code>发挥作用的地方。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@CacheConfig（</span> <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”）</span></span></strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">BookRepositoryImpl</span> <span class="directive">实现</span> BookRepository <span class="annotation">{@Cacheable</span> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号）{...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@CacheConfig</code>是一个类级注释，允许共享缓存名称，自定义<code>KeyGenerator</code> ，自定义<code>CacheManager</code>以及最后的自定义<code>CacheResolver</code> 。将此批注放在类上不会打开任何缓存操作。</p>
</div>
<div class="paragraph">
<p>操作级别自定义将始终覆盖<code>@CacheConfig</code>上的自定义集。因此，这为每个缓存操作提供了三个级别的自定义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>全局配置，可用于<code>CacheManager</code> ， <code>KeyGenerator</code></p>
</li>
<li>
<p>在类级别，使用<code>@CacheConfig</code></p>
</li>
<li>
<p>在操作层面</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotation-enable"><a class="anchor" href="#cache-annotation-enable"></a> 8.3.6。启用缓存注释</h4>
<div class="paragraph">
<p>重要的是要注意，即使声明缓存注释不会自动触发它们的操作 - 就像Spring中的许多内容一样，该功能必须以声明方式启用（这意味着如果您怀疑缓存是责任，您可以通过删除来禁用它只有一个配置行而不是代码中的所有注释。</p>
</div>
<div class="paragraph">
<p>要启用缓存注释，请将注释<code>@EnableCaching</code>添加到<code>@Configuration</code>类之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableCaching</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">AppConfig</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者对于XML配置使用<code>cache:annotation-driven</code>元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：cache</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www .springframework.org / schema / cache</span> <span class="delimiter">“</span></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">”</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http：// www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;cache：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cache:annotation-driven</code>元素和<code>@EnableCaching</code>批注都允许指定各种选项，这些选项会影响通过AOP将缓存行为添加到应用程序的方式。配置与<a href="data-access.html#tx-annotation-driven-settings"><code>@Transactional</code></a>的配置有意类似：</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>处理缓存注释的默认建议模式是“代理”，它允许仅通过代理拦截调用;同一类中的本地调用不能以这种方式截获。对于更高级的拦截模式，请考虑结合编译时或加载时编织切换到“aspectj”模式。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用Java配置的高级自定义需要实现<code>CachingConfigurer</code> ： <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">有关更多详细信息，</a>请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">javadoc</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<table id="cache-annotation-driven-settings" class="tableblock frame-all grid-all spread">
<caption class="title">表12。缓存注释设置</caption>
<colgroup>
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:50.0002%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">XML属性</th>
<th class="tableblock halign-left valign-top">注释属性</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>缓存管理</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N / A（参见<code>CachingConfigurer</code> javadocs）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的CacheManager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的缓存管理器的名称。默认的<code>CacheResolver</code>将使用此缓存管理器（或未设置的`cacheManager`）在幕后初始化。要获得更精细的缓存分辨率管理，请考虑设置“缓存解析器”属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>缓存解析器</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N / A（参见<code>CachingConfigurer</code> javadocs）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用配置的<code>cacheManager</code> <code>SimpleCacheResolver</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于解析后备高速缓存的CacheResolver的bean名称。此属性不是必需的，只需要指定为“cache-manager”属性的替代。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>密钥生成器</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N / A（参见<code>CachingConfigurer</code> javadocs）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleKeyGenerator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的自定义密钥生成器的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>错误处理</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N / A（参见<code>CachingConfigurer</code> javadocs）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleCacheErrorHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的自定义缓存错误处理程序的名称。默认情况下，在缓存相关操作期间抛出的任何异常都会在客户端返回。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>模式</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>模式</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认模式“proxy”使用Spring的AOP框架处理要注释的注释bean（遵循代理语义，如上所述，仅适用于通过代理进入的方法调用）。替代模式“aspectj”用Spring的AspectJ缓存方面编织受影响的类，修改目标类字节代码以应用于任何类型的方法调用。AspectJ编织需要在类路径中使用spring-aspects.jar以及启用加载时编织（或编译时编织）。（有关如何设置加载时编织的详细信息，请参阅<a href="core.html#aop-aj-ltw-spring">Spring配置</a> 。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>代理目标类</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxyTargetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅适用于代理模式。控制为使用<code>@Cacheable</code>或<code>@CacheEvict</code>注释注释的类创建的缓存代理类型。如果<code>proxy-target-class</code>属性设置为<code>true</code> ，则会创建基于类的代理。如果<code>proxy-target-class</code>为<code>false</code>或者省略了该属性，则会创建基于标准JDK接口的代理。（参见<a href="core.html#aop-proxying">代理机制</a> ，详细检查不同的代理类型。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>订购</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>订购</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有序。LOWEST_PRECEDENCE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义应用于使用<code>@Cacheable</code>或<code>@CacheEvict</code>注释的bean的缓存建议的顺序。（有关与AOP建议排序相关的规则的更多信息，请参阅<a href="core.html#aop-ataspectj-advice-ordering">建议排序</a> 。）没有指定的排序意味着AOP子系统确定建议的顺序。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;cache:annotation-driven/&gt;</code>仅查找在其定义的相同应用程序上下文中的bean上的<code>@Cacheable/@CachePut/@CacheEvict/@Caching</code> 。这意味着，如果在<code>WebApplicationContext</code>为<code>DispatcherServlet</code>放置<code>&lt;cache:annotation-driven/&gt;</code> ，它只检查控制器中的bean，而不检查您的服务。有关更多信息，请参阅<a href="web.html#mvc-servlet">MVC部分</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">方法可见性和缓存注释</div>
<div class="paragraph">
<p>使用代理时，应仅将缓存注释应用于具有<em>公共</em>可见性的方法。如果使用这些注释对带保护的，私有的或包可见的方法进行注释，则不会引发错误，但带注释的方法不会显示已配置的高速缓存设置。如果需要注释非公共方法，请考虑使用AspectJ（见下文），因为它会更改字节码本身。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring建议您只使用<code>@Cache*</code>注释来注释具体类（以及具体类的方法），而不是注释接口。您当然可以将<code>@Cache*</code>注释放在接口（或接口方法）上，但这只能在您使用基于接口的代理时按预期工作。Java注释<em>不是从接口继承</em>的事实意味着如果您使用基于类的代理（ <code>proxy-target-class="true"</code> ）或基于编织的方面（ <code>mode="aspectj"</code> ），那么缓存设置是代理和编织基础设施无法识别，并且该对象不会被包装在缓存代理中，这将是非常<em>糟糕的</em> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在代理模式（默认设置）下，只拦截通过代理进入的外部方法调用。这意味着实际上，自调用目标对象中的一个方法调用目标对象的另一个方法，即使被调用的方法用<code>@Cacheable</code>标记，也不会在运行时导致实际的缓存 - 考虑使用aspectj模式这个案例。此外，必须完全初始化代理以提供预期的行为，因此您不应该在初始化代码中依赖此功能，即<code>@PostConstruct</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotation-stereotype"><a class="anchor" href="#cache-annotation-stereotype"></a> 8.3.7。使用自定义注释</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">自定义注释和AspectJ</div>
<div class="paragraph">
<p>此功能仅与基于代理的方法一起使用，但可以使用AspectJ进行一些额外的工作。</p>
</div>
<div class="paragraph">
<p><code>spring-aspects</code>模块仅定义标准注释的方面。如果您已定义自己的注释，则还需要为这些注释定义方面。检查<code>AnnotationCacheAspect</code>以获取示例。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>缓存抽象允许您使用自己的注释来标识触发缓存填充或驱逐的方法。这作为模板机制非常方便，因为它消除了复制缓存注释声明的需要（如果指定了键或条件，则特别有用），或者在代码库中不允许外部导入（ <code>org.springframework</code> ）。与其他<code>@Cacheable</code> <a href="core.html#beans-stereotype-annotations">型</a>注释<code>@Cacheable</code> ， <code>@CachePut</code> ， <code>@CacheEvict</code> <code>@Cacheable</code> ， <code>@CachePut</code> <code>@CacheEvict</code>和<code>@CacheConfig</code>可用作<a href="core.html#beans-meta-annotations">元</a>注释，即可注释其他注释的注释。<code>@Cacheable</code> ，让我们用我们自己的自定义注释替换一个常见的<code>@Cacheable</code>声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。方法}） <span class="annotation">@ Cache</span> （cacheNames = <span class="string"><span class="delimiter">“</span> <span class="content">books</span> <span class="delimiter">”</span></span> ，key = <span class="string"><span class="delimiter">“</span> <span class="content">＃isbn</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="annotation">@interface</span> SlowService {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面，我们定义了自己的<code>SlowService</code>注释，它本身用<code>@Cacheable</code>注释 - 现在我们可以替换以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span>关键= <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“#isbn”）</span></span></span></span> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> includeUsed）</code></pre>
</div>
</div>
<div class="paragraph">
<p>有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SlowService</span> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> includeUsed）</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管<code>@SlowService</code>不是Spring注释，但容器会在运行时自动获取其声明并理解其含义。请注意， <a href="#cache-annotation-enable">如上所述</a> ，需要启用注释驱动的行为。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-jsr-107"><a class="anchor" href="#cache-jsr-107"></a> 8.4。JCache（JSR-107）注释</h3>
<div class="paragraph">
<p>从Spring Framework 4.1开始，缓存抽象完全支持JCache标准注释： <code>@CacheResult</code> ， <code>@CachePut</code> ， <code>@CacheRemove</code>和<code>@CacheRemoveAll</code>以及<code>@CacheDefaults</code> ， <code>@CacheKey</code>和<code>@CacheValue</code>伴侣。这些注释可以直接使用，无需将缓存存储迁移到JSR-107：内部实现使用Spring的缓存抽象，并提供符合规范的默认<code>CacheResolver</code>和<code>KeyGenerator</code>实现。换句话说，如果您已经在使用Spring的缓存抽象，那么您可以切换到这些标准注释，而无需更改缓存存储（或配置，就此而言）。</p>
</div>
<div class="sect3">
<h4 id="cache-jsr-107-summary"><a class="anchor" href="#cache-jsr-107-summary"></a> 8.4.1。功能摘要</h4>
<div class="paragraph">
<p>对于那些熟悉Spring的缓存注释的人，下表描述了Spring注释和JSR-107版本之间的主要区别：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表13。Spring vs. JSR-107缓存注释</caption>
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:60%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">弹簧</th>
<th class="tableblock halign-left valign-top">JSR-107</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Cacheable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非常相似。<code>@CacheResult</code>可以缓存特定的异常并强制执行该方法，而不管缓存的内容如何。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CachePut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CachePut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当Spring使用方法调用的结果更新缓存时，JCache需要将其作为使用<code>@CacheValue</code>注释的参数<code>@CacheValue</code> 。由于这种差异，JCache允许在实际方法调用之前或之后更新缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheEvict</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheRemove</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非常相似。<code>@CacheRemove</code>支持条件逐出，以防方法调用导致异常。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheEvict（allEntries =真）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheRemoveAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请参阅<code>@CacheRemove</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheDefaults</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许以类似的方式配置相同的概念。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>JCache有<code>javax.cache.annotation.的概念<code>javax.cache.annotation.CacheResolver</code>与Spring的<code>CacheResolver</code>接口相同，只是JCache只支持单个缓存。默认情况下，一个简单的实现根据注释上声明的名称检索要使用的缓存。应该注意的是，如果注释上没有指定缓存名称，则会自动生成默认值，请检查<code>@CacheResult#cacheName()</code>的javadoc以获取更多信息。</p>
</div>
<div class="paragraph">
<p><code>CacheResolver</code>实例由<code>CacheResolverFactory</code>检索。可以自定义每个缓存操作的工厂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CacheResult（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <strong><span class="delimiter">”，cacheResolverFactory</span></strong></span> <strong>= MyCacheResolverFactory.class）</strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号）</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于所有引用的<em>类</em> ，Spring尝试查找具有给定类型的bean。如果存在多个匹配项，则会创建一个新实例，并且可以使用常规bean生命周期回调，例如依赖项注入。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>密钥由<code>javax.cache.annotation.生成<code>javax.cache.annotation.CacheKeyGenerator</code>与Spring的<code>KeyGenerator</code>具有相同的用途。默认情况下，除非至少有一个参数使用<code>@CacheKey</code>注释，否则将考虑所有方法参数。这类似于Spring的<a href="#cache-annotations-cacheable-key">自定义密钥生成声明</a> 。例如，这些是相同的操作，一个使用Spring的抽象，另一个使用JCache：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Cacheable（cacheNames</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”，</span></span> <strong>关键= <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“#isbn”）</span></span></span></span></strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">布尔</span> <span class="annotation">includeUsed）@CacheResult（cacheName</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <span class="delimiter">”）</span></span> <span class="directive">公共</span> <span class="predefined-type">图书</span> <strong><span class="annotation">findBook（@CacheKey</span></strong> ISBN书号， <span class="type">布尔</span> checkWarehouse， <span class="type">boolean</span> includeUsed）</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用的<code>CacheKeyResolver</code>也可以在操作中指定，其方式与<code>CacheResolverFactory</code>类似。</p>
</div>
<div class="paragraph">
<p>JCache可以管理由带注释的方法抛出的异常：这可以防止更新缓存，但它也可以将异常缓存为失败的指示器，而不是再次调用该方法。假设如果ISBN的结构无效，则抛出<code>InvalidIsbnNotFoundException</code> 。这是一个永久性的失败，没有任何书籍可以用这样的参数检索。以下缓存异常，以便使用相同的无效ISBN进一步调用直接抛出缓存的异常，而不是再次调用该方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CacheResult（cacheName</span> = <span class="string"><span class="delimiter">“</span> <span class="content">书</span> <strong><span class="delimiter">”，exceptionCacheName</span></strong></span> <strong>= <span class="string"><span class="delimiter">“</span> <span class="content">失败</span> <span class="delimiter">”</span></span></strong> <strong>cachedExceptions = InvalidIsbnNotFoundException.class）</strong> <span class="directive">公共</span> <span class="predefined-type">图书</span> findBook（ISBN书号）</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enabling-jsr-107-support"><a class="anchor" href="#enabling-jsr-107-support"></a> 8.4.2。启用JSR-107支持</h4>
<div class="paragraph">
<p>除了Spring的声明性注释支持之外，没有什么特别需要实现JSR-107支持。如果JSR-107 API和<code>spring-context-support</code>模块都存在于类路径中，则<code>@EnableCaching</code>和<code>cache:annotation-driven</code>元素将自动启用JCache支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根据您的使用情况，选择基本上是您的。您甚至可以使用JSR-107 API和其他使用Spring自己的注释来混合和匹配服务。但请注意，如果这些服务影响相同的缓存，则应使用一致且相同的密钥生成实现。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-declarative-xml"><a class="anchor" href="#cache-declarative-xml"></a> 8.5。声明性的基于XML的缓存</h3>
<div class="paragraph">
<p>如果注释不是一个选项（无法访问源代码或没有外部代码），则可以使用XML进行声明性缓存。因此，不是注释缓存方法，而是在外部指定目标方法和缓存指令（类似于声明性事务管理<a href="data-access.html#transaction-declarative-first-example">建议</a> ）。前面的例子可以翻译成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 我们想要缓存的服务 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">bookService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyservice。DefaultBookService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 缓存定义 - &gt;</span> <span class="tag">&lt;cache：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cacheAdvice</span> <span class="delimiter">“</span></span> <span class="attribute-name">cache-manager</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cacheManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;cache：caching</span> <span class="attribute-name">cache</span> = <span class="string"><span class="delimiter">”</span> <span class="content">books</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;cache：cacheable</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">findBook</span> <span class="delimiter">“</span></span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">#isbn</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;cache：cache-evict</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">“</span> <span class="content">loadBooks</span> <span class="delimiter">”</span></span> <span class="attribute-name">all-entries</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ cache：caching&gt;</span> <span class="tag">&lt;/ cache：advice&gt;</span> <span class="comment">&lt;！ - 将可缓存行为应用于所有BookService interfaces  - &gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheAdvice</span> <span class="delimiter">”</span></span> <span class="attribute-name">pointcut</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* xybookService的。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="comment">&lt;！ - 省略缓存管理器定义 - &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的配置中， <code>bookService</code>可以缓存。要应用的缓存语义封装在<code>cache:advice</code>定义中，该定义指示方法<code>findBooks</code>用于将数据放入缓存，而方法<code>loadBooks</code>用于驱逐数据。这两个定义都适用于<code>books</code>缓存。</p>
</div>
<div class="paragraph">
<p><code>aop:config</code>定义通过使用AspectJ切入点表达式将缓存建议应用于程序中的适当点（有关<a href="core.html#aop">Spring的Aspect Oriented Programming中</a>提供了更多信息）。在上面的示例中，将考虑<code>BookService</code>中的所有方法，并将缓存建议应用于它们。</p>
</div>
<div class="paragraph">
<p>声明性XML缓存支持所有基于注释的模型，因此在两者之间移动应该相当容易 - 更多可以在同一个应用程序中使用。基于XML的方法不会触及目标代码，但它本身就更加冗长;当处理具有缓存目标的重载方法的类时，识别正确的方法确实需要额外的努力，因为<code>method</code>参数不是一个好的鉴别器 - 在这些情况下，AspectJ切入点可用于挑选目标方法并应用适当的缓存功能。但是，通过XML，更容易应用包/组/接口范围的缓存（同样由于AspectJ切入点）并创建类似模板的定义（正如我们在上面的示例中通过缓存定义目标缓存所做的那样<code>cache:definitions</code> <code>cache</code>属性）。</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-store-configuration"><a class="anchor" href="#cache-store-configuration"></a> 8.6。配置缓存存储</h3>
<div class="paragraph">
<p>开箱即用，缓存抽象提供了几种存储集成。要使用它们，需要简单地声明一个适当的<code>CacheManager</code>一个控制和管理<code>Cache</code>的实体，并可用于检索这些存储。</p>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-jdk"><a class="anchor" href="#cache-store-configuration-jdk"></a> 8.6.1。基于JDK ConcurrentMap的Cache</h4>
<div class="paragraph">
<p>基于JDK的<code>Cache</code>实现位于<code>org.springframework.cache.concurrent</code>包下。它允许使用<code>ConcurrentHashMap</code>作为支持<code>Cache</code>存储。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  simple cache manager  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.cache.support。SimpleCacheManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">caches</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.cache.concurrent。ConcurrentMapCacheFactoryBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">default</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.cache.concurrent。ConcurrentMapCacheFactoryBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">books</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码片段使用<code>SimpleCacheManager</code>为两个嵌套的<code>ConcurrentMapCache</code>实例创建一个<code>CacheManager</code> ，名为<em>default</em>和<em>books</em> 。请注意，名称是直接为每个缓存配置的。</p>
</div>
<div class="paragraph">
<p>由于缓存是由应用程序创建的，因此它被绑定到其生命周期，使其适用于基本用例，测试或简单应用程序。缓存可以很好地扩展并且非常快，但它不提供任何管理或持久性功能，也不提供驱逐合同。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-ehcache"><a class="anchor" href="#cache-store-configuration-ehcache"></a> 8.6.2。基于Ehcache的缓存</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Ehcache 3.x完全符合JSR-107标准，无需专门支持。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ehcache 2.x实现位于<code>org.springframework.cache.ehcache</code>包下。再次，要使用它，只需要声明适当的<code>CacheManager</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.cache.ehcache。EhCacheCacheManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：cache-manager-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ehcache</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  EhCache库设置 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ehcache</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.cache.ehcache。EhCacheManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：config-location</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ehcache.xml</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个设置引导Spring IoC中的ehcache库（通过<code>ehcache</code> bean），然后连接到专用的<code>CacheManager</code>实现。请注意，从<code>ehcache.xml</code>读取整个特定于ehcache的配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-caffeine"><a class="anchor" href="#cache-store-configuration-caffeine"></a> 8.6.3。咖啡因缓存</h4>
<div class="paragraph">
<p>Caffeine是Java 8重写的Guava缓存，它的实现位于<code>org.springframework.cache.caffeine</code>包下，并提供对Caffeine的几个功能的访问。</p>
</div>
<div class="paragraph">
<p>配置按需创建缓存的<code>CacheManager</code>非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.cache.caffeine。CaffeineCacheManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以提供明确使用的高速缓存。在这种情况下，只有经理才能提供：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.cache.caffeine。CaffeineCacheManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">caches</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;set&gt;</span> <span class="tag">&lt;value&gt;</span> default <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> books <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ set&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Caffeine <code>CacheManager</code>还支持海关<code>Caffeine</code>和<code>CacheLoader</code> 。有关这些<a href="https://github.com/ben-manes/caffeine/wiki">内容</a>的详细信息，请参阅<a href="https://github.com/ben-manes/caffeine/wiki">Caffeine文档</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-gemfire"><a class="anchor" href="#cache-store-configuration-gemfire"></a> 8.6.4。基于GemFire的缓存</h4>
<div class="paragraph">
<p>GemFire是一种面向内存/磁盘支持，可弹性扩展，持续可用，活动（具有内置的基于模式的订阅通知），全局复制的数据库，并提供全功能的边缘缓存。有关如何将GemFire用作CacheManager（以及更多）的更多信息，请参阅<a href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/">Spring Data GemFire参考文档</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-jsr107"><a class="anchor" href="#cache-store-configuration-jsr107"></a> 8.6.5。JSR-107缓存</h4>
<div class="paragraph">
<p>Spring的缓存抽象也可以使用JSR-107兼容的缓存。JCache实现位于<code>org.springframework.cache.jcache</code>包下。</p>
</div>
<div class="paragraph">
<p>再次，要使用它，只需要声明适当的<code>CacheManager</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.cache.jcache。JCacheCacheManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">p：cache-manager-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jCacheManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  JSR-107缓存管理器设置 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jCacheManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">...</span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-noop"><a class="anchor" href="#cache-store-configuration-noop"></a> 8.6.6。处理没有后备存储的缓存</h4>
<div class="paragraph">
<p>有时在切换环境或进行测试时，可能会有缓存声明而没有配置实际的后备缓存。由于这是无效配置，因此在运行时将抛出异常，因为缓存基础结构无法找到合适的存储。在这种情况下，而不是删除缓存声明（这可能证明是乏味的），可以连接一个不执行缓存的简单虚拟缓存 - 也就是说，强制每次都执行缓存的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">cacheManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.cache.support。CompositeCacheManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cacheManagers</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdkCache</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span> = <span class="string"><span class="delimiter">”</span> <span class="content">gemfireCache</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fallbackToNoOpCache</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的<code>CompositeCacheManager</code>链接多个<code>CacheManager</code> ，另外，通过<code>fallbackToNoOpCache</code>标志，为所有未由配置的缓存管理器处理的定义添加<em>no op</em>缓存。也就是说，在<code>jdkCache</code>或<code>gemfireCache</code> （上面配置）中找不到的每个缓存定义都<code>jdkCache</code> no op缓存处理，该缓存不会存储导致每次执行目标方法的任何信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-plug"><a class="anchor" href="#cache-plug"></a> 8.7。插入不同的后端缓存</h3>
<div class="paragraph">
<p>很明显，有很多缓存产品可以用作后备存储。要插入它们，需要提供<code>CacheManager</code>和<code>Cache</code>实现，因为遗憾的是我们没有可用的标准。这可能听起来比实际上更难，因为在实践中，类往往是简单的<a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器</a> ，它将缓存抽象框架映射到存储API之上，就像<code>ehcache</code>类可以显示的那样。大多数<code>CacheManager</code>类都可以使用<code>org.springframework.cache.support</code>包中的类，例如<code>AbstractCacheManager</code> ，它负责处理样板代码，只留下实际的<em>映射</em> 。我们希望及时提供与Spring集成的库可以填补这个小的配置差距。</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-specific-config"><a class="anchor" href="#cache-specific-config"></a> 8.8。如何设置TTL / TTI /逐出政策/ XXX功能？</h3>
<div class="paragraph">
<p>直接通过缓存提供程序。缓存抽象是......好吧，抽象不是缓存实现。您正在使用的解决方案可能支持各种数据策略和其他解决方案所不具备的不同拓扑（例如JDK <code>ConcurrentHashMap</code> ） - 暴露在缓存抽象中只会因为没有后备支持而无用。在配置或通过其本机API时，应通过后备缓存直接控制此类功能。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a> 9。附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a> 9.1。XML模式</h3>
<div class="paragraph">
<p>附录的这一部分列出了与集成技术相关的XML模式。</p>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jee"><a class="anchor" href="#xsd-schemas-jee"></a> 9.1.1。jee架构</h4>
<div class="paragraph">
<p><code>jee</code>标签处理与Java EE（Java Enterprise Edition）相关的配置问题，例如查找JNDI对象和定义EJB引用。</p>
</div>
<div class="paragraph">
<p>要在<code>jee</code>模式中使用标记，您需要在Spring XML配置文件的顶部有以下前导码;以下代码段中的文本引用了正确的架构，以便您可以使用<code>jee</code>命名空间中的标记。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：jee</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/jee</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup"></a> &lt;jee：jndi-lookup /&gt;（简单）</h5>
<div class="paragraph">
<p>之前...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content"><strong>dataSource</strong></span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jndi。JndiObjectFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">userDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo。JdbcUserDao</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  Spring会自动执行</span> 强制转换</span></span> <span class="comment">（像往常一样） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content"><strong>dataSource</strong></span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content"><strong>dataSource</strong></span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">userDao</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.foo。JdbcUserDao</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  Spring会自动执行</span> 强制转换</span></span> <span class="comment">（像往常一样） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content"><strong>dataSource</strong></span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-environment-single"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-environment-single"></a> &lt;jee：jndi-lookup /&gt;（使用单个JNDI环境设置）</h5>
<div class="paragraph">
<p>之前...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jndi。JndiObjectFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiEnvironment</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">foo</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> bar <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property &gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jee：environment&gt;</span> foo = bar <span class="tag">&lt;/ jee：environment&gt;</span> <span class="tag">&lt;/ jee：jndi-lookup&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-evironment-multiple"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-evironment-multiple"></a> &lt;jee：jndi-lookup /&gt;（具有多个JNDI环境设置）</h5>
<div class="paragraph">
<p>之前...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jndi。JndiObjectFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiEnvironment</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">foo</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> bar <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ping</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> pong <span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 环境的换行符分隔的键值对（标准属性格式） - &gt;</span> <span class="tag">&lt;jee：environment&gt;</span> foo = bar ping = pong <span class="tag">&lt;/ jee：environment&gt;</span> <span class="tag">&lt;/ jee：jndi-lookup&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-complex"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-complex"></a> &lt;jee：jndi-lookup /&gt;（复杂）</h5>
<div class="paragraph">
<p>之前...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jndi。JndiObjectFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cache</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceRef</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">lookupOnStartup</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">false</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">expectedType</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.myapp。DefaultFoo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">proxyInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.myapp。Foo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc / MyDataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">cache</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">resource-ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">lookup-on-startup</span> = <span class="string"><span class="delimiter">“</span> <span class="content">false</span> <span class="delimiter">”</span></span> <span class="attribute-name">expected-type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.myapp。DefaultFoo</span> <span class="delimiter">“</span></span> <span class="attribute-name">proxy-interface</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.myapp。Foo</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-local-slsb"><a class="anchor" href="#xsd-schemas-jee-local-slsb"></a> &lt;jee：local-slsb /&gt;（简单）</h5>
<div class="paragraph">
<p><code>&lt;jee:local-slsb/&gt;</code>标记配置对EJB Stateless SessionBean的引用。</p>
</div>
<div class="paragraph">
<p>之前...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simple</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ejb.access。LocalStatelessSessionProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ejb / RentalServiceBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo.service。RentalService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jee：local-slsb</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">simpleSlsb</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">ejb / RentalServiceBean</span> <span class="delimiter">”</span></span> <span class="attribute-name">business-interface</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.foo.service。RentalService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-local-slsb-complex"><a class="anchor" href="#xsd-schemas-jee-local-slsb-complex"></a> &lt;jee：local-slsb /&gt;（复杂）</h5>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">complexLocalEjb</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ejb.access。LocalStatelessSessionProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ejb / RentalServiceBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo.service。RentalService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cacheHome</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">lookupHomeOnStartup</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceRef</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;JEE：本地SLSB</span> <span class="attribute-name">ID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“complexLocalEjb”</span></span></span></span> <span class="attribute-name">JNDI名称</span> = <span class="string"><span class="content"><span class="delimiter">“EJB</span> / <span class="delimiter">RentalServiceBean”</span></span></span> <span class="attribute-name">业务接口</span> <span class="string"><span class="delimiter"><span class="content">=“com.foo.service。</span>RentalService</span> <span class="delimiter">“</span></span> <span class="attribute-name">cache-home</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="attribute-name">lookup-home-on-startup</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="attribute-name">resource-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-remote-slsb"><a class="anchor" href="#xsd-schemas-jee-remote-slsb"></a> &lt;JEE：远程SLSB /&gt;</h5>
<div class="paragraph">
<p><code>&lt;jee:remote-slsb/&gt;</code>标记配置对<code>remote</code> EJB Stateless SessionBean的引用。</p>
</div>
<div class="paragraph">
<p>之前...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">complexRemoteEjb</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ejb.access。SimpleRemoteStatelessSessionProxyFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jndiName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ejb / MyRemoteBean</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">businessInterface</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo.service。RentalService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">cacheHome</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">lookupHomeOnStartup</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">resourceRef</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">homeInterface</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.foo.service。RentalService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">refreshHomeOnConnectFailure</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;JEE：远程SLSB</span> <span class="attribute-name">ID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“complexRemoteEjb”</span></span></span></span> <span class="attribute-name">JNDI名称</span> = <span class="string"><span class="content"><span class="delimiter">“EJB</span> / <span class="delimiter">MyRemoteBean”</span></span></span> <span class="attribute-name">业务接口</span> <span class="string"><span class="delimiter"><span class="content">=“com.foo.service。</span>RentalService</span> <span class="delimiter">“</span></span> <span class="attribute-name">cache-home</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="attribute-name">lookup-home-on-startup</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="attribute-name">resource-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="attribute-name">home-interface</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.foo.service。RentalService</span> <span class="delimiter">“</span></span> <span class="attribute-name">refresh-home-on-connect-failure</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jms"><a class="anchor" href="#xsd-schemas-jms"></a> 9.1.2。jms架构</h4>
<div class="paragraph">
<p><code>jms</code>标签用于配置与JMS相关的bean，例如Spring的<a href="#jms-mdp">MessageListenerContainers</a> 。这些标记在<a href="#jms">JMS章节</a>标题为<a href="#jms-namespace">JMS名称空间支持</a>的部分中有详细说明。有关此支持和<code>jms</code>标签本身的完整详细信息，请参阅该章节。</p>
</div>
<div class="paragraph">
<p>为了完整性，要在<code>jms</code>模式中使用标记，您需要在Spring XML配置文件的顶部有以下前导码;以下代码段中的文本引用了正确的架构，以便您可以使用<code>jms</code>命名空间中的标记。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：jms</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/jms</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a> 9.1.3。 &lt;上下文：mbean的出口/&gt;</h4>
<div class="paragraph">
<p><a href="#jmx-context-mbeanexport">配置基于MBean导出的注释中</a>详细介绍了此元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-cache"><a class="anchor" href="#xsd-schemas-cache"></a> 9.1.4。缓存架构</h4>
<div class="paragraph">
<p><code>cache</code>标记可用于支持Spring的<code>@CacheEvict</code> ， <code>@CachePut</code>和<code>@Caching</code>注释。它还支持基于声明的基于XML的缓存。有关详细信息，请参阅<a href="#cache-annotation-enable">启用高速缓存注释</a>和<a href="#cache-declarative-xml">基于声明的基于XML的高速缓存</a> 。</p>
</div>
<div class="paragraph">
<p>要在<code>cache</code>模式中使用标记，您需要在Spring XML配置文件的顶部包含以下前导码;以下代码段中的文本引用了正确的架构，以便您可以使用<code>cache</code>命名空间中的标记。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name"><em>xmlns：cache</em></span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/cache</span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="attribute-name">xsi：schemaLocation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content"><em>http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd</em></span> <span class="delimiter">“</span></span> <span class="attribute-name"></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>