<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Web上的反应堆栈</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="spring-web-reactive" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>Web上的反应堆栈</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#webflux">1。Spring WebFlux</a>
<ul class="sectlevel3">
<li><a href="#webflux-new-framework">1.1。动机</a></li>
<li><a href="#webflux-why-reactive">1.2。定义“反应”</a></li>
<li><a href="#webflux-reactive-api">1.3。反应性API</a></li>
<li><a href="#webflux-programming-models">1.4。编程模型</a></li>
<li><a href="#webflux-framework-choice">1.5。适用性</a></li>
<li><a href="#webflux-server-choice">1.6。服务器</a></li>
<li><a href="#webflux-performance">1.7。绩效与规模</a></li>
<li><a href="#webflux-concurrency-model">1.8。并发模型</a></li>
<li><a href="#webflux-reactive-spring-web">1.9。反应核心</a>
<ul class="sectlevel3">
<li><a href="#webflux-httphandler">1.9.1。使用<code>HttpHandler</code></a></li>
<li><a href="#webflux-web-handler-api">1.9.2。使用<code>WebHandler</code> API</a>
<ul class="sectlevel4">
<li><a href="#webflux-web-handler-api-special-beans">特殊的豆类</a></li>
<li><a href="#webflux-form-data">表格数据</a></li>
<li><a href="#webflux-multipart">多部分数据</a></li>
<li><a href="#webflux-forwarded-headers">转发标题</a></li>
</ul>
</li>
<li><a href="#webflux-filters">1.9.3。过滤器</a>
<ul class="sectlevel4">
<li><a href="#webflux-filters-cors">CORS</a></li>
</ul>
</li>
<li><a href="#webflux-exception-handler">1.9.4。例外</a></li>
<li><a href="#webflux-codecs">1.9.5。编解码器</a>
<ul class="sectlevel4">
<li><a href="#webflux-codecs-jackson">用杰克逊</a></li>
<li><a href="#webflux-codecs-streaming">HTTP流媒体</a></li>
</ul>
</li>
<li><a href="#webflux-logging">1.9.6。记录</a>
<ul class="sectlevel4">
<li><a href="#webflux-logging-id">记录ID</a></li>
<li><a href="#webflux-logging-sensitive-data">记录敏感数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-dispatcher-handler">1.10。使用<code>DispatcherHandler</code></a>
<ul class="sectlevel3">
<li><a href="#webflux-special-bean-types">1.10.1。特殊豆类</a></li>
<li><a href="#webflux-framework-config">1.10.2。WebFlux配置</a></li>
<li><a href="#webflux-dispatcher-handler-sequence">1.10.3。处理</a></li>
<li><a href="#webflux-resulthandling">1.10.4。结果处理</a></li>
<li><a href="#webflux-dispatcher-exceptions">1.10.5。例外</a></li>
<li><a href="#webflux-viewresolution">1.10.6。查看分辨率</a>
<ul class="sectlevel4">
<li><a href="#webflux-viewresolution-handling">处理</a></li>
<li><a href="#webflux-redirecting-redirect-prefix">重定向</a></li>
<li><a href="#webflux-multiple-representations">内容谈判</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-controller">1.11。带注释的控制器</a>
<ul class="sectlevel3">
<li><a href="#webflux-ann-controller">1.11.1。使用<code>@Controller</code></a></li>
<li><a href="#webflux-ann-requestmapping">1.11.2。请求映射</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-requestmapping-uri-templates">URI模式</a></li>
<li><a href="#webflux-ann-requestmapping-pattern-comparison">模式比较</a></li>
<li><a href="#webflux-ann-requestmapping-consumes">耗材类型</a></li>
<li><a href="#webflux-ann-requestmapping-produces">可生产的媒体类型</a></li>
<li><a href="#webflux-ann-requestmapping-params-and-headers">参数和标题</a></li>
<li><a href="#webflux-ann-requestmapping-head-options">HTTP HEAD，OPTIONS</a></li>
<li><a href="#webflux-ann-requestmapping-composed">自定义注释</a></li>
<li><a href="#webflux-ann-requestmapping-registration">明确的注册</a></li>
</ul>
</li>
<li><a href="#webflux-ann-methods">1.11.3。处理程序方法</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-arguments">方法参数</a></li>
<li><a href="#webflux-ann-return-types">返回值</a></li>
<li><a href="#webflux-ann-typeconversion">类型转换</a></li>
<li><a href="#webflux-ann-matrix-variables">矩阵变量</a></li>
<li><a href="#webflux-ann-requestparam">使用<code>@RequestParam</code></a></li>
<li><a href="#webflux-ann-requestheader">使用<code>@RequestHeader</code></a></li>
<li><a href="#webflux-ann-cookievalue">使用<code>@CookieValue</code></a></li>
<li><a href="#webflux-ann-modelattrib-method-args">使用<code>@ModelAttribute</code></a></li>
<li><a href="#webflux-ann-sessionattributes">使用<code>@SessionAttributes</code></a></li>
<li><a href="#webflux-ann-sessionattribute">使用<code>@SessionAttribute</code></a></li>
<li><a href="#webflux-ann-requestattrib">使用<code>@RequestAttribute</code></a></li>
<li><a href="#webflux-multipart-forms">多部分内容</a></li>
<li><a href="#webflux-ann-requestbody">使用<code>@RequestBody</code></a></li>
<li><a href="#webflux-ann-httpentity">使用<code>HttpEntity</code></a></li>
<li><a href="#webflux-ann-responsebody">使用<code>@ResponseBody</code></a></li>
<li><a href="#webflux-ann-responseentity">使用<code>ResponseEntity</code></a></li>
<li><a href="#webflux-ann-jackson">杰克逊JSON</a></li>
</ul>
</li>
<li><a href="#webflux-ann-modelattrib-methods">1.11.4。使用模型</a></li>
<li><a href="#webflux-ann-initbinder">1.11.5。使用<code>DataBinder</code></a></li>
<li><a href="#webflux-ann-controller-exceptions">1.11.6。管理例外</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-rest-exceptions">REST API例外</a></li>
</ul>
</li>
<li><a href="#webflux-ann-controller-advice">1.11.7。控制器建议</a></li>
</ul>
</li>
<li><a href="#webflux-fn">1.12。功能端点</a>
<ul class="sectlevel3">
<li><a href="#webflux-fn-overview">1.12.1。概观</a></li>
<li><a href="#webflux-fn-handler-functions">1.12.2。HandlerFunction</a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-request">使用<code>ServerRequest</code></a></li>
<li><a href="#webflux-fn-response">使用<code>ServerResponse</code></a></li>
<li><a href="#webflux-fn-handler-classes">处理程序类</a></li>
</ul>
</li>
<li><a href="#webflux-fn-router-functions">1.12.3。使用<code>RouterFunction</code></a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-predicates">使用谓词</a></li>
<li><a href="#webflux-fn-routes">路线</a></li>
</ul>
</li>
<li><a href="#webflux-fn-running">1.12.4。运行服务器</a></li>
<li><a href="#webflux-fn-handler-filter-function">1.12.5。使用<code>HandlerFilterFunction</code></a></li>
</ul>
</li>
<li><a href="#webflux-uri-building">1.13。URI链接</a>
<ul class="sectlevel3">
<li><a href="#web-uricomponents">1.13.1。UriComponents</a></li>
<li><a href="#web-uribuilder">1.13.2。UriBuilder</a></li>
<li><a href="#web-uri-encoding">1.13.3。URI编码</a></li>
</ul>
</li>
<li><a href="#webflux-cors">1.14。CORS</a>
<ul class="sectlevel3">
<li><a href="#webflux-cors-intro">1.14.1。介绍</a></li>
<li><a href="#webflux-cors-processing">1.14.2。处理</a></li>
<li><a href="#webflux-cors-controller">1.14.3。使用<code>@CrossOrigin</code></a></li>
<li><a href="#webflux-cors-global">1.14.4。全局配置</a></li>
<li><a href="#webflux-cors-webfilter">1.14.5。CORS <code>WebFilter</code></a></li>
</ul>
</li>
<li><a href="#webflux-web-security">1.15。网络安全</a></li>
<li><a href="#webflux-view">1.16。查看技术</a>
<ul class="sectlevel3">
<li><a href="#webflux-view-thymeleaf">1.16.1。Thymeleaf</a></li>
<li><a href="#webflux-view-freemarker">1.16.2。FreeMarker的</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-freemarker-contextconfig">查看配置</a></li>
<li><a href="#webflux-views-freemarker">FreeMarker配置</a></li>
</ul>
</li>
<li><a href="#webflux-view-script">1.16.3。脚本视图</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-script-dependencies">要求</a></li>
<li><a href="#webflux-view-script-integrate">脚本模板</a></li>
</ul>
</li>
<li><a href="#webflux-view-httpmessagewriter">1.16.4。JSON和XML</a></li>
</ul>
</li>
<li><a href="#webflux-caching">1.17。HTTP缓存</a>
<ul class="sectlevel3">
<li><a href="#webflux-caching-cachecontrol">1.17.1。<code>CacheControl</code></a></li>
<li><a href="#webflux-caching-etag-lastmodified">1.17.2。控制器</a></li>
<li><a href="#webflux-caching-static-resources">1.17.3。静态资源</a></li>
</ul>
</li>
<li><a href="#webflux-config">1.18。WebFlux配置</a>
<ul class="sectlevel3">
<li><a href="#webflux-config-enable">1.18.1。启用WebFlux配置</a></li>
<li><a href="#webflux-config-customize">1.18.2。WebFlux配置API</a></li>
<li><a href="#webflux-config-conversion">1.18.3。转换，格式化</a></li>
<li><a href="#webflux-config-validation">1.18.4。验证</a></li>
<li><a href="#webflux-config-content-negotiation">1.18.5。内容类型解析器</a></li>
<li><a href="#webflux-config-message-codecs">1.18.6。HTTP消息编解码器</a></li>
<li><a href="#webflux-config-view-resolvers">1.18.7。查看解析器</a></li>
<li><a href="#webflux-config-static-resources">1.18.8。静态资源</a></li>
<li><a href="#webflux-config-path-matching">1.18.9。路径匹配</a></li>
<li><a href="#webflux-config-advanced-java">10年1月18日。高级配置模式</a></li>
</ul>
</li>
<li><a href="#webflux-http2">1.19。HTTP / 2</a></li>
</ul>
</li>
<li><a href="#webflux-client">2。Web客户端</a>
<ul class="sectlevel2">
<li><a href="#webflux-client-builder">2.1。组态</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-builder-reactor">2.1.1。Reactor Netty</a>
<ul class="sectlevel4">
<li><a href="#webflux-client-builder-reactor-resources">资源</a></li>
<li><a href="#webflux-client-builder-reactor-timeout">超时</a></li>
</ul>
</li>
<li><a href="#webflux-client-builder-jetty">2.1.2。码头</a></li>
</ul>
</li>
<li><a href="#webflux-client-retrieve">2.2。使用<code>retrieve()</code></a></li>
<li><a href="#webflux-client-exchange">2.3。使用<code>exchange()</code></a></li>
<li><a href="#webflux-client-body">2.4。请求机构</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-body-form">2.4.1。表格数据</a></li>
<li><a href="#webflux-client-body-multipart">2.4.2。多部分数据</a></li>
</ul>
</li>
<li><a href="#webflux-client-filter">2.5。客户过滤器</a></li>
<li><a href="#webflux-client-testing">2.6。测试</a></li>
</ul>
</li>
<li><a href="#webflux-websocket">3。的WebSockets</a>
<ul class="sectlevel2">
<li><a href="#websocket-intro">3.1。WebSocket简介</a>
<ul class="sectlevel3">
<li><a href="#websocket-intro-architecture">3.1.1。HTTP与WebSocket</a></li>
<li><a href="#websocket-intro-when-to-use">3.1.2。何时使用WebSockets</a></li>
</ul>
</li>
<li><a href="#webflux-websocket-server">3.2。WebSocket API</a>
<ul class="sectlevel3">
<li><a href="#webflux-websocket-server-handler">3.2.1。服务器</a></li>
<li><a href="#webflux-websockethandler">3.2.2。使用<code>WebSocketHandler</code></a></li>
<li><a href="#webflux-websocket-server-handshake">3.2.3。握手</a></li>
<li><a href="#webflux-websocket-server-config">3.2.4。服务器配置</a></li>
<li><a href="#webflux-websocket-server-cors">3.2.5。CORS</a></li>
<li><a href="#webflux-websocket-client">3.2.6。客户</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-test">4。测试</a></li>
<li><a href="#webflux-reactive-libraries">5。反应性图书馆</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>这部分文档包括对基于<a href="http://www.reactive-streams.org/">Reactive Streams</a> API构建的反应堆栈Web应用程序的支持，以便在非阻塞服务器（如Netty，Undertow和Servlet 3.1+容器）上运行。各个章节涵盖<a href="#webflux">Spring WebFlux</a>框架，反应式<a href="#webflux-client"><code>WebClient</code></a> ， <a href="#webflux-test">测试</a>支持和<a href="#webflux-reactive-libraries">反应库</a> 。对于Servlet-stack Web应用程序，请参阅<a href="web.html#spring-web">Servlet Stack上的Web</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux"><a class="anchor" href="#webflux"></a> 1。Spring WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework中包含的原始Web框架Spring Web MVC是专为Servlet API和Servlet容器构建的。反应堆栈Web框架Spring WebFlux稍后在5.0版中添加。它完全无阻塞，支持<a href="http://www.reactive-streams.org/">Reactive Streams</a>背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。</p>
</div>
<div class="paragraph">
<p>这两个Web框架都反映了其源模块的名称（ <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a> ），并在Spring Framework中并存。每个模块都是可选的。应用程序可以使用一个或另一个模块，或者在某些情况下，两者都使用 - 例如，带有反应式<code>WebClient</code> Spring MVC控制器。</p>
</div>
<div class="sect3">
<h4 id="webflux-new-framework"><a class="anchor" href="#webflux-new-framework"></a> 1.1。动机</h4>
<div class="paragraph">
<p>为什么Spring WebFlux被创建了？</p>
</div>
<div class="paragraph">
<p>部分答案是需要一个非阻塞的Web堆栈来处理少量线程的并发性，并使用较少的硬件资源进行扩展。Servlet 3.1确实为非阻塞I / O提供了API。但是，使用它会远离Servlet API的其余部分，其中契约是同步的（ <code>Filter</code> ， <code>Servlet</code> ）或阻塞（ <code>getParameter</code> ， <code>getPart</code> ）。这是新的通用API作为任何非阻塞运行时的基础的动机。这很重要，因为在异步，非阻塞空间中已经建立了良好的服务器（例如Netty）。</p>
</div>
<div class="paragraph">
<p>答案的另一部分是函数式编程。就像在Java 5中添加注释一样创造了机会（例如带注释的REST控制器或单元测试），Java 8中添加lambda表达式为Java中的功能API创造了机会。这对于非阻塞应用程序和continuation-style API（由<code>CompletableFuture</code>和<a href="http://reactivex.io/">ReactiveX</a>推广）来说是一个福音，它允许异步逻辑的声明性组合。在编程模型级别，Java 8使Spring WebFlux能够提供功能性Web端点以及带注释的控制器。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-why-reactive"><a class="anchor" href="#webflux-why-reactive"></a> 1.2。定义“反应”</h4>
<div class="paragraph">
<p>我们触及“非阻塞”和“功能性”但反应意味着什么？</p>
</div>
<div class="paragraph">
<p>术语“反应性”是指围绕变化做出反应的编程模型 - 对I / O事件做出反应的网络组件，对鼠标事件做出反应的UI控制器等。从这个意义上讲，非阻塞是被动的，因为我们现在处于一种模式，即在操作完成或数据可用时对通知作出反应。</p>
</div>
<div class="paragraph">
<p>还有另一个重要的机制，我们在Spring团队中与“反应”相关联，即非阻塞背压。在同步，命令式代码中，阻塞调用是一种自然形式的背压，迫使调用者等待。在非阻塞代码中，控制事件的速率变得很重要，这样快速的生产者就不会淹没其目的地。</p>
</div>
<div class="paragraph">
<p>Reactive Streams是一个<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#specification">小规范</a> （在Java 9中也<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">采用</a> ），用于定义具有背压的异步组件之间的交互。例如，数据存储库（充当<a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">发布者</a> ）可以生成HTTP服务器（充当<a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">订阅服务器</a> ）然后可以写入响应的数据。Reactive Streams的主要目的是让订阅者控制发布者生成数据的速度或速度。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<strong>常见问题：如果出版商不能放慢速度怎么办？</strong><br>Reactive Streams的目的只是建立机制和边界。如果发布者不能放慢速度，则必须决定是缓冲，丢弃还是失败。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-reactive-api"><a class="anchor" href="#webflux-reactive-api"></a> 1.3。反应性API</h4>
<div class="paragraph">
<p>反应流在互操作性方面发挥着重要作用。它对库和基础架构组件很感兴趣，但作为应用程序API不太有用，因为它太低级了。应用程序需要更高级别和更丰富的功能API来组成异步逻辑 - 类似于Java 8 <code>Stream</code> API，但不仅适用于集合。这是反应性图书馆所扮演的角色。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor">Reactor</a>是Spring WebFlux的首选反应库。它提供<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html"><code>Mono</code></a>和<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html"><code>Flux</code></a> API类型来处理0..1（ <code>Mono</code> ）和0的数据序列。N（ <code>Flux</code> ）通过一组丰富的运算符与运算符的ReactiveX <a href="http://reactivex.io/documentation/operators.html">词汇表</a>对齐。Reactor是一个Reactive Streams库，因此，它的所有运营商都支持非阻塞背压。Reactor非常关注服务器端Java。它是与Spring密切合作开发的。</p>
</div>
<div class="paragraph">
<p>WebFlux要求Reactor作为核心依赖项，但它可以通过Reactive Streams与其他反应库互操作。作为一般规则，WebFlux API接受普通<code>Publisher</code>作为输入，在内部使其适应Reactor类型，使用它，并返回<code>Flux</code>或<code>Mono</code>作为输出。因此，您可以将任何<code>Publisher</code>作为输入传递，并且可以对输出应用操作，但是您需要调整输出以与另一个反应库一起使用。只要可行（例如，带注释的控制器），WebFlux就会透明地适应RxJava或其他反应库的使用。有关详细信息，请参阅<a href="#webflux-reactive-libraries">活动库</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-programming-models"><a class="anchor" href="#webflux-programming-models"></a> 1.4。编程模型</h4>
<div class="paragraph">
<p><code>spring-web</code>模块包含作为Spring WebFlux基础的反应基础，包括HTTP抽象，支持服务器的反应流<a href="#webflux-httphandler">适配器</a> ， <a href="#webflux-codecs">编解码器</a>和核心<a href="#webflux-web-handler-api">使用</a>与Servlet API相当但具有非阻塞合同<a href="#webflux-web-handler-api">的<code>WebHandler</code> API</a> 。</p>
</div>
<div class="paragraph">
<p>在此基础上，Spring WebFlux提供了两种编程模型供您选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-controller">带注释的控制器</a> ：与Spring MVC一致，并基于<code>spring-web</code>模块的相同注释。Spring MVC和WebFlux控制器都支持反应式（Reactor和RxJava）返回类型，因此，要区分它们并不容易。一个值得注意的区别是WebFlux还支持反应式<code>@RequestBody</code>参数。</p>
</li>
<li>
<p><a href="#webflux-fn">功能端点</a> ：基于Lambda，轻量级和函数式编程模型。您可以将其视为一个小型库或一组应用程序可用于路由和处理请求的实用程序。与带注释的控制器的最大区别在于，应用程序负责从头到尾的请求处理，而不是通过注释声明意图并被回调。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-framework-choice"><a class="anchor" href="#webflux-framework-choice"></a> 1.5。适用性</h4>
<div class="paragraph">
<p>Spring MVC还是WebFlux？</p>
</div>
<div class="paragraph">
<p>一个自然而然的问题，但是要设置一个不合理的二分法。实际上，两者共同努力扩大可用选项的范围。这两个设计是为了连续性和相互一致性，它们可以并排使用，每一方的反馈都有利于双方。下图显示了两者之间的关系，它们的共同点以及各自支持的内容：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-mvc-and-webflux-venn.png" alt="spring mvc和webflux venn">
</div>
</div>
<div class="paragraph">
<p>我们建议您考虑以下具体要点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您的Spring MVC应用程序运行正常，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您可以选择最多的库，因为从历史上看，大多数库都是阻塞的。</p>
</li>
<li>
<p>如果您已购买非阻塞Web堆栈，Spring WebFlux提供与此空间中的其他人相同的执行模型优势，并且还提供服务器选择（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能Web端点），以及选择反应库（Reactor，RxJava或其他）。</p>
</li>
<li>
<p>如果您对用于Java 8 lambdas或Kotlin的轻量级，功能性Web框架感兴趣，则可以使用Spring WebFlux功能Web端点。对于较小的应用程序或具有较低复杂要求的微服务而言，这也是一个不错的选择，可以从更高的透明度和控制中受益。</p>
</li>
<li>
<p>在微服务架构中，您可以将应用程序与Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点混合使用。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择合适的工具。</p>
</li>
<li>
<p>评估应用程序的一种简单方法是检查其依赖性。如果您要使用阻塞持久性API（JPA，JDBC）或网络API，则Spring MVC是常见体系结构的最佳选择。Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，但是你不会充分利用非阻塞的Web堆栈。</p>
</li>
<li>
<p>如果您有一个调用远程服务的Spring MVC应用程序，请尝试使用反应式<code>WebClient</code> 。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava <a href="#webflux-reactive-libraries">或其他</a> ）。每次呼叫的延迟或呼叫之间的相互依赖性越大，其益处就越大。Spring MVC控制器也可以调用其他无功组件。</p>
</li>
<li>
<p>如果您有一个庞大的团队，请记住转向非阻塞，功能和声明性编程时的陡峭学习曲线。在没有完整切换的情况下启动的实用方法是使用反应式<code>WebClient</code> 。除此之外，从小做起并衡量收益。我们希望，对于广泛的应用，这种转变是不必要的。如果您不确定要查找哪些好处，请首先了解非阻塞I / O的工作原理（例如，单线程Node.js上的并发）及其影响。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-server-choice"><a class="anchor" href="#webflux-server-choice"></a> 1.6。服务器</h4>
<div class="paragraph">
<p>Spring WebFlux在Tomcat，Jetty，Servlet 3.1+容器以及非Servlet运行时（如Netty和Undertow）上受支持。所有服务器都适用于低级别的<a href="#webflux-httphandler">通用API，</a>因此可以跨服务器支持更高级别的<a href="#webflux-programming-models">编程模型</a> 。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux没有内置支持来启动或停止服务器。但是，从Spring配置和<a href="#webflux-config">WebFlux基础架构</a> <a href="#webflux-web-handler-api">组装</a>应用程序并使用几行代码<a href="#webflux-httphandler">运行它</a>很容易。</p>
</div>
<div class="paragraph">
<p>Spring Boot有一个WebFlux启动器，可以自动执行这些步骤。默认情况下，starter使用Netty，但通过更改Maven或Gradle依赖项可以轻松切换到Tomcat，Jetty或Undertow。Spring Boot默认为Netty，因为它在异步，非阻塞空间中使用得更广泛，并允许客户端和服务器共享资源。</p>
</div>
<div class="paragraph">
<p>Tomcat和Jetty可以与Spring MVC和WebFlux一起使用。但请记住，它们的使用方式非常不同。Spring MVC依赖于Servlet阻塞I / O，并允许应用程序在需要时直接使用Servlet API。Spring WebFlux依赖于Servlet 3.1非阻塞I / O，并在低级适配器后面使用Servlet API，而不是直接使用。</p>
</div>
<div class="paragraph">
<p>对于Undertow，Spring WebFlux直接使用Undertow API而不使用Servlet API。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-performance"><a class="anchor" href="#webflux-performance"></a> 1.7。绩效与规模</h4>
<div class="paragraph">
<p>性能有许多特征和含义。反应性和非阻塞性通常不会使应用程序运行得更快。在某些情况下，它们可以（例如，如果使用<code>WebClient</code>并行执行远程调用）。总的来说，它需要更多的工作来以非阻塞的方式做事，并且可以略微增加所需的处理时间。</p>
</div>
<div class="paragraph">
<p>反应和非阻塞的关键预期好处是能够使用少量固定数量的线程和更少的内存进行扩展。这使得应用程序在负载下更具弹性，因为它们以更可预测的方式扩展。但是，为了观察这些好处，您需要有一些延迟（包括缓慢和不可预测的网络I / O的混合）。这就是反应堆栈开始显示其优势的地方，差异可能是戏剧性的。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-concurrency-model"><a class="anchor" href="#webflux-concurrency-model"></a> 1.8。并发模型</h4>
<div class="paragraph">
<p>Spring MVC和Spring WebFlux都支持带注释的控制器，但并发模型和阻塞和线程的默认假设存在关键差异。</p>
</div>
<div class="paragraph">
<p>在Spring MVC（以及一般的servlet应用程序）中，假设应用程序可以阻塞当前线程（例如，用于远程调用），因此，servlet容器使用大型线程池来吸收请求期间的潜在阻塞处理。</p>
</div>
<div class="paragraph">
<p>在Spring WebFlux（以及一般的非阻塞服务器）中，假设应用程序不会阻塞，因此，非阻塞服务器使用小的固定大小的线程池（事件循环工作程序）来处理请求。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">“缩放”和“少量线程”可能听起来很矛盾，但永远不会阻塞当前线程（并依赖于回调）意味着您不需要额外的线程，因为没有阻塞调用来吸收。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">调用阻止API</div>
<p>如果您确实需要使用阻止库，该怎么办？Reactor和RxJava都提供了<code>publishOn</code>运算符以继续在不同的线程上进行处理。这意味着有一个简单的逃生舱口。但请记住，阻塞API不适合这种并发模型。</p>
</div>
<div class="paragraph">
<div class="title">可变状态</div>
<p>在Reactor和RxJava中，您通过运算符声明逻辑，并且在运行时，形成一个反应流水线，其中数据在不同的阶段按顺序处理。这样做的一个主要好处是它可以使应用程序免于必须保护可变状态，因为该管道中的应用程序代码永远不会同时被调用。</p>
</div>
<div class="paragraph">
<div class="title">线程模型</div>
<p>您希望在运行Spring WebFlux的服务器上看到哪些线程？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在“vanilla”Spring WebFlux服务器上（例如，没有数据访问或其他可选依赖项），您可以期望服务器有一个线程，而其他几个用于请求处理（通常与CPU核心数一样多）。但是，Servlet容器可以从更多线程开始（例如，在Tomcat上为10），以支持servlet（阻塞）I / O和servlet 3.1（非阻塞）I / O使用。</p>
</li>
<li>
<p>反应式<code>WebClient</code>以事件循环方式运行。因此，您可以看到与此相关的少量固定数量的处理线程（例如，使用Reactor Netty连接器的<code>reactor-http-nio-</code> ）。但是，如果Reactor Netty同时用于客户端和服务器，则默认情况下两者共享事件循环资源。</p>
</li>
<li>
<p>Reactor和RxJava提供线程池抽象，称为调度程序，与<code>publishOn</code>运算符一起使用，该<code>publishOn</code>符用于将处理切换到不同的线程池。调度程序具有建议特定并发策略的名称 - 例如，“并行”（对于具有有限数量线程的CPU绑定工作）或“弹性”（对于具有大量线程的I / O绑定工作）。如果您看到这样的线程，则意味着某些代码正在使用特定的线程池<code>Scheduler</code>策略。</p>
</li>
<li>
<p>数据访问库和其他第三方依赖项也可以创建和使用自己的线程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">配置</div>
<p>Spring Framework不支持启动和停止<a href="#webflux-server-choice">服务器</a> 。要为服务器配置线程模型，需要使用特定于服务器的配置API，或者，如果使用Spring Boot，请检查每个服务器的Spring Boot配置选项。您可以直接<a href="#webflux-client-builder">配置</a> <code>WebClient</code> 。对于所有其他库，请参阅其各自的文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-reactive-spring-web"><a class="anchor" href="#webflux-reactive-spring-web"></a> 1.9。反应核心</h3>
<div class="paragraph">
<p><code>spring-web</code>模块包含用于构建反应式Web应用程序的抽象和基础结构。对于服务器端处理，它分为两个不同的级别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-httphandler">HttpHandler</a> ：用于HTTP请求处理的基本通用API，具有非阻塞I / O和（反应流）背压，以及每个支持的服务器的适配器。</p>
</li>
<li>
<p><a href="#webflux-web-handler-api">使用<code>WebHandler</code> API</a> ：稍高级别但仍然是用于服务器请求处理的通用API，它是更高级别编程模型的基础，例如带注释的控制器和功能端点。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>响应核心还包括用于客户端和服务器端使用的<a href="#webflux-codecs">编解码器</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-httphandler"><a class="anchor" href="#webflux-httphandler"></a> 1.9.1。使用<code>HttpHandler</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>是一个简单的契约，只有一个方法来处理请求和响应。它故意是最小的，因为它的主要目的是为HTTP请求处理提供不同服务器API的抽象。</p>
</div>
<div class="paragraph">
<p>下表描述了支持的服务器API：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:20%">
<col style="width:40%">
<col style="width:40%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">使用的服务器API</th>
<th class="tableblock halign-left valign-top">Reactive Streams支持</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网状</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/reactor/reactor-netty">Reactor Netty</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">暗潮</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：发布Reactive Streams桥接器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1非阻塞I / O;用于读写ByteBuffers与byte []的Tomcat API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Servlet 3.1非阻塞I / O到Reactive Streams网桥</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">码头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1非阻塞I / O;用于编写ByteBuffers与byte []的Jetty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Servlet 3.1非阻塞I / O到Reactive Streams网桥</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1容器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1非阻塞I / O.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Servlet 3.1非阻塞I / O到Reactive Streams网桥</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下表描述了服务器依赖性（和<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework">支持的版本</a> ）：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">组ID</th>
<th class="tableblock halign-left valign-top">工件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactor Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.projectreactor.netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">反应器 - 网状</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">暗潮</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">暗流核心</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.tomcat.embed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat的嵌入芯</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">码头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.eclipse.jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jetty-server，jetty-servlet</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下代码片段使<code>HttpHandler</code>适应每个服务器API：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Reactor Netty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler处理程序= ...ReactorHttpHandlerAdapter adapter = <span class="keyword">new</span> ReactorHttpHandlerAdapter（handler）; HttpServer.create（host，port）.newHandler（adapter）.block（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>暗潮</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler处理程序= ...UndertowHttpHandlerAdapter adapter = <span class="keyword">new</span> UndertowHttpHandlerAdapter（handler）; Undertow server = Undertow.builder（）。addHttpListener（port，host）.setHandler（adapter）.build（）; server.start（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tomcat的</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler处理程序= ...Servlet servlet = <span class="keyword">新的</span> TomcatHttpHandlerAdapter（处理程序）; Tomcat服务器= <span class="keyword">新的</span> Tomcat（）; <span class="predefined-type">文件</span>库= <span class="keyword">新</span> <span class="predefined-type">文件</span> （ <span class="predefined-type">System</span> .getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">java.io.tmpdir</span> <span class="delimiter">”</span></span> ））; <span class="predefined-type">Context</span> rootContext = server.addContext（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ，base.getAbsolutePath（））; Tomcat.addServlet（rootContext， <span class="string"><span class="delimiter">“</span> <span class="content">main</span> <span class="delimiter">”</span></span> ，servlet）; rootContext.addServletMappingDecoded（ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">main</span> <span class="delimiter">”</span></span> ）; server.setHost（主机）; server.setPort（端口）; server.start（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>码头</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler处理程序= ...Servlet servlet = <span class="keyword">new</span> JettyHttpHandlerAdapter（handler）; Server server = <span class="keyword">new</span> Server（）; ServletContextHandler contextHandler = <span class="keyword">new</span> ServletContextHandler（server， <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ）; contextHandler.addServlet（ <span class="keyword">new</span> ServletHolder（servlet）， <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ）; contextHandler.start（）; ServerConnector连接器= <span class="keyword">新的</span> ServerConnector（服务器）; connector.setHost（主机）; connector.setPort（端口）; server.addConnector（连接器）; server.start（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Servlet 3.1+容器</strong></p>
</div>
<div class="paragraph">
<p>要将WAR部署到任何Servlet 3.1+容器，您可以在WAR中扩展并包含<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html"><code>AbstractReactiveWebInitializer</code></a> 。该类用<code>ServletHttpHandlerAdapter</code>包装一个<code>HttpHandler</code>并将其注册为<code>Servlet</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-web-handler-api"><a class="anchor" href="#webflux-web-handler-api"></a> 1.9.2。使用<code>WebHandler</code> API</h4>
<div class="paragraph">
<p>所述WebHandler API是用于通过链中处理请求的通用服务器网络API <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html"><code>WebExceptionHandler</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html"><code>WebFilter</code></a>组件和目标<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html"><code>WebHandler</code></a>组件。您可以通过向构建器添加组件或从Spring <code>ApplicationContext</code>检测到组件来使用<code>WebHttpHandlerBuilder</code>组装链。构建器返回一个<a href="#webflux-httphandler">Using <code>HttpHandler</code></a> ，然后您可以<a href="#webflux-httphandler">使用该<code>HttpHandler</code></a>在任何支持的服务器上运行。</p>
</div>
<div class="paragraph">
<p>虽然<code>HttpHandler</code>旨在成为跨HTTP服务器的最小合同，但<code>WebHandler</code> API提供了常用于构建Web应用程序的基本功能。例如，WebHandler API组件可用的<code>ServerWebExchange</code>不仅可以访问请求和响应，还可以访问请求和会话属性，访问已分析的表单数据，多部分数据等。</p>
</div>
<div class="sect4">
<h5 id="webflux-web-handler-api-special-beans"><a class="anchor" href="#webflux-web-handler-api-special-beans"></a>特殊的豆类</h5>
<div class="paragraph">
<p>下表列出了<code>WebHttpHandlerBuilder</code>检测到的组件：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:12.5%">
<col style="width:37.5%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">豆名</th>
<th class="tableblock halign-left valign-top">豆类型</th>
<th class="tableblock halign-left valign-top">计数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;任何&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 ..ñ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供对<code>WebFilter</code>实例链和目标<code>WebHandler</code>异常的处理。有关更多详细信息，请参阅<a href="#webflux-exception-handler">例外</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;任何&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>网页过滤</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 ..ñ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将拦截样式逻辑应用于过滤器链的其余部分和目标<code>WebHandler</code>之前和之后。有关详细信息，请参阅<a href="#webflux-filters">过滤器</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的处理程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code>实例的管理器通过<code>ServerWebExchange</code>上的方法<code>ServerWebExchange</code> 。
  默认情况下为<code>DefaultWebSessionManager</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serverCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问<code>HttpMessageReader</code>实例以解析表单数据和多部分数据，然后通过<code>ServerWebExchange</code>方法公开这些数据。<code>ServerCodecConfigurer.create()</code>默认情况下。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localeContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过<code>LocaleContext</code>的方法<code>ServerWebExchange</code> 。
  默认情况下为<code>AcceptHeaderLocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ForwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理转发类型标头，通过提取和删除它们或仅删除它们。默认情况下不使用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-form-data"><a class="anchor" href="#webflux-form-data"></a>表格数据</h5>
<div class="paragraph">
<p><code>ServerWebExchange</code>公开以下方法来访问表单数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt;&gt; getFormData（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader</code>将表单数据（ <code>application/x-www-form-urlencoded</code> ）解析为<code>MultiValueMap</code> 。默认情况下， <code>FormHttpMessageReader</code>配置为由<code>ServerCodecConfigurer</code> bean使用（请参阅<a href="#webflux-web-handler-api">Web处理程序API</a> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart"><a class="anchor" href="#webflux-multipart"></a>多部分数据</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multipart">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerWebExchange</code>公开以下方法来访问多部分数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;MultiValueMap &lt; <span class="predefined-type">String</span> ，Part &gt;&gt; getMultipartData（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code>将<code>multipart/form-data</code>内容解析为<code>MultiValueMap</code> 。目前， <a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>是唯一受支持的第三方库，也是我们唯一知道的用于对多部分请求进行非阻塞解析的库。它通过<code>ServerCodecConfigurer</code> bean启用（请参阅<a href="#webflux-web-handler-api">Web Handler API</a> ）。</p>
</div>
<div class="paragraph">
<p>要解析的流媒体的方式多数据，你可以使用<code>Flux&lt;Part&gt;</code>从返回<code>HttpMessageReader&lt;Part&gt;</code>代替。例如，在带注释的控制器中，使用<code>@RequestPart</code>意味着按名称对各个部分进行<code>@RequestPart</code> <code>Map</code>访问，因此需要完整地解析多部分数据。相比之下，您可以使用<code>@RequestBody</code>将内容解码为<code>Flux&lt;Part&gt;</code>而无需收集到<code>MultiValueMap</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-forwarded-headers"><a class="anchor" href="#webflux-forwarded-headers"></a>转发标题</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters-forwarded-headers">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>当请求通过代理（例如负载平衡器）时，主机，端口和方案可能会发生变化，从客户的角度来看，这会产生一个挑战，即创建指向正确主机，端口和方案的链接。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可以用来提供有关原始请求的信息的<code>Forwarded</code> HTTP头。还有其他非标准头文件，包括<code>X-Forwarded-Host</code> ， <code>X-Forwarded-Port</code> ， <code>X-Forwarded-Proto</code> ， <code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code> 。</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderTransformer</code>是一个组件，它根据转发的标头修改请求的主机，端口和方案，然后删除这些标头。您可以将其声明为名为<code>forwardedHeaderTransformer</code>的bean，并将其<a href="#webflux-web-handler-api-special-beans">检测</a>并使用。</p>
</div>
<div class="paragraph">
<p>转发标头存在安全注意事项，因为应用程序无法知道标头是由代理按预期添加还是由恶意客户端添加。这就是为什么应该配置信任边界的代理来删除来自外部的不受信任的转发流量。您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderTransformer</code> ，在这种情况下，它会删除但不使用标头。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在5.1 <code>ForwardedHeaderFilter</code>已被废弃，并通过所取代<code>ForwardedHeaderTransformer</code>所以转发报头可以更早被处理时，将创建交换之前。如果仍然配置了过滤器，则将其从过滤器列表中取出，而使用<code>ForwardedHeaderTransformer</code> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-filters"><a class="anchor" href="#webflux-filters"></a> 1.9.3。过滤器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>在<a href="#webflux-web-handler-api">使用<code>WebHandler</code> API中</a> ，您可以使用<code>WebFilter</code>在过滤器的其余处理链和目标<code>WebHandler</code>之前和之后应用拦截样式逻辑。当使用<a href="#webflux-config">WebFlux配置</a> ，注册<code>WebFilter</code>是通过使用声明为一个Spring bean和（任选地）表达的优先级一样简单<code>@Order</code>在bean声明或通过实施<code>Ordered</code> 。</p>
</div>
<div class="sect4">
<h5 id="webflux-filters-cors"><a class="anchor" href="#webflux-filters-cors"></a> CORS</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters-cors">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux通过控制器上的注释为CORS配置提供细粒度的支持。但是，当您将其与Spring Security一起使用时，我们建议依赖内置的<code>CorsFilter</code> ，它必须在Spring Security的过滤器链之前进行排序。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#webflux-cors">CORS</a>和<a href="#webflux-cors-webfilter">CORS <code>WebFilter</code></a>一节。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-exception-handler"><a class="anchor" href="#webflux-exception-handler"></a> 1.9.4。例外</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-customer-servlet-container-error-page">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>在<a href="#webflux-web-handler-api">使用<code>WebHandler</code> API</a> ，你可以使用一个<code>WebExceptionHandler</code>处理来自链异常<code>WebFilter</code>情况和目标<code>WebHandler</code> 。使用<a href="#webflux-config">WebFlux配置时</a> ，注册<code>WebExceptionHandler</code>就像将它声明为Spring bean一样简单，并且（可选）通过在bean声明上使用<code>@Order</code>或通过实现<code>Ordered</code>来表示优先级。</p>
</div>
<div class="paragraph">
<p>下表描述了可用的<code>WebExceptionHandler</code>实现：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">异常处理程序</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过设置对异常的HTTP状态代码的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html"><code>ResponseStatusException</code></a> ，提供对<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html"><code>ResponseStatusException</code></a>类型的异常的处理。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFluxResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code>扩展，它还可以确定任何异常的<code>@ResponseStatus</code>注释的HTTP状态代码。
</p><p class="tableblock">此处理程序在<a href="#webflux-config">WebFlux配置中</a>声明。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-codecs"><a class="anchor" href="#webflux-codecs"></a> 1.9.5。编解码器</h4>
<div class="paragraph">
<p><span class="small"><a href="integration.html#rest-message-conversion">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html"><code>HttpMessageReader</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html"><code>HttpMessageWriter</code></a>是通过具有（Rective Streams）背压的非阻塞I / O编码和解码HTTP请求和响应内容的合同。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html"><code>Encoder</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html"><code>Decoder</code></a>是用于编码和解码内容的合同，独立于HTTP。它们可以用<code>EncoderHttpMessageWriter</code>或<code>DecoderHttpMessageReader</code>包装，并用于Web处理。</p>
</div>
<div class="paragraph">
<p>所有编解码器都用于客户端或服务器端。所有构建都基于<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html"><code>DataBuffer</code></a> ，它抽象字节缓冲区表示，例如Netty <code>ByteBuf</code>或<code>java.nio.ByteBuffer</code> （有关详细信息，请参阅<a href="core.html#databuffers">数据缓冲区和编解码器</a> ）。<code>ClientCodecConfigurer</code>和<code>ServerCodecConfigurer</code>通常用于配置和自定义要在应用程序中使用的编解码器。</p>
</div>
<div class="paragraph">
<p><code>spring-core</code>模块具有<code>byte[]</code> ， <code>ByteBuffer</code> ， <code>DataBuffer</code> ， <code>Resource</code>和<code>String</code>编码器和解码器。<code>spring-web</code>模块为Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers以及其他特定于Web的HTTP消息读取器和编写器添加了编码器和解码器，用于表单数据，多部分请求和服务器发送事件。</p>
</div>
<div class="sect4">
<h5 id="webflux-codecs-jackson"><a class="anchor" href="#webflux-codecs-jackson"></a>用杰克逊</h5>
<div class="paragraph">
<p>解码器依赖Jackson的非阻塞字节数组解析器将字节块流解析为<code>TokenBuffer</code>流，然后可以使用Jackson的<code>ObjectMapper</code>将其转换为对象。目前支持JSON和<a href="https://github.com/FasterXML/smile-format-specification">Smile</a> （二进制JSON）数据格式。</p>
</div>
<div class="paragraph">
<p>编码器处理<code>Publisher&lt;?&gt;</code> ，如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果<code>Publisher</code>是<code>Mono</code> （即单个值），则在可用时对值进行编码。</p>
</li>
<li>
<p>如果媒体类型是针对JSON的<code>application/stream+json</code>或者针对Smile的<code>application/stream+x-jackson-smile</code> ，则<code>Publisher</code>生成的每个值都是单独编码的（并且后面跟着JSON中的新行）。</p>
</li>
<li>
<p>否则，将使用<code>Flux#collectToList()</code>收集<code>Publisher</code>中的所有项目，并将生成的集合编码为数组。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>作为前面规则的特例， <code>ServerSentEventHttpMessageWriter</code>将从其输入<code>Publisher</code>发出的项单独地作为<code>Mono&lt;?给<code>Jackson2JsonEncoder</code> <code>Mono&lt;?&gt;</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，Jackson JSON编码器和解码器都明确地退出了<code>String</code>类型的渲染元素。相反， <code>String</code>实例被视为低级内容（即序列化的JSON），并由<code>CharSequenceEncoder</code>按原样呈现。如果要将<code>Flux&lt;String&gt;</code>呈现为JSON数组，则必须使用<code>Flux#collectToList()</code>并提供<code>Mono&lt;List&lt;String&gt;&gt;</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-streaming"><a class="anchor" href="#webflux-codecs-streaming"></a> HTTP流媒体</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-async-http-streaming">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>当诸如<code>Flux</code>的多值反应类型用于响应呈现时，它可以被收集到<code>List</code>并作为整体呈现（例如，JSON数组），或者它可以被视为每个项目的无限流立刻冲了过来。确定是基于内容协商和所选媒体类型进行的，这可能意味着流式格式（例如， <code>text/event-stream</code> ， <code>application/stream+json</code> ）或不是（例如， <code>application/json</code> ） 。</p>
</div>
<div class="paragraph">
<p>当流式传输到HTTP响应时，无论媒体类型如何（例如， <code>text/event-stream</code>和<code>application/stream+json</code> ），定期发送数据都很重要，因为如果客户端断开连接，写入将失败。发送可以采用空（仅注释）SSE事件或另一方必须解释为心跳并忽略的任何其他数据的形式。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-logging"><a class="anchor" href="#webflux-logging"></a> 1.9.6。记录</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-logging">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中的DEBUG级别日志记录旨在实现紧凑，最小化和人性化。它侧重于高价值的信息，这些信息对于仅在调试特定问题时有用的其他信息一次又一次有用。</p>
</div>
<div class="paragraph">
<p>TRACE级别日志记录通常遵循与DEBUG相同的原则（例如，也不应该是一个firehose），但可以用于调试任何问题。此外，一些日志消息可能在TRACE与DEBUG中显示不同的详细程度。</p>
</div>
<div class="paragraph">
<p>良好的日志记录来自使用日志的经验。如果您发现任何不符合既定目标的事件，请告知我们。</p>
</div>
<div class="sect4">
<h5 id="webflux-logging-id"><a class="anchor" href="#webflux-logging-id"></a>记录ID</h5>
<div class="paragraph">
<p>在WebFlux中，可以在多个线程上执行单个请求，并且线程ID对于关联属于特定请求的日志消息没有用。这就是默认情况下WebFlux日志消息以特定于请求的ID为前缀的原因。</p>
</div>
<div class="paragraph">
<p>在服务器端，日志ID存储在<code>ServerWebExchange</code>属性（ <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a> ）中，而基于该ID的完全格式化的前缀可从<code>ServerWebExchange#getLogPrefix()</code> 。在<code>WebClient</code>端，日志ID存储在<code>ClientRequest</code>属性（ <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a> ）中，而完全格式化的前缀可从<code>ClientRequest#logPrefix()</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-logging-sensitive-data"><a class="anchor" href="#webflux-logging-sensitive-data"></a>记录敏感数据</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-logging-sensitive-data">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DEBUG</code>和<code>TRACE</code>日志记录可以记录敏感信息。这就是默认情况下屏蔽表单参数和标头的原因，您必须明确启用它们的日志记录。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何对服务器端请求执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="type">类</span> <span class="class">的myconfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureHttpMessageCodecs（ServerCodecConfigurer配置器）{configurer.defaultCodecs（）enableLoggingRequestDetails（ <span class="predefined-constant">真</span> ）。 }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何对客户端请求执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Consumer &lt;ClientCodecConfigurer&gt; consumer = configurer  - &gt; configurer.defaultCodecs（）。enableLoggingRequestDetails（ <span class="predefined-constant">true</span> ）; WebClient webClient = WebClient.builder（）。exchangeStrategies（ExchangeStrategies.builder（）。codecs（consumer）.build（））。build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-handler"><a class="anchor" href="#webflux-dispatcher-handler"></a> 1.10。使用<code>DispatcherHandler</code></h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>与Spring MVC类似，Spring WebFlux是围绕前端控制器模式设计的，其中中央<code>WebHandler</code> （ <code>DispatcherHandler</code>为请求处理提供了共享算法，而实际工作则由可配置的委托组件执行。该模型非常灵活，支持多种工作流程。</p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code>从Spring配置中发现它需要的委托组件。它也被设计为一个Spring bean本身，并实现<code>ApplicationContextAware</code>以访问它运行的上下文。如果使用<code>webHandler</code>的bean名称声明<code>DispatcherHandler</code> ，则它又由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html"><code>WebHttpHandlerBuilder</code></a>发现， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html"><code>WebHttpHandlerBuilder</code></a>将请求处理链组合在一起，如<a href="#webflux-web-handler-api">使用<code>WebHandler</code> API中所述</a> 。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序中的Spring配置通常包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DispatcherHandler</code>带有bean名称<code>webHandler</code></p>
</li>
<li>
<p><code>WebFilter</code>和<code>WebExceptionHandler</code>豆</p>
</li>
<li>
<p><a href="#webflux-special-bean-types"><code>DispatcherHandler</code>特殊bean</a></p>
</li>
<li>
<p>其他</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>配置给<code>WebHttpHandlerBuilder</code>以构建处理链，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = ...HttpHandler handler = WebHttpHandlerBuilder.applicationContext（context）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生成的<code>HttpHandler</code>已准备好与<a href="#webflux-httphandler">服务器适配器一起使用</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-special-bean-types"><a class="anchor" href="#webflux-special-bean-types"></a> 1.10.1。特殊豆类</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-special-bean-types">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code>委托特殊bean处理请求并呈现适当的响应。“特殊bean”是指实现WebFlux框架契约的Spring管理的<code>Object</code>实例。那些通常带有内置合同，但您可以自定义其属性，扩展它们或替换它们。</p>
</div>
<div class="paragraph">
<p>下表列出了<code>DispatcherHandler</code>检测到的特殊bean。请注意，还有一些其他bean在较低级别检测到（请参阅Web Handler API中的<a href="#webflux-web-handler-api-special-beans">特殊bean类型</a> ）。</p>
</div>
<table id="webflux-special-beans-table" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">豆类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将请求映射到处理程序。映射基于一些标准，其细节因<code>HandlerMapping</code>实现而异 - 带注释的控制器，简单的URL模式映射等。
</p><p class="tableblock">主要的<code>HandlerMapping</code>实现是用于<code>@RequestMapping</code>注释方法的<code>RequestMappingHandlerMapping</code> ，用于功能端点路由的<code>RouterFunctionMapping</code> ，以及用于URI路径模式和<code>WebHandler</code>实例的显式注册的<code>SimpleUrlHandlerMapping</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无论实际调用处理程序如何，都可以帮助<code>DispatcherHandler</code>调用映射到请求的处理程序。例如，调用带注释的控制器需要解析注释。<code>HandlerAdapter</code>的主要目的是保护<code>DispatcherHandler</code>免受此类细节的影响。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理处理程序调用的结果并完成响应。请参见<a href="#webflux-resulthandling">结果处理</a> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-framework-config"><a class="anchor" href="#webflux-framework-config"></a> 1.10.2。WebFlux配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-config">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>应用程序可以声明处理请求所需的基础结构bean（在<a href="#webflux-web-handler-api-special-beans">Web Handler API</a>和<a href="#webflux-special-bean-types"><code>DispatcherHandler</code></a> ）。但是，在大多数情况下， <a href="#webflux-config">WebFlux配置</a>是最佳起点。它声明了所需的bean并提供了更高级别的配置回调API来自定义它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot依赖于WebFlux配置来配置Spring WebFlux，还提供了许多额外的便捷选项。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-handler-sequence"><a class="anchor" href="#webflux-dispatcher-handler-sequence"></a> 1.10.3。处理</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-sequence">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code>按如下方式处理请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要求每个<code>HandlerMapping</code>查找匹配的处理程序，并使用第一个匹配项。</p>
</li>
<li>
<p>如果找到一个处理程序，它将通过适当的<code>HandlerAdapter</code>执行，该处理程序将执行的返回值公开为<code>HandlerResult</code> 。</p>
</li>
<li>
<p><code>HandlerResult</code>被赋予适当的<code>HandlerResultHandler</code> ，通过直接写入响应或使用视图进行渲染来完成处理。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-resulthandling"><a class="anchor" href="#webflux-resulthandling"></a> 1.10.4。结果处理</h4>
<div class="paragraph">
<p>通过<code>HandlerAdapter</code>调用处理程序的返回值被包装为<code>HandlerResult</code>以及一些其他上下文，并传递给声称支持它的第一个<code>HandlerResultHandler</code> 。下表显示了可用的<code>HandlerResultHandler</code>实现，所有这些实现都在<a href="#webflux-config">WebFlux配置</a>中声明：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:50%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">结果处理程序类型</th>
<th class="tableblock halign-left valign-top">返回值</th>
<th class="tableblock halign-left valign-top">默认订单</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntityResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntity</code> ，通常来自<code>@Controller</code>实例。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponseResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponse</code> ，通常来自功能端点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理<code>@ResponseBody</code>方法或<code>@RestController</code>类的返回值。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolutionResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CharSequence</code> ， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/View.html"><code>View</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/ui/Model.html">Model</a> ， <code>Map</code> ， <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>或任何其他<code>Object</code>被视为模型属性。
</p><p class="tableblock">另请参见<a href="#webflux-viewresolution">视图分辨率</a> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>整数。MAX_VALUE</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-exceptions"><a class="anchor" href="#webflux-dispatcher-exceptions"></a> 1.10.5。例外</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-exceptionhandlers">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>从<code>HandlerAdapter</code>返回的<code>HandlerResult</code>可以基于某些特定于处理程序的机制公开用于错误处理的函数。在以下情况下调用此错误函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理程序（例如， <code>@Controller</code> ）调用失败。</p>
</li>
<li>
<p>通过<code>HandlerResultHandler</code>处理处理程序返回值失败。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只要在从处理程序返回的被动类型产生任何数据项之前发生错误信号，错误函数就可以更改响应（例如，更改为错误状态）。</p>
</div>
<div class="paragraph">
<p>这就是支持<code>@Controller</code>类中<code>@ExceptionHandler</code>方法的方法。相比之下，Spring MVC中<code>HandlerExceptionResolver</code>支持是基于<code>HandlerExceptionResolver</code> 。这通常无关紧要。但是，请记住，在WebFlux中，您不能使用<code>@ControllerAdvice</code>来处理在选择处理程序之前发生的异常。</p>
</div>
<div class="paragraph">
<p>另见<a href="#webflux-ann-controller-exceptions">管理异常</a>的“注释控制器”部分或<a href="#webflux-exception-handler">异常</a>的WebHandler API部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-viewresolution"><a class="anchor" href="#webflux-viewresolution"></a> 1.10.6。查看分辨率</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-viewresolver">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>视图分辨率允许使用HTML模板和模型呈现给浏览器，而无需将您与特定的视图技术联系起来。在Spring WebFlux中，通过专用的<a href="#webflux-resulthandling">HandlerResultHandler</a>支持视图解析，该<a href="#webflux-resulthandling">HandlerResultHandler</a>使用<code>ViewResolver</code>实例将String（表示逻辑视图名称）映射到<code>View</code>实例。然后使用<code>View</code>呈现响应。</p>
</div>
<div class="sect4">
<h5 id="webflux-viewresolution-handling"><a class="anchor" href="#webflux-viewresolution-handling"></a>处理</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-handling">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>传递给<code>ViewResolutionResultHandler</code>的<code>HandlerResult</code>包含处理程序的返回值以及包含在请求处理期间添加的属性的模型。返回值将作为以下之一处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code> ， <code>CharSequence</code> ：要通过已配置的<code>ViewResolver</code>实现列表解析为<code>View</code>逻辑视图名称。</p>
</li>
<li>
<p><code>void</code> ：根据请求路径选择默认视图名称，减去前导和尾部斜杠，并将其解析为<code>View</code> 。如果未提供视图名称（例如，返回模型属性）或异步返回值（例如， <code>Mono</code>完成为空），也会发生相同的情况。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a> ：用于视图分辨率方案的API。通过代码完成探索IDE中的选项。</p>
</li>
<li>
<p><code>Model</code> ， <code>Map</code> ：要添加到请求模型的额外模型属性。</p>
</li>
<li>
<p>任何其他：任何其他返回值（由简单类型除外，由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）被视为要添加到模型的模型属性。除非存在处理程序方法<code>@ModelAttribute</code>批注，否则属性名称是使用<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/Conventions.html">约定</a>从类名派生的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该模型可以包含异步，反应类型（例如，来自Reactor或RxJava）。在渲染之前， <code>AbstractView</code>将此类模型属性解析为具体值并更新模型。单值反应类型被解析为单个值或没有值（如果为空），而多值反应类型（例如， <code>Flux&lt;T&gt;</code> ）被收集并解析为<code>List&lt;T&gt;</code> 。</p>
</div>
<div class="paragraph">
<p>配置视图分辨率就像将<code>ViewResolutionResultHandler</code> bean添加到Spring配置一样简单。<a href="#webflux-config-view-resolvers">WebFlux Config</a>为视图分辨率提供专用配置API。</p>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参阅<a href="#webflux-view">View Technologies</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-redirecting-redirect-prefix"><a class="anchor" href="#webflux-redirecting-redirect-prefix"></a>重定向</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-redirecting-redirect-prefix">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>视图名称中的特殊<code>redirect:</code>前缀允许您执行重定向。<code>UrlBasedViewResolver</code> （和子类）将此识别为需要重定向的指令。视图名称的其余部分是重定向URL。</p>
</div>
<div class="paragraph">
<p>净效果与控制器返回<code>RedirectView</code>或<code>Rendering.redirectTo("abc").build()</code> ，但现在控制器本身可以根据逻辑视图名称进行操作。视图名称（例如<code>redirect:/some/resource</code> ）相对于当前应用程序，而视图名称（例如<code>redirect:http://example.com/arbitrary/path</code>重定向到绝对URL。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multiple-representations"><a class="anchor" href="#webflux-multiple-representations"></a>内容谈判</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multiple-representations">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ViewResolutionResultHandler</code>支持内容协商。它将请求媒体类型与每个所选<code>View</code>支持的媒体类型进行比较。使用支持所请求的媒体类型的第一个<code>View</code> 。</p>
</div>
<div class="paragraph">
<p>为了支持JSON和XML等媒体类型，Spring WebFlux提供了<code>HttpMessageWriterView</code> ，这是一个通过<a href="#webflux-codecs">HttpMessageWriter</a>呈现的特殊<code>View</code> 。通常，您可以通过<a href="#webflux-config-view-resolvers">WebFlux配置</a>将它们配置为默认视图。如果默认视图与请求的媒体类型匹配，则始终选择并使用它们。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-controller"><a class="anchor" href="#webflux-controller"></a> 1.11。带注释的控制器</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-controller">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux提供基于注释的编程模型，其中<code>@Controller</code>和<code>@RestController</code>组件使用注释来表达请求映射，请求输入，处理异常等。带注释的控制器具有灵活的方法签名，不必扩展基类，也不必实现特定的接口。</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个基本示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">HelloController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ hello</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">Hello WebFlux</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，该方法返回要写入响应主体的<code>String</code> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller"><a class="anchor" href="#webflux-ann-controller"></a> 1.11.1。使用<code>@Controller</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用标准的Spring bean定义来定义控制器bean。<code>@Controller</code>型允许自动检测，并与Spring一般支持一致，用于检测<code>@Component</code>路径中的<code>@Component</code>类并自动注册它们的bean定义。它还充当带注释类的构造型，表明它作为Web组件的角色。</p>
</div>
<div class="paragraph">
<p>要启用此类<code>@Controller</code> bean的自动检测，您可以将组件扫描添加到Java配置中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@ComponentScan</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">org.example.web</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>扫描<code>org.example.web</code>包。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@RestController</code>是一个<a href="core.html#beans-meta-annotations">组合注释</a> ，它本身使用<code>@Controller</code>和<code>@ResponseBody</code>元注释，表示一个控制器，其每个方法都继承了类型级<code>@ResponseBody</code>注释，因此，直接写入响应主体与视图分辨率和使用HTML模板。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping"><a class="anchor" href="#webflux-ann-requestmapping"></a> 1.11.2。请求映射</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code>注释用于将请求映射到控制器方法。它具有各种属性，可通过URL，HTTP方法，请求参数，标头和媒体类型进行匹配。您可以在类级别使用它来表示共享映射，或者在方法级别使用它来缩小到特定的端点映射。</p>
</div>
<div class="paragraph">
<p>还有<code>@RequestMapping</code> HTTP方法特定快捷方式变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的注释是提供的<a href="#webflux-ann-requestmapping-composed">自定义注释</a> ，因为可以说，大多数控制器方法应该映射到特定的HTTP方法而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。同时，在类级别仍然需要<code>@RequestMapping</code>来表示共享映射。</p>
</div>
<div class="paragraph">
<p>以下示例使用类型和方法级别映射：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons</span> <span class="delimiter">”</span></span> ） <span class="type">class</span> <span class="class">PersonController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Person getPerson（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@PostMapping</span> <span class="annotation">@ResponseStatus</span> （ <span class="annotation">HttpStatus</span> 。创建） <span class="directive">public</span> <span class="type">void</span> add（ <span class="annotation">@RequestBody</span> Person person）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-uri-templates"><a class="anchor" href="#webflux-ann-requestmapping-uri-templates"></a> URI模式</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-uri-templates">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用glob模式和通配符来映射请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>？</code> 匹配一个字符</p>
</li>
<li>
<p><code>*</code>匹配路径段中的零个或多个字符</p>
</li>
<li>
<p><code>**</code>匹配零个或多个路径段</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以使用<code>@PathVariable</code>声明URI变量并访问它们的值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Pet findPet（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> ownerId， <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在类和方法级别声明URI变量，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId}</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">OwnerController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">public</span> Pet findPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> ownerId， <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> petId）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>类级URI映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>方法级URI映射。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>URI变量会自动转换为适当的类型，或者引发<code>TypeMismatchException</code> 。默认情况下支持简单类型（ <code>int</code> ， <code>long</code> ， <code>Date</code>等），您可以注册对任何其他数据类型的支持。请参见<a href="#webflux-ann-typeconversion">类型转换</a>和<a href="#webflux-ann-initbinder">使用<code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>URI变量可以显式命名（例如， <code>@PathVariable("customId")</code> ），但如果名称相同，您可以保留该详细信息，并使用调试信息或Java 8上的<code>-parameters</code>编译器标志编译代码。</p>
</div>
<div class="paragraph">
<p>语法<code>{*varName}</code>声明一个URI变量，该变量匹配零个或多个剩余路径段。例如<code>/resources/{*path}</code>匹配所有文件<code>/resources/</code> ， <code>"path"</code>变量捕获完整的相对路径。</p>
</div>
<div class="paragraph">
<p>语法<code>{varName:regex}</code>声明一个URI变量，其正则表达式的语法为： <code>{varName:regex}</code> 。例如，给定<code>/spring-web-3.0.5 .jar</code>的URL，以下方法将提取名称，版本和文件扩展名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {name：[az  - ] +}  -  {version：</span> <span class="char">\\</span> <span class="content">d</span> <span class="char">\\</span> <span class="content">。</span> <span class="char">\\</span> <span class="content">d</span> <span class="char">\\</span> <span class="content">。</span> <span class="char">\\</span> <span class="content">d} {ext：</span> <span class="char">\\</span> <span class="content">。[az] +}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle （ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> version， <span class="annotation">@ PathVariable</span> <span class="predefined-type">String</span> ext）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>URI路径模式还可以嵌入<code>${…​}</code>占位符，这些占位符在启动时通过<code>PropertyPlaceHolderConfigurer</code>针对本地，系统，环境和其他属性源进行解析。例如，您可以使用它来根据某些外部配置参数化基本URL。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring WebFlux使用<code>PathPattern</code>和<code>PathPatternParser</code>来支持URI路径匹配。这两个类都位于<code>spring-web</code> ，并且专门设计用于Web应用程序中的HTTP URL路径，其中在运行时匹配大量URI路径模式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux不支持后缀模式匹配 - 与Spring MVC不同，其中<code>/person</code>类的映射也与<code>/person.匹配<code>/person.*</code> 。对于基于URL的内容协商，如果需要，我们建议使用查询参数，该参数更简单，更明确，并且不易受基于URL路径的攻击。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-pattern-comparison"><a class="anchor" href="#webflux-ann-requestmapping-pattern-comparison"></a>模式比较</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-pattern-comparison">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>当多个模式与URL匹配时，必须对它们进行比较以找到最佳匹配。这是通过<code>PathPattern.完成的<code>PathPattern.SPECIFICITY_COMPARATOR</code> ，用于查找更具体的模式。</p>
</div>
<div class="paragraph">
<p>对于每个模式，根据URI变量和通配符的数量计算得分，其中URI变量得分低于通配符。总得分较低的模式获胜。如果两个模式具有相同的分数，则选择的时间越长。</p>
</div>
<div class="paragraph">
<p>Catch-all模式（例如， <code>**</code> ， <code>{*varName}</code> ）将从评分中排除，并始终排在最后。如果两个模式都是全部捕获，则选择的时间越长。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-consumes"><a class="anchor" href="#webflux-ann-requestmapping-consumes"></a>耗材类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-consumes">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据请求的<code>Content-Type</code>缩小请求映射范围，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets</span> <span class="delimiter">”</span></span> ， <span class="annotation">consume</span> <strong>= <span class="string"><span class="delimiter">“</span> <span class="content">application / json</span> <span class="delimiter">”</span></span></strong> ） <span class="directive">public</span> <span class="type">void</span> addPet（ <span class="annotation">@RequestBody</span> Pet pet）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>consumemes属性还支持否定表达式 - 例如， <code>!text/plain</code>表示<code>text/plain</code>以外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>你可以声明一个共享的<code>consumes</code>类级别属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>consumes</code>属性覆盖而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>为常用媒体类型提供常量 - 例如， <code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-produces"><a class="anchor" href="#webflux-ann-requestmapping-produces"></a>可生产的媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-produces">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="content">produce</span></span> <strong>= <span class="string"><span class="delimiter">“</span> <span class="content">application / json; charset = UTF-8</span> <span class="delimiter">”</span></span></strong> ） <span class="annotation">@ResponseBody</span> <span class="directive">public</span> Pet getPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>媒体类型可以指定字符集。支持否定表达式 - 例如， <code>!text/plain</code>表示<code>text/plain</code>以外的任何内容类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于JSON内容类型，即使<a href="https://tools.ietf.org/html/rfc7159#section-11">RFC7159</a>明确指出“没有为此注册定义charset参数”，也应指定UTF-8 <code>charset</code> ，因为某些浏览器要求它正确解释UTF-8特殊字符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以在类级别声明共享的<code>produces</code>属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>produces</code>属性覆盖，而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>为常用媒体类型提供常量 - 例如<code>APPLICATION_JSON_UTF8_VALUE</code> ， <code>APPLICATION_XML_VALUE</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-params-and-headers"><a class="anchor" href="#webflux-ann-requestmapping-params-and-headers"></a>参数和标题</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-params-and-headers">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据查询参数条件缩小请求映射。您可以测试是否存在查询参数（ <code>myParam</code> ），因为它不存在（ <code>!myParam</code> ），或特定值（ <code>myParam=myValue</code> ）。以下示例测试具有值的参数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ，params = <span class="string"><span class="delimiter">“</span> <span class="content">myParam = myValue</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>检查<code>myParam</code>等于<code>myValue</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以将其与请求标头条件一起使用，如下面的示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （path = <span class="string"><span class="delimiter">“</span> <span class="content">/ pets</span> <span class="delimiter">”</span></span> ，headers = <span class="string"><span class="delimiter">“</span> <span class="content">myHeader = myValue</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>检查<code>myHeader</code>等于<code>myValue</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-head-options"><a class="anchor" href="#webflux-ann-requestmapping-head-options"></a> HTTP HEAD，OPTIONS</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-head-options">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>和<code>@RequestMapping(method=HttpMethod.GET)</code>透明地支持HTTP HEAD以用于请求映射目的。控制器方法无需更改。在<code>HttpHandler</code>服务器适配器中应用的响应包装器确保将<code>Content-Length</code>头设置为写入的字节数，而不实际写入响应。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过将<code>Allow</code>响应头设置为所有具有匹配URL模式的<code>@RequestMapping</code>方法中列出的HTTP方法列表来处理HTTP OPTIONS。</p>
</div>
<div class="paragraph">
<p>对于没有HTTP方法声明的@ <code>@RequestMapping</code> ， <code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code> 。控制器方法应始终声明支持的HTTP方法（例如，通过使用HTTP方法特定的变体 - <code>@GetMapping</code> ， <code>@PostMapping</code>等）。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@RequestMapping</code>方法显式映射到HTTP HEAD和HTTP OPTIONS，但在常见情况下这不是必需的。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-composed"><a class="anchor" href="#webflux-ann-requestmapping-composed"></a>自定义注释</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-composed">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux支持使用<a href="core.html#beans-meta-annotations">组合注释</a>进行请求映射。这些注释本身是使用<code>@RequestMapping</code>元注释的，并且用于重新声明具有更窄，更具体目的的<code>@RequestMapping</code>属性的子集（或全部）。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> ， <code>@PostMapping</code> ， <code>@PutMapping</code> ， <code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。它们是提供的，因为可以说，大多数控制器方法应该映射到特定的HTTP方法而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。如果您需要组合注释的示例，请查看如何声明这些注释。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要对<code>RequestMappingHandlerMapping</code>子类化并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并返回自己的<code>RequestCondition</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-registration"><a class="anchor" href="#webflux-ann-requestmapping-registration"></a>明确的注册</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-registration">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以以编程方式注册Handler方法，这些方法可用于动态注册或高级情况，例如不同URL下的同一处理程序的不同实例。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfig</span> { <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setHandlerMapping（RequestMappingHandlerMapping mapping，UserHandler handler） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">抛出</span> <span class="exception">NoSuchMethodException</span> {RequestMappingInfo info = RequestMappingInfo .paths（ <span class="string"><span class="delimiter">“</span> <span class="content">/ user / {id}</span> <span class="delimiter">”</span></span> ）。method（RequestMethod。GET）.build（）; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="predefined-type">方法</span>方法= UserHandler.class.getMethod（ <span class="string"><span class="delimiter">“</span> <span class="content">getUser</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Long</span> .class）; <i class="conum" data-value="3"></i> <b>（3）</b> mapping.registerMapping（info，handler，method）; <i class="conum" data-value="4"></i> <b>（4）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加注册。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-methods"><a class="anchor" href="#webflux-ann-methods"></a> 1.11.3。处理程序方法</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-methods">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从一系列受支持的控制器方法参数和返回值中进行选择。</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-arguments"><a class="anchor" href="#webflux-ann-arguments"></a>方法参数</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-arguments">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>下表显示了受支持的控制器方法参数。</p>
</div>
<div class="paragraph">
<p>需要阻塞I / O（例如，读取请求主体）的参数支持反应类型（Reactor，RxJava <a href="#webflux-reactive-libraries">或其他</a> ）。这在“描述”列中标记。对于不需要阻塞的参数，不期望使用反应类型。</p>
</div>
<div class="paragraph">
<p>JDK 1.8的<code>java.util.Optional</code>支持作为方法参数与具有<code>required</code>属性的注释（例如，@ <code>@RequestParam</code> ，@ <code>@RequestHeader</code>等）相结合，并且等效于<code>required=false</code> 。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerWebExchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问完整的<code>ServerWebExchange</code> -  HTTP请求和响应的容器，请求和会话属性， <code>checkNotModified</code>方法等。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpRequest</code> ， <code>ServerHttpResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问HTTP请求或响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问会话。除非添加属性，否则这不会强制启动新会话。支持反应类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security。主要</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前经过身份验证的用户 - 可能是特定的<code>Principal</code>实现类（如果已知）。支持反应类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.http。列举HTTPMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。语言环境</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前请求区域设置，由最可用的<code>LocaleResolver</code>确定 - 实际上是已配置的<code>LocaleResolver</code> / <code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。TimeZone</code> + <code>java.time.了zoneid</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI模板变量。请参阅<a href="#webflux-ann-requestmapping-uri-templates">URI模式</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI路径段中的名称 - 值对。请参见<a href="#webflux-ann-matrix-variables">矩阵变量</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet请求参数。参数值将转换为声明的方法参数类型。请参阅<a href="#webflux-ann-requestparam">使用<code>@RequestParam</code></a> 。
</p><p class="tableblock">请注意，使用<code>@RequestParam</code>是可选的 - 例如，设置其属性。请参阅本表后面的“任何其他参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头。标头值将转换为声明的方法参数类型。请参阅<a href="#webflux-ann-requestheader">使用<code>@RequestHeader</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问cookie。Cookie值将转换为声明的方法参数类型。请参阅<a href="#webflux-ann-cookievalue">使用<code>@CookieValue</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTTP请求正文。通过使用<code>HttpMessageReader</code>实例将<code>HttpMessageReader</code>内容转换为声明的方法参数类型。支持反应类型。请参阅<a href="#webflux-ann-requestbody">使用<code>@RequestBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity &lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头和正文。使用<code>HttpMessageReader</code>实例转换<code>HttpMessageReader</code> 。支持反应类型。请参阅<a href="#webflux-ann-httpentity">使用<code>HttpEntity</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问<code>multipart/form-data</code>请求中的部件。支持反应类型。请参阅<a href="#webflux-multipart-forms">多部分内容</a>和<a href="#webflux-multipart">多部分数据</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。Map</code> ， <code>org.springframework.ui.Model</code>和<code>org.springframework.ui.ModelMap</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTML控制器中使用的模型，并作为视图呈现的一部分向模板公开。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问模型中的现有属性（如果不存在则实例化），并应用数据绑定和验证。请参阅<a href="#webflux-ann-modelattrib-method-args">使用<code>@ModelAttribute</code></a>以及<a href="#webflux-ann-modelattrib-methods">使用模型</a>和<a href="#webflux-ann-initbinder">使用<code>DataBinder</code></a> 。
</p><p class="tableblock">请注意，使用<code>@ModelAttribute</code>是可选的 - 例如，设置其属性。请参阅本表后面的“任何其他参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code> ， <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问来自命令对象的验证和数据绑定的错误（即<code>@ModelAttribute</code>参数）或来自验证<code>@RequestBody</code>或<code>@RequestPart</code>参数的错误。必须在经过验证的方法参数之后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> +类级别<code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于标记表单处理完成，它触发通过类级别<code>@SessionAttributes</code>注释声明的会话属性的清除。有关更多详细信息，请参阅<a href="#webflux-ann-sessionattributes">使用<code>@SessionAttributes</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于准备相对于当前请求的主机，端口，方案和路径的URL。请参阅<a href="#webflux-uri-building">URI链接</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问任何会话属性 - 与由于类级别<code>@SessionAttributes</code>声明而存储在会话中的模型属性相反。有关更多详细信息，请参阅<a href="#webflux-ann-sessionattribute">使用<code>@SessionAttribute</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求属性。有关更多详细信息，请参阅<a href="#webflux-ann-requestattrib">使用<code>@RequestAttribute</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他论点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果方法参数与上述任何一个都不匹配，则默认情况下，如果它是一个简单类型（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定），或者为<code>@ModelAttribute</code> ，则默认情况下将其解析为<code>@RequestParam</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-return-types"><a class="anchor" href="#webflux-ann-return-types"></a>返回值</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-return-types">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>下表显示了支持的控制器方法返回值。请注意，所有返回值通常都支持来自库（如Reactor，RxJava <a href="#webflux-reactive-libraries">或其他）的</a>反应类型。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法返回值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值通过<code>HttpMessageWriter</code>实例进行编码并写入响应。请参阅<a href="#webflux-ann-responsebody">使用<code>@ResponseBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code> ， <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值指定完整响应，包括HTTP标头，并且正文通过<code>HttpMessageWriter</code>实例进行编码并写入响应。请参阅<a href="#webflux-ann-responseentity">使用<code>ResponseEntity</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于返回带标题且没有正文的响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>串</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用<code>ViewResolver</code>实例解析并与隐式模型一起使用的视图名称 - 通过命令对象和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数（ <a href="#webflux-viewresolution-handling">如前所述</a> ）以编程方式丰富模型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>视图</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数（ <a href="#webflux-viewresolution-handling">如前所述</a> ）以编程方式丰富模型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。Map</code> ， <code>org.springframework.ui.模型</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到隐式模型的属性，其中视图名称是根据请求路径隐式确定的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到模型的属性，其中视图名称是根据请求路径隐式确定的。
</p><p class="tableblock">请注意，@ <code>@ModelAttribute</code>是可选的。请参阅此表后面的“任何其他返回值”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>渲染</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于模型和视图渲染方案的API。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>空虚</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有<code>void</code> ，可能是异步的方法（例如， <code>Mono&lt;Void&gt;</code> ），返回类型（或<code>null</code>返回值）被认为已完全处理响应，如果它还具有<code>ServerHttpResponse</code> ， <code>ServerWebExchange</code>参数或<code>@ResponseStatus</code>注解。如果控制器已经进行了正ETag或<code>lastModified</code>时间戳检查，情况也是如此。// TODO：有关详细信息，请参阅<a href="#webflux-caching-etag-lastmodified">控制器</a> 。
</p><p class="tableblock">如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;ServerSentEvent&gt;</code> ， <code>Observable&lt;ServerSentEvent&gt;</code>或其他被动类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发送服务器发送的事件。当只需要写入数据时，可以省略<code>ServerSentEvent</code>包装器（但是，必须通过<code>produces</code>属性在映射中请求或声明<code>text/event-stream</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果返回值与上述任何一个不匹配，则默认情况下将其视为视图名称，如果它是<code>String</code>或<code>void</code> （应用默认视图名称选择），或者作为要添加到模型的模型属性，除非它是一个简单类型，由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定，在这种情况下它仍然没有得到解决。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-typeconversion"><a class="anchor" href="#webflux-ann-typeconversion"></a>类型转换</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-typeconversion">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>表示基于字符串的请求输入一些注释的控制器方法的参数（例如， <code>@RequestParam</code> ， <code>@RequestHeader</code> ， <code>@PathVariable</code> ， <code>@MatrixVariable</code>和<code>@CookieValue</code> ）可能需要类型转换如果参数被声明为比其它东西<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>对于此类情况，将根据配置的转换器自动应用类型转换。默认情况下，支持简单类型（如<code>int</code> ， <code>long</code> ， <code>Date</code>等）。可以通过<code>WebDataBinder</code> （参见<a href="#mvc-ann-initbinder">[mvc-ann-initbinder]</a> ）或使用<code>FormattingConversionService</code>注册<code>Formatters</code>来查看类型转换（请参阅<a href="core.html#format">Spring Field Formatting</a> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-matrix-variables"><a class="anchor" href="#webflux-ann-matrix-variables"></a>矩阵变量</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-matrix-variables">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a>讨论了路径段中的名称 - 值对。在Spring WebFlux中，我们将这些基于Tim Berners-Lee的<a href="http://www.w3.org/DesignIssues/MatrixURIs.html">“旧帖子”</a>称为“矩阵变量”，但它们也可以称为URI路径参数。</p>
</div>
<div class="paragraph">
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔 - 例如， <code>"/cars;color=red,green;year=2012"</code> 。也可以通过重复的变量名来指定多个值 - 例如， <code>"color=red;color=green;color=blue"</code> 。</p>
</div>
<div class="paragraph">
<p>与Spring MVC不同，在WebFlux中，URL中矩阵变量的存在与否不会影响请求映射。换句话说，您不需要使用URI变量来屏蔽变量内容。也就是说，如果要从控制器方法访问矩阵变量，则需要将URI变量添加到期望矩阵变量的路径段中。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / pets / 42; q = 11; r = 22</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">String</span> petId， <span class="annotation">@ MatrixVariable</span> <span class="type">int</span> q）{ <span class="comment">// petId == 42</span> <span class="comment">// q == 11</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>鉴于所有路径段都可以包含矩阵变量，您有时可能需要消除矩阵变量所在的路径变量的歧义，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / owners / 42; q = 11 / pets / 21; q = 22</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@MatrixVariable</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， pathVar = <span class="string"><span class="delimiter">“</span> <span class="content">ownerId</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> q1， <span class="annotation">@ MatrixVariable</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ，pathVar = <span class="string"><span class="delimiter">“</span> <span class="content">petId</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> q2）{ <span class="comment">// q1 == 11</span> <span class="comment">// q2 == 22</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以定义矩阵变量，可以将其定义为可选，并指定默认值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / pets / 42</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@MatrixVariable</span> （required = <span class="predefined-constant">false</span> ，defaultValue = <span class="string"><span class="delimiter">“</span> <span class="content">1</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> q）{ <span class="comment">// q == 1</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要获取所有矩阵变量，请使用<code>MultiValueMap</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET / owners / 42; q = 11; r = 12 / pets / 21; q = 22; s = 23</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> findPet（ <span class="annotation">@ MatrixVariable</span> MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; matrixVars， <span class="annotation">@ MatrixVariable</span> （pathVar = <span class="string"><span class="delimiter">“</span> <span class="content">petId</span> <span class="delimiter">”</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">）MultiValueMap &lt;String，String&gt; petMatrixVars）{// matrixVars：[</span> <span class="delimiter">”</span></span> q <span class="string"><span class="delimiter">“</span> <span class="content">：[11,22]，</span> <span class="delimiter">”</span></span> r <span class="string"><span class="delimiter">“</span> <span class="content">：12，</span> <span class="delimiter">”</span></span> s <span class="string"><span class="delimiter">“</span> <span class="content">：23] // petMatrixVars：[</span> <span class="delimiter">”</span></span> q <span class="string"><span class="delimiter">“</span> <span class="content">：22，</span> <span class="delimiter">”</span></span> s <span class="string"><span class="delimiter">“</span> <span class="content">：23]}</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestparam"><a class="anchor" href="#webflux-ann-requestparam"></a>使用<code>@RequestParam</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestparam">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestParam</code>批注将查询参数绑定到控制器中的方法参数。以下代码段显示了用法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">EditPetForm</span> { <span class="comment">// ...</span>

    <span class="annotation">@GetMapping</span> <span class="directive">public</span> <span class="predefined-type">String</span> setupForm（ <span class="annotation">@RequestParam</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">petId</span> <span class="delimiter">”</span></span> ） <span class="type">int</span> petId，Model model）{ <i class="conum" data-value="1"></i> <b>（1）</b> Pet pet = <span class="local-variable">this</span> .clinic.loadPet（petId）; model.addAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ，pet）; <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">petForm</span> <span class="delimiter">”</span></span> ; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestParam</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Servlet API“请求参数”概念将查询参数，表单数据和多部分合并为一个。但是，在WebFlux中，每个都是通过<code>ServerWebExchange</code>单独访问的。虽然<code>@RequestParam</code>仅绑定到查询参数，但您可以使用数据绑定将查询参数，表单数据和多部分应用于<a href="#webflux-ann-modelattrib-method-args">命令对象</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，需要使用<code>@RequestParam</code>注释的方法参数，但您可以通过将<code>@RequestParam</code>的required标志设置为<code>false</code>或通过使用<code>java.util.声明参数来指定方法参数是可选的<code>java.util.Optional</code>包装。</p>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是<code>String</code>则自动应用类型转换。见<a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a> 。</p>
</div>
<div class="paragraph">
<p>在<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>参数上声明<code>@RequestParam</code>注释时，将使用所有查询参数填充地图。</p>
</div>
<div class="paragraph">
<p>请注意，使用<code>@RequestParam</code>是可选的 - 例如，设置其属性。默认情况下，任何属于简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）并且未被任何其他参数解析器解析的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">视图</a>都被视为使用<code>@RequestParam</code>进行注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestheader"><a class="anchor" href="#webflux-ann-requestheader"></a>使用<code>@RequestHeader</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestheader">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestHeader</code>批注将请求标头绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了包含标头的请求：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>主机localhost：8080接受text / html，application / xhtml + xml，application / xml; q = 0.9 Accept-Language fr，en-gb; q = 0.7，en; q = 0.3 Accept-Encoding gzip，deflate Accept-Charset ISO -8859-1，utf-8; q = 0.7，*; q = 0.7 Keep-Alive 300</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code>标头的值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ demo</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@RequestHeader</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Accept-Encoding</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">字符串</span>编码， <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@RequestHeader</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Keep-Alive</span> <span class="delimiter">”</span></span> ） <span class="type">long</span> keepAlive）{ <i class="conum" data-value="2"></i> <b>（2）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>获取<code>Accept-Encoging</code>标头的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获取<code>Keep-Alive</code>标头的值。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是<code>String</code>则自动应用类型转换。见<a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a> 。</p>
</div>
<div class="paragraph">
<p>在<code>Map&lt;String, String&gt;</code> ， <code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用<code>@RequestHeader</code>注释时，将使用所有标头值填充地图。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型。例如，使用<code>@RequestHeader("Accept")</code>注释的方法参数可以是<code>String</code>类型，也可以是<code>String[]</code>或<code>List&lt;String&gt;</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-cookievalue"><a class="anchor" href="#webflux-ann-cookievalue"></a>使用<code>@CookieValue</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-cookievalue">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@CookieValue</code>批注将HTTP cookie的值绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了带cookie的请求：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>JSESSIONID = 415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下代码示例演示了如何获取cookie值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ demo</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@CookieValue</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">JSESSIONID</span> <span class="delimiter">”</span></span> ） <span class="predefined-type">String</span> cookie）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>获取cookie值。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是<code>String</code>则自动应用类型转换。见<a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-modelattrib-method-args"><a class="anchor" href="#webflux-ann-modelattrib-method-args"></a>使用<code>@ModelAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-modelattrib-method-args">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以在方法参数上使用<code>@ModelAttribute</code>批注来从模型访问属性，或者如果不存在则将其实例化。model属性还覆盖了查询参数和名称与字段名称匹配的表单字段的值。这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段。以下示例绑定<code>Pet</code>的实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> processSubmit（ <span class="annotation">@ModelAttribute</span> Pet pet）{} <i class="conum" data-value="1"></i> <b>（1）</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>绑定一个<code>Pet</code>的实例。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上例中的<code>Pet</code>实例解析如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果已经通过<a href="#webflux-ann-modelattrib-methods">使用模型</a>添加<a href="#webflux-ann-modelattrib-methods">了模型</a> 。</p>
</li>
<li>
<p>从HTTP会话到<a href="#webflux-ann-sessionattributes">使用<code>@SessionAttributes</code></a> 。</p>
</li>
<li>
<p>从默认构造函数的调用。</p>
</li>
<li>
<p>从调用具有与查询参数或表单字段匹配的参数的“主构造函数”。参数名称通过JavaBeans <code>@ConstructorProperties</code>或字节码中的运行时保留参数名称确定。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>获取模型属性实例后，将应用数据绑定。<code>WebExchangeDataBinder</code>类将查询参数和表单字段的名称与目标<code>Object</code>上的字段名称相匹配。在必要时应用类型转换后填充匹配字段。有关数据绑定（和验证）的更多信息，请参阅<a href="core.html#validation">验证</a> 。有关自定义数据绑定的更多信息，请参阅<a href="#webflux-ann-initbinder">使用<code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>数据绑定可能导致错误。默认情况下，会引发<code>WebExchangeBindException</code> ，但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加一个<code>BindingResult</code>参数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> processSubmit（ <span class="annotation">@ModelAttribute</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ）Pet pet，BindingResult result）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="keyword">if</span> （result.hasErrors（））{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">petForm</span> <span class="delimiter">”</span></span> ; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>添加<code>BindingResult</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过添加<code>javax.validation.在数据绑定后自动应用验证<code>javax.validation.Valid</code>注释或Spring的<code>@Validated</code>注释（另请参阅<a href="core.html#validation-beanvalidation">Bean验证</a>和<a href="core.html#validation">Spring验证</a> ）。以下示例使用<code>@Valid</code>注释：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> processSubmit（ <strong><span class="annotation">@Valid</span> <span class="annotation">@ModelAttribute</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ）Pet pet</strong> ，BindingResult result）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="keyword">if</span> （result.hasErrors（））{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">petForm</span> <span class="delimiter">”</span></span> ; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;1&gt;</p>
</div>
</div>
</div>
<div class="paragraph">
<p>与Spring MVC不同，Spring WebFlux支持模型中的反应类型 - 例如， <code>Mono&lt;Account&gt;</code>或<code>io.reactivex.Single&lt;Account&gt;</code> 。您可以使用或不使用响应式包装器声明<code>@ModelAttribute</code>参数，并在必要时将其相应地解析为实际值。但是，请注意，要使用<code>BindingResult</code>参数，必须在没有响应式包装器的情况下声明<code>@ModelAttribute</code>参数，如前所示。或者，您可以通过响应类型处理任何错误，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ owners / {ownerId} / pets / {petId} / edit</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt; <span class="predefined-type">String</span> &gt; processSubmit（ <span class="annotation">@Valid</span> <span class="annotation">@ModelAttribute</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ）Mono &lt;Pet&gt; petMono）{ <span class="keyword">return</span> petMono .flatMap（pet  - &gt; { <span class="comment">// ......</span>} .onErrorResume（ex  - &gt; { <span class="comment">// ...</span>}）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，使用<code>@ModelAttribute</code>是可选的 - 例如，设置其属性。默认情况下，任何不是简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）并且未被任何其他参数解析器解析的参数都被视为使用<code>@ModelAttribute</code>进行注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattributes"><a class="anchor" href="#webflux-ann-sessionattributes"></a>使用<code>@SessionAttributes</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-sessionattributes">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code>用于在请求之间在<code>WebSession</code>存储模型属性。它是一个类型级别的注释，用于声明特定控制器使用的会话属性。这通常列出模型属性的名称或模型属性的类型，这些属性应该透明地存储在会话中以供后续访问请求使用。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@SessionAttributes</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">EditPetForm</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@SessionAttributes</code>注释。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在第一个请求中，当名称为<code>pet</code>的模型属性添加到模型中时，它会自动提升并保存在<code>WebSession</code> 。它保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="annotation">@SessionAttributes</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">pet</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">class</span> <span class="class">EditPetForm</span> { <span class="comment">// ...</span>

    <span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ pets / {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（Pet pet，BindingResult errors，SessionStatus status）{ <i class="conum" data-value="2"></i> <b>（2）</b> <span class="keyword">if</span> （errors.hasErrors）{ <span class="comment">// ...</span>} status.setComplete（）; <span class="comment">// ...</span>}}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@SessionAttributes</code>注释。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>SessionStatus</code>变量。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattribute"><a class="anchor" href="#webflux-ann-sessionattribute"></a>使用<code>@SessionAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-sessionattribute">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>如果您需要访问全局管理的预先存在的会话属性（即，在控制器外部 - 例如，通过过滤器）并且可能存在或不存在，则可以对方法参数使用<code>@SessionAttribute</code>批注，如以下示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@SessionAttribute</span> User user）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@SessionAttribute</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>对于需要添加或删除会话属性的用例，请考虑将<code>WebSession</code>注入控制器方法。</p>
</div>
<div class="paragraph">
<p>要在会话中临时存储模型属性作为控制器工作流的一部分，请考虑使用<code>SessionAttributes</code> ，如<a href="#webflux-ann-sessionattributes">使用<code>@SessionAttributes</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestattrib"><a class="anchor" href="#webflux-ann-requestattrib"></a>使用<code>@RequestAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestattrib">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>与<code>@SessionAttribute</code>类似，您可以使用<code>@RequestAttribute</code>批注来访问先前创建的预先存在的请求属性（例如，通过<code>WebFilter</code> ），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@RequestAttribute</span> Client client）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestAttribute</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart-forms"><a class="anchor" href="#webflux-multipart-forms"></a>多部分内容</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multipart-forms">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>如<a href="#webflux-multipart">Multipart Data中所述</a> ， <code>ServerWebExchange</code>提供对多部分内容的访问。在控制器中处理文件上载表单（例如，从浏览器）的最佳方法是通过数据绑定到<a href="#webflux-ann-modelattrib-method-args">命令对象</a> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyForm</span> { <span class="directive">private</span> <span class="predefined-type">String</span> name; <span class="directive">私有的</span> MultipartFile文件; <span class="comment">// ...</span>} <span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">FileUploadController</span> { <span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ form</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handleFormUpload（MyForm form，BindingResult errors）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以在RESTful服务方案中提交来自非浏览器客户端的多部分请求。以下示例使用文件和JSON：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>POST / someUrl Content-Type：multipart / mixed --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition：form-data; name =“meta-data”Content-Type：application / json; charset = UTF-8 Content-Transfer-Encoding：8bit {“name”：“value”} --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition：form-data; NAME =“文件的数据”; filename =“file.properties”Content-Type：text / xml Content-Transfer-Encoding：8bit ...档案数据......</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestPart</code>访问各个部分，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">meta-data</span> <span class="delimiter">”</span></span> ）部分元数据， <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">file-data</span> <span class="delimiter">”</span></span> ）FilePart文件）{ <i class="conum" data-value="2"></i> <b>（2）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>@RequestPart</code>获取文件。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要反序列化原始部件内容（例如，到JSON  - 类似于<code>@RequestBody</code> ），您可以声明具体的目标<code>Object</code>而不是<code>Part</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">meta-data</span> <span class="delimiter">”</span></span> ）MetaData metadata）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以将<code>@RequestPart</code>与<code>javax.validation.结合使用<code>javax.validation.Valid</code>或Spring的<code>@Validated</code>注释，它会导致应用标准Bean验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code> ，该异常会变为400（ <code>BAD_REQUEST</code> ）响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@Valid</span> <span class="annotation">@RequestPart</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">meta-data</span> <span class="delimiter">”</span></span> ）MetaData元数据， <i class="conum" data-value="1"></i> <b>（1）</b> BindingResult结果）{ <i class="conum" data-value="2"></i> <b>（2）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@Valid</code>注释。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>BindingResult</code>参数。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要将所有多部分数据作为<code>MultiValueMap</code>访问，可以使用<code>@RequestBody</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@RequestBody</span> Mono &lt;MultiValueMap &lt; <span class="predefined-type">String</span> ，Part &gt;&gt; parts）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestBody</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要以流方式顺序访问多部分数据，您可以使用<code>@RequestBody</code>和<code>Flux&lt;Part&gt;</code> ，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@RequestBody</span> Flux &lt;Part&gt; parts）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@RequestBody</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestbody"><a class="anchor" href="#webflux-ann-requestbody"></a>使用<code>@RequestBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestbody">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestBody</code>批注通过<a href="#webflux-codecs">HttpMessageReader</a>将请求主体读取并反序列化为<code>Object</code> 。以下示例使用<code>@RequestBody</code>参数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@RequestBody</span> Account account）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>不像Spring MVC的，在WebFlux，所述<code>@RequestBody</code>方法参数支持反应类型和完全无阻塞读取和（客户端到服务器）流。以下示例使用<code>Mono</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@RequestBody</span> Mono &lt;Account&gt; account）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<a href="#webflux-config">WebFlux配置</a>的<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>选项来配置或自定义消息读取器。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@RequestBody</code>与<code>javax.validation.结合使用<code>javax.validation.Valid</code>或Spring的<code>@Validated</code>注释，它会导致应用标准Bean验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code> ，该异常会变为400（ <code>BAD_REQUEST</code> ）响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误。以下示例使用<code>BindingResult</code>参数<code>BindingResult</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（ <span class="annotation">@Valid</span> <span class="annotation">@RequestBody</span> Account account，BindingResult result）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-httpentity"><a class="anchor" href="#webflux-ann-httpentity"></a>使用<code>HttpEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-httpentity">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code>与<a href="#webflux-ann-requestbody">使用<code>@RequestBody</code></a>或多或少相同，但它基于公开请求标头和正文的容器对象。以下示例使用<code>HttpEntity</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> handle（HttpEntity &lt;Account&gt; entity）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responsebody"><a class="anchor" href="#webflux-ann-responsebody"></a>使用<code>@ResponseBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-responsebody">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以在方法上使用<code>@ResponseBody</code>批注，以通过<a href="#webflux-codecs">HttpMessageWriter</a>将返回序列化到响应主体。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts / {id}</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ResponseBody</span> <span class="directive">公共</span>帐户句柄（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类级别也支持<code>@ResponseBody</code> ，在这种情况下，它由所有控制器方法继承。这是<code>@RestController</code>的效果，它只不过是一个用<code>@Controller</code>和<code>@ResponseBody</code>标记的元注释。</p>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code>支持反应类型，这意味着您可以返回Reactor或RxJava类型，并将它们生成的异步值呈现给响应。有关其他详细信息，请参阅<a href="#webflux-codecs-streaming">HTTP Streaming</a>和<a href="#webflux-codecs-jackson">JSON呈现</a> 。</p>
</div>
<div class="paragraph">
<p>您可以将<code>@ResponseBody</code>方法与JSON序列化视图结合使用。有关详细信息，请参阅<a href="#webflux-ann-jackson">Jackson JSON</a> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="#webflux-config">WebFlux配置</a>的<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>选项来配置或自定义消息编写。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responseentity"><a class="anchor" href="#webflux-ann-responseentity"></a>使用<code>ResponseEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-responseentity">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>使用<code>ResponseEntity</code>与<a href="#webflux-ann-responsebody">使用<code>@ResponseBody</code></a>或多或少相同，但它基于指定请求标头和正文的容器对象。以下示例使用<code>ResponseEntity</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ something</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">String</span> &gt; handle（）{ <span class="comment">// ...</span>
    <span class="predefined-type">URI</span>位置= ...返回<span class="keyword">新的</span> ResponseEntity.created（location）.build（）; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-jackson"><a class="anchor" href="#webflux-ann-jackson"></a>杰克逊JSON</h5>
<div class="paragraph">
<p>Spring为Jackson JSON库提供支持。</p>
</div>
<div class="sect5">
<h6 id="webflux-ann-jsonview"><a class="anchor" href="#webflux-ann-jsonview"></a>杰克逊序列化观点</h6>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-jackson">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux为<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson的序列化视图</a>提供内置支持，允许仅渲染<code>Object</code>中所有字段的子集。要将其与<code>@ResponseBody</code>或<code>ResponseEntity</code>控制器方法一起使用，您可以使用Jackson的<code>@JsonView</code>批注来激活序列化视图类，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">UserController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ user</span> <span class="delimiter">”</span></span> ） <span class="annotation">@JsonView</span> （User。WithoutPasswordView.class） <span class="directive">public</span> User getUser（）{ <span class="keyword">return</span> <span class="keyword">new</span> User（ <span class="string"><span class="delimiter">“</span> <span class="content">eric</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">7！jd＃h23</span> <span class="delimiter">“</span></span> ）;}} <span class="directive">public</span> <span class="type">class</span> <span class="class">User</span> { <span class="directive">public</span> <span class="type">interface</span> <span class="class">WithoutPasswordView</span> {}; <span class="directive">public</span> <span class="type">interface</span> <span class="class">WithPasswordView</span> <span class="directive">extends</span> WithoutPasswordView {}; <span class="directive">private</span> <span class="predefined-type">String</span> username; <span class="directive">private</span> <span class="predefined-type">String</span> password; <span class="directive">public</span> User（）{} <span class="directive">public</span> User（ <span class="predefined-type">String</span> username， <span class="predefined-type">String</span> password）{ <span class="local-variable">this</span> .username = username; <span class="local-variable">this</span> .password = password;} <span class="annotation">@JsonView</span> （WithoutPasswordView.class） <span class="directive">public</span> <span class="predefined-type">String</span> getUsername（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .username;} <span class="annotation">@JsonView</span> （WithPasswordView.class） <span class="directive">public</span> <span class="predefined-type">String</span> getPassword（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .password; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@JsonView</code>允许一组视图类，但每个控制器方法只能指定一个。如果需要激活多个视图，请使用复合接口。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-modelattrib-methods"><a class="anchor" href="#webflux-ann-modelattrib-methods"></a> 1.11.4。使用模型</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-modelattrib-methods">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ModelAttribute</code>注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在<code>@RequestMapping</code>方法中的<a href="#webflux-ann-modelattrib-method-args">方法参数</a> ，用于从模型创建或访问Object并通过<code>WebDataBinder</code>将其绑定到请求。</p>
</li>
<li>
<p>作为<code>@Controller</code>或<code>@ControllerAdvice</code>类中的方法级注释，有助于在任何<code>@RequestMapping</code>方法调用之前初始化模型。</p>
</li>
<li>
<p>在<code>@RequestMapping</code>方法<code>@RequestMapping</code>其返回值标记为模型属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节讨论<code>@ModelAttribute</code>方法，或前面列表中的第二项。控制器可以包含任意数量的<code>@ModelAttribute</code>方法。在同一控制器中的<code>@RequestMapping</code>方法之前调用所有这些方法。<code>@ModelAttribute</code>方法也可以通过<code>@ControllerAdvice</code>在控制器之间共享。有关更多详细信息，请参阅<a href="#webflux-ann-controller-advice">控制器建议</a>部分。</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。它们支持许多与<code>@RequestMapping</code>方法相同的参数（除了<code>@ModelAttribute</code>本身以及与请求体相关的任何内容）。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@ModelAttribute</code>方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span> <span class="directive">public</span> <span class="type">void</span> populateModel（ <span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number，Model model）{model.addAttribute（accountRepository.findAccount（number））; <span class="comment">//添加更多......</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例仅添加一个属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span> <span class="directive">public</span> account addAccount（ <span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number）{ <span class="keyword">return</span> accountRepository.findAccount（number）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未明确指定名称，则会根据<code>Object</code>类型选择默认名称，如Javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a> 。您始终可以使用重载的<code>addAttribute</code>方法或<code>@ModelAttribute</code>上的name属性（返回值）来指定显式名称。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与Spring MVC不同，Spring WebFlux明确支持模型中的反应类型（例如， <code>Mono&lt;Account&gt;</code>或<code>io.reactivex.Single&lt;Account&gt;</code> ）。如果在没有包装器的情况下声明<code>@ModelAttribute</code>参数，则可以在<code>@RequestMapping</code>调用时将此类异步模型属性透明地解析（并且模型更新）为其实际值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span> <span class="directive">public</span> <span class="type">void</span> addAccount（ <span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number）{Mono &lt;Account&gt; accountMono = accountRepository.findAccount（number）; model.addAttribute（ <span class="string"><span class="delimiter">“</span> <span class="content">account</span> <span class="delimiter">”</span></span> ，accountMono）; } <span class="annotation">@PostMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ accounts</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="predefined-type">String</span> handle（ <span class="annotation">@ModelAttribute</span> Account account，BindingResult errors）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，具有反应式包装器的任何模型属性都会在视图呈现之前解析为其实际值（并且模型已更新）。</p>
</div>
<div class="paragraph">
<p>您还可以使用<code>@ModelAttribute</code>作为一个方法级别注解<code>@RequestMapping</code>方法，在这种情况下的返回值<code>@RequestMapping</code>方法被解释为一个模型属性。这通常不是必需的，因为它是HTML控制器中的默认行为，除非返回值是否则将被解释为视图名称的<code>String</code> 。<code>@ModelAttribute</code>还可以帮助自定义模型属性名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping（</span> <span class="string"><span class="content"><span class="delimiter">“/</span>帐号/（编号<span class="delimiter"><span class="annotation">）”）@ModelAttribute（</span></span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">我的帐户</span> <span class="delimiter">”）</span></span> <span class="directive">公共</span>账户手柄<span class="comment">（）{// ...</span>
    <span class="keyword">退货</span>帐户; }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-initbinder"><a class="anchor" href="#webflux-ann-initbinder"></a> 1.11.5。使用<code>DataBinder</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-initbinder">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>或<code>@ControllerAdvice</code>类可以有<code>@InitBinder</code>方法来初始化<code>WebDataBinder</code>实例。反过来，这些用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将请求参数（即表单数据或查询）绑定到模型对象。</p>
</li>
<li>
<p>将基于<code>String</code>的请求值（例如请求参数，路径变量，标题，cookie等）转换为目标类型的控制器方法参数。</p>
</li>
<li>
<p>在呈现HTML表单时将模型对象值格式化为<code>String</code>值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法可以注册特定于控制器的<code>java.bean.PropertyEditor</code>或Spring <code>Converter</code>和<code>Formatter</code>组件。此外，您可以使用<a href="#webflux-config-conversion">WebFlux Java配置</a>在全局共享的<code>FormattingConversionService</code>注册<code>Converter</code>和<code>Formatter</code>类型。</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法支持许多与<code>@RequestMapping</code>方法相同的参数，但<code>@ModelAttribute</code> （命令对象）参数除外。通常，它们使用<code>WebDataBinder</code>参数声明，用于注册和<code>void</code>返回值。以下示例使用<code>@InitBinder</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">FormController</span> { <span class="annotation">@InitBinder</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> <span class="type">void</span> initBinder（WebDataBinder binder）{ <span class="predefined-type">SimpleDateFormat</span> dateFormat = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd</span> <span class="delimiter">”</span></span> ）; dateFormat.setLenient（ <span class="predefined-constant">false</span> ）; binder.registerCustomEditor（ <span class="predefined-type">Date</span> .class， <span class="keyword">new</span> CustomDateEditor（dateFormat， <span class="predefined-constant">false</span> ））; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@InitBinder</code>注释。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，当通过共享的<code>FormattingConversionService</code>使用基于<code>Formatter</code>的设置时，您可以重复使用相同的方法并注册特定于控制器的<code>Formatter</code>实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">FormController</span> { <span class="annotation">@InitBinder</span> <span class="directive">protected</span> <span class="type">void</span> initBinder（WebDataBinder binder）{binder.addCustomFormatter（ <span class="keyword">new</span> <span class="predefined-type">DateFormatter</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-MM-dd</span> <span class="delimiter">”</span></span> ））; <i class="conum" data-value="1"></i> <b>（1）</b> } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>添加自定义格式化程序（在本例中为<code>DateFormatter</code> ）。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-exceptions"><a class="anchor" href="#webflux-ann-controller-exceptions"></a> 1.11.6。管理例外</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-exceptionhandler">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>和<a href="#mvc-ann-controller-advice">@ControllerAdvice</a>类可以使用<code>@ExceptionHandler</code>方法来处理来自控制器方法的异常。以下示例包含此类处理程序方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleController</span> { <span class="comment">// ...</span>

    <span class="annotation">@ExceptionHandler</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">String</span> &gt; handle（ <span class="exception">IOException</span> ex）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>声明<code>@ExceptionHandler</code> ：</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>该异常可以匹配传播的顶级异常（即，抛出直接<code>IOException</code> ）或顶级包装器异常中的直接原因（例如，包含在<code>IllegalStateException</code>内的<code>IOException</code> ）。</p>
</div>
<div class="paragraph">
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如上例所示。或者，注释声明可以缩小要匹配的异常类型。我们通常建议在参数签名中尽可能具体，并在<code>@ControllerAdvice</code>上声明您的主根异常映射，并使用相应的顺序进行优先级排序。有关详细信息，请参阅<a href="web.html#mvc-ann-exceptionhandler">MVC部分</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>@ExceptionHandler</code>中的<code>@ExceptionHandler</code>方法支持相同的方法参数，并返回值作为<code>@RequestMapping</code>方法，但请求body-和<code>@ModelAttribute</code>相关的方法参数除外。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>HandlerAdapter</code>为<code>@RequestMapping</code>方法提供了对Spring WebFlux中的<code>@ExceptionHandler</code>方法的支持。有关更多详细信息，请参阅<a href="#webflux-dispatcher-handler">使用<code>DispatcherHandler</code></a> 。</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-rest-exceptions"><a class="anchor" href="#webflux-ann-rest-exceptions"></a> REST API例外</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-rest-exceptions">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>REST服务的一个常见要求是在响应正文中包含错误详细信息。Spring Framework不会自动执行此操作，因为响应正文中错误详细信息的表示是特定于应用程序的。但是， <code>@RestController</code>可以使用带有<code>ResponseEntity</code>返回值的<code>@ExceptionHandler</code>方法来设置<code>ResponseEntity</code>的状态和正文。这些方法也可以在<code>@ControllerAdvice</code>类中声明，以全局应用它们。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，Spring WebFlux没有Spring MVC <code>ResponseEntityExceptionHandler</code>的等效项，因为WebFlux仅引发<code>ResponseStatusException</code> （或其子类），并且不需要将它们转换为HTTP状态代码。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-advice"><a class="anchor" href="#webflux-ann-controller-advice"></a> 1.11.7。控制器建议</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller-advice">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>通常， <code>@ExceptionHandler</code> ， <code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于声明它们的<code>@Controller</code>类（或类层次结构）。如果您希望此类方法更全局地应用（跨控制器），则可以在标有<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>的类中声明它们。</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code>用<code>@Component</code>标记，这意味着可以通过<a href="core.html#beans-java-instantiating-container-scan">组件扫描</a>将这些类注册为Spring bean。
<code>@RestControllerAdvice</code>也是一个用<code>@ControllerAdvice</code>和<code>@ResponseBody</code>标记的元注释，这实际上意味着<code>@ExceptionHandler</code>方法通过消息转换（与视图分辨率或模板渲染相对）呈现给响应主体。</p>
</div>
<div class="paragraph">
<p>在启动时，该基础设施类<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法检测类型的Spring bean的<code>@ControllerAdvice</code>并在运行时应用它们的方法。全局<code>@ExceptionHandler</code>方法（来自<code>@ControllerAdvice</code> ） <strong>在</strong>本地方法之后（来自<code>@Controller</code> ）应用。相比之下，全局<code>@ModelAttribute</code>和<code>@InitBinder</code>方法<strong>在</strong>本地方法<strong>之前</strong>应用。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>@ControllerAdvice</code>方法适用于每个请求（即所有控制器），但您可以通过注释上的属性将其缩小到控制器的子集，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//使用@RestController注释所有控制器</span> <span class="annotation">@ControllerAdvice</span> （annotations = RestController.class） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice1</span> {} <span class="comment">//定位特定包中的所有控制器</span> <span class="annotation">@ControllerAdvice</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">org.example.controllers</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice2</span> {} <span class="comment">// Target所有可分配给特定类的控制器</span> <span class="annotation">@ControllerAdvice</span> （assignableTypes = {ControllerInterface.class，AbstractController.class}） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice3</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的选择器在运行时进行评估，如果您广泛使用它们，可能会对性能产生负面影响。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a> Javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-fn"><a class="anchor" href="#webflux-fn"></a> 1.12。功能端点</h3>
<div class="paragraph">
<p>Spring WebFlux包含一个轻量级的函数式编程模型，其中函数用于路由和处理请求，而契约是为不变性而设计的。它是基于注释的编程模型的替代方案，但是在相同的<a href="#webflux-reactive-spring-web">Reactive Core</a>基础上运行。</p>
</div>
<div class="sect3">
<h4 id="webflux-fn-overview"><a class="anchor" href="#webflux-fn-overview"></a> 1.12.1。概观</h4>
<div class="paragraph">
<p>使用<code>HandlerFunction</code>处理HTTP请求，该<code>HandlerFunction</code>接收<code>ServerRequest</code>并返回<code>Mono&lt;ServerResponse&gt;</code> ，这两者都是不可变的合同，提供对HTTP请求和响应的JDK 8友好访问。<code>HandlerFunction</code>相当于基于注释的编程模型中的<code>@RequestMapping</code>方法。</p>
</div>
<div class="paragraph">
<p>请求被路由到带有<code>HandlerFunction</code> ，该<code>RouterFunction</code>接受<code>ServerRequest</code>并返回<code>Mono&lt;HandlerFunction&gt;</code> 。当请求与特定路由匹配时，将<code>HandlerFunction</code>映射到该路由的<code>HandlerFunction</code> 。<code>RouterFunction</code>相当于<code>@RequestMapping</code>注释。</p>
</div>
<div class="paragraph">
<p><code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code>提供了一个路由器函数默认实现，可以与许多内置请求谓词一起使用，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http。媒体类型。APPLICATION_JSON</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server。RequestPredicates</span> 。*; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server。RouterFunctions.route</span> ; PersonRepository存储库= ...PersonH​​andler handler = <span class="keyword">new</span> PersonH​​andler（repository）; RouterFunction &lt;ServerResponse&gt; route = route（GET（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person / {id}</span> <span class="delimiter">”</span></span> ）。和（accept（APPLICATION_JSON）），handler :: getPerson）.andRoute（GET（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person</span> <span class="delimiter">”</span></span> ）。和（accept（APPLICATION_JSON）） ），handler :: listPeople）.andRoute（POST（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person</span> <span class="delimiter">”</span></span> ），handler :: createPerson）; <span class="directive">公共</span> <span class="type">类</span> <span class="class">PersonH​​andler</span> { <span class="comment">// ...</span>

    <span class="directive">public</span> Mono &lt;ServerResponse&gt; listPeople（ServerRequest request）{ <span class="comment">// ...</span><span class="directive">public</span> Mono &lt;ServerResponse&gt; createPerson（ServerRequest request）{ <span class="comment">// ...</span><span class="directive">public</span> Mono &lt;ServerResponse&gt; getPerson（ServerRequest request）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行<code>RouterFunction</code>一种方法是将其转换为<code>HttpHandler</code>并通过其中一个内置<a href="#webflux-httphandler">服务器适配器</a>安装它：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler（RouterFunction）</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler（RouterFunction，HandlerStrategies）</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大多数应用程序可以通过WebFlux Java配置<a href="#webflux-fn-running">运行</a> ，请参阅<a href="#webflux-fn-running">运行服务器</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-functions"><a class="anchor" href="#webflux-fn-handler-functions"></a> 1.12.2。HandlerFunction</h4>
<div class="paragraph">
<p><code>ServerRequest</code>和<code>ServerResponse</code>是不可变的接口，提供对HTTP请求的JDK 8友好访问以及响应请求和响应正文流的<a href="http://www.reactive-streams.org">Reactive Streams</a>响应。请求体用Reactor <code>Flux</code>或<code>Mono</code> 。响应正文由任何Reactive Streams <code>Publisher</code> ，包括<code>Flux</code>和<code>Mono</code> 。有关更多信息，请参阅<a href="#webflux-reactive-libraries">Reactive Libraries</a> 。</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-request"><a class="anchor" href="#webflux-fn-request"></a>使用<code>ServerRequest</code></h5>
<div class="paragraph">
<p><code>ServerRequest</code>提供对HTTP方法，URI，标头和查询参数的访问，同时通过<code>body</code>方法提供对<code>body</code>访问。</p>
</div>
<div class="paragraph">
<p>以下示例将请求正文提取为<code>Mono&lt;String&gt;</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt; <span class="predefined-type">String</span> &gt; string = request.bodyToMono（ <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例将body提取为<code>Flux&lt;Person&gt;</code> ，其中<code>Person</code>对象从某些序列化形式（如JSON或XML）解码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt;Person&gt; people = request.bodyToFlux（Person.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例是使用更通用的<code>ServerRequest.body(BodyExtractor)</code>快捷方式，它接受<code>BodyExtractor</code>功能策略接口。实用程序类<code>BodyExtractors</code>提供对许多实例的访问。例如，前面的例子也可以写成如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt; <span class="predefined-type">String</span> &gt; string = request.body（BodyExtractors.toMono（ <span class="predefined-type">String</span> .class））; Flux &lt;Person&gt; people = request.body（BodyExtractors.toFlux（Person.class））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何访问表单数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; map = request.body（BodyExtractors.toFormData（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何以地图形式访问多部分数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;MultiValueMap &lt; <span class="predefined-type">String</span> ，Part&gt; map = request.body（BodyExtractors.toMultipartData（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何以流方式一次访问多个部分：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt;Part&gt; parts = request.body（BodyExtractos.toParts（））;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-response"><a class="anchor" href="#webflux-fn-response"></a>使用<code>ServerResponse</code></h5>
<div class="paragraph">
<p><code>ServerResponse</code>提供对HTTP响应的访问，因为它是不可变的，所以您可以使用<code>build</code>方法来创建它。您可以使用构建器来设置响应状态，添加响应标头或提供正文。以下示例使用JSON内容创建200（OK）响应：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">单声道&lt;人&gt;人= ...ServerResponse.ok（）的contentType（的MediaType。APPLICATION_JSON）.body（person，Person.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何使用<code>Location</code>标头而不是正文构建201（CREATED）响应：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span>位置= ...ServerResponse.created（位置）.build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-classes"><a class="anchor" href="#webflux-fn-handler-classes"></a>处理程序类</h5>
<div class="paragraph">
<p>我们可以将处理函数编写为lambda，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HandlerFunction &lt;ServerResponse&gt; helloWorld = request  - &gt; ServerResponse.ok（）。body（fromObject（ <span class="string"><span class="delimiter">“</span> <span class="content">Hello World</span> <span class="delimiter">”</span></span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这很方便，但是，在应用程序中，我们需要多个函数，将相关的处理函数组合成一个处理程序（如<code>@Controller</code> ）是很有用的。例如，以下类公开了一个被动的<code>Person</code>存储库：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http。媒体类型。APPLICATION_JSON</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function。ServerResponse.ok</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function。BodyInserters.fromObject</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">PersonH​​andler</span> { <span class="directive">private</span> <span class="directive">final</span> PersonRepository repository; <span class="directive">public</span> PersonH​​andler（PersonRepository repository）{ <span class="local-variable">this</span> .repository = repository; <span class="directive">public</span> Mono &lt;ServerResponse&gt; listPeople（ServerRequest request）{ <i class="conum" data-value="1"></i> <b>（1）</b> Flux &lt;Person&gt; people = repository.allPeople（）; <span class="keyword">return</span> ok（）。contentType（APPLICATION_JSON）.body（people，Person.class）; <span class="directive">public</span> Mono &lt;ServerResponse&gt; createPerson（ServerRequest request）{ <i class="conum" data-value="2"></i> <b>（2）</b> Mono &lt;Person&gt; person = request.bodyToMono（Person.class）; <span class="keyword">return</span> ok（）。build（repository.savePerson（person））; <span class="directive">public</span> Mono &lt;ServerResponse&gt; getPerson（ServerRequest request）{ <i class="conum" data-value="3"></i> <b>（3）</b> <span class="type">int</span> personId = <span class="predefined-type">Integer</span> .valueOf（request.pathVariable（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ））; <span class="keyword">return</span> repository.getPerson（personId）.flatMap（person  - &gt; ok（）。contentType（APPLICATION_JSON）.body（fromObject（person）））。switchIfEmpty（ServerResponse.notFound（）。build（））; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>listPeople</code>是一个处理函数，它将存储库中找到的所有<code>Person</code>对象作为JSON返回。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>createPerson</code>是一个处理函数，用于存储请求正文中包含的新<code>Person</code> 。请注意， <code>PersonRepository.savePerson(Person)</code>返回<code>Mono&lt;Void&gt;</code> ：一个空的<code>Mono</code> ，当该人从请求中读取并存储时，它会发出完成信号。因此，我们使用<code>build(Publisher&lt;Void&gt;)</code>方法在收到完成信号时（即，保存<code>Person</code>时<code>build(Publisher&lt;Void&gt;)</code>发送响应。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>getPerson</code>是一个处理函数，它返回一个由<code>id</code>路径变量标识的人。我们从存储库中检索该<code>Person</code>并创建一个JSON响应（如果找到）。如果找不到，我们使用<code>switchIfEmpty(Mono&lt;T&gt;)</code>返回404 Not Found响应。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-router-functions"><a class="anchor" href="#webflux-fn-router-functions"></a> 1.12.3。使用<code>RouterFunction</code></h4>
<div class="paragraph">
<p><code>RouterFunction</code>用于将请求路由到<code>HandlerFunction</code> 。通常，您不自己编写路由器功能，而是使用<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code> 。如果谓词适用，请求将路由到给定的<code>HandlerFunction</code> 。否则，不执行路由，这将转换为404（未找到）响应。</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-predicates"><a class="anchor" href="#webflux-fn-predicates"></a>使用谓词</h5>
<div class="paragraph">
<p>您可以编写自己的<code>RequestPredicate</code> ，但<code>RequestPredicates</code>实用程序类根据请求路径，HTTP方法，内容类型等提供常用的实现。以下示例基于路径创建请求谓词：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction &lt;ServerResponse&gt; route = RouterFunctions.route（RequestPredicates.path（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hello-world</span> <span class="delimiter">”</span></span> ），request  - &gt; Response.ok（）。body（fromObject（ <span class="string"><span class="delimiter">“</span> <span class="content">Hello World</span> <span class="delimiter">”</span></span> ）））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下命令组合多个请求谓词：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestPredicate.and(RequestPredicate)</code> - 两者必须匹配。</p>
</li>
<li>
<p><code>RequestPredicate.or(RequestPredicate)</code> - 要么匹配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>来自<code>RequestPredicates</code>许多谓词都是由组成的。例如， <code>RequestPredicates.GET(String)</code>由<code>RequestPredicates.method(HttpMethod)</code>和<code>RequestPredicates.path(String)</code> 。</p>
</div>
<div class="paragraph">
<p>您可以将多个路由器功能组合成一个，以便按顺序对它们进行评估，如果第一个路由不匹配，则评估第二个路由器功能。您可以在更一般的路线之前声明更具体的路线。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-routes"><a class="anchor" href="#webflux-fn-routes"></a>路线</h5>
<div class="paragraph">
<p>您可以使用以下命令组合多个路由器功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunction.and（RouterFunction）</code></p>
</li>
<li>
<p><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> - <code>RouterFunction.and()</code>快捷方式，带有嵌套的<code>RouterFunctions.route()</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用组合路由和谓词，我们可以声明以下路由，通过<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">方法引用引用</a> <code>PersonHandler</code>方法（在<a href="#webflux-fn-handler-class">[webflux-fn-handler-class]中显示</a> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http。媒体类型。APPLICATION_JSON</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server。RequestPredicates</span> 。*; PersonRepository存储库= ...PersonH​​andler handler = <span class="keyword">new</span> PersonH​​andler（repository）; RouterFunction &lt;ServerResponse&gt; personRoute = route（GET（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person / {id}</span> <span class="delimiter">”</span></span> ）.and（accept（APPLICATION_JSON）），handler :: getPerson）.andRoute（GET（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person</span> <span class="delimiter">”</span></span> ）。and（accept（APPLICATION_JSON） ），handler :: listPeople）.andRoute（POST（ <span class="string"><span class="delimiter">“</span> <span class="content">/ person</span> <span class="delimiter">”</span></span> ），handler :: createPerson）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-running"><a class="anchor" href="#webflux-fn-running"></a> 1.12.4。运行服务器</h4>
<div class="paragraph">
<p>如何在HTTP服务器中运行路由器功能？一个简单的选择是使用以下方法之一将路由器功能转换为<code>HttpHandler</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler（RouterFunction）</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler（RouterFunction，HandlerStrategies）</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，您可以使用返回<code>HttpHandler</code>按照与多个服务器适配器的<a href="#webflux-httphandler">HttpHandler的</a>特定服务器的指令。</p>
</div>
<div class="paragraph">
<p>更高级的选项是通过<a href="#webflux-config">WebFlux Config</a>运行基于<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>的设置，该<a href="#webflux-config">配置</a>使用Spring配置来声明处理请求所需的组件。WebFlux Java配置声明以下基础结构组件以支持功能端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctionMapping</code> ：检测一个或多个<code>RouterFunction&lt;?&gt;</code> Spring配置中的bean，通过<code>RouterFunction.andOther</code>将它们组合在一起，并将请求路由到生成的组合<code>RouterFunction</code> 。</p>
</li>
<li>
<p><code>HandlerFunctionAdapter</code> ：简单的适配器，它允许<code>DispatcherHandler</code>调用映射到请求的<code>HandlerFunction</code> 。</p>
</li>
<li>
<p><code>ServerResponseResultHandler</code> ：通过调用<code>ServerResponse</code>的<code>writeTo</code>方法处理调用<code>HandlerFunction</code>的结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的组件允许功能端点适合<code>DispatcherHandler</code>请求处理生命周期，并且（可能）与带注释的控制器并行运行（如果有的话）。它也是Spring Boot WebFlux启动器启用功能端点的方式。</p>
</div>
<div class="paragraph">
<p>以下示例显示了WebFlux Java配置（有关如何运行它，请参阅<a href="#webflux-dispatcher-handler">DispatcherHandler</a> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现了</span> WebFluxConfigurer { <span class="annotation">@Bean</span> <span class="directive">public</span> RouterFunction &lt;？&gt; routerFunctionA（）{ <span class="comment">// ...</span>} <span class="annotation">@Bean</span> <span class="directive">public</span> RouterFunction &lt;？&gt; routerFunctionB（）{ <span class="comment">// ...</span>} <span class="comment">// ...</span>

    <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureHttpMessageCodecs（ServerCodecConfigurer configurer）{ <span class="comment">//配置消息转换...</span>} <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addCorsMappings（CorsRegistry注册表<span class="comment">）{//配置CORS ...</span>} <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> configureViewResolvers（ViewResolverRegistry registry）{ <span class="comment">//为HTML呈现配置视图分辨率...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-filter-function"><a class="anchor" href="#webflux-fn-handler-filter-function"></a> 1.12.5。使用<code>HandlerFilterFunction</code></h4>
<div class="paragraph">
<p>您可以通过调用<code>RouterFunction.filter(HandlerFilterFunction)</code>来过滤路由器函数映射的路由，其中<code>HandlerFilterFunction</code>本质上是一个接受<code>ServerRequest</code>和<code>HandlerFunction</code>并返回<code>ServerResponse</code>的函数。handler函数参数表示链中的下一个元素。这通常是路由到的<code>HandlerFunction</code> ，但如果应用了多个过滤器，它也可以是另一个<code>FilterFunction</code> 。使用注释，您可以通过使用<code>@ControllerAdvice</code> <code>ServletFilter</code> ， <code>ServletFilter</code>或两者来实现类似的功能。现在我们可以在路由中添加一个简单的安全过滤器，假设我们有一个可以确定是否允许特定路径的<code>SecurityManager</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http。的HTTPStatus。未经授权</span> ; <span class="predefined-type">SecurityManager</span> securityManager = ...RouterFunction &lt;ServerResponse&gt; route = ...RouterFunction &lt;ServerResponse&gt; filteredRoute = route.filter（（request，next） - &gt; { <span class="keyword">if</span> （securityManager.allowAccessTo（request.path（）））{ <span class="keyword">return</span> next.handle（request）;} <span class="keyword">else</span> { <span class="keyword">return</span> ServerResponse.status（UNAUTHORIZED） .build（）;}}）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例演示了调用<code>next.handle(ServerRequest)</code>是可选的。我们只允许在允许访问时执行处理函数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">功能端点的CORS支持通过专用的<a href="#webflux-cors-webfilter"><code>CorsWebFilter</code></a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-uri-building"><a class="anchor" href="#webflux-uri-building"></a> 1.13。URI链接</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-uri-building">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>本节介绍Spring Framework中可用于准备URI的各种选项。</p>
</div>
<div class="sect3">
<h4 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a> 1.13.1。UriComponents</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>有助于使用变量从URI模板构建URI，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UriComponents uriComponents = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="2"></i> <b>（2）</b> .encode（） <i class="conum" data-value="3"></i> <b>（3）</b> .build（）; <i class="conum" data-value="4"></i> <b>（4）</b> <span class="predefined-type">URI</span> uri = uriComponents.expand（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）。toUri（）; <i class="conum" data-value="5"></i> <b>（5）</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>请求编码URI模板和URI变量。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>建立一个<code>UriComponents</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>展开变量并获取<code>URI</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例可以合并到一个链中，并使用<code>buildAndExpand</code>缩短，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。encode（）。buildAndExpand（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）.toUri（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。build（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您使用完整的URI模板进一步缩短它，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder .fromUriString（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com/hotels/{hotel}？q = {q}</span> <span class="delimiter">“</span></span> ）。build（ <span class="string"><span class="delimiter">”</span> <span class="content">威斯汀</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">123</span> <span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a> 1.13.2。UriBuilder</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a>实现了<code>UriBuilder</code> 。您可以使用<code>UriBuilder</code>创建一个<code>UriBuilderFactory</code> 。<code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p>
</div>
<div class="paragraph">
<p>您可以配置<code>RestTemplate</code>和<code>WebClient</code>与<code>UriBuilderFactory</code>自定义的URI的准备。 <code>DefaultUriBuilderFactory</code>是一个缺省的实现的<code>UriBuilderFactory</code>使用<code>UriComponentsBuilder</code>内部和暴露共享配置选项。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何配置<code>RestTemplate</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// import org.springframework.web.util。DefaultUriBuilderFactory。EncodingMode;</span> <span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.org</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）; factory.setEncodingMode（EncodingMode。TEMPLATE_AND_VARIABLES）; RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate（）; restTemplate.setUriTemplateHandler（工厂）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例配置<code>WebClient</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// import org.springframework.web.util。DefaultUriBuilderFactory。EncodingMode;</span> <span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.org</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）; factory.setEncodingMode（EncodingMode。TEMPLATE_AND_VARIABLES）; WebClient客户端= WebClient.builder（）。uriBuilderFactory（工厂）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，您还可以直接使用<code>DefaultUriBuilderFactory</code> 。它类似于使用<code>UriComponentsBuilder</code>但它不是静态工厂方法，而是一个包含配置和首选项的实际实例，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory uriBuilderFactory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）; <span class="predefined-type">URI</span> uri = uriBuilderFactory.uriString（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotels / {hotel}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。build（ <span class="string"><span class="delimiter">“</span> <span class="content">Westin</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">123</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a> 1.13.3。URI编码</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder #coding（）</a> ：首先对URI模板进行预编码，然后在扩展时严格编码URI变量。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents #coding（）</a> ：扩展URI变量<em>后</em> <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">对</a> URI组件<em>进行</em>编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个选项都使用转义的八位字节替换非ASCII和非法字符。但是，第一个选项还会替换出现在URI变量中的保留含义的字符。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">考虑“;”，这在路径中是合法的但具有保留意义。第一个选项取代“;”在URI变量中使用“％3B”但在URI模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于大多数情况，第一个选项可能会给出预期结果，因为它将URI变量视为完全编码的不透明数据，而选项2仅在URI变量故意包含保留字符时才有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用第一个选项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotel list / {city}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。encode（）。buildAndExpand（ <span class="string"><span class="delimiter">“</span> <span class="content">New York</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">foo + bar</span> <span class="delimiter">”</span></span> ）.toUri （）; <span class="comment">//结果是“/ hotel％20list / New％20York？Q = FOO％2Bbar”</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotel list / {city}</span> <span class="delimiter">”</span></span> ）。queryParam（ <span class="string"><span class="delimiter">“</span> <span class="content">q</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">{q}</span> <span class="delimiter">”</span></span> ）。build（ <span class="string"><span class="delimiter">“</span> <span class="content">New York</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">foo + bar</span> <span class="delimiter">”</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath（ <span class="string"><span class="delimiter">“</span> <span class="content">/ hotel list / {city}？q = {q}</span> <span class="delimiter">“</span></span> ）。build（ <span class="string"><span class="delimiter">”</span> <span class="content">纽约</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">foo + bar</span> <span class="delimiter">“</span></span> ）</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>WebClient</code>和<code>RestTemplate</code>通过<code>UriBuilderFactory</code>策略在内部扩展和编码URI模板。两者都可以配置自定义策略。如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">“</span> <span class="content">http://example.com</span> <span class="delimiter">”</span></span> ; DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory（baseUrl）factory.setEncodingMode（EncodingMode。TEMPLATE_AND_VALUES）; <span class="comment">//自定义RestTemplate ..</span>RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate（）; restTemplate.setUriTemplateHandler（工厂）; <span class="comment">//自定义WebClient ..</span>WebClient客户端= WebClient.builder（）。uriBuilderFactory（工厂）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DefaultUriBuilderFactory</code>实现<code>UriComponentsBuilder</code>内部使用<code>UriComponentsBuilder</code>来扩展和编码URI模板。作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code> ：使用<code>UriComponentsBuilder#encode()</code> （对应于前面列表中的第一个选项）对URI模板进行预编码，并在扩展时严格编码URI变量。</p>
</li>
<li>
<p><code>VALUES_ONLY</code> ：不对URI模板进行编码，而是在将URI变量扩展到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对URI变量应用严格编码。</p>
</li>
<li>
<p><code>URI_COMPONENTS</code> ：使用<code>UriComponents#encode()</code> （对应于前面列表中的第二个选项<code>UriComponents#encode()</code> ， <em>在</em> URI变量展开<em>后</em>对URI组件值进行编码。</p>
</li>
<li>
<p><code>NONE</code> ：未应用编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>RestTemplate</code>设置为<code>EncodingMode.URI_COMPONENTS</code>用于历史原因和向后兼容性。<code>WebClient</code>依赖于<code>DefaultUriBuilderFactory</code>的默认值，该值已从<code>EncodingMode.更改<code>EncodingMode.5.0.x中的URI_COMPONENTS</code>到<code>EncodingMode.5.1中的TEMPLATE_AND_VALUES</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a> 1.14。CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux允许您处理CORS（跨源资源共享）。本节介绍如何执行此操作。</p>
</div>
<div class="sect3">
<h4 id="webflux-cors-intro"><a class="anchor" href="#webflux-cors-intro"></a> 1.14.1。介绍</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-intro">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>出于安全原因，浏览器禁止对当前源外的资源进行AJAX调用。例如，您可以将您的银行帐户放在一个标签页中，将evil.com放在另一个标签页中。来自evil.com的脚本不应该使用您的凭据向您的银行API发出AJAX请求 - 例如，从您的帐户中提取资金！</p>
</div>
<div class="paragraph">
<p>跨源资源共享（CORS）是<a href="http://caniuse.com/#feat=cors">大多数浏览器</a>实现的<a href="http://www.w3.org/TR/cors/">W3C规范</a> ，允许您指定授权的跨域请求类型，而不是使用基于IFRAME或JSONP的安全性较低且功能较弱的变通方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-processing"><a class="anchor" href="#webflux-cors-processing"></a> 1.14.2。处理</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-processing">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>CORS规范区分了预检，简单和实际请求。要了解CORS的工作原理，您可以阅读<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>以及其他许多内容，或者查看规范以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux <code>HandlerMapping</code>实现为CORS提供内置支持。成功将请求映射到处理程序后， <code>HandlerMapping</code>检查给定请求和处理程序的CORS配置并采取进一步操作。直接处理预检请求，同时拦截，验证简单和实际的CORS请求，并设置所需的CORS响应头。</p>
</div>
<div class="paragraph">
<p>为了启用跨源请求（即，存在<code>Origin</code>头并且与请求的主机不同），您需要具有一些显式声明的CORS配置。如果未找到匹配的CORS配置，则拒绝预检请求。没有CORS头添加到简单和实际CORS请求的响应中，因此浏览器拒绝它们。</p>
</div>
<div class="paragraph">
<p>可以使用基于URL模式的<code>CorsConfiguration</code>映射单独<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a>每个<code>HandlerMapping</code> 。在大多数情况下，应用程序使用WebFlux Java配置来声明此类映射，这会导致将单个全局映射传递给所有<code>HadlerMappping</code>实现。</p>
</div>
<div class="paragraph">
<p>您可以将<code>HandlerMapping</code>级别的全局CORS配置与更细粒度的处理程序级CORS配置相结合。例如，带注释的控制器可以使用类或方法级别的<code>@CrossOrigin</code>注释（其他处理程序可以实现<code>CorsConfigurationSource</code> ）。</p>
</div>
<div class="paragraph">
<p>组合全局和本地配置的规则通常是附加的 - 例如，所有全局和所有本地源。对于只能接受单个值的属性，例如<code>allowCredentials</code>和<code>maxAge</code> ，本地会覆盖全局值。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要从源中了解更多信息或进行高级自定义，请参阅：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code>和<code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>是AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-controller"><a class="anchor" href="#webflux-cors-controller"></a> 1.14.3。使用<code>@CrossOrigin</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-controller">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>注释在带注释的控制器方法上启用跨源请求，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountController</span> { <span class="annotation">@CrossOrigin</span> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt;Account&gt; retrieve（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@DeleteMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt; <span class="predefined-type">Void</span> &gt; remove（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>@CrossOrigin</code>允许：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p>控制器方法映射到的所有HTTP方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下不启用<code>allowedCredentials</code> ，因为它建立了一个信任级别，用于公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的时候使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code>也在类级别受支持，并由所有方法继承。以下示例指定某个域并将<code>maxAge</code>设置为一小时：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span> （ <span class="annotation">origin</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://domain2.com</span> <span class="delimiter">”</span></span> ，maxAge = <span class="integer">3600</span> ） <span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountController</span> { <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt;Account&gt; retrieve（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@DeleteMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt; <span class="predefined-type">Void</span> &gt; remove（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在类和方法级别使用<code>@CrossOrigin</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span> （maxAge = <span class="integer">3600</span> ） <i class="conum" data-value="1"></i> <b>（1）</b> <span class="annotation">@RestController</span> <span class="annotation">@RequestMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ account</span> <span class="delimiter">”</span></span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">AccountController</span> { <span class="annotation">@CrossOrigin</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">http://domain2.com</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="2"></i> <b>（2）</b> <span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt;Account&gt; retrieve（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>} <span class="annotation">@DeleteMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> Mono &lt; <span class="predefined-type">Void</span> &gt; remove（ <span class="annotation">@ PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>在班级使用<code>@CrossOrigin</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在方法级别使用<code>@CrossOrigin</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-global"><a class="anchor" href="#webflux-cors-global"></a> 1.14.4。全局配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-global">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>除了细粒度的控制器方法级配置之外，您可能还想定义一些全局CORS配置。您可以在任何<code>HandlerMapping</code>上单独设置基于URL的<code>CorsConfiguration</code>映射。但是，大多数应用程序都使用WebFlux Java配置来执行此操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，全局配置启用以下内容</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p><code>GET</code> ， <code>HEAD</code>和<code>POST</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下不启用<code>allowedCredentials</code> ，因为它建立了一个信任级别，用于公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的时候使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="paragraph">
<p>要在WebFlux Java配置中启用CORS，可以使用<code>CorsRegistry</code>回调，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addCorsMappings（CorsRegistry注册表）{registry.addMapping（ <span class="string"><span class="content"><span class="delimiter">“/</span> API / <span class="delimiter">**”）.allowedOrigins（</span></span></span> <span class="string"><span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="delimiter"><span class="content">“http://domain2.com”）.allowedMethods（“PUT</span></span></span></span></span></span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">DELETE</span> <span class="delimiter">“</span></span> ）。allowedHeaders（ <span class="string"><span class="delimiter">”</span> <span class="content">header1</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">header2</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">header3</span> <span class="delimiter">“</span></span> ）。expposedHeaders（ <span class="string"><span class="delimiter">”</span> <span class="content">header1</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">header2</span> <span class="delimiter">“</span></span> ）。allowCredentials（ <span class="predefined-constant">true</span> ）.maxAge（ <span class="integer">3600</span> ）; <span class="comment">//添加更多映射...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-webfilter"><a class="anchor" href="#webflux-cors-webfilter"></a> 1.14.5。CORS <code>WebFilter</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-filter">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过内置的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html"><code>CorsWebFilter</code></a>应用CORS支持，这非常适合<a href="#webflux-fn">功能端点</a> 。</p>
</div>
<div class="paragraph">
<p>要配置过滤器，您可以声明<code>CorsWebFilter</code> bean并将<code>CorsConfigurationSource</code>传递给其构造函数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span> CorsWebFilter corsFilter（）{CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration（）; <span class="comment">//可能......</span>
    <span class="comment">// config.applyPermitDefaultValues（）</span> config.setAllowCredentials（ <span class="predefined-constant">true</span> ）; config.addAllowedOrigin（ <span class="string"><span class="delimiter">“</span> <span class="content">http://domain1.com</span> <span class="delimiter">”</span></span> ）; config.addAllowedHeader（ <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> ）; config.addAllowedMethod（ <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> ）; UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource（）; source.registerCorsConfiguration（ <span class="string"><span class="delimiter">“</span> <span class="content">/ **</span> <span class="delimiter">”</span></span> ，config）; <span class="keyword">返回</span> <span class="keyword">新的</span> CorsWebFilter（来源）; }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-web-security"><a class="anchor" href="#webflux-web-security"></a> 1.15。网络安全</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-web-security">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://projects.spring.io/spring-security/">Spring Security</a>项目为保护Web应用程序免受恶意攻击提供支持。请参阅Spring Security参考文档，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#jc-webflux">WebFlux安全</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-webflux">WebFlux测试支持</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF保护</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">安全响应标头</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-view"><a class="anchor" href="#webflux-view"></a> 1.16。查看技术</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中使用视图技术是可插拔的。您是否决定使用Thymeleaf，FreeMarker或其他一些视图技术主要是配置更改的问题。本章介绍与Spring WebFlux集成的视图技术。我们假设您已经熟悉<a href="#webflux-viewresolution">View Resolution</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-view-thymeleaf"><a class="anchor" href="#webflux-view-thymeleaf"></a> 1.16.1。Thymeleaf</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-thymeleaf">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf是一个现代服务器端Java模板引擎，强调自然HTML模板，可以通过双击在浏览器中预览，这对于UI模板的独立工作（例如，由设计师）非常有用，而无需运行服务器。Thymeleaf提供广泛的功能，并积极开发和维护。有关更完整的介绍，请参阅<a href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
</div>
<div class="paragraph">
<p>Thymeleaf与Spring WebFlux的集成由Thymeleaf项目管理。配置涉及一些bean声明，例如<code>SpringResourceTemplateResolver</code> ， <code>SpringWebFluxTemplateEngine</code>和<code>ThymeleafReactiveViewResolver</code> 。有关更多详细信息，请参阅<a href="http://www.thymeleaf.org/documentation.html">Thymeleaf + Spring</a>和WebFlux集成<a href="http://forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html">公告</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-freemarker"><a class="anchor" href="#webflux-view-freemarker"></a> 1.16.2。FreeMarker的</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://www.freemarker.org">Apache FreeMarker</a>是一个模板引擎，用于生成从HTML到电子邮件和其他人的任何类型的文本输出。Spring Framework具有内置的集成，可以将Spring WebFlux与FreeMarker模板结合使用。</p>
</div>
<div class="sect4">
<h5 id="webflux-view-freemarker-contextconfig"><a class="anchor" href="#webflux-view-freemarker-contextconfig"></a>查看配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker-contextconfig">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何将FreeMarker配置为视图技术：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.freemarker（）; } <span class="comment">//配置FreeMarker ......</span>

    <span class="annotation">@Bean</span> <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer（）{FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer（）; configurer.setTemplateLoaderPath（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/ templates</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您的模板需要存储在<code>FreeMarkerConfigurer</code>指定的目录中，如前面的示例所示。根据前面的配置，如果您的控制器返回视图名称<code>welcome</code> ，则解析器将查找<code>classpath:/templates/freemarker/welcome.ftl</code>模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-views-freemarker"><a class="anchor" href="#webflux-views-freemarker"></a> FreeMarker配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-views-freemarker">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过在<code>FreeMarkerConfigurer</code> bean上设置适当的bean属性，将<code>FreeMarkerConfigurer</code> '和'SharedVariables'直接传递给FreeMarker <code>Configuration</code>对象（由Spring管理）。<code>freemarkerSettings</code>属性需要<code>java.util.Properties</code>对象和<code>freemarkerVariables</code>属性需要<code>java.util.Map</code> 。以下示例显示如何使用<code>FreeMarkerConfigurer</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer { <span class="comment">// ...</span>

    <span class="annotation">@Bean</span> <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer（）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; variables = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt;&gt;（）; variables.put（ <span class="string"><span class="delimiter">“</span> <span class="content">xml_escape</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> XmlEscape（））; FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer（）; configurer.setTemplateLoaderPath（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/ templates</span> <span class="delimiter">”</span></span> ）; configurer.setFreemarkerVariables（变量）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关适用于<code>Configuration</code>对象的设置和变量的详细信息，请参阅FreeMarker文档。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-script"><a class="anchor" href="#webflux-view-script"></a> 1.16.3。脚本视图</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework有一个内置的集成，可以将Spring WebFlux与任何可以在<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java脚本引擎之上运行的模板库一起使用。下表显示了我们在不同脚本引擎上测试的模板库：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">脚本库</th>
<th class="tableblock halign-left valign-top">脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://handlebarsjs.com/">把手</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">胡子</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://facebook.github.io/react/">应对</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">犀牛</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.stuartellis.eu/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://jruby.org">JRuby的</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">字符串模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.jython.org/">Jython的</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin脚本模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://kotlinlang.org/">科特林</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="webflux-view-script-dependencies"><a class="anchor" href="#webflux-view-script-dependencies"></a>要求</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script-dependencies">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您需要在类路径上安装脚本引擎，其详细信息因脚本引擎而异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript引擎随Java 8+一起提供。强烈建议使用最新的更新版本。</p>
</li>
<li>
<p>应该添加<a href="http://jruby.org">JRuby</a>作为Ruby支持的依赖项。</p>
</li>
<li>
<p>应该添加<a href="http://www.jython.org">Jython</a>作为Python支持的依赖项。</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和<code>META-INF/services/javax.script.ScriptEngineFactory</code>文件包含<code>org.jetbrains.kotlin.script.jsr223.应该为Kotlin脚本支持添加KotlinJsr223JvmLocalScriptEngineFactory</code>行。有关详细信息，请参阅<a href="https://github.com/sdeleuze/kotlin-script-templating">此示例</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要拥有脚本模板库。对Javascript这样做的一种方法是通过<a href="http://www.webjars.org/">WebJars</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-view-script-integrate"><a class="anchor" href="#webflux-view-script-integrate"></a>脚本模板</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script-integrate">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以声明<code>ScriptTemplateConfigurer</code> bean以指定要使用的脚本引擎，要加载的脚本文件，要调用以呈现模板的函数，等等。以下示例使用Mustache模板和Nashorn JavaScript引擎：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.scriptTemplate（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> ScriptTemplateConfigurer configurer（）{ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer（）; configurer.setEngineName（ <span class="string"><span class="delimiter">“</span> <span class="content">nashorn</span> <span class="delimiter">”</span></span> ）; configurer.setScripts（ <span class="string"><span class="delimiter">“</span> <span class="content">mustache.js</span> <span class="delimiter">”</span></span> ）; configurer.setRenderObject（ <span class="string"><span class="delimiter">“</span> <span class="content">Mustache</span> <span class="delimiter">”</span></span> ）; configurer.setRenderFunction（ <span class="string"><span class="delimiter">“</span> <span class="content">render</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用以下参数调用<code>render</code>函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code> ：模板内容</p>
</li>
<li>
<p><code>Map model</code> ：视图模型</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code> ： <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a> ，提供对应用程序上下文，区域设置，模板加载器和URL的访问（自5.0起）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code>本身与此签名兼容，因此您可以直接调用它。</p>
</div>
<div class="paragraph">
<p>如果您的模板技术需要一些自定义，您可以提供实现自定义渲染功能的脚本。例如， <a href="http://handlebarsjs.com">Handlerbars</a>需要使用它们之前编译模板和需要<a href="http://en.wikipedia.org/wiki/Polyfill">填充工具</a>以模拟在服务器端脚本引擎无法使用浏览器的一些设施。以下示例显示如何设置自定义渲染功能：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebMvc</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.scriptTemplate（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> ScriptTemplateConfigurer configurer（）{ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer（）; configurer.setEngineName（ <span class="string"><span class="delimiter">“</span> <span class="content">nashorn</span> <span class="delimiter">”</span></span> ）; configurer.setScripts（ <span class="string"><span class="delimiter">“</span> <span class="content">polyfill.js</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">handlebars.js</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">render.js</span> <span class="delimiter">”</span></span> ）; configurer.setRenderFunction（ <span class="string"><span class="delimiter">“</span> <span class="content">render</span> <span class="delimiter">”</span></span> ）; configurer.setSharedEngine（ <span class="predefined-constant">false</span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当使用非线程安全脚本引擎以及不是为并发而设计的模板库（例如在Nashorn上运行的Handlebars或React）时，需要将<code>sharedEngine</code>属性设置为<code>false</code> 。在这种情况下，由于<a href="https://bugs.openjdk.java.net/browse/JDK-8076099">此错误</a> ，需要Java 8u60或更高版本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code>仅定义Handlebars正常运行所需的<code>window</code>对象，如下面的代码段所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">var</span> window = {};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个基本的<code>render.js</code>实现在使用之前编译模板。生产就绪实现还应存储和重用缓存模板或预编译模板。这可以在脚本端完成，也可以在您需要的任何自定义（例如管理模板引擎配置）上完成。以下示例显示了如何编译模板：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">render</span> （template，model）{ <span class="keyword">var</span> compiledTemplate = Handlebars.compile（template）; <span class="keyword">return</span> compileTemplate（model）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多配置示例，请查看Spring Framework单元测试， <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script">Java</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script">资源</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-httpmessagewriter"><a class="anchor" href="#webflux-view-httpmessagewriter"></a> 1.16.4。JSON和XML</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-jackson">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>对于<a href="#webflux-multiple-representations">内容协商</a>目的，根据客户端请求的内容类型，能够在使用HTML模板或其他格式（如JSON或XML）呈现模型之间进行交替是很有用的。为了支持这一点，Spring WebFlux提供了<code>HttpMessageWriterView</code> ，您可以使用它来插入<code>spring-web</code>中的任何可用<a href="#webflux-codecs">编解码器</a> ，例如<code>Jackson2JsonEncoder</code> ， <code>Jackson2SmileEncoder</code>或<code>Jaxb2XmlEncoder</code> 。</p>
</div>
<div class="paragraph">
<p>与其他视图技术不同， <code>HttpMessageWriterView</code>不需要<code>ViewResolver</code> ，而是<a href="#webflux-config-view-resolvers">配置</a>为默认视图。您可以配置一个或多个此类默认视图，包装不同的<code>HttpMessageWriter</code>实例或<code>Encoder</code>实例。匹配请求的内容类型的那个在运行时使用。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，模型包含多个属性。要确定要序列化的序列，可以使用要用于呈现的model属性的名称配置<code>HttpMessageWriterView</code> 。如果模型仅包含一个属性，则使用该属性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-caching"><a class="anchor" href="#webflux-caching"></a> 1.17。HTTP缓存</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕<code>Cache-Control</code>响应头和后续条件请求头，例如<code>Last-Modified</code>和<code>ETag</code> 。<code>Cache-Control</code>建议私有（例如，浏览器）和公共（例如，代理）缓存如何缓存和重用响应。如果内容未更改，则<code>ETag</code>标头用于生成条件请求，该条件请求可能导致304（NOT_MODIFIED）没有正文。<code>ETag</code>可以被视为<code>Last-Modified</code>标头的更复杂的后继者。</p>
</div>
<div class="paragraph">
<p>本节介绍Spring WebFlux中可用的HTTP缓存相关选项。</p>
</div>
<div class="sect3">
<h4 id="webflux-caching-cachecontrol"><a class="anchor" href="#webflux-caching-cachecontrol"></a> 1.17.1。<code>CacheControl</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-cachecontrol">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>支持配置与<code>Cache-Control</code>标头相关的设置，并在许多地方被接受为参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-caching-etag-lastmodified">控制器</a></p>
</li>
<li>
<p><a href="#webflux-caching-static-resources">静态资源</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然<a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用面向用例的方法，该方法侧重于常见场景，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//缓存一小时 - “Cache-Control：max-age = 3600”</span> CacheControl ccCacheOneHour = CacheControl.maxAge（ <span class="integer">1</span> ， <span class="predefined-type">TimeUnit</span> 。小时）; <span class="comment">//防止缓存 - “Cache-Control：no-store”</span> CacheControl ccNoStore = CacheControl.noStore（）; <span class="comment">//在公共和私有缓存中缓存十天，</span> <span class="comment">//公共缓存不应该转换响应</span> <span class="comment">//“Cache-Control：max-age = 864000，public，no-transform”</span> CacheControl ccCustom = CacheControl.maxAge（ <span class="integer">10</span> ， <span class="predefined-type">TimeUnit</span> 。DAYS）.noTransform（）cachePublic（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-etag-lastmodified"><a class="anchor" href="#webflux-caching-etag-lastmodified"></a> 1.17.2。控制器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-etag-lastmodified">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以添加对HTTP缓存的显式支持。我们建议这样做，因为在将资源与条件请求标头进行比较之前，需要计算资源的<code>lastModified</code>或<code>ETag</code>值。控制器可以将<code>ETag</code>和<code>Cache-Control</code>设置添加到<code>ResponseEntity</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">/ book / {id}</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> ResponseEntity &lt; <span class="predefined-type">Book</span> &gt; showBook（ <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id）{ <span class="predefined-type">Book</span> book = findBook（id）; <span class="predefined-type">String</span> version = book.getVersion（）; <span class="keyword">返回</span> ResponseEntity .ok（）。cacheControl（CacheControl.maxAge（ <span class="integer">30</span> ， <span class="predefined-type">TimeUnit</span> 。DAYS））。eTag（版本） <span class="comment">// lastModified也可用</span> .body（book）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果与条件请求标头的比较表明内容未更改，则前面的示例发送304（NOT_MODIFIED）响应，其中包含空主体。否则， <code>ETag</code>和<code>Cache-Control</code>标头将添加到响应中。</p>
</div>
<div class="paragraph">
<p>您还可以对控制器中的条件请求标头进行检查，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestMapping</span> <span class="directive">public</span> <span class="predefined-type">String</span> myHandleMethod（ServerWebExchange exchange，Model model）{ <span class="type">long</span> eTag = ...<i class="conum" data-value="1"></i> <b>（1）</b> if（exchange.checkNotModified（eTag））{ <span class="keyword">return</span> <span class="predefined-constant">null</span> ; <i class="conum" data-value="2"></i> <b>（2）</b> } model.addAttribute（...）; <i class="conum" data-value="3"></i> <b>（3）</b> <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">myViewName</span> <span class="delimiter">”</span></span> ; }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>特定于应用的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）。没有进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>继续请求处理。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有三种变体可用于检查针对<code>eTag</code>值， <code>lastModified</code>值或两者的条件请求。对于条件<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为304（NOT_MODIFIED）。对于条件<code>POST</code> ， <code>PUT</code>和<code>DELETE</code> ，您可以将响应设置为409（PRECONDITION_FAILED）以防止并发修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-static-resources"><a class="anchor" href="#webflux-caching-static-resources"></a> 1.17.3。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-static-resources">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您应该使用<code>Cache-Control</code>和条件响应头来提供静态资源，以获得最佳性能。请参阅有关配置<a href="#webflux-config-static-resources">静态资源</a>的部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config"><a class="anchor" href="#webflux-config"></a> 1.18。WebFlux配置</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>WebFlux Java配置声明处理具有带注释的控制器或功能端点的请求所需的组件，并提供用于自定义配置的API。这意味着您不需要了解Java配置创建的底层bean。但是，如果您想了解它们，可以在<code>WebFluxConfigurationSupport</code>查看它们，或者阅读有关它们在<a href="#webflux-special-bean-types">特殊Bean类型中的更多信息</a> 。</p>
</div>
<div class="paragraph">
<p>对于配置API中未提供的更高级自定义，您可以通过<a href="#webflux-config-advanced-java">高级配置模式</a>完全控制<a href="#webflux-config-advanced-java">配置</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-config-enable"><a class="anchor" href="#webflux-config-enable"></a> 1.18.1。启用WebFlux配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-enable">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以在Java配置中使用<code>@EnableWebFlux</code>批注，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例注册了许多Spring WebFlux <a href="#mvc-webflux-special-bean-types">基础结构bean，</a>并适应类路径上可用的依赖项 - 适用于JSON，XML和其他。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-customize"><a class="anchor" href="#webflux-config-customize"></a> 1.18.2。WebFlux配置API</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-customize">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以实现<code>WebFluxConfigurer</code>接口，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer { <span class="comment">//实现配置方法...</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-conversion"><a class="anchor" href="#webflux-config-conversion"></a> 1.18.3。转换，格式化</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-conversion">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，会安装<code>Number</code>和<code>Date</code>类型的格式化程序，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code>注释的支持。如果类路径中存在Joda-Time，则还会安装对Joda-Time格式库的完全支持。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何注册自定义格式化程序和转换器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addFormatters（FormatterRegistry注册表<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关何时使用<code>FormatterRegistrar</code>实现的更多信息，请参阅<a href="core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>和<code>FormattingConversionServiceFactoryBean</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-validation"><a class="anchor" href="#webflux-config-validation"></a> 1.18.4。验证</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-validation">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，如果类路径上存在<a href="core.html#validation-beanvalidation-overview">Bean Validation</a> （例如，Hibernate Validator），则<code>LocalValidatorFactoryBean</code>将注册为全局<a href="core.html#validator">验证程序</a> ，以便与<code>@Valid</code>和<code>@Controller</code>方法参数上的<code>Validated</code>一起使用。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以自定义全局<code>Validator</code>实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="predefined-type">验证</span> getValidator（）; { <span class="comment">// ......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，您还可以在本地注册<code>Validator</code>实现，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> { <span class="annotation">@InitBinder</span> <span class="directive">protected</span> <span class="type">void</span> initBinder（WebDataBinder binder）{binder.addValidators（ <span class="keyword">new</span> FooValidator（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果需要在某处注入<code>LocalValidatorFactoryBean</code> ，请创建一个bean并使用<code>@Primary</code>标记它，以避免与MVC配置中声明的那个冲突。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-content-negotiation"><a class="anchor" href="#webflux-config-content-negotiation"></a> 1.18.5。内容类型解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-content-negotiation">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以配置Spring WebFlux如何根据请求确定<code>@Controller</code>实例的请求媒体类型。默认情况下，仅选中<code>Accept</code>标头，但您也可以启用基于查询参数的策略。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义请求的内容类型解析：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureContentTypeResolver（RequestedContentTypeResolverBuilder建设者<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-message-codecs"><a class="anchor" href="#webflux-config-message-codecs"></a> 1.18.6。HTTP消息编解码器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-message-converters">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义读取和写入请求和响应正文的方式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureHttpMessageCodecs（ServerCodecConfigurer配置者<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ServerCodecConfigurer</code>提供了一组默认的读者和编写者。您可以使用它来添加更多读者和编写者，自定义默认值，或完全替换默认值。</p>
</div>
<div class="paragraph">
<p>对于Jackson JSON和XML，请考虑使用<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a> ，它使用以下方法自定义Jackson的默认属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature。FAIL_ON_UNKNOWN_PROPERTIES</code></a>已禁用。</p>
</li>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature。DEFAULT_VIEW_INCLUSION</code></a>已禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在类路径中检测到它们，它还会自动注册以下众所周知的模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7"><code>jackson-datatype-jdk7</code></a> ：支持Java 7类型，如<code>java.nio.file.Path</code> 。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda"><code>jackson-datatype-joda</code></a> ：支持Joda-Time类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310"><code>jackson-datatype-jsr310</code></a> ：支持Java 8 Date和Time API类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8"><code>jackson-datatype-jdk8</code></a> ：支持其他Java 8类型，例如<code>Optional</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-view-resolvers"><a class="anchor" href="#webflux-config-view-resolvers"></a> 1.18.7。查看解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-view-resolvers">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置视图分辨率：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ViewResolverRegistry</code>具有Spring Framework集成的视图技术的快捷方式。以下示例使用FreeMarker（还需要配置基础FreeMarker视图技术）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.freeMarker（）; } <span class="comment">//配置Freemarker ...</span>

    <span class="annotation">@Bean</span> <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer（）{FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer（）; configurer.setTemplateLoaderPath（ <span class="string"><span class="delimiter">“</span> <span class="content">classpath：/ templates</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> configurer; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以插入任何<code>ViewResolver</code>实现，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{ViewResolver的解析器= ...; registry.viewResolver（分解）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了支持<a href="#webflux-multiple-representations">内容协商</a>并通过视图解析（除了HTML）呈现其他格式，您可以基于<code>HttpMessageWriterView</code>实现配置一个或多个默认视图，该实现接受来自<code>spring-web</code>任何可用<a href="#webflux-codecs">编解码器</a> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configureViewResolvers（ViewResolverRegistry注册表）{registry.freeMarker（）; Jackson2JsonEncoder encoder = <span class="keyword">new</span> Jackson2JsonEncoder（）; registry.defaultViews（ <span class="keyword">new</span> HttpMessageWriterView（encoder））; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参阅<a href="#webflux-view">View Technologies</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-static-resources"><a class="anchor" href="#webflux-config-static-resources"></a> 1.18.8。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-static-resources">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>此选项提供了一种从基于<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a>的位置列表中提供静态资源的便捷方法。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，给定以<code>/resources</code>开头的请求，相对路径用于查找和提供相对于类路径上的<code>/static</code>静态资源。资源的使用期限为一年，以确保最大限度地使用浏览器缓存并减少浏览器发出的HTTP请求。还会评估<code>Last-Modified</code>标头，如果存在，则返回<code>304</code>状态代码。以下列表显示了示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addResourceHandlers（ResourceHandlerRegistry注册表）{registry.addResourceHandler（ <span class="string"><span class="content"><span class="delimiter">“/</span>资源/ <span class="delimiter">**”）.addResourceLocations（</span></span></span> <span class="string"><span class="content"><span class="delimiter">“/</span>公众</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">类路径：/静态<span class="delimiter">/”）.setCacheControl</span></span></span> （CacheControl.maxAge（ <span class="integer">365</span> ， <span class="predefined-type">TimeUnit</span> 。天））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>资源处理程序还支持一系列<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html"><code>ResourceResolver</code></a>实现和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a>实现，这些实现可用于创建工具链以使用优化的资源。</p>
</div>
<div class="paragraph">
<p>您可以根据从内容，固定应用程序版本或其他信息计算的MD5哈希，将<code>VersionResourceResolver</code>用于版本化资源URL。<code>ContentVersionStrategy</code> （MD5哈希）是一个很好的选择，有一些值得注意的例外（例如模块加载器使用的JavaScript资源）。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java配置中使用<code>VersionResourceResolver</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> addResourceHandlers（ResourceHandlerRegistry注册表）{registry.addResourceHandler（ <span class="string"><span class="content"><span class="delimiter">“/</span>资源/ <span class="delimiter">**”）.addResourceLocations（</span></span></span> <span class="string"><span class="content"><span class="delimiter">“/</span>公<span class="delimiter">/”）.resourceChain（</span></span></span> <span class="predefined-constant">真</span> ）.addResolver（ <span class="keyword">新</span> VersionResourceResolver（）。addContentVersionStrategy（ <span class="string"><span class="delimiter">“</span> <span class="content">/ **</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>ResourceUrlProvider</code>重写URL并应用完整的解析器和转换器链（例如，插入版本）。WebFlux配置提供<code>ResourceUrlProvider</code>以便可以将其注入其他人。</p>
</div>
<div class="paragraph">
<p>与Spring MVC不同，目前，在WebFlux中，没有办法透明地重写静态资源URL，因为没有可以使用非阻塞的解析器和变换器链的视图技术。仅提供本地资源时，解决方法是直接使用<code>ResourceUrlProvider</code> （例如，通过自定义元素）和阻止。</p>
</div>
<div class="paragraph">
<p>请注意，当同时使用<code>EncodedResourceResolver</code> （例如，Gzip，Brotli编码）和<code>VersionedResourceResolver</code> ，必须按顺序注册它们，以确保始终基于未编码的文件可靠地计算基于内容的版本。</p>
</div>
<div class="paragraph">
<p><a href="http://www.webjars.org/documentation">WebJars</a>也通过<code>WebJarsResourceResolver</code>支持，并且当类路径中存在<code>org.webjars:webjars-locator</code>时会自动注册。解析程序可以重写URL以包含jar的版本，也可以匹配没有版本的传入URL（例如，/ <code>/jquery/jquery.min.js</code>到<code>/jquery/1.2.0/jquery.min.js</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-path-matching"><a class="anchor" href="#webflux-config-path-matching"></a> 1.18.9。路径匹配</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-path-matching">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以自定义与路径匹配相关的选项。有关各个选项的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/web/reactive/config/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> Javadoc。以下示例显示如何使用<code>PathMatchConfigurer</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="annotation">@EnableWebFlux</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">实现</span> WebFluxConfigurer <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> configurePathMatch（PathMatchConfigurer配置器）{配置器.setUseCaseSensitiveMatch（ <span class="predefined-constant">真</span> ）.setUseTrailingSlashMatch（ <span class="predefined-constant">假</span> ）.addPathPrefix（ <span class="string"><span class="content"><span class="delimiter">“/</span> <span class="delimiter">API”，HandlerTypePredicate.forAnnotation（RestController.class））;</span></span></span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring WebFlux依赖于名为<code>RequestPath</code>的请求路径的解析表示，以访问已解码的路径段值，并删除分号内容（即路径或矩阵变量）。这意味着，与Spring MVC不同，您无需指示是否解码请求路径，也不需要删除分号内容以进行路径匹配。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux也不支持后缀模式匹配，与Spring MVC不同，我们也<a href="web.html#mvc-ann-requestmapping-suffix-pattern-match">建议</a>不要依赖它。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-advanced-java"><a class="anchor" href="#webflux-config-advanced-java"></a> 10年1月18日。高级配置模式</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-advanced-java">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebFlux</code>导入<code>DelegatingWebFluxConfiguration</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为WebFlux应用程序提供默认的Spring配置</p>
</li>
<li>
<p>检测并委托<code>WebFluxConfigurer</code>实现来自定义该配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级模式，您可以删除<code>@EnableWebFlux</code>并直接从<code>DelegatingWebFluxConfiguration</code>扩展而不是实现<code>WebFluxConfigurer</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">WebConfig</span> <span class="directive">扩展了</span> DelegatingWebFluxConfiguration { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<code>WebConfig</code>保留现有方法，但现在您也可以从基类覆盖bean声明，并且在类路径上仍然有任意数量的其他<code>WebMvcConfigurer</code>实现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http2"><a class="anchor" href="#webflux-http2"></a> 1.19。HTTP / 2</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-http2">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4容器需要支持HTTP / 2，Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要具体做什么。但是，存在与服务器配置相关的注意事项。有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP / 2 Wiki页面</a> 。</p>
</div>
<div class="paragraph">
<p>目前，Spring WebFlux不支持使用Netty的HTTP / 2。也没有支持以编程方式将资源推送给客户端。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-client"><a class="anchor" href="#webflux-client"></a> 2。Web客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring WebFlux包含一个用于HTTP请求的反应式非阻塞<code>WebClient</code> 。客户端具有功能性，流畅的API以及用于声明性组合的反应类型，请参阅<a href="#webflux-reactive-libraries">Reactive Libraries</a> 。WebFlux客户端和服务器依赖相同的非阻塞<a href="#webflux-codecs">编解码器</a>来编码和解码请求和响应内容。</p>
</div>
<div class="paragraph">
<p>内部<code>WebClient</code>委托给HTTP客户端库。默认情况下，它使用<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a> ，内置支持Jetty <a href="https://github.com/jetty-project/jetty-reactive-httpclient">反应式HtpClient</a> ，其他可以通过<code>ClientHttpConnector</code>插入。</p>
</div>
<div class="sect2">
<h3 id="webflux-client-builder"><a class="anchor" href="#webflux-client-builder"></a> 2.1。组态</h3>
<div class="paragraph">
<p>创建<code>WebClient</code>的最简单方法是通过以下静态工厂方法之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WebClient.create（）</code></p>
</li>
<li>
<p><code>WebClient.create（String baseUrl）</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>上述方法使用具有默认设置的Reactor Netty <code>HttpClient</code> ，并期望<code>io.projectreactor.netty:reactor-netty</code>位于类路径上。</p>
</div>
<div class="paragraph">
<p>您还可以使用<code>WebClient.builder()</code>以及更多选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>uriBuilderFactory</code> ：自定义<code>UriBuilderFactory</code>以用作基本URL。</p>
</li>
<li>
<p><code>defaultHeader</code> ：每个请求的<code>defaultHeader</code>头。</p>
</li>
<li>
<p><code>defaultCookie</code> ：每个请求的Cookie。</p>
</li>
<li>
<p><code>defaultRequest</code> ： <code>Consumer</code>来自定义每个请求。</p>
</li>
<li>
<p><code>filter</code> ：每个请求的客户端过滤器。</p>
</li>
<li>
<p><code>exchangeStrategies</code> ：HTTP消息读取器/写入器自定义。</p>
</li>
<li>
<p><code>clientConnector</code> ：HTTP客户端库设置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例配置<a href="#webflux-codecs">HTTP编解码器</a> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExchangeStrategies策略= ExchangeStrategies.builder（）。codecs（configurer  - &gt; { <span class="comment">// ...</span>}）.build（）; WebClient客户端= WebClient.builder（）。exchangeStrategies（策略）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>构建后， <code>WebClient</code>实例是不可变的。但是，您可以克隆它并构建修改后的副本，而不会影响原始实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient client1 = WebClient.builder（）。filter（filterA）.filter（filterB）.build（）; WebClient client2 = client1.mutate（）。filter（filterC）.filter（filterD）.build（）; <span class="comment">// client1有filterA，filterB</span> <span class="comment">//</span> <span class="comment">client2</span> <span class="comment">有filterA，filterB，filterC，filterD</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-reactor"><a class="anchor" href="#webflux-client-builder-reactor"></a> 2.1.1。Reactor Netty</h4>
<div class="paragraph">
<p>要自定义Reactor Netty设置，只需提供预先配置的<code>HttpClient</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = HttpClient.create（）。secure（sslSpec  - &gt; ...）; WebClient webClient = WebClient.builder（）.clientConnector（ <span class="keyword">new</span> ReactorClientHttpConnector（httpClient））。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-resources"><a class="anchor" href="#webflux-client-builder-reactor-resources"></a>资源</h5>
<div class="paragraph">
<p>默认情况下， <code>HttpClient</code>参与<code>HttpClient</code>中保存的全局Reactor Netty资源<code>reactor.netty.http.HttpResources</code> ，包括事件循环线程和连接池。这是推荐的模式，因为固定的共享资源是事件循环并发的首选。在此模式下，全局资源将保持活动状态，直到进程退出。</p>
</div>
<div class="paragraph">
<p>如果服务器与进程同步，则通常不需要显式关闭。但是，如果服务器可以在进程中启动或停止（例如，部署为WAR的Spring MVC应用程序），则可以使用<code>globalResources=true</code> （默认值）声明类型为<code>ReactorResourceFactory</code>的Spring管理的bean，以确保Reactor Spring <code>ApplicationContext</code>关闭时，Netty全局资源将关闭，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Bean</span> <span class="directive">public</span> ReactorResourceFactory reactorResourceFactory（）{ <span class="keyword">return</span> <span class="keyword">new</span> ReactorResourceFactory（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以选择不参与全局Reactor Netty资源。但是，在此模式下，您需要确保所有Reactor Netty客户端和服务器实例都使用共享资源，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Bean</span> <span class="directive">public</span> ReactorResourceFactory resourceFactory（）{ReactorResourceFactory factory = <span class="keyword">new</span> ReactorResourceFactory（）; factory.setGlobalResources（ <span class="predefined-constant">false</span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> <span class="keyword">退货</span> ; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebClient webClient（）{Function &lt;HttpClient，HttpClient&gt; mapper = client  - &gt; { <span class="comment">//进一步自定义......</span>}; ClientHttpConnector connector = <span class="keyword">new</span> ReactorClientHttpConnector（resourceFactory（），mapper）; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="keyword">返回</span> WebClient.builder（）。clientConnector（connector）.build（）; <i class="conum" data-value="3"></i> <b>（3）</b> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>创建独立于全球资源的资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将<code>ReactorClientHttpConnector</code>构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将连接器插入<code>WebClient.Builder</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-timeout"><a class="anchor" href="#webflux-client-builder-reactor-timeout"></a>超时</h5>
<div class="paragraph">
<p>配置连接超时：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">io.netty.channel。ChannelOption</span> ; HttpClient httpClient = HttpClient.create（）。tcpConfiguration（client  - &gt; client.option（ChannelOption。CONNECT_TIMEOUT_MILLIS， <span class="integer">10000</span> ））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要配置读取和/或写入超时值：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">io.netty.handler.timeout。ReadTimeoutHandler</span> ; <span class="keyword">import</span> <span class="include">io.netty.handler.timeout。WriteTimeoutHandler</span> ; HttpClient httpClient = HttpClient.create（）。tcpConfiguration（client  - &gt; client.doOnConnected（conn  - &gt; conn .addHandlerLast（ <span class="keyword">new</span> ReadTimeoutHandler（ <span class="integer">10</span> ））。addHandlerLast（ <span class="keyword">new</span> WriteTimeoutHandler（ <span class="integer">10</span> ））））;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-jetty"><a class="anchor" href="#webflux-client-builder-jetty"></a> 2.1.2。码头</h4>
<div class="paragraph">
<p>以下示例显示如何自定义Jetty <code>HttpClient</code>设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = <span class="keyword">new</span> HttpClient（）; httpClient.setCookieStore（...）; ClientHttpConnector connector = <span class="keyword">new</span> JettyClientHttpConnector（httpClient）; WebClient webClient = WebClient.builder（）。clientConnector（connector）.build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>HttpClient</code>创建自己的资源（ <code>Executor</code> ， <code>ByteBufferPool</code> ， <code>Scheduler</code> ），它们一直处于活动状态，直到进程退出或调用<code>stop()</code>为止。</p>
</div>
<div class="paragraph">
<p>您可以在Jetty客户端（和服务器）的多个实例之间共享资源，并通过声明<code>JettyResourceFactory</code>类型的Spring管理bean来确保在关闭Spring <code>ApplicationContext</code>时关闭资源，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Bean</span> <span class="directive">public</span> JettyResourceFactory resourceFactory（）{ <span class="keyword">return</span> <span class="keyword">new</span> JettyResourceFactory（）; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebClient webClient（）{Consumer &lt;HttpClient&gt; customizer = client  - &gt; { <span class="comment">//进一步自定义...</span>}; ClientHttpConnector connector = <span class="keyword">new</span> JettyClientHttpConnector（resourceFactory（），customizer）; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="keyword">返回</span> WebClient.builder（）。clientConnector（connector）.build（）; <i class="conum" data-value="3"></i> <b>（3）</b> }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>创建共享资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将<code>JettyClientHttpConnector</code>构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将连接器插入<code>WebClient.Builder</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-retrieve"><a class="anchor" href="#webflux-client-retrieve"></a> 2.2。使用<code>retrieve()</code></h3>
<div class="paragraph">
<p><code>retrieve()</code>方法是获取响应主体并对其进行解码的最简单方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient客户端= WebClient.create（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.org</span> <span class="delimiter">”</span></span> ）; Mono &lt;Person&gt; result = client.get（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.accept（MediaType。APPLICATION_JSON）.retrieve（）。bodyToMono（Person.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以获取从响应中解码的对象流，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt;Quote&gt; result = client.get（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ quotes</span> <span class="delimiter">”</span></span> ）。accept（MediaType。TEXT_EVENT_STREAM）.retrieve（）。bodyToFlux（Quote.class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，具有4xx或5xx状态代码的响应会导致<code>WebClientResponseException</code>或其HTTP状态特定子类之一，例如<code>WebClientResponseException.BadRequest</code> ， <code>WebClientResponseException.NotFound</code>和其他人。您还可以使用<code>onStatus</code>方法自定义生成的异常，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;Person&gt; result = client.get（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.accept（MediaType。APPLICATION_JSON）.retrieve（）。onStatus（HttpStatus :: is4xxServerError，response  - &gt; ...）.onStatus（HttpStatus :: is5xxServerError，响应 - &gt; ...）.bodyToMono（Person.class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-exchange"><a class="anchor" href="#webflux-client-exchange"></a> 2.3。使用<code>exchange()</code></h3>
<div class="paragraph">
<p><code>exchange()</code>方法提供比<code>retrieve</code>方法更多的控制。以下示例等同于<code>retrieve()</code>但也提供对<code>ClientResponse</code>访问：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;Person&gt; result = client.get（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.accept（MediaType。APPLICATION_JSON）.exchange（）。flatMap（response  - &gt; response.bodyToMono（Person.class））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此级别，您还可以创建完整的<code>ResponseEntity</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono &lt;ResponseEntity &lt;Person &gt;&gt; result = client.get（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.accept（MediaType。APPLICATION_JSON）.exchange（）。flatMap（response  - &gt; response.toEntity（Person.class））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意（与<code>retrieve()</code>不同），使用<code>exchange()</code> ，4xx和5xx响应没有自动错误信号。您必须检查状态代码并决定如何继续。</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">使用<code>exchange()</code> ，必须始终使用<code>ClientResponse</code>任何<code>body</code>或<code>toEntity</code>方法来确保释放资源并避免HTTP连接池的潜在问题。如果没有预期的响应内容，您可以使用<code>bodyToMono(Void.class)</code> 。但是，如果响应确实包含内容，则连接将关闭，并且不会放回池中。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-body"><a class="anchor" href="#webflux-client-body"></a> 2.4。请求机构</h3>
<div class="paragraph">
<p>请求正文可以从<code>Object</code>进行编码，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">单声道&lt;人&gt; personMono = ...; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.contentType（MediaType。APPLICATION_JSON）.body（personMono，Person.class）.retrieve（）。bodyToMono（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以编码对象流，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux &lt;Person&gt; personFlux = ...; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.contentType（MediaType。APPLICATION_STREAM_JSON）.body（personFlux，Person.class）.retrieve（）。bodyToMono（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果您有实际值，则可以使用<code>syncBody</code>快捷方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">人物= ......; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ persons / {id}</span> <span class="delimiter">”</span></span> ，id）.contentType（MediaType。APPLICATION_JSON）.syncBody（person）.retrieve（）。bodyToMono（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-form"><a class="anchor" href="#webflux-client-body-form"></a> 2.4.1。表格数据</h4>
<div class="paragraph">
<p>要发送表单数据，可以提供<code>MultiValueMap&lt;String, String&gt;</code>作为正文。请注意，内容由<code>FormHttpMessageWriter</code>自动设置为<code>application/x-www-form-urlencoded</code> 。以下示例显示如何使用<code>MultiValueMap&lt;String, String&gt;</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MultiValueMap &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; formData = ...; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ path</span> <span class="delimiter">”</span></span> ，id）.syncBody（formData）.retrieve（）。bodyToMono（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<code>BodyInserters</code>在线提供表单数据，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function。BodyInserters</span> 。*; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ path</span> <span class="delimiter">”</span></span> ，id）.body（fromFormData（ <span class="string"><span class="delimiter">“</span> <span class="content">k1</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">v1</span> <span class="delimiter">”</span></span> ）。with（ <span class="string"><span class="delimiter">“</span> <span class="content">k2</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">v2</span> <span class="delimiter">”</span></span> ））。retrieve（） .bodyToMono（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-multipart"><a class="anchor" href="#webflux-client-body-multipart"></a> 2.4.2。多部分数据</h4>
<div class="paragraph">
<p>要发送多部分数据，您需要提供<code>MultiValueMap&lt;String, ?&gt;</code>其值是表示部件内容的<code>Object</code>实例或表示部件的内容和标头的<code>HttpEntity</code>实例。<code>MultipartBodyBuilder</code>提供了一个方便的API来准备多部分请求。以下示例显示如何创建<code>MultiValueMap&lt;String, ?&gt;</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MultipartBodyBuilder builder = <span class="keyword">new</span> MultipartBodyBuilder（）; builder.part（ <span class="string"><span class="delimiter">“</span> <span class="content">fieldPart</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">fieldValue</span> <span class="delimiter">”</span></span> ）; builder.part（ <span class="string"><span class="delimiter">“</span> <span class="content">filePart</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> FileSystemResource（ <span class="string"><span class="delimiter">“</span> <span class="content">... logo.png</span> <span class="delimiter">”</span></span> ））; builder.part（ <span class="string"><span class="delimiter">“</span> <span class="content">jsonPart</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> Person（ <span class="string"><span class="delimiter">“</span> <span class="content">Jason</span> <span class="delimiter">”</span></span> ））; MultiValueMap &lt; <span class="predefined-type">String</span> ，HttpEntity &lt;？&gt;&gt; parts = builder.build（）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下，您不必为每个部件指定<code>Content-Type</code> 。内容类型是根据选择用于序列​​化它的<code>HttpMessageWriter</code>自动确定的，或者在<code>Resource</code>的情况下，基于文件扩展名自动确定。如有必要，您可以通过其中一个重载的构建器<code>part</code>方法显式提供要用于每个部件的<code>MediaType</code> 。</p>
</div>
<div class="paragraph">
<p>准备好<code>MultiValueMap</code> ，将其传递给<code>WebClient</code>的最简单方法是通过<code>syncBody</code>方法，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MultipartBodyBuilder构建器= ...; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ path</span> <span class="delimiter">”</span></span> ，id）.syncBody（ <strong>builder.build（）</strong> ）。retrieve（）。bodyToMono（ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果<code>MultiValueMap</code>包含至少一个非<code>String</code>值，它也可以表示常规表单数据（即<code>application/x-www-form-urlencoded</code> ），则无需将<code>Content-Type</code>设置为<code>multipart/form-data</code> 。使用<code>MultipartBodyBuilder</code>时总是如此，它确保了<code>HttpEntity</code>包装器。</p>
</div>
<div class="paragraph">
<p>作为<code>MultipartBodyBuilder</code>的替代方案，您还可以通过内置的<code>BodyInserters</code>提供内联样式的多部分内容，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function。BodyInserters</span> 。*; Mono &lt; <span class="predefined-type">Void</span> &gt; result = client.post（）.uri（ <span class="string"><span class="delimiter">“</span> <span class="content">/ path</span> <span class="delimiter">”</span></span> ，id）.body（fromMultipartData（ <span class="string"><span class="delimiter">“</span> <span class="content">fieldPart</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">value</span> <span class="delimiter">”</span></span> ）。 <span class="string"><span class="content">with</span></span> （ <span class="string"><span class="delimiter">“</span> <span class="content">filePart</span> <span class="delimiter">”</span></span> ，resource））。retrieve（）。bodyToMono （ <span class="predefined-type">Void</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-filter"><a class="anchor" href="#webflux-client-filter"></a> 2.5。客户过滤器</h3>
<div class="paragraph">
<p>您可以通过<code>WebClient.注册客户端过滤器（ <code>ExchangeFilterFunction</code> ） <code>WebClient.Builder</code>以拦截和修改请求，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient client = WebClient.builder（）。filter（（request，next） - &gt; {ClientRequest filtered = ClientRequest.from（request）.header（ <span class="string"><span class="delimiter">“</span> <span class="content">foo</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">bar</span> <span class="delimiter">”</span></span> ）。build（）; <span class="keyword">return</span> next.exchange（filtered ）;}}。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这可用于横切关注点，例如身份验证。以下示例使用过滤器通过静态工厂方法进行基本身份验证：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//静态导入ExchangeFilterFunctions.basicAuthentication</span> WebClient client = WebClient.builder（）。filter（basicAuthentication（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> ））。build（）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>过滤器全局应用于每个请求。要更改特定请求的过滤器行为，您可以向<code>ClientRequest</code>添加请求属性，然后链中的所有过滤器都可以访问这些属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient client = WebClient.builder（）。filter（（request，next） - &gt; {Optional &lt; <span class="predefined-type">Object</span> &gt; usr = request.attribute（ <span class="string"><span class="delimiter">“</span> <span class="content">myAttribute</span> <span class="delimiter">”</span></span> ）; <span class="comment">// ...</span>}）.build（）; client.get（）。uri（ <span class="string"><span class="delimiter">“</span> <span class="content">http://example.org/</span> <span class="delimiter">”</span></span> ）。attribute（ <span class="string"><span class="delimiter">“</span> <span class="content">myAttribute</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> ）。retrieve（）。bodyToMono（ <span class="predefined-type">Void</span> .class）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以复制现有<code>WebClient</code> ，插入新过滤器或删除已注册的过滤器。以下示例在索引0处插入基本身份验证筛选器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//静态导入ExchangeFilterFunctions.basicAuthentication</span> WebClient client = webClient.mutate（）.filters（filterList  - &gt; {filterList.add（ <span class="integer">0</span> ，basicAuthentication（ <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> ））;}）。build（）;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-testing"><a class="anchor" href="#webflux-client-testing"></a> 2.6。测试</h3>
<div class="paragraph">
<p>要测试使用<code>WebClient</code>代码，可以使用模拟Web服务器，例如<a href="https://github.com/square/okhttp#mockwebserver">OkHttp MockWebServer</a> 。要查看其使用示例，请检查Spring Framework测试中的<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java"><code>WebClientIntegrationTests</code></a>或OkHttp存储库中的<a href="https://github.com/square/okhttp/tree/master/samples/static-server"><code>static-server</code></a>示例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-websocket"><a class="anchor" href="#webflux-websocket"></a> 3。的WebSockets</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>这部分参考文档涵盖了对反应堆栈WebSocket消息传递的支持。</p>
</div>
<div class="sect2">
<h3 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a> 3.1。WebSocket简介</h3>
<div class="paragraph">
<p>WebSocket协议<a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准化方法，可通过单个TCP连接在客户端和服务器之间建立全双工双向通信通道。它是来自HTTP的不同TCP协议，但设计为使用端口80和443通过HTTP工作，并允许重用现有防火墙规则。</p>
</div>
<div class="paragraph">
<p>WebSocket交互以HTTP请求开始，该HTTP请求使用HTTP <code>Upgrade</code>标头进行升级，或者在这种情况下，切换到WebSocket协议。以下示例显示了这样的交互：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>GET / spring-websocket-portfolio / portfolio HTTP / 1.1主机：localhost：8080升级：websocket &lt;1&gt;连接：升级&lt;2&gt; Sec-WebSocket-Key：Uc9l9TMkWGbHFD2qnFHltg == Sec-WebSocket-Protocol：v10.stomp，v11。 stomp Sec-WebSocket-Version：13来源：http：// localhost：8080</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>Upgrade</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>具有WebSocket支持的服务器返回类似于以下内容的输出，而不是通常的200状态代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre><strong>HTTP / 1.1 101交换协议</strong>升级：websocket连接：升级Sec-WebSocket-Accept：1qVdfYHU9hPOl4JYYNXF623Gzn0 = Sec-WebSocket-Protocol：v10.stomp</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>成功握手后，HTTP升级请求下的TCP套接字将保持打开状态，以便客户端和服务器继续发送和接收消息。</p>
</div>
<div class="paragraph">
<p>有关WebSockets如何工作的完整介绍超出了本文档的范围。请参阅RFC 6455，HTML5的WebSocket章节，或Web上的许多介绍和教程。</p>
</div>
<div class="paragraph">
<p>请注意，如果WebSocket服务器在Web服务器（例如nginx）后面运行，您可能需要将其配置为将WebSocket升级请求传递到WebSocket服务器。同样，如果应用程序在云环境中运行，请检查与WebSocket支持相关的云提供程序的说明。</p>
</div>
<div class="sect3">
<h4 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a> 3.1.1。HTTP与WebSocket</h4>
<div class="paragraph">
<p>尽管WebSocket被设计为与HTTP兼容并且以HTTP请求开始，但重要的是要理解这两种协议会导致非常不同的体系结构和应用程序编程模型。</p>
</div>
<div class="paragraph">
<p>在HTTP和REST中，应用程序被建模为多个URL。要与应用程序进行交互，客户端将访问这些URL，请求 - 响应样式。服务器根据HTTP URL，方法和标头将请求路由到适当的处理程序。</p>
</div>
<div class="paragraph">
<p>相比之下，在WebSockets中，初始连接通常只有一个URL。随后，所有应用程序消息都在同一TCP连接上流动。这指向完全不同的异步，事件驱动的消息传递体系结构。</p>
</div>
<div class="paragraph">
<p>WebSocket也是一种低级传输协议，与HTTP不同，它不对消息内容规定任何语义。这意味着除非客户端和服务器就消息语义达成一致，否则无法路由或处理消息。</p>
</div>
<div class="paragraph">
<p>WebSocket客户端和服务器可以通过HTTP握手请求上的<code>Sec-WebSocket-Protocol</code>标头协商使用更高级别的消息传递协议（例如，STOMP）。如果没有，他们需要提出自己的惯例。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a> 3.1.2。何时使用WebSockets</h4>
<div class="paragraph">
<p>WebSockets可以使网页变得动态和交互。但是，在许多情况下，Ajax和HTTP流式传输或长轮询的组合可以提供简单有效的解决方案。</p>
</div>
<div class="paragraph">
<p>例如，新闻，邮件和社交订阅源需要动态更新，但每隔几分钟就可以完全正常更新。另一方面，协作，游戏和财务应用程序需要更接近实时。</p>
</div>
<div class="paragraph">
<p>仅延迟不是决定因素。如果消息量相对较低（例如，监视网络故障），HTTP流式传输或轮询可以提供有效的解决方案。它是低延迟，高频率和高容量的组合，是WebSocket使用的最佳选择。</p>
</div>
<div class="paragraph">
<p>还要记住，通过Internet，受控制之外的限制性代理可能会阻止WebSocket交互，因为它们未配置为传递<code>Upgrade</code>标头，或者因为它们关闭看似空闲的长期连接。这意味着将WebSocket用于防火墙内的内部应用程序是一个比面向公众的应用程序更直接的决策。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server"><a class="anchor" href="#webflux-websocket-server"></a> 3.2。WebSocket API</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework提供了一个WebSocket API，您可以使用它来编写处理WebSocket消息的客户端和服务器端应用程序。</p>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handler"><a class="anchor" href="#webflux-websocket-server-handler"></a> 3.2.1。服务器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handler">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>要创建WebSocket服务器，可以先创建<code>WebSocketHandler</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.reactive.socket。WebSocketHandler</span> ; <span class="keyword">import</span> <span class="include">org.springframework.web.reactive.socket。WebSocketSession</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyWebSocketHandler</span> <span class="directive">实现</span> WebSocketHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span>单&lt; <span class="predefined-type">空隙</span> &gt;手柄（WebSocketSession会话<span class="comment">）{// ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将其映射到URL并添加<code>WebSocketHandlerAdapter</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">WebConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> HandlerMapping handlerMapping（）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ，WebSocketHandler&gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt;&gt;（）; map.put（ <span class="string"><span class="delimiter">“</span> <span class="content">/ path</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> MyWebSocketHandler（））; SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping（）; mapping.setUrlMap（地图）; mapping.setOrder（ - <span class="integer">1</span> ）; <span class="comment">//在带注释的控制器之前</span> <span class="keyword">返回</span>映射; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebSocketHandlerAdapter <span class="annotation">handlerAdapter</span> （）{ <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter（）; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websockethandler"><a class="anchor" href="#webflux-websockethandler"></a> 3.2.2。使用<code>WebSocketHandler</code></h4>
<div class="paragraph">
<p><code>WebSocketHandler</code>的<code>handle</code>方法接受<code>WebSocketSession</code>并返回<code>Mono&lt;Void&gt;</code>以指示会话的应用程序处理何时完成。会话通过两个流处理，一个用于入站消息，一个用于出站消息。下表描述了处理流的两种方法：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>WebSocketSession</code>方法</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux &lt;WebSocketMessage&gt; receive（）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供对入站消息流的访问，并在关闭连接时完成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono &lt;Void&gt;发送（Publisher &lt;WebSocketMessage&gt;）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取传出消息的源，写入消息，并返回在源完成并写入完成时完成的<code>Mono&lt;Void&gt;</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>WebSocketHandler</code>必须将入站和出站流组成一个统一的流，并返回反映该流完成的<code>Mono&lt;Void&gt;</code> 。根据应用程序要求，统一流程在以下情况下完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>入站或出站消息流完成。</p>
</li>
<li>
<p>入站流完成（即连接已关闭），而出站流是无限的。</p>
</li>
<li>
<p>在选定的点上，通过<code>WebSocketSession</code>的<code>close</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当入站和出站消息流组合在一起时，无需检查连接是否打开，因为Reactive Streams信号终止活动。入站流接收完成或错误信号，并且出站流接收取消信号。</p>
</div>
<div class="paragraph">
<p>处理程序的最基本实现是处理入站流的实现。以下示例显示了这样的实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">类</span> <span class="class">ExampleHandler</span> <span class="directive">实现</span> WebSocketHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span>单&lt; <span class="predefined-type">空隙</span> &gt;手柄（WebSocketSession会话）{ <span class="keyword">返回</span> session.receive（） <i class="conum" data-value="1"></i> <b>（1）</b> .doOnNext（消息 - &gt; { <span class="comment">// ...</span><i class="conum" data-value="2"></i> <b>（2）</b> }）。concatMap（message  - &gt; { <span class="comment">// ...</span><i class="conum" data-value="3"></i> <b>（3）</b> }）。then（）; <i class="conum" data-value="4"></i> <b>（4）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>访问入站邮件流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对每条消息做点什么。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行使用消息内容的嵌套异步操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>返回接收完成时完成的<code>Mono&lt;Void&gt;</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">对于嵌套的异步操作，您可能需要在使用池化数据缓冲区（例如，Netty）的底层服务器上调用<code>message.retain()</code> ）。否则，可能在您有机会读取数据之前释放数据缓冲区。有关更多背景信息，请参阅<a href="core.html#databuffers">数据缓冲区和编解码器</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下实现组合了入站和出站流：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">类</span> <span class="class">ExampleHandler</span> <span class="directive">实现</span> WebSocketHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span>单&lt; <span class="predefined-type">空隙</span> &gt;手柄（WebSocketSession会话）{通量&lt;WebSocketMessage&gt;输出= session.receive（） <i class="conum" data-value="1"></i> <b>（1）</b> .doOnNext（消息 - &gt; { <span class="comment">// ...</span>}）.concatMap（message  - &gt; { <span class="comment">// ...</span>} .map（value  - &gt; session.textMessage（ <span class="string"><span class="delimiter">“</span> <span class="content">Echo</span> <span class="delimiter">”</span></span> + value））; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="keyword">return</span> session.send（输出）; <i class="conum" data-value="3"></i> <b>（3）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建出站消息，生成组合流。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>返回我们继续收到时未完成的<code>Mono&lt;Void&gt;</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>入站和出站流可以是独立的，只有完成才能连接，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">类</span> <span class="class">ExampleHandler</span> <span class="directive">实现</span> WebSocketHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span>单&lt; <span class="predefined-type">空隙</span> &gt;手柄（WebSocketSession会话）{单&lt; <span class="predefined-type">空隙</span> &gt;输入= session.receive（） <i class="conum" data-value="1"></i> <b>（1）</b> .doOnNext（消息 - &gt; { <span class="comment">// ...</span>}）.concatMap（message  - &gt; { <span class="comment">// ...</span>}） 。然后（）; Flux &lt; <span class="predefined-type">String</span> &gt; source = ...; Mono &lt; <span class="predefined-type">Void</span> &gt; output = session.send（source.map（session :: textMessage））; <i class="conum" data-value="2"></i> <b>（2）</b> <span class="keyword">返回</span> Mono.zip（输入，输出）.then（）; <i class="conum" data-value="3"></i> <b>（3）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>发送外发邮件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>加入流并返回<code>Mono&lt;Void&gt;</code> ，当任一流结束时完成。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handshake"><a class="anchor" href="#webflux-websocket-server-handshake"></a> 3.2.3。握手</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handshake">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>WebSocketHandlerAdapter</code>委托给<code>WebSocketService</code> 。默认情况下，这是<code>HandshakeWebSocketService</code>一个实例，它对WebSocket请求执行基本检查，然后对正在使用的服务器使用<code>RequestUpgradeStrategy</code> 。目前，内置支持Reactor Netty，Tomcat，Jetty和Undertow。</p>
</div>
<div class="paragraph">
<p><code>HandshakeWebSocketService</code>公开了一个<code>sessionAttributePredicate</code>属性，该属性允许设置<code>Predicate&lt;String&gt;</code>以从<code>WebSession</code>提取属性并将它们插入到<code>WebSocketSession</code>的属性中。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-config"><a class="anchor" href="#webflux-websocket-server-config"></a> 3.2.4。服务器配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-runtime-configuration">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>每个服务器的<code>RequestUpgradeStrategy</code>公开了可用于底层WebSocket引擎的与WebSocket相关的配置选项。以下示例在Tomcat上运行时设置WebSocket选项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">静态</span> <span class="type">类</span> <span class="class">WebConfig</span> { <span class="annotation">@Bean</span> <span class="directive">public</span> WebSocketHandlerAdapter <span class="annotation">handlerAdapter</span> （）{ <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter（webSocketService（））; } <span class="annotation">@Bean</span> <span class="directive">public</span> WebSocketService webSocketService（）{TomcatRequestUpgradeStrategy strategy = <span class="keyword">new</span> TomcatRequestUpgradeStrategy（）; strategy.setMaxSessionIdleTimeout（ <span class="integer">0L</span> ）; <span class="keyword">返回</span> <span class="keyword">新的</span> HandshakeWebSocketService（策略）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>检查服务器的升级策略以查看可用的选项。目前，只有Tomcat和Jetty公开了这样的选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-cors"><a class="anchor" href="#webflux-websocket-server-cors"></a> 3.2.5。CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-allowed-origins">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>配置CORS并限制对WebSocket端点的访问的最简单方法是让<code>WebSocketHandler</code>实现<code>CorsConfigurationSource</code>并返回<code>CorsConfiguraiton</code>其中包含允许的起源，标题和其他详细信息。如果您不能这样做，您还可以在<code>SimpleUrlHandler</code>上设置<code>corsConfigurations</code>属性，以按URL模式指定CORS设置。如果同时指定了两者，则使用<code>CorsConfiguration</code>上的<code>combine</code>方法<code>combine</code>它们组合<code>combine</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-client"><a class="anchor" href="#webflux-websocket-client"></a> 3.2.6。客户</h4>
<div class="paragraph">
<p>Spring WebFlux提供了一个<code>WebSocketClient</code>抽象，其中包含Reactor Netty，Tomcat，Jetty，Undertow和标准Java（即JSR-356）的实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Tomcat客户端实际上是标准Java的扩展，在<code>WebSocketSession</code>处理中具有一些额外的功能，以利用特定于Tomcat的API来暂停接收消息以获得反压。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要启动WebSocket会话，您可以创建客户端的实例并使用其<code>execute</code>方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebSocketClient client = <span class="keyword">new</span> ReactorNettyWebSocketClient（）; <span class="predefined-type">URI</span> url = <span class="keyword">new</span> <span class="predefined-type">URI</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">ws：// localhost：8080 / path</span> <span class="delimiter">”</span></span> ）; client.execute（url，session  - &gt; session.receive（）。doOnNext（ <span class="predefined-type">System</span> .out :: println）.then（））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>某些客户端（如Jetty）实现了<code>Lifecycle</code> ，需要先停止并启动它们才能使用它们。所有客户端都具有与底层WebSocket客户端配置相关的构造函数选项。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-test"><a class="anchor" href="#webflux-test"></a> 4。测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#testing">在Spring MVC中也是如此</a></span></p>
</div>
<div class="paragraph">
<p><code>spring-test</code>模块提供<code>ServerHttpRequest</code> ， <code>ServerHttpResponse</code>和<code>ServerWebExchange</code>模拟实现。有关模拟对象的讨论，请参阅<a href="testing.html#mock-objects-web-reactive">Spring Web Reactive</a> 。</p>
</div>
<div class="paragraph">
<p><a href="testing.html#webtestclient"><code>WebTestClient</code></a>构建在这些模拟请求和响应对象之上，以支持在没有HTTP服务器的情况下测试WebFlux应用程序。您也可以使用<code>WebTestClient</code>进行端到端集成测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-reactive-libraries"><a class="anchor" href="#webflux-reactive-libraries"></a> 5。反应性图书馆</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>spring-webflux</code>依赖于<code>reactor-core</code>并在内部使用它来组成异步逻辑并提供Reactive Streams支持。通常，WebFlux API返回<code>Flux</code>或<code>Mono</code> （因为它们在内部使用）并且宽松地接受任何Reactive Streams <code>Publisher</code>实现作为输入。使用<code>Flux</code>与<code>Mono</code>非常重要，因为它有助于表达基数 - 例如，是否需要单个或多个异步值，这对于做出决策（例如，编码或解码HTTP消息时）至关重要。</p>
</div>
<div class="paragraph">
<p>对于带注释的控制器，WebFlux透明地适应应用程序选择的反应库。这是在<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a>的帮助下完成的，它为反应库和其他异步类型提供可插入支持。注册表内置了对RxJava和<code>CompletableFuture</code>支持，但您也可以注册其他人。</p>
</div>
<div class="paragraph">
<p>对于功能API（例如<a href="#webflux-fn">功能端点</a> ， <code>WebClient</code>等），WebFlux API的一般规则适用 - <code>Flux</code>和<code>Mono</code>作为返回值，Reactive Streams <code>Publisher</code>作为输入。当<code>Publisher</code> ，无论是自定义的或从另一个反应性文库，提供，它可以被视为仅与未知的语义（0流..N）。但是，如果已知语义，则可以使用<code>Flux</code>或<code>Mono.from(Publisher)</code>将其包装，而不是传递原始<code>Publisher</code> 。</p>
</div>
<div class="paragraph">
<p>例如，如果<code>Publisher</code>不是<code>Mono</code> ，则Jackson JSON消息编写者需要多个值。如果媒体类型意味着无限流（例如， <code>application/json+stream</code> ），则会单独写入和刷新值。否则，将值缓冲到列表中并呈现为JSON数组。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>