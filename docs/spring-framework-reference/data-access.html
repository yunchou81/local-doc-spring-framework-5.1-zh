<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8"></meta>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
<meta name="generator" content="Asciidoctor 1.5.5"></meta>
<title>数据访问</title>
<style>
  /* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
  /* ===================================================================== */
  
  @import url('stylesheets/asciidoctor-spring.css');
  
  /* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  /* ============================================================================ */
  
  @import url('tocbot-3.0.2/tocbot.css');
  
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
  #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
  #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
    padding-left: 0 }
  #tocbot a.toc-link{ height:100% }
  .is-collapsible{ max-height:3000px; overflow:hidden; }
  .is-collapsed{ max-height:0 }
  .is-active-link{ font-weight:700 }
  }
  @media print{
  #tocbot a.toc-link.node-name--H4{ display:none }
  }
  
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <style>
  /* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
  /*pre.CodeRay {background-color:#f7f7f8;}*/
  .CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
  .CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
  .CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
  table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
  table.CodeRay td{vertical-align: top;line-height:1.45}
  table.CodeRay td.line-numbers{text-align:right}
  table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
  table.CodeRay td.code{padding:0 0 0 .5em}
  table.CodeRay td.code>pre{padding:0}
  .CodeRay .debug{color:#fff !important;background:#000080 !important}
  .CodeRay .annotation{color:#007}
  .CodeRay .attribute-name{color:#000080}
  .CodeRay .attribute-value{color:#700}
  .CodeRay .binary{color:#509}
  .CodeRay .comment{color:#998;font-style:italic}
  .CodeRay .char{color:#04d}
  .CodeRay .char .content{color:#04d}
  .CodeRay .char .delimiter{color:#039}
  .CodeRay .class{color:#458;font-weight:bold}
  .CodeRay .complex{color:#a08}
  .CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
  .CodeRay .color{color:#099}
  .CodeRay .class-variable{color:#369}
  .CodeRay .decorator{color:#b0b}
  .CodeRay .definition{color:#099}
  .CodeRay .delimiter{color:#000}
  .CodeRay .doc{color:#970}
  .CodeRay .doctype{color:#34b}
  .CodeRay .doc-string{color:#d42}
  .CodeRay .escape{color:#666}
  .CodeRay .entity{color:#800}
  .CodeRay .error{color:#808}
  .CodeRay .exception{color:inherit}
  .CodeRay .filename{color:#099}
  .CodeRay .function{color:#900;font-weight:bold}
  .CodeRay .global-variable{color:#008080}
  .CodeRay .hex{color:#058}
  .CodeRay .integer,.CodeRay .float{color:#099}
  .CodeRay .include{color:#555}
  .CodeRay .inline{color:#000}
  .CodeRay .inline .inline{background:#ccc}
  .CodeRay .inline .inline .inline{background:#bbb}
  .CodeRay .inline .inline-delimiter{color:#d14}
  .CodeRay .inline-delimiter{color:#d14}
  .CodeRay .important{color:#555;font-weight:bold}
  .CodeRay .interpreted{color:#b2b}
  .CodeRay .instance-variable{color:#008080}
  .CodeRay .label{color:#970}
  .CodeRay .local-variable{color:#963}
  .CodeRay .octal{color:#40e}
  .CodeRay .predefined{color:#369}
  .CodeRay .preprocessor{color:#579}
  .CodeRay .pseudo-class{color:#555}
  .CodeRay .directive{font-weight:bold}
  .CodeRay .type{font-weight:bold}
  .CodeRay .predefined-type{color:inherit}
  .CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
  .CodeRay .key{color:#808}
  .CodeRay .key .delimiter{color:#606}
  .CodeRay .key .char{color:#80f}
  .CodeRay .value{color:#088}
  .CodeRay .regexp .delimiter{color:#808}
  .CodeRay .regexp .content{color:#808}
  .CodeRay .regexp .modifier{color:#808}
  .CodeRay .regexp .char{color:#d14}
  .CodeRay .regexp .function{color:#404;font-weight:bold}
  .CodeRay .string{color:#d20}
  .CodeRay .string .string .string{background:#ffd0d0}
  .CodeRay .string .content{color:#d14}
  .CodeRay .string .char{color:#d14}
  .CodeRay .string .delimiter{color:#d14}
  .CodeRay .shell{color:#d14}
  .CodeRay .shell .delimiter{color:#d14}
  .CodeRay .symbol{color:#990073}
  .CodeRay .symbol .content{color:#a60}
  .CodeRay .symbol .delimiter{color:#630}
  .CodeRay .tag{color:#008080}
  .CodeRay .tag-special{color:#d70}
  .CodeRay .variable{color:#036}
  .CodeRay .insert{background:#afa}
  .CodeRay .delete{background:#faa}
  .CodeRay .change{color:#aaf;background:#007}
  .CodeRay .head{color:#f8f;background:#505}
  .CodeRay .insert .insert{color:#080}
  .CodeRay .delete .delete{color:#800}
  .CodeRay .change .change{color:#66f}
  .CodeRay .head .head{color:#f4f}
  </style>
</head>
<body id="spring-data-tier" class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>数据访问</h1>
<div class="details">
<span id="revnumber">版本5.1.0。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#transaction">1。交易管理</a>
<ul class="sectlevel2">
<li><a href="#transaction-motivation">1.1。Spring Framework的事务支持模型的优点</a>
<ul class="sectlevel3">
<li><a href="#transaction-global">1.1.1。全球交易</a></li>
<li><a href="#transaction-local">1.1.2。本地交易</a></li>
<li><a href="#transaction-programming-model">1.1.3。Spring Framework的一致性编程模型</a></li>
</ul>
</li>
<li><a href="#transaction-strategies">1.2。理解Spring Framework事务抽象</a></li>
<li><a href="#tx-resource-synchronization">1.3。资源与事务同步</a>
<ul class="sectlevel3">
<li><a href="#tx-resource-synchronization-high">1.3.1。高级同步方法</a></li>
<li><a href="#tx-resource-synchronization-low">1.3.2。低级同步方法</a></li>
<li><a href="#tx-resource-synchronization-tadsp">1.3.3。<code>类TransactionAwareDataSourceProxy</code></a></li>
</ul>
</li>
<li><a href="#transaction-declarative">1.4。声明式事务管理</a>
<ul class="sectlevel3">
<li><a href="#tx-decl-explained">1.4.1。理解Spring Framework的声明式事务实现</a></li>
<li><a href="#transaction-declarative-first-example">1.4.2。声明性事务实现的示例</a></li>
<li><a href="#transaction-declarative-rolling-back">1.4.3。回滚声明性交易</a></li>
<li><a href="#transaction-declarative-diff-tx">1.4.4。为不同的Bean配置不同的事务语义</a></li>
<li><a href="#transaction-declarative-txadvice-settings">1.4.5。 &lt;tx：advice /&gt;设置</a></li>
<li><a href="#transaction-declarative-annotations">1.4.6。使用<code>@Transactional</code></a>
<ul class="sectlevel4">
<li><a href="#transaction-declarative-attransactional-settings"><code>@Transactional</code>设置</a></li>
<li><a href="#tx-multiple-tx-mgrs-with-attransactional">使用<code>@Transactional</code>多个交易管理器</a></li>
<li><a href="#tx-custom-attributes">自定义快捷方式注释</a></li>
</ul>
</li>
<li><a href="#tx-propagation">1.4.7。交易传播</a>
<ul class="sectlevel4">
<li><a href="#tx-propagation-required">了解<code>PROPAGATION_REQUIRED</code></a></li>
<li><a href="#tx-propagation-requires_new">了解<code>PROPAGATION_REQUIRES_NEW</code></a></li>
<li><a href="#tx-propagation-nested">了解<code>PROPAGATION_NESTED</code></a></li>
</ul>
</li>
<li><a href="#transaction-declarative-applying-more-than-just-tx-advice">1.4.8。为交易操作提供咨询</a></li>
<li><a href="#transaction-declarative-aspectj">1.4.9。将<code>@Transactional</code>与AspectJ一起使用</a></li>
</ul>
</li>
<li><a href="#transaction-programmatic">1.5。程序化交易管理</a>
<ul class="sectlevel3">
<li><a href="#tx-prog-template">1.5.1。使用<code>TransactionTemplate</code></a>
<ul class="sectlevel4">
<li><a href="#tx-prog-template-settings">指定交易设置</a></li>
</ul>
</li>
<li><a href="#transaction-programmatic-ptm">1.5.2。使用<code>PlatformTransactionManager</code></a></li>
</ul>
</li>
<li><a href="#tx-decl-vs-prog">1.6。在程序化和声明式事务管理之间进行选择</a></li>
<li><a href="#transaction-event">1.7。交易约束事件</a></li>
<li><a href="#transaction-application-server-integration">1.8。应用程序服务器特定的集成</a>
<ul class="sectlevel3">
<li><a href="#transaction-application-server-integration-websphere">1.8.1。IBM WebSphere</a></li>
<li><a href="#transaction-application-server-integration-weblogic">1.8.2。Oracle WebLogic Server</a></li>
</ul>
</li>
<li><a href="#transaction-solutions-to-common-problems">1.9。解决常见问题</a>
<ul class="sectlevel3">
<li><a href="#transaction-solutions-to-common-problems-wrong-ptm">1.9.1。使用错误的事务管理器来获取特定的<code>DataSource</code></a></li>
</ul>
</li>
<li><a href="#transaction-resources">1.10。更多资源</a></li>
</ul>
</li>
<li><a href="#dao">2。DAO支持</a>
<ul class="sectlevel2">
<li><a href="#dao-exceptions">2.1。一致的异常层次结构</a></li>
<li><a href="#dao-annotations">2.2。用于配置DAO或存储库类的注释</a></li>
</ul>
</li>
<li><a href="#jdbc">3。使用JDBC进行数据访问</a>
<ul class="sectlevel3">
<li><a href="#jdbc-choose-style">3.1。选择JDBC数据库访问方法</a></li>
<li><a href="#jdbc-packages">3.2。包层次结构</a></li>
<li><a href="#jdbc-core">3.3。使用JDBC核心类控制基本JDBC处理和错误处理</a>
<ul class="sectlevel3">
<li><a href="#jdbc-JdbcTemplate">3.3.1。使用<code>JdbcTemplate</code></a>
<ul class="sectlevel4">
<li><a href="#jdbc-JdbcTemplate-examples">JdbcTemplate类用法的示例</a></li>
<li><a href="#jdbc-JdbcTemplate-idioms"><code>JdbcTemplate</code>最佳实践</a></li>
</ul>
</li>
<li><a href="#jdbc-NamedParameterJdbcTemplate">3.3.2。使用<code>NamedParameterJdbcTemplate</code></a></li>
<li><a href="#jdbc-SQLExceptionTranslator">3.3.3。使用<code>SQLExceptionTranslator</code></a></li>
<li><a href="#jdbc-statements-executing">3.3.4。运行语句</a></li>
<li><a href="#jdbc-statements-querying">3.3.5。运行查询</a></li>
<li><a href="#jdbc-updates">3.3.6。更新数据库</a></li>
<li><a href="#jdbc-auto-genereted-keys">3.3.7。检索自动生成的密钥</a></li>
</ul>
</li>
<li><a href="#jdbc-connections">3.4。控制数据库连接</a>
<ul class="sectlevel3">
<li><a href="#jdbc-datasource">3.4.1。使用<code>DataSource</code></a></li>
<li><a href="#jdbc-DataSourceUtils">3.4.2。使用<code>DataSourceUtils</code></a></li>
<li><a href="#jdbc-SmartDataSource">3.4.3。实现<code>SmartDataSource</code></a></li>
<li><a href="#jdbc-AbstractDataSource">3.4.4。扩展<code>AbstractDataSource</code></a></li>
<li><a href="#jdbc-SingleConnectionDataSource">3.4.5。使用<code>SingleConnectionDataSource</code></a></li>
<li><a href="#jdbc-DriverManagerDataSource">3.4.6。使用<code>DriverManagerDataSource</code></a></li>
<li><a href="#jdbc-TransactionAwareDataSourceProxy">3.4.7。使用<code>TransactionAwareDataSourceProxy</code></a></li>
<li><a href="#jdbc-DataSourceTransactionManager">3.4.8。使用<code>DataSourceTransactionManager</code></a></li>
</ul>
</li>
<li><a href="#jdbc-advanced-jdbc">3.5。JDBC批处理操作</a>
<ul class="sectlevel3">
<li><a href="#jdbc-batch-classic">3.5.1。使用<code>JdbcTemplate</code>基本批处理操作</a></li>
<li><a href="#jdbc-batch-list">3.5.2。使用对象列表进行批处理操作</a></li>
<li><a href="#xsd-schemas-jdbc">3.5.3。<code>jdbc</code>架构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>这部分参考文档涉及数据访问以及数据访问层与业务或服务层之间的交互。</p>
</div>
<div class="paragraph">
<p>Spring详细介绍了Spring的全面事务管理支持，然后详细介绍了Spring Framework集成的各种数据访问框架和技术。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transaction"><a class="anchor" href="#transaction"></a> 1。交易管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>全面的事务支持是使用Spring Framework的最有说服力的理由之一。Spring Framework为事务管理提供了一致的抽象，具有以下优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跨不同事务API的一致编程模型，例如Java Transaction API（JTA），JDBC，Hibernate和Java Persistence API（JPA）。</p>
</li>
<li>
<p>支持<a href="#transaction-declarative">声明式事务管理</a> 。</p>
</li>
<li>
<p>比复杂事务API（如JTA）更简单的<a href="#transaction-programmatic">编程</a>事务管理API。</p>
</li>
<li>
<p>与Spring的数据访问抽象完美集成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下部分描述了Spring Framework的事务特性和技术：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#transaction-motivation">Spring Framework的事务支持模型的优点</a>描述了为什么要使用Spring Framework的事务抽象而不是EJB容器管理事务（CMT）或选择通过专有API（如Hibernate）来驱动本地事务。</p>
</li>
<li>
<p><a href="#transaction-strategies">理解Spring Framework事务抽象</a>概述了核心类，并描述了如何从各种源配置和获取<code>DataSource</code>实例。</p>
</li>
<li>
<p><a href="#tx-resource-synchronization">将资源与事务同步</a>描述了应用程序代码如何确保正确创建，重用和清理资源。</p>
</li>
<li>
<p><a href="#transaction-declarative">声明式事务管理</a>描述了对声明式事务管理的支持。</p>
</li>
<li>
<p><a href="#transaction-programmatic">程序化事务管理</a>包括对程序化（即明确编码）事务管理的支持。</p>
</li>
<li>
<p><a href="#transaction-event">事务绑定事件</a>描述了如何在事务中使用应用程序事件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>（本章还包括对最佳实践， <a href="#transaction-application-server-integration">应用程序服务器集成</a>以及<a href="#transaction-solutions-to-common-problems">常见问题解决方案的</a>讨论。）</p>
</div>
<div class="sect2">
<h3 id="transaction-motivation"><a class="anchor" href="#transaction-motivation"></a> 1.1。Spring Framework的事务支持模型的优点</h3>
<div class="paragraph">
<p>传统上，Java EE开发人员有两种交易管理选择：全局或本地交易，这两种交易都有很大的局限性。在接下来的两节中将对全局和本地事务管理进行审核，然后讨论Spring Framework的事务管理支持如何解决全局和本地事务模型的局限性。</p>
</div>
<div class="sect3">
<h4 id="transaction-global"><a class="anchor" href="#transaction-global"></a> 1.1.1。全球交易</h4>
<div class="paragraph">
<p>全局事务使您可以使用多个事务资源，通常是关系数据库和消息队列。应用程序服务器通过JTA管理全局事务，这是一个繁琐的API（部分原因是它的异常模型）。此外，JTA <code>UserTransaction</code>通常需要从JNDI获取，这意味着您还需要使用JNDI才能使用JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为JTA通常仅在应用程序服务器环境中可用。</p>
</div>
<div class="paragraph">
<p>以前，使用全局事务的首选方法是通过EJB CMT（容器管理事务）。CMT是一种声明式事务管理（与程序化事务管理不同）。EJB CMT消除了与事务相关的JNDI查找的需要，尽管使用EJB本身需要使用JNDI。它消除了编写Java代码以控制事务的大部分但不是全部的需要。重要的缺点是CMT与JTA和应用服务器环境相关联。此外，仅当选择在EJB中（或至少在事务EJB外观之后）实现业务逻辑时，它才可用。一般来说，EJB的负面影响是如此之大，以至于这不是一个有吸引力的主张，特别是在面对声明式事务管理的令人信服的替代方案时。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-local"><a class="anchor" href="#transaction-local"></a> 1.1.2。本地交易</h4>
<div class="paragraph">
<p>本地事务是特定于资源的，例如与JDBC连接关联的事务。本地事务可能更容易使用，但具有明显的缺点：它们无法跨多个事务资源工作。例如，使用JDBC连接管理事务的代码无法在全局JTA事务中运行。由于应用程序服务器不参与事务管理，因此无法确保跨多个资源的正确性。（值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型是侵入性的。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-programming-model"><a class="anchor" href="#transaction-programming-model"></a> 1.1.3。Spring Framework的一致性编程模型</h4>
<div class="paragraph">
<p>Spring解决了全局和本地事务的缺点。它允许应用程序开发人员在任何环境中使用一致的编程模型您编写一次代码，它可以从不同环境中的不同事务管理策略中受益。Spring Framework提供了声明式和编程式事务管理。大多数用户更喜欢声明式事务管理，我们建议在大多数情况下使用。</p>
</div>
<div class="paragraph">
<p>通过编程事务管理，开发人员可以使用Spring Framework事务抽象，它可以在任何底层事务基础结构上运行。使用首选的声明性模型，开发人员通常很少编写或不编写与事务管理相关的代码，因此不依赖于Spring Framework事务API或任何其他事务API。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">您是否需要应用程序服务器进行事务管理？</div>
<div class="paragraph">
<p>Spring Framework的事务管理支持改变了关于企业Java应用程序何时需要应用程序服务器的传统规则。</p>
</div>
<div class="paragraph">
<p>特别是，您不需要纯粹用于通过EJB进行声明式事务的应用程序服务器。实际上，即使您的应用程序服务器具有强大的JTA功能，您也可以决定Spring Framework的声明性事务提供比EJB CMT更强大的功能和更高效的编程模型。</p>
</div>
<div class="paragraph">
<p>通常，只有当应用程序需要处理跨多个资源的事务时，才需要应用程序服务器的JTA功能，这对许多应用程序来说并不是必需的。许多高端应用程序使用单个高度可伸缩的数据库（例如Oracle RAC）。独立的事务管理器（例如<a href="http://www.atomikos.com/">Atomikos Transactions</a>和<a href="http://jotm.objectweb.org/">JOTM</a> ）是其他选项。当然，您可能需要其他应用程序服务器功能，例如Java消息服务（JMS）和Java EE连接器体系结构（JCA）。</p>
</div>
<div class="paragraph">
<p>Spring Framework使您可以选择何时将应用程序扩展到完全加载的应用程序服务器。使用EJB CMT或JTA的唯一替代方法是使用本地事务（例如JDBC连接上的代码）编写代码，并且如果您需要在全局容器管理的事务中运行代码，则会面临大量的返工。使用Spring Framework，只需要更改配置文件中的一些bean定义（而不是代码）。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-strategies"><a class="anchor" href="#transaction-strategies"></a> 1.2。理解Spring Framework事务抽象</h3>
<div class="paragraph">
<p>Spring事务抽象的关键是事务策略的概念。事务策略由<code>org.springframework.transaction.定义<code>org.springframework.transaction.PlatformTransactionManager</code>接口，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">PlatformTransactionManager</span> {TransactionStatus getTransaction（TransactionDefinition definition） <span class="directive">抛出</span> TransactionException; <span class="type">void</span> commit（TransactionStatus status） <span class="directive">抛出</span> TransactionException; <span class="type">void</span> rollback（TransactionStatus status） <span class="directive">抛出</span> TransactionException; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这主要是服务提供者接口（SPI），尽管您可以从应用程序代码中以<a href="#transaction-programmatic-ptm">编程</a>方式使用它。因为<code>PlatformTransactionManager</code>是一个接口，所以可以根据需要轻松地模拟或存根。它与查找策略无关，例如JNDI。 <code>PlatformTransactionManager</code>实现的定义与Spring Framework IoC容器中的任何其他对象（或bean）相同。仅使用此优势使Spring Framework事务成为一种有价值的抽象，即使您使用JTA也是如此。与直接使用JTA相比，您可以更轻松地测试事务代码。</p>
</div>
<div class="paragraph">
<p>同样，为了与Spring的理念保持一致，可以取消选中任何<code>PlatformTransactionManager</code>接口的方法抛出的<code>TransactionException</code> （即，它扩展了<code>java.lang.RuntimeException</code>类）。交易基础设施故障几乎总是致命的。在极少数情况下，应用程序代码实际上可以从事务失败中恢复，应用程序开发人员仍然可以选择捕获并处理<code>TransactionException</code> 。重点是开发人员不会<em>被迫</em>这样做。</p>
</div>
<div class="paragraph">
<p><code>getTransaction(..)</code>方法返回<code>TransactionStatus</code>对象，具体取决于<code>TransactionDefinition</code>参数。如果当前调用堆栈中存在匹配的事务，则返回的<code>TransactionStatus</code>可能表示新事务或可表示现有事务。后一种情况的含义是，与Java EE事务上下文一样， <code>TransactionStatus</code>与执行线程相关联。</p>
</div>
<div class="paragraph">
<p><code>TransactionDefinition</code>接口指定：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>传播：通常，在事务范围内执行的所有代码都在该事务中运行。但是，如果在事务上下文已存在时执行事务方法，则可以指定行为。例如，代码可以继续在现有事务中运行（常见情况），或者可以暂停现有事务并创建新事务。Spring提供了EJB CMT熟悉的所有事务传播选项。要阅读有关Spring中事务传播的语义，请参阅<a href="#tx-propagation">事务传播</a> 。</p>
</li>
<li>
<p>隔离：此事务与其他事务的工作隔离的程度。例如，此事务是否可以看到来自其他事务的未提交的写入？</p>
</li>
<li>
<p>超时：此事务在超时并由基础事务基础结构自动回滚之前运行多长时间。</p>
</li>
<li>
<p>只读状态：您可以在代码读取时使用只读事务，但不能修改数据。在某些情况下，只读事务可能是一种有用的优化，例如当您使用Hibernate时。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些设置反映了标准的事务概念。如有必要，请参阅讨论事务隔离级别和其他核心事务概念的资源。理解这些概念对于使用Spring Framework或任何事务管理解决方案至关重要。</p>
</div>
<div class="paragraph">
<p><code>TransactionStatus</code>接口为事务代码提供了一种控制事务执行和查询事务状态的简单方法。这些概念应该是熟悉的，因为它们对于所有事务API都是通用的。以下清单显示了<code>TransactionStatus</code>接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">TransactionStatus</span> <span class="directive">扩展</span> SavepointManager { <span class="type">boolean</span> isNewTransaction（）; <span class="type">boolean</span> hasSavepoint（）; <span class="type">void</span> setRollbackOnly（）; <span class="type">boolean</span> isRollbackOnly（）; <span class="type">void</span> flush（）; <span class="type">boolean</span> isCompleted（）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>无论您是在Spring中选择声明式还是程序化事务管理，定义正确的<code>PlatformTransactionManager</code>实现都是绝对必要的。您通常通过依赖注入来定义此实现。</p>
</div>
<div class="paragraph">
<p><code>PlatformTransactionManager</code>实现通常需要了解它们工作的环境：JDBC，JTA，Hibernate等。以下示例显示了如何定义本地<code>PlatformTransactionManager</code>实现（在本例中，使用普通JDBC）。</p>
</div>
<div class="paragraph">
<p>您可以通过创建类似于以下内容的bean来定义JDBC <code>DataSource</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">username</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，相关的<code>PlatformTransactionManager</code> bean定义具有对<code>DataSource</code>定义的引用。它应该类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jdbc.datasource。DataSourceTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果在Java EE容器中使用JTA，则使用通过JNDI获得的容器<code>DataSource</code>以及Spring的<code>JtaTransactionManager</code> 。以下示例显示了JTA和JNDI查找版本的外观：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：jee</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/jee</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/jee</span> <span class="content">http://www.springframework.org/schema/jee/spring-jee.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc / jpetstore</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.transaction.jta。JtaTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 其他&lt;bean /&gt;定义 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>JtaTransactionManager</code>不需要了解<code>DataSource</code> （或任何其他特定资源），因为它使用容器的全局事务管理基础结构。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>dataSource</code> bean的前面定义使用<code>jee</code>名称空间中的<code>&lt;jndi-lookup/&gt;</code>标记。有关更多信息，请参阅<a href="integration.html#xsd-schemas-jee">JEE架构</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您还可以轻松使用Hibernate本地事务，如以下示例所示。在这种情况下，您需要定义一个Hibernate <code>LocalSessionFactoryBean</code> ，您的应用程序代码可以使用它来获取Hibernate <code>Session</code>实例。</p>
</div>
<div class="paragraph">
<p><code>DataSource</code> bean定义类似于前面显示的本地JDBC示例，因此未在以下示例中显示。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果<code>DataSource</code> （由任何非JTA事务管理器使用）通过JNDI查找并由Java EE容器管理，则它应该是非事务性的，因为Spring Framework（而不是Java EE容器）管理事务。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在这种情况下， <code>txManager</code> bean是<code>HibernateTransactionManager</code>类型。在作为相同的方式<code>DataSourceTransactionManager</code>需要将基准<code>DataSource</code> ，所述<code>HibernateTransactionManager</code>需要的一个参考<code>SessionFactory</code> 。以下示例声明了<code>sessionFactory</code>和<code>txManager</code> bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sessionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.hibernate5。LocalSessionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappingResources</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> org / springframework / samples / petclinic / hibernate / petclinic.hbm.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">hibernateProperties</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> hibernate.dialect = $ {hibernate.dialect} <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.hibernate5。HibernateTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用Hibernate和Java EE容器管理的JTA事务，则应使用与之前的JDBC JTA示例相同的<code>JtaTransactionManager</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.transaction.jta。JtaTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用JTA，那么无论您使用何种数据访问技术，无论是JDBC，Hibernate JPA还是任何其他支持的技术，您的事务管理器定义都应该看起来相同。这是因为JTA事务是全局事务，可以登记任何事务资源。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在所有这些情况下，应用程序代码不需要更改。您可以仅通过更改配置来更改事务的管理方式，即使该更改意味着从本地事务转移到全局事务，反之亦然。</p>
</div>
</div>
<div class="sect2">
<h3 id="tx-resource-synchronization"><a class="anchor" href="#tx-resource-synchronization"></a> 1.3。资源与事务同步</h3>
<div class="paragraph">
<p>现在应该清楚如何创建不同的事务管理器以及它们如何链接到需要与事务同步的相关资源（例如，将<code>DataSourceTransactionManager</code>到JDBC <code>DataSource</code> ， <code>HibernateTransactionManager</code>到Hibernate <code>SessionFactory</code>等等）。本节描述应用程序代码（直接或间接使用诸如JDBC，Hibernate或JPA之类的持久性API）如何确保正确创建，重用和清理这些资源。本节还讨论了如何（可选）通过相关的<code>PlatformTransactionManager</code>触发事务同步。</p>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-high"><a class="anchor" href="#tx-resource-synchronization-high"></a> 1.3.1。高级同步方法</h4>
<div class="paragraph">
<p>首选方法是使用Spring最高级别的基于模板的持久性集成API，或者将本机ORM API与事务感知工厂bean或代理一起使用，以管理本机资源工厂。这些事务感知解决方案在内部处理资源创建和重用，清理，资源的可选事务同步以及异常映射。因此，用户数据访问代码不必解决这些任务，而是可以完全专注于非样板持久性逻辑。通常，您使用本机ORM API或使用模板方法通过使用<code>JdbcTemplate</code>进行JDBC访问。这些解决方案将在本参考文档的后续章节中详细介绍。</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-low"><a class="anchor" href="#tx-resource-synchronization-low"></a> 1.3.2。低级同步方法</h4>
<div class="paragraph">
<p>诸如<code>DataSourceUtils</code> （用于JDBC）， <code>EntityManagerFactoryUtils</code> （用于JPA）， <code>SessionFactoryUtils</code> （用于Hibernate）等的类存在于较低级别。当您希望应用程序代码直接处理本机持久性API的资源类型时，您可以使用这些类来确保获得正确的Spring Framework托管实例，（可选）同步事务，并且在此过程中发生的异常是正确映射到一致的API。</p>
</div>
<div class="paragraph">
<p>例如，在JDBC的情况下，您可以使用Spring的<code>org.springframework.jdbc.datasource.而不是传统的JDBC方法来调用<code>DataSource</code>上的<code>getConnection()</code>方法<code>org.springframework.jdbc.datasource.DataSourceUtils</code>类，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Connection</span> conn = DataSourceUtils.getConnection（dataSource）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果现有事务已经与其同步（链接）了连接，则返回该实例。否则，方法调用会触发新连接的创建，该连接（可选）与任何现有事务同步，并可在随后的同一事务中重用。如前所述，任何<code>SQLException</code>都包含在Spring Framework <code>CannotGetJdbcConnectionException</code> ，Spring Framework是未经检查的<code>DataAccessException</code>类型的层次结构之一。这种方法为您提供了比从<code>SQLException</code>轻松获得的更多信息，并确保跨数据库甚至跨不同持久性技术的可移植性。</p>
</div>
<div class="paragraph">
<p>这种方法在没有Spring事务管理（事务同步是可选的）的情况下也可以工作，因此无论您是否使用Spring进行事务管理，都可以使用它。</p>
</div>
<div class="paragraph">
<p>当然，一旦您使用了Spring的JDBC支持，JPA支持或Hibernate支持，您通常不希望使用<code>DataSourceUtils</code>或其他帮助程序类，因为您通过Spring抽象工作比直接使用相关API更快乐。例如，如果您使用Spring <code>JdbcTemplate</code>或<code>jdbc.object</code>包来简化JDBC的使用，则在后台进行正确的连接检索，您无需编写任何特殊代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-tadsp"><a class="anchor" href="#tx-resource-synchronization-tadsp"></a> 1.3.3。<code>类TransactionAwareDataSourceProxy</code></h4>
<div class="paragraph">
<p>在最低级别存在<code>TransactionAwareDataSourceProxy</code>类。这是目标<code>DataSource</code>的代理，它包装目标<code>DataSource</code>以添加对Spring管理的事务的感知。在这方面，它类似于Java EE服务器提供的事务性JNDI <code>DataSource</code> 。</p>
</div>
<div class="paragraph">
<p>您几乎从不需要或不想使用此类，除非必须调用现有代码并传递标准JDBC <code>DataSource</code>接口实现。在这种情况下，此代码可能可用但参与Spring管理的事务。您可以使用前面提到的更高级别的抽象来编写新代码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-declarative"><a class="anchor" href="#transaction-declarative"></a> 1.4。声明式事务管理</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">大多数Spring Framework用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此与非侵入式轻量级容器的理想最为一致。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用Spring面向方面编程（AOP），Spring Framework的声明式事务管理成为可能。但是，由于事务方面代码随Spring Framework发行版一起提供并且可能以样板方式使用，因此通常不必理解AOP概念以有效使用此代码。</p>
</div>
<div class="paragraph">
<p>Spring Framework的声明式事务管理类似于EJB CMT，因为您可以将事务行为（或缺少它）指定为单个方法级别。如有必要，您可以在事务上下文中进行<code>setRollbackOnly()</code>调用。两种类型的交易管理之间的区别是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与绑定到JTA的EJB CMT不同，Spring Framework的声明式事务管理适用于任何环境。它可以通过调整配置文件使用JDBC，JPA或Hibernate来处理JTA事务或本地事务。</p>
</li>
<li>
<p>您可以将Spring Framework声明式事务管理应用于任何类，而不仅仅是EJB等特殊类。</p>
</li>
<li>
<p>Spring Framework提供了声明性<a href="#transaction-declarative-rolling-back">回滚规则</a> ，这是一个没有EJB等价的功能。提供了对回滚规则的编程和声明性支持。</p>
</li>
<li>
<p>Spring Framework允许您使用AOP自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意建议以及事务性建议。使用EJB CMT，除了使用<code>setRollbackOnly()</code>之外，您无法影响容器的事务管理。</p>
</li>
<li>
<p>Spring框架不支持跨远程调用传播事务上下文，就像高端应用程序服务器那样。如果您需要此功能，我们建议您使用EJB。但是，在使用此类功能之前请仔细考虑，因为通常情况下，人们不希望事务跨越远程调用。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">TransactionProxyFactoryBean在哪里？</div>
<div class="paragraph">
<p>Spring 2.0及更高版本中的声明式事务配置与以前的Spring版本有很大不同。主要区别在于不再需要配置<code>TransactionProxyFactoryBean</code> bean。</p>
</div>
<div class="paragraph">
<p>Spring 2.0之前的配置样式仍然是100％有效的配置。将新的<code>&lt;tx:tags/&gt;</code>视为代表您定义<code>TransactionProxyFactoryBean</code> bean。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>回滚规则的概念很重要。它们允许您指定哪些异常（和throwables）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在Java代码中。因此，尽管您仍然可以在<code>TransactionStatus</code>对象上调用<code>setRollbackOnly()</code>来回滚当前事务，但大多数情况下您可以指定<code>MyApplicationException</code>必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础结构。例如，它们通常不需要导入Spring事务API或其他Spring API。</p>
</div>
<div class="paragraph">
<p>虽然EJB容器默认行为会自动回滚系统异常（通常是运行时异常）上的事务，但EJB CMT不会在应用程序异常（即<code>java.rmi.以外的已检查异常）上自动回滚事务<code>java.rmi.RemoteException</code> ）。虽然声明式事务管理的Spring默认行为遵循EJB约定（回滚仅在未经检查的异常上自动执行），但定制此行为通常很有用。</p>
</div>
<div class="sect3">
<h4 id="tx-decl-explained"><a class="anchor" href="#tx-decl-explained"></a> 1.4.1。理解Spring Framework的声明式事务实现</h4>
<div class="paragraph">
<p>仅仅通过<code>@Transactional</code>注释告诉您注释您的类是不够的，将<code>@EnableTransactionManagement</code>添加到您的配置中，并期望您了解它是如何工作的。为了更深入地理解，本节解释了在发生与事务相关的问题时Spring Framework的声明式事务基础结构的内部工作原理。</p>
</div>
<div class="paragraph">
<p>关于Spring Framework的声明式事务支持，最重要的概念是<a href="core.html#aop-understanding-aop-proxies">通过AOP代理</a>启用此支持，并且事务性建议由元数据（当前基于XML或基于注释）驱动。AOP与事务元数据的组合产生一个AOP代理，该代理使用<code>TransactionInterceptor</code>和适当的<code>PlatformTransactionManager</code>实现来驱动方法调用周围的事务。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring AOP包含在<a href="core.html#aop">AOP部分</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下图像显示了在事务代理上调用方法的概念视图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tx.png" alt="TX">
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-first-example"><a class="anchor" href="#transaction-declarative-first-example"></a> 1.4.2。声明性事务实现的示例</h4>
<div class="paragraph">
<p>请考虑以下接口及其附带实现。此示例使用<code>Foo</code>和<code>Bar</code>类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。出于此示例的目的， <code>DefaultFooService</code>类在每个实现的方法的主体中抛出<code>UnsupportedOperationException</code>实例的事实是好的。该行为允许您查看事务，然后回滚以响应<code>UnsupportedOperationException</code>实例。以下清单显示了<code>FooService</code>接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//我们想要使用事务</span> <span class="keyword">包</span> <span class="namespace">xyservice</span> <span class="comment">的服务接口</span> ; <span class="directive">public</span> <span class="type">interface</span> <span class="class">FooService</span> {Foo getFoo（ <span class="predefined-type">String</span> fooName）; Foo getFoo（ <span class="predefined-type">String</span> fooName， <span class="predefined-type">String</span> barName）; <span class="type">void</span> insertFoo（Foo foo）; <span class="type">void</span> updateFoo（Foo foo）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了上述接口的实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">xyservice</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultFooService</span> <span class="directive">实现</span> FooService { <span class="directive">public</span> Foo getFoo（ <span class="predefined-type">String</span> fooName）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span> （）; <span class="directive">public</span> Foo getFoo（ <span class="predefined-type">String</span> fooName， <span class="predefined-type">String</span> barName）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span> （）; <span class="directive">public</span> <span class="type">void</span> insertFoo（Foo foo）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span> （）; <span class="directive">public</span> <span class="type">void</span> updateFoo（Foo foo）{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span> （）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设<code>FooService</code>接口的前两个方法<code>getFoo(String)</code>和<code>getFoo(String, String)</code>必须在具有只读语义的事务的上下文中执行，并且其他方法， <code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code> ，必须在具有读写语义的事务的上下文中执行。以下配置将在接下来的几段中详细说明：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 来自文件'context.xml' - &gt;</span> <span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这是我们想要进行交易的服务对象 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fooService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyservice。DefaultFooService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 事务性建议（'发生了';请参阅下面的&lt;aop：advisor /&gt; bean） - &gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="attribute-name">transaction-manager</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 事务语义...  - &gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="comment">&lt;！ - 所有以'get'开头的方法都是只读的 - &gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">get *</span> <span class="delimiter">”</span></span> <span class="attribute-name">read-only</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 其他方法使用默认事务设置（见下文） - &gt;</span> <span class="tag">&lt;tx：方法</span> <span class="attribute-name">名称</span> = <span class="string"><span class="delimiter">”</span> <span class="content">*</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span> <span class="comment">&lt;！ - 确保上述事务建议针对由FooService接口定义的操作的任何执行运行 - &gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fooServiceOperation</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* xyservice。FooService接口。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fooServiceOperation</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="comment">&lt;！ - 不要忘记DataSource  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">oracle.jdbc.driver。OracleDriver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：oracle：thin：@ rj-t42：1521：elvis</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">scott</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">密码</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tiger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 同样，不要忘记PlatformTransactionManager  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jdbc.datasource。DataSourceTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 其他&lt;bean /&gt;定义 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>检查前面的配置。它假定您要创建一个服务对象， <code>fooService</code> bean，transactional。要应用的事务语义封装在<code>&lt;tx:advice/&gt;</code>定义中。<code>&lt;tx:advice/&gt;</code>定义读作“所有方法，从<code>get</code>开始，将在只读事务的上下文中执行，所有其他方法将使用默认事务语义执行”。<code>&lt;tx:advice/&gt;</code>标记的<code>transaction-manager</code>属性设置为将驱动事务的<code>PlatformTransactionManager</code> bean的名称（在本例中为<code>txManager</code> bean）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要连接的<code>PlatformTransactionManager</code>的bean名称具有名称<code>transactionManager</code> ，则可以省略事务建议（ <code>&lt;tx:advice/&gt;</code> ）中的<code>transaction-manager</code>属性。如果要连接的<code>PlatformTransactionManager</code> bean具有任何其他名称，则必须显式使用<code>transaction-manager</code>属性，如上例所示。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>&lt;aop:config/&gt;</code>定义确保<code>txAdvice</code> bean定义的事务性建议在程序中的适当位置执行。首先，定义一个切入点，该切入点与<code>FooService</code>接口（ <code>fooServiceOperation</code> ）中定义的任何操作的执行相匹配。然后使用顾问程序将切入点与<code>txAdvice</code>相关联。结果表明，在执行<code>fooServiceOperation</code> ，将运行<code>txAdvice</code>定义的建议。</p>
</div>
<div class="paragraph">
<p><code>&lt;aop:pointcut/&gt;</code>元素中定义的表达式是AspectJ切入点表达式。有关Spring中切入点表达式的更多详细信息，请参阅<a href="core.html#aop">AOP部分</a> 。</p>
</div>
<div class="paragraph">
<p>常见的要求是使整个服务层具有事务性。执行此操作的最佳方法是更改​​切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fooServiceMethods</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">execution（* xyservice。*。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fooServiceMethods</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在前面的示例中，假设您的所有服务接口都在<code>xyservice</code>包中定义。有关详细信息，请参阅<a href="core.html#aop">AOP部分</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们已经分析了配置，您可能会问自己，“所有这些配置实际上做了什么？”</p>
</div>
<div class="paragraph">
<p>前面显示的配置用于创建围绕从<code>fooService</code> bean定义创建的对象的事务代理。代理配置有事务性建议，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动，挂起，标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> { <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="directive">final</span> <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">Exception</span> {ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">context.xml</span> <span class="delimiter">”</span></span> ，Boot.class）; FooService fooService =（FooService）ctx.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">fooService</span> <span class="delimiter">”</span></span> ）; fooService.insertFoo（ <span class="keyword">new</span> Foo（））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行前面程序的输出应该类似于以下内容（为清楚起见，LogFJ输出和DefaultFooService类的insertFoo（..）方法抛出的UnsupportedOperationException中的堆栈跟踪已被截断）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  Spring容器正在启动...  - &gt;</span> [AspectJInvocationContextExposingAdvisorAutoProxyCreator]  - 使用0个常见拦截器和1个特定拦截器创建bean'fooService'的隐式代理<span class="comment">&lt;！ -  DefaultFooService实际上是代理的 - &gt;</span> [JdkDynamicAopProxy ]  - 为[xyservice创建JDK动态代理。DefaultFooService] <span class="comment">&lt;！ -  ...现在正在代理上调用insertFoo（..）方法 - &gt;</span> [TransactionInterceptor]  - 获取xyservice的事务。FooService.insertFoo <span class="comment">&lt;！ - 事务性建议在这里开始...  - &gt;</span> [DataSourceTransactionManager]  - 用名称[xyservice创建新事务。FooService.insertFoo] [DataSourceTransactionManager]  - 获取连接[org.apache.commons.dbcp。PoolableConnection @ a53de4]用于JDBC事务<span class="comment">&lt;！ - 来自DefaultFooService的insertFoo（..）方法抛出异常...  - &gt;</span> [RuleBasedTransactionAttribute]  - 应用规则来确定事务是否应该在java.lang上回滚。UnsupportedOperationException [TransactionInterceptor]  - 在xyservice上调用事务的回滚。FooService.insertFoo由于throwable [java.lang。UnsupportedOperationException] <span class="comment">&lt;！ - 并且事务被回滚（默认情况下，RuntimeException实例导致回滚） - &gt;</span> [DataSourceTransactionManager]  - 在Connection上回滚JDBC事务[org.apache.commons.dbcp。PoolableConnection @ a53de4] [DataSourceTransactionManager]  - 在事务[DataSourceUtils]之后释放JDBC连接 - 在线程“main”java.lang中返回JDBC连接到DataSource异常。xyservice上的UnsupportedOperationException。DefaultFooService.insertFoo（DefaultFooService.java:14） <span class="comment">&lt;！ - 为了清楚起见，删除了AOP基础架构堆栈跟踪元素 - &gt;</span>在Boot.main上的$ Proxy0.insertFoo（未知源）（Boot.java:11）</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-rolling-back"><a class="anchor" href="#transaction-declarative-rolling-back"></a> 1.4.3。回滚声明性交易</h4>
<div class="paragraph">
<p>上一节概述了如何在应用程序中以声明方式指定类（通常是服务层类）的事务设置的基础知识。本节介绍如何以简单的声明方式控制事务回滚。</p>
</div>
<div class="paragraph">
<p>向Spring Framework的事务基础结构指示事务的工作将被回滚的推荐方法是从当前在事务上下文中执行的代码中抛出<code>Exception</code> 。Spring Framework的事务基础结构代码捕获任何未处理的<code>Exception</code>因为它冒泡调用堆栈并确定是否将事务标记为回滚。</p>
</div>
<div class="paragraph">
<p>在其默认配置中，Spring Framework的事务基础结构代码仅在运行时未经检查的异常情况下标记回滚事务。也就是说，抛出的异常是<code>RuntimeException</code>的实例或子类。（默认情况下， <code>Error</code>实例也会导致回滚）。从事务方法抛出的已检查异常不会导致在默认配置中回滚。</p>
</div>
<div class="paragraph">
<p>您可以准确配置哪些<code>Exception</code>类型标记用于回滚的事务，包括已检查的异常。以下XML代码段演示了如何为已检查的特定于应用程序的<code>Exception</code>类型配置回滚：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txAdvice</span> <span class="delimiter">”</span></span> <span class="attribute-name">transaction-manager</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">get *</span> <span class="delimiter">”</span></span> <span class="attribute-name">read-only</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="attribute-name">rollback-for</span> = <span class="string"><span class="delimiter">“</span> <span class="content">NoProductInStockException</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;tx ：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不希望在抛出异常时回滚事务，则还可以指定“无回滚规则”。以下示例告诉Spring Framework的事务基础结构即使面对未处理的<code>InstrumentNotFoundException</code>也要提交话务员事务：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txAdvice</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">updateStock</span> <span class="delimiter">”</span></span> <span class="attribute-name">no-rollback-for</span> = <span class="string"><span class="delimiter">“</span> <span class="content">InstrumentNotFoundException</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx： attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当Spring Framework的事务基础结构捕获异常并且它参考配置的回滚规则以确定是否将事务标记为回滚时，最强匹配规则获胜。因此，在以下配置的情况下，除了<code>InstrumentNotFoundException</code>之外的任何异常都会导致后续事务的回滚：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txAdvice</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="attribute-name">rollback-for</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Throwable</span> <span class="delimiter">”</span></span> <span class="attribute-name">no-rollback-for</span> = <span class="string"><span class="delimiter">“</span> <span class="content">InstrumentNotFoundException</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ TX：建议&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且会将您的代码紧密地耦合到Spring Framework的事务基础结构中。以下示例显示如何以编程方式指示所需的回滚：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> resolvePosition（）{ <span class="keyword">try</span> { <span class="comment">//一些业务逻辑......</span>} <span class="keyword">catch</span> （NoProductInStockException ex）{ <span class="comment">//以编程方式触发回滚</span> TransactionAspectSupport.currentTransactionStatus（）。setRollbackOnly（）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要程序化回滚，则可以使用程序化回滚，但它的使用方式可以实现基于POJO的简洁体系结构。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-diff-tx"><a class="anchor" href="#transaction-declarative-diff-tx"></a> 1.4.4。为不同的Bean配置不同的事务语义</h4>
<div class="paragraph">
<p>考虑具有多个服务层对象的情况，并且您希望对每个对象应用完全不同的事务配置。您可以通过使用不同的<code>pointcut</code>和<code>advice-ref</code>属性值定义不同的<code>&lt;aop:advisor/&gt;</code>元素来实现。</p>
</div>
<div class="paragraph">
<p>作为比较，首先假设您的所有服务层类都在根<code>xyservice</code>包中定义。要使所有作为在该包（或子包中）中定义的类的实例的bean以及以<code>Service</code>结尾的名称具有默认的事务配置，您可以编写以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">”</span> <span class="content">execution （* xyservice ..*服务。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="comment">&lt;！ - 这两个bean将是事务性的......  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fooService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyservice。DefaultFooService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">barService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyservice.extras。SimpleBarService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  ...并且这两个bean不会 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">anotherService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.xyz。SomeService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - （不在正确的包中） - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">barManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyservice。SimpleBarManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - （不以'Service'结尾） - &gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">get *</span> <span class="delimiter">“</span></span> <span class="attribute-name">read-only</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;tx：方法</span> <span class="attribute-name">名称</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span> <span class="comment">&lt;！ - 其他事务基础结构bean，例如省略了PlatformTransactionManager ...  - &gt;</span> <span class="tag">&lt;/ beans &gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何使用完全不同的事务设置配置两个不同的bean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultServiceOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">”</span> <span class="content">execution （* xyservice。*服务。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">noTxServiceOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">”</span> <span class="content">execution（* xyservice.ddl。DefaultDdlManager。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultServiceOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultTxAdvice</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">noTxServiceOperation</span> <span class="delimiter">“</span></span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">noTxAdvice</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt; / aop：config&gt;</span> <span class="comment">&lt;！ - 这个bean将是事务性的（参见'defaultServiceOperation'切入点） - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fooService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyservice。DefaultFooService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 这个bean也是事务性的，但具有完全不同的事务设置 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">anotherFooService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyservice.ddl。DefaultDdlManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">defaultTxAdvice</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">get *</span> <span class="delimiter">“</span></span> <span class="attribute-name">read-only</span> = <span class="string"><span class="delimiter">”</span> <span class="content">true</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">*</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt; / tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">noTxAdvice</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="attribute-name">propagation</span> = <span class="string"><span class="delimiter">“</span> <span class="content">NEVER</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx：advice&gt;</span> <span class="comment">&lt;！ - 其他事务基础结构bean，例如省略了PlatformTransactionManager ...  - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-txadvice-settings"><a class="anchor" href="#transaction-declarative-txadvice-settings"></a> 1.4.5。 &lt;tx：advice /&gt;设置</h4>
<div class="paragraph">
<p>本节总结了您可以使用<code>&lt;tx:advice/&gt;</code>标记指定的各种事务设置。默认的<code>&lt;tx:advice/&gt;</code>设置为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#tx-propagation">传播设置</a>是<code>REQUIRED.</code></p>
</li>
<li>
<p>隔离级别为<code>DEFAULT.</code></p>
</li>
<li>
<p>该事务是读写的。</p>
</li>
<li>
<p>事务超时默认为基础事务系统的默认超时，如果不支持超时，则默认为none。</p>
</li>
<li>
<p>任何<code>RuntimeException</code>触发回滚，而任何已检查的<code>Exception</code>都不会。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以更改这些默认设置。下表总结了嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标记内的<code>&lt;tx:method/&gt;</code>标记的各种属性：</p>
</div>
<table id="tx-method-settings" class="tableblock frame-all grid-all spread">
<caption class="title">表1. &lt;tx：method /&gt;设置</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">需要？</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>名称</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与事务属性关联的方法名称。通配符（*）字符可用于将相同的事务属性设置与多个方法相关联（例如， <code>get*</code> ， <code>handle*</code> ， <code>on*Event</code>等）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>传播</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>需要</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务传播行为。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>隔离</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>默认</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务隔离级别。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>传播设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>时间到</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务超时（秒）。仅适用于传播<code>REQUIRED</code>或<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>只读</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读写与只读事务。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>回滚换</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以逗号分隔的触发回滚的<code>Exception</code>实例列表。例如， <code>com.foo.MyBusinessException，ServletException异常。</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>无回退换</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以逗号分隔的<code>Exception</code>实例列表，不会触发回滚。例如， <code>com.foo.MyBusinessException，ServletException异常。</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="transaction-declarative-annotations"><a class="anchor" href="#transaction-declarative-annotations"></a> 1.4.6。使用<code>@Transactional</code></h4>
<div class="paragraph">
<p>除了基于XML的事务配置声明方法之外，您还可以使用基于注释的方法。直接在Java源代码中声明事务语义使声明更接近受影响的代码。没有太多的过度耦合的危险，因为无论如何，用于事务处理的代码几乎总是以这种方式部署。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">标准的<code>javax.transaction.还支持Transactional</code>注释作为Spring自己的注释的替代品。有关更多详细信息，请参阅JTA 1.2文档。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用<code>@Transactional</code>注释提供的易用性最好通过一个示例来说明，该示例将在后面的文本中进行说明。考虑以下类定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//我们想要进行事务的服务类</span> <strong><span class="annotation">@Transactional</span></strong> <span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultFooService</span> <span class="directive">实现</span> FooService {Foo getFoo（ <span class="predefined-type">String</span> fooName）; Foo getFoo（ <span class="predefined-type">String</span> fooName， <span class="predefined-type">String</span> barName）; <span class="type">void</span> insertFoo（Foo foo）; <span class="type">void</span> updateFoo（Foo foo）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当前面的POJO被定义为Spring IoC容器中的bean时，您可以通过仅添加一行XML配置来使bean实例进行事务处理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 来自文件'context.xml' - &gt;</span> <span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 这是我们想要进行交易的服务对象 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">fooService</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xyservice。DefaultFooService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 根据注释启用事务行为的配置 - &gt;</span> <span class="tag">&lt;tx：annotation-driven</span> <span class="attribute-name">transaction-manager</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 仍然需要PlatformTransactionManager  - &gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jdbc.datasource。DataSourceTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - （此依赖关系在其他地方定义） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="comment">&lt;！ - 其他&lt;bean /&gt;定义 - &gt;</span> <span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使bean实例成为事务的行。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要连接的<code>PlatformTransactionManager</code>的bean名称具有名称<code>transactionManager</code> ，则可以省略<code>&lt;tx:annotation-driven/&gt;</code>标记中的<code>transaction-manager</code>属性。如果要依赖注入的<code>PlatformTransactionManager</code> bean具有任何其他名称，则必须使用<code>transaction-manager</code>属性，如上例所示。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果使用基于Java的配置，则<code>@EnableTransactionManagement</code>批注提供等效支持。您可以将注释添加到<code>@Configuration</code>类。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html">Javadoc</a> 。
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">方法可见性和<code>@Transactional</code></div>
<div class="paragraph">
<p>使用代理时，只应将<code>@Transactional</code>注释应用于具有公共可见性的方法。如果使用<code>@Transactional</code>批注对protected，private或package-visible方法进行批注，则不会引发错误，但带注释的方法不会显示已配置的事务设置。如果需要注释非公共方法，请考虑使用AspectJ（稍后介绍）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以将<code>@Transactional</code>注释放在接口定义，接口上的方法，类定义或类的公共方法之前。但是，仅仅存在<code>@Transactional</code>注释不足以激活事务行为。<code>@Transactional</code>注释仅仅是某些运行时基础结构可以使用的元数据，这些运行时基础结构是<code>@Transactional</code> -aware，可以使用元数据来配置具有事务行为的适当bean。在前面的示例中， <code>&lt;tx:annotation-driven/&gt;</code>元素会切换事务行为。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring团队建议您使用<code>@Transactional</code>注释仅注释具体类（以及具体类的方法），而不是注释接口。您当然可以将<code>@Transactional</code>注释放在接口（或接口方法）上，但这只能在您使用基于接口的代理时按预期工作。Java注释不是从接口继承的事实意味着，如果使用基于类的代理（ <code>proxy-target-class="true"</code> ）或基于编织的方面（ <code>mode="aspectj"</code> ），则事务设置不是由代理和编织基础结构识别，并且对象不包含在事务代理中，这将是非常糟糕的。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在代理模式（默认设置）下，只拦截通过代理进入的外部方法调用。这意味着自调用（实际上，目标对象中的一个方法调用目标对象的另一个方法）在运行时不会导致实际的事务，即使调用的方法用<code>@Transactional</code>标记。此外，必须完全初始化代理以提供预期的行为，因此您不应该在初始化代码（即<code>@PostConstruct</code> ）中依赖此功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您希望自我调用也包含在事务中，请考虑使用AspectJ模式（请参阅下表中的<code>mode</code>属性）。在这种情况下，首先没有代理。相反，编织目标类（即，修改其字节代码）以将<code>@Transactional</code>转换为任何类型方法的运行时行为。</p>
</div>
<table id="tx-annotation-driven-settings" class="tableblock frame-all grid-all spread">
<caption class="title">表2。注释驱动的事务设置</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">XML属性</th>
<th class="tableblock halign-left valign-top">注释属性</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>交易经理</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N / A（参见<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html"><code>TransactionManagementConfigurer</code> Javadoc</a> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transactionManager的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的事务管理器的名称。仅当事务管理器的名称不是<code>transactionManager</code>时才需要，如前面的示例所示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>模式</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>模式</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>代理</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认模式（ <code>proxy</code> ）使用Spring的AOP框架处理要注释的注释bean（遵循代理语义，如前所述，仅适用于通过代理进入的方法调用）。替代模式（ <code>aspectj</code> ）用Spring的AspectJ事务方面​​编织受影响的类，修改目标类字节代码以应用于任何类型的方法调用。AspectJ编织需要类路径中的<code>spring-aspects.jar</code>以及启用加载时编织（或编译时编织）。（有关如何设置加载时编织的详细信息，请参阅<a href="core.html#aop-aj-ltw-spring">Spring配置</a> 。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>代理目标类</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxyTargetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>假</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅适用于<code>proxy</code>模式。控制为使用<code>@Transactional</code>注释注释的类创建的事务代理类型。如果<code>proxy-target-class</code>属性设置为<code>true</code> ，则创建基于类的代理。如果<code>proxy-target-class</code>为<code>false</code>或者省略了该属性，则会创建基于标准JDK接口的代理。（参见<a href="core.html#aop-proxying">代理机制</a> ，详细检查不同的代理类型。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>订购</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>订购</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>有序。LOWEST_PRECEDENCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义应用于使用<code>@Transactional</code>注释的bean的事务通知的顺序。（有关与AOP建议订购相关的规则的更多信息，请参阅<a href="core.html#aop-ataspectj-advice-ordering">建议订购</a> 。）没有指定的排序意味着AOP子系统确定建议的顺序。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">处理<code>@Transactional</code>注释的默认建议模式是<code>proxy</code> ，它允许仅通过代理拦截调用。同一类中的本地调用不能以这种方式截获。对于更高级的拦截模式，请考虑结合编译时或加载时编织切换到<code>aspectj</code>模式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>proxy-target-class</code>属性控制为使用<code>@Transactional</code>注释注释的类创建的事务代理类型。如果<code>proxy-target-class</code>设置为<code>true</code> ，则创建基于类的代理。如果<code>proxy-target-class</code>为<code>false</code>或者省略了该属性，则会创建基于标准JDK接口的代理。（有关不同代理类型的讨论，请参阅<a href="#aop-proxying">[aop-proxying]</a> 。）
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@EnableTransactionManagement</code>和<code>&lt;tx:annotation-driven/&gt;</code>仅在定义它们的同一应用程序上下文中的bean上查找<code>@Transactional</code> 。这意味着，如果您将注释驱动的配置放在<code>DispatcherServlet</code>的<code>WebApplicationContext</code>中，它只会在您的控制器而不是您的服务中检查<code>@Transactional</code> bean。有关更多信息，请参阅<a href="web.html#mvc-servlet">MVC</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在评估方法的事务设置时，派生最多的位置优先。在以下示例的情况下， <code>DefaultFooService</code>类在类级别使用只读事务的设置进行注释，但同一类中<code>updateFoo(Foo)</code>方法的<code>@Transactional</code>注释优先于定义的事务设置在班级。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Transactional</span> （readOnly = <span class="predefined-constant">true</span> ） <span class="directive">公共</span> <span class="type">类</span> <span class="class">DefaultFooService</span> <span class="directive">实现</span> FooService { <span class="directive">public</span> Foo getFoo（ <span class="predefined-type">String</span> fooName）{ <span class="comment">//做某事</span> } <span class="comment">//这些设置优先于此方法</span> <span class="annotation">@Transactional</span> （readOnly = <span class="predefined-constant">false</span> ，propagation = Propagation。REQUIRES_NEW） <span class="directive">public</span> <span class="type">void</span> updateFoo（Foo foo）{ <span class="comment">//做某事</span> }}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transaction-declarative-attransactional-settings"><a class="anchor" href="#transaction-declarative-attransactional-settings"></a> <code>@Transactional</code>设置</h5>
<div class="paragraph">
<p><code>@Transactional</code>注释是指定接口，类或方法必须具有事务语义的元数据（例如，“在调用此方法时启动全新的只读事务，暂停任何现有事务”）。默认的<code>@Transactional</code>设置如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>传播设置为<code>PROPAGATION_REQUIRED.</code></p>
</li>
<li>
<p>隔离级别为<code>ISOLATION_DEFAULT.</code></p>
</li>
<li>
<p>该事务是读写的。</p>
</li>
<li>
<p>事务超时默认为基础事务系统的默认超时，如果不支持超时，则默认为none。</p>
</li>
<li>
<p>任何<code>RuntimeException</code>触发回滚，而任何已检查的<code>Exception</code>都不会。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以更改这些默认设置。下表总结了<code>@Transactional</code>注释的各种属性：</p>
</div>
<table id="tx-attransactional-properties" class="tableblock frame-all grid-all spread">
<caption class="title">表3。@Transactional设置</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx-multiple-tx-mgrs-with-attransactional">值</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>串</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选限定符，指定要使用的事务管理器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx-propagation">传播</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code> ： <code>Propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的传播设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>隔离</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code> ： <code>Isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的隔离级别。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>传播值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>时间到</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code> （以粒度为单位）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的事务超时。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>传播值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>只读</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>布尔</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读写与只读事务。仅适用于valeus <code>REQUIRED</code>或<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的rollbackFor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Class</code>对象的数组，必须从<code>Throwable.</code>派生<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">必须引发回滚的可选异常类数组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类名数组。这些类必须从<code>Throwable.</code>派生<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">必须导致回滚的可选异常类名称数组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackFor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Class</code>对象的数组，必须从<code>Throwable.</code>派生<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的异常类数组，不得导致回滚。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code>类名称的数组，必须从<code>Throwable.</code>派生<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选不会导致回滚的异常类名称的可选数组。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>目前，您无法明确控制事务名称，其中“名称”表示事务监视器中显示的事务名称（如果适用）（例如，WebLogic的事务监视器）和日志记录输出。对于声明性事务，事务名称始终是完全限定的类名+ <code>.</code>+事务建议类的方法名称。例如，如果<code>BusinessService</code>类的<code>handlePayment(..)</code>方法启动了事务，则事务的名称将为： <code>com.example.BusinessService.handlePayment</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-multiple-tx-mgrs-with-attransactional"><a class="anchor" href="#tx-multiple-tx-mgrs-with-attransactional"></a>使用<code>@Transactional</code>多个交易管理器</h5>
<div class="paragraph">
<p>大多数Spring应用程序只需要一个事务管理器，但在某些情况下，您可能需要在单个应用程序中使用多个独立的事务管理器。您可以使用<code>@Transactional</code>批注的<code>value</code>属性来选择性地指定要使用的<code>PlatformTransactionManager</code>的标识。这可以是bean名称或事务管理器bean的限定符值。例如，使用限定符表示法，您可以将以下Java代码与应用程序上下文中的以下事务管理器bean声明组合在一起：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TransactionalService</span> { <span class="annotation">@Transactional</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">order</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> setSomething（ <span class="predefined-type">String</span> name）{...} <span class="annotation">@Transactional</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">account</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">void</span> doSomething（）{...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了bean声明：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;tx：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">transactionManager1</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jdbc.datasource。DataSourceTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...
        <span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">order</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">transactionManager2</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jdbc.datasource。DataSourceTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...
        <span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">account</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>TransactionalService</code>上的两个方法在单独的事务管理器下运行，由<code>order</code>和<code>account</code>限定符区分。如果未找到特定限定的<code>PlatformTransactionManager</code> bean，则仍将使用缺省<code>&lt;tx:annotation-driven&gt;</code>目标bean名称<code>transactionManager</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-custom-attributes"><a class="anchor" href="#tx-custom-attributes"></a>自定义快捷方式注释</h5>
<div class="paragraph">
<p>如果您发现在许多不同方法上重复使用与<code>@Transactional</code>相同的属性， <a href="core.html#beans-meta-annotations">Spring的元注释支持</a>允许您为特定用例定义自定义快捷方式注释。例如，请考虑以下注释定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。方法， <span class="predefined-type">ElementType</span> 。TYPE}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Transactional</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">order</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="annotation">@interface</span> OrderTx {} <span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。方法， <span class="predefined-type">ElementType</span> 。TYPE}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Transactional</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">account</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="annotation">@interface</span> AccountTx {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的注释允许我们编写上一节中的示例，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TransactionalService</span> { <span class="annotation">@OrderTx</span> <span class="directive">public</span> <span class="type">void</span> setSomething（ <span class="predefined-type">String</span> name）{...} <span class="annotation">@AccountTx</span> <span class="directive">public</span> <span class="type">void</span> doSomething（）{...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们使用语法来定义事务管理器限定符，但我们也可以包含传播行为，回滚规则，超时和其他功能。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tx-propagation"><a class="anchor" href="#tx-propagation"></a> 1.4.7。交易传播</h4>
<div class="paragraph">
<p>本节描述了Spring中事务传播的一些语义。请注意，本节不是适当的事务传播介绍。相反，它详细介绍了Spring中有关事务传播的一些语义。</p>
</div>
<div class="paragraph">
<p>在Spring管理的事务中，要注意物理和逻辑事务之间的区别，以及传播设置如何应用于这种差异。</p>
</div>
<div class="sect4">
<h5 id="tx-propagation-required"><a class="anchor" href="#tx-propagation-required"></a>了解<code>PROPAGATION_REQUIRED</code></h5>
<div class="imageblock">
<div class="content">
<img src="images/tx_prop_required.png" alt="需要tx道具">
</div>
</div>
<div class="paragraph">
<p><code>PROPAGATION_REQUIRED</code>在当前范围内强制执行物理事务（如果尚未存在事务）或参与为更大范围定义的现有“外部”事务。这是同一线程内公共调用堆栈安排的一个很好的默认值（例如，委托给几个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，参与事务加入外部作用域的特征，静默忽略本地隔离级别，超时值或只读标志（如果有）。如果希望在参与具有不同隔离级别的现有事务时拒绝隔离级别声明，请考虑在事务管理器上将<code>validateExistingTransactions</code>标志切换为<code>true</code> 。此非宽松模式还拒绝只读不匹配（即，尝试参与只读外部作用域的内部读写事务）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当传播设置为<code>PROPAGATION_REQUIRED</code> ，将为应用该设置的每个方法创建逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准<code>PROPAGATION_REQUIRED</code>行为的情况下，所有这些范围都映射到同一物理事务。因此，内部事务范围中的仅回滚标记集确实会影响外部事务实际提交的机会。</p>
</div>
<div class="paragraph">
<p>但是，在内部事务作用域设置仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务作用域静默触发）是意外的。此时抛出相应的<code>UnexpectedRollbackException</code> 。这是预期的行为，因此事务的调用者永远不会被误导以假设在实际上没有执行提交。因此，如果内部事务（外部调用者不知道）默认将事务标记为仅回滚，则外部调用者仍调用commit。外部调用者需要接收<code>UnexpectedRollbackException</code>以清楚地指示已执行回滚。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-propagation-requires_new"><a class="anchor" href="#tx-propagation-requires_new"></a>了解<code>PROPAGATION_REQUIRES_NEW</code></h5>
<div class="imageblock">
<div class="content">
<img src="images/tx_prop_requires_new.png" alt="tx prop需要新的">
</div>
</div>
<div class="paragraph">
<p><code>PROPAGATION_REQUIRES_NEW</code>相反， <code>PROPAGATION_REQUIRED</code>始终对每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。在这样的安排中，底层资源事务是不同的，因此可以独立地提交或回滚，外部事务不受内部事务的回滚状态的影响，并且内部事务的锁在完成后立即释放。这样一个独立的内部事务也可以声明它自己的隔离级别，超时和只读设置，而不是继承外部事务的特性。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-propagation-nested"><a class="anchor" href="#tx-propagation-nested"></a>了解<code>PROPAGATION_NESTED</code></h5>
<div class="paragraph">
<p><code>PROPAGATION_NESTED</code>使用具有多个保存点的单个物理事务，它可以回滚到该事务。这种部分回滚允许内部事务作用域触发其作用域的回滚，外部事务能够继续物理事务，尽管已经回滚了一些操作。此设置通常映射到JDBC保存点，因此它仅适用于JDBC资源事务。请参阅Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html"><code>DataSourceTransactionManager</code></a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-applying-more-than-just-tx-advice"><a class="anchor" href="#transaction-declarative-applying-more-than-just-tx-advice"></a> 1.4.8。为交易操作提供咨询</h4>
<div class="paragraph">
<p>假设您要执行事务操作和一些基本概要分析建议。你如何在<code>&lt;tx:annotation-driven/&gt;</code>的上下文中实现这一点？</p>
</div>
<div class="paragraph">
<p>当您调用<code>updateFoo(Foo)</code>方法时，您希望看到以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置的性能分析方面开始。</p>
</li>
<li>
<p>交易建议执行。</p>
</li>
<li>
<p>建议对象上的方法执行。</p>
</li>
<li>
<p>交易提交。</p>
</li>
<li>
<p>概要分析方面报告整个事务方法调用的确切持续时间。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本章不涉及详细解释AOP（除非它适用于交易）。有关<a href="core.html#aop">AOP</a>配置和AOP的详细信息，请参阅<a href="core.html#aop">AOP</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下代码显示了前面讨论的简单分析方面：。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包</span> <span class="namespace">xy</span> ; <span class="keyword">import</span> <span class="include">org.aspectj.lang。ProceedingJoinPoint</span> ; <span class="keyword">import</span> <span class="include">org.springframework.util。秒表</span> ; <span class="keyword">import</span> <span class="include">org.springframework.core。订购</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleProfiler</span> <span class="directive">实现</span> Ordered { <span class="directive">private</span> <span class="type">int</span> order; <span class="comment">//允许我们控制通知的排序</span> <span class="directive">public</span> <span class="type">int</span> getOrder（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .order; <span class="directive">public</span> <span class="type">void</span> setOrder（ <span class="type">int</span> order）{ <span class="local-variable">this</span> .order = order; } <span class="comment">//这个方法<strong>是</strong> around advice</span> <span class="directive">public</span> <span class="predefined-type">Object</span> profile（ProceedingJoinPoint call） <span class="directive">抛出</span> <span class="predefined-type">Throwable</span> { <span class="predefined-type">Object</span> returnValue; StopWatch clock = <span class="keyword">new</span> StopWatch（getClass（）。getName（））; <span class="keyword">try</span> {clock.start（call.toShortString（））; returnValue = call.proceed（）; } <span class="keyword">finally</span> {clock.stop（）; <span class="predefined-type">System</span> .out.println（clock.prettyPrint（））; } <span class="keyword">return</span> returnValue; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过<code>Ordered</code>接口控制建议的<code>Ordered</code> 。有关建议订购的完整详细信息，请参阅<a href="core.html#aop-ataspectj-advice-ordering">建议订购</a> 。</p>
</div>
<div class="paragraph">
<p>以下配置创建了一个<code>fooService</code> bean，它以所需的顺序对其应用了分析和事务方面：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fooService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyservice。DefaultFooService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 这是方面 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profiler</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xySimpleProfiler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 在事务性建议之前执行（因此是较低的订单号） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">order</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;tx：annotation-driven</span> <span class="attribute-name">transaction-manager</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">order</span> = <span class="string"><span class="delimiter">“</span> <span class="content">200</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="comment">&lt;！ - 此建议将围绕事务建议执行 - &gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">profilingAspect</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">profiler</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">serviceMethodWithReturnValue</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">执行（！无效xy。*服务。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：around</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profile</span> <span class="delimiter">“</span></span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceMethodWithReturnValue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org .apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">oracle.jdbc.driver。OracleDriver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：oracle：thin：@ rj-t42：1521：elvis</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">scott</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">密码</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">tiger</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.jdbc.datasource。DataSourceTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以以类似的方式配置任意数量的其他方面。</p>
</div>
<div class="paragraph">
<p>以下示例创建与前两个示例相同的设置，但使用纯XML声明方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">fooService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xyservice。DefaultFooService</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ -  profiling advice  - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profiler</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">xySimpleProfiler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 在事务性建议之前执行（因此是较低的订单号） - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">order</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">1</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;aop：config&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">entryPointMethod</span> <span class="delimiter">”</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">“</span> <span class="content">执行（* xy。*服务。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 将在分析建议后执行（cf命令属性） - &gt;</span> <span class="tag">&lt;aop：advisor</span> <span class="attribute-name">advice-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">entryPointMethod</span> <span class="delimiter">“</span></span> <span class="attribute-name">order</span> = <span class="string"><span class="delimiter">”</span> <span class="content">2</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="comment">&lt;！ - 订单值高于分析方面 - &gt;</span> <span class="tag">&lt;aop：aspect</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profilingAspect</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profiler</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;aop：pointcut</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceMethodWithReturnValue</span> <span class="delimiter">“</span></span> <span class="attribute-name">expression</span> = <span class="string"><span class="delimiter">”</span> <span class="content">execution（！无效xy。*服务。*（..））</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;aop：around</span> <span class="attribute-name">method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">profile</span> <span class="delimiter">“</span></span> <span class="attribute-name">pointcut-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">serviceMethodWithReturnValue</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ aop：aspect&gt;</span> <span class="tag">&lt;/ aop：config&gt;</span> <span class="tag">&lt;tx：advice</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">txAdvice</span> <span class="delimiter">“</span></span> <span class="attribute-name">transaction- manager</span> = <span class="string"><span class="delimiter">“</span> <span class="content">txManager</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;tx：attributes&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">get *</span> <span class="delimiter">”</span></span> <span class="attribute-name">read-only</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;tx：method</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">*</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ tx：attributes&gt;</span> <span class="tag">&lt;/ tx ：advice&gt;</span> <span class="comment">&lt;！ - 其他&lt;bean /&gt;定义，例如DataSource和PlatformTransactionManager这里 - &gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面配置的结果是一个<code>fooService</code> bean，它具有按顺序应用于它的分析和事务方面。如果希望在关于出路的事务性建议之前和之前的事务性建议之后执行性能分析建议，则可以交换性能分析方面bean的<code>order</code>属性的值，使其高于事务性建议的顺序值。</p>
</div>
<div class="paragraph">
<p>您可以以类似的方式配置其他方面。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-aspectj"><a class="anchor" href="#transaction-declarative-aspectj"></a> 1.4.9。将<code>@Transactional</code>与AspectJ一起使用</h4>
<div class="paragraph">
<p>您还可以通过AspectJ方面在Spring容器外部使用Spring Framework的<code>@Transactional</code>支持。为此，首先使用<code>@Transactional</code>注释注释您的类（以及可选的类的方法），然后使用<code>org.springframework.transaction.aspectj.链接（编织）您的应用程序<code>org.springframework.transaction.aspectj.在<code>spring-aspects.jar</code>文件中定义的AnnotationTransactionAspect</code> 。您还必须使用事务管理器配置方面。您可以使用Spring Framework的IoC容器来处理依赖项注入方面。配置事务管理方面的最简单方法是使用<code>&lt;tx:annotation-driven/&gt;</code>元素，并指定<code>mode</code>属性<code>aspectj</code>中所述<a href="#transaction-declarative-annotations">使用<code>@Transactional</code></a> 。因为我们专注于在Spring容器之外运行的应用程序，所以我们将向您展示如何以编程方式执行此操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在继续之前，您可能希望分别阅读<a href="#transaction-declarative-annotations">使用<code>@Transactional</code></a>和<a href="core.html#aop">AOP</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何创建事务管理器并配置<code>AnnotationTransactionAspect</code>以使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//构造一个合适的事务管理器</span> DataSourceTransactionManager txManager = <span class="keyword">new</span> DataSourceTransactionManager（getDataSource（））; <span class="comment">//配置AnnotationTransactionAspect以使用它;这必须在执行任何事务方法之前完成</span> AnnotationTransactionAspect.aspectOf（）。setTransactionManager（txManager）;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用此方面时，必须注释实现类（或该类中的方法或两者），而不是类实现的接口（如果有）。AspectJ遵循Java的规则，即接口上的注释不会被继承。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>类上的<code>@Transactional</code>注释指定了在类中执行任何公共方法的默认事务语义。</p>
</div>
<div class="paragraph">
<p>类中方法的<code>@Transactional</code>注释会覆盖类注释（如果存在）给出的默认事务语义。无论可见性如何，您都可以注释任何方法。</p>
</div>
<div class="paragraph">
<p>要使用<code>AnnotationTransactionAspect</code>编写应用程序，必须使用AspectJ构建应用程序（请参阅<a href="http://www.eclipse.org/aspectj/doc/released/devguide/index.html">AspectJ开发指南</a> ）或使用加载时编织。有关<a href="core.html#aop-aj-ltw">使用AspectJ进行加载时编织</a>的讨论，请参阅<a href="core.html#aop-aj-ltw">Spring Framework中使用AspectJ</a>进行加载时编织。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-programmatic"><a class="anchor" href="#transaction-programmatic"></a> 1.5。程序化交易管理</h3>
<div class="paragraph">
<p>Spring Framework提供了两种程序化事务管理方法，使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransactionTemplate</code> 。</p>
</li>
<li>
<p>直接使用<code>PlatformTransactionManager</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring团队通常建议使用<code>TransactionTemplate</code>进行程序化事务管理。第二种方法类似于使用JTA <code>UserTransaction</code> API，尽管异常处理不那么麻烦。</p>
</div>
<div class="sect3">
<h4 id="tx-prog-template"><a class="anchor" href="#tx-prog-template"></a> 1.5.1。使用<code>TransactionTemplate</code></h4>
<div class="paragraph">
<p><code>TransactionTemplate</code>采用与其他Spring模板相同的方法，例如<code>JdbcTemplate</code> 。它使用回调方法（使应用程序代码免于必须进行样板采集和释放事务资源）并产生意图驱动的代码，因为您的代码仅关注您想要做的事情。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如下面的示例所示，使用<code>TransactionTemplate</code>绝对将您与Spring的事务基础结构和API结合在一起。程序化事务管理是否适合您的开发需求是您必须自己做出的决定。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>必须在事务上下文中执行并且显式使用<code>TransactionTemplate</code>应用程序代码类似于下一个示例。作为应用程序开发人员，您可以编写一个<code>TransactionCallback</code>实现（通常表示为匿名内部类），该实现包含您需要在事务上下文中执行的代码。然后，您可以通过自定义的实例<code>TransactionCallback</code>到<code>execute(..)</code>暴露的方法<code>TransactionTemplate</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SimpleService</span> <span class="directive">实现</span> Service { <span class="comment">//在此实例中的所有方法之间共享的单个TransactionTemplate</span> <span class="directive">私有</span> <span class="directive">final</span> TransactionTemplate transactionTemplate; <span class="comment">//使用构造函数注入来提供PlatformTransactionManager</span> <span class="directive">public</span> SimpleService（PlatformTransactionManager transactionManager）{ <span class="local-variable">this</span> .transactionTemplate = <span class="keyword">new</span> TransactionTemplate（transactionManager）; <span class="directive">public</span> <span class="predefined-type">Object</span> someServiceMethod（）{ <span class="keyword">return</span> transactionTemplate.execute（ <span class="keyword">new</span> TransactionCallback（）{ <span class="comment">//此方法中的代码在事务上下文中执行</span> <span class="directive">public</span> <span class="predefined-type">Object</span> doInTransaction（TransactionStatus status）{updateOperation1（）; <span class="keyword">return</span> resultOfUpdateOperation2（）;}}）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有返回值，则可以使用方便的<code>TransactionCallbackWithoutResult</code>类和匿名类，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">transactionTemplate.execute（ <span class="keyword">new</span> <strong>TransactionCallbackWithoutResult</strong> （）{ <span class="directive">protected</span> <span class="type">void</span> doInTransactionWithoutResult（TransactionStatus status）{updateOperation1（）; updateOperation2（）;}}）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>回调中的代码可以通过调用提供的<code>TransactionStatus</code>对象上的<code>setRollbackOnly()</code>方法来回滚<code>TransactionStatus</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">transactionTemplate.execute（ <span class="keyword">new</span> TransactionCallbackWithoutResult（）{ <span class="directive">protected</span> <span class="type">void</span> doInTransactionWithoutResult（TransactionStatus status）{ <span class="keyword">try</span> {updateOperation1（）; updateOperation2（）;} <span class="keyword">catch</span> （SomeBusinessException ex）{ <strong>status.setRollbackOnly（）;</strong> }}}）;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tx-prog-template-settings"><a class="anchor" href="#tx-prog-template-settings"></a>指定交易设置</h5>
<div class="paragraph">
<p>您可以通过编程方式或在配置中在<code>TransactionTemplate</code>上指定事务设置（例如传播模式，隔离级别，超时等）。默认情况下， <code>TransactionTemplate</code>实例具有<a href="#transaction-declarative-txadvice-settings">默认的事务设置</a> 。以下示例显示了特定<code>TransactionTemplate:</code>的事务设置的编程自定义<code>TransactionTemplate:</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleService</span> <span class="directive">实现</span> Service { <span class="directive">private</span> <span class="directive">final</span> TransactionTemplate transactionTemplate; <span class="directive">public</span> SimpleService（PlatformTransactionManager transactionManager）{ <span class="local-variable">this</span> .transactionTemplate = <span class="keyword">new</span> TransactionTemplate（transactionManager）; <span class="comment">//交易设置可以在这里明确地如果需要的话</span> <span class="local-variable">这个</span> .transactionTemplate.setIsolationLevel（TransactionDefinition的<span class="comment">设置</span> 。ISOLATION_READ_UNCOMMITTED）; <span class="local-variable">这个</span> .transactionTemplate.setTimeout（ <span class="integer">30</span> ）; <span class="comment">// 30秒</span> <span class="comment">//等等......</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例使用Spring XML配置定义具有一些自定义事务设置的<code>TransactionTemplate</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sharedTransactionTemplate</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.transaction.support。TransactionTemplate</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">isolationLevelName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">ISOLATION_READ_UNCOMMITTED</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">timeout</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">30</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> ”</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将<code>sharedTransactionTemplate</code>注入所需<code>sharedTransactionTemplate</code>服务。</p>
</div>
<div class="paragraph">
<p>最后， <code>TransactionTemplate</code>类的实例是线程安全的，因为实例不保持任何会话状态。但是， <code>TransactionTemplate</code>实例会保持配置状态。因此，虽然许多类可以共享<code>TransactionTemplate</code>的单个实例，但如果类需要使用具有不同设置的<code>TransactionTemplate</code> （例如，不同的隔离级别），则需要创建两个不同的<code>TransactionTemplate</code>实例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-programmatic-ptm"><a class="anchor" href="#transaction-programmatic-ptm"></a> 1.5.2。使用<code>PlatformTransactionManager</code></h4>
<div class="paragraph">
<p>您还可以使用<code>org.springframework.transaction.PlatformTransactionManager</code>直接管理您的交易。为此，请通过bean引用将您使用的<code>PlatformTransactionManager</code>的实现传递给bean。然后，通过使用<code>TransactionDefinition</code>和<code>TransactionStatus</code>对象，您可以启动事务，回滚和提交。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition（）; <span class="comment">//显式设置事务名称只能以编程方式完成</span> def.setName（ <span class="string"><span class="delimiter">“</span> <span class="content">SomeTxName</span> <span class="delimiter">”</span></span> ）; def.setPropagationBehavior（TransactionDefinition的。PROPAGATION_REQUIRED）; TransactionStatus status = txManager.getTransaction（def）; <span class="keyword">try</span> { <span class="comment">//在这里执行你的业务逻辑</span> } <span class="keyword">catch</span> （MyException ex）{txManager.rollback（status）; <span class="keyword">抛出</span>前} txManager.commit（status）;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx-decl-vs-prog"><a class="anchor" href="#tx-decl-vs-prog"></a> 1.6。在程序化和声明式事务管理之间进行选择</h3>
<div class="paragraph">
<p>只有在进行少量事务操作时，程序化事务管理通常才是一个好主意。例如，如果您的Web应用程序仅需要针对某些更新操作进行事务处理，则可能不希望使用Spring或任何其他技术来设置事务代理。在这种情况下，使用<code>TransactionTemplate</code>可能是一个很好的方法。能够明确设置事务名称也只能通过使用程序化方法进行事务管理。</p>
</div>
<div class="paragraph">
<p>另一方面，如果您的应用程序有许多事务操作，则声明式事务管理通常是值得的。它使事务管理不受业务逻辑的影响，并且不难配置。使用Spring Framework而不是EJB CMT时，声明式事务管理的配置成本大大降低。</p>
</div>
</div>
<div class="sect2">
<h3 id="transaction-event"><a class="anchor" href="#transaction-event"></a> 1.7。交易约束事件</h3>
<div class="paragraph">
<p>从Spring 4.2开始，事件的监听器可以绑定到事务的一个阶段。典型示例是在事务成功完成时处理事件。这样做可以在当前事务的结果对于监听器实际上很重要时更灵活地使用事件。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@EventListener</code>注释注册常规事件侦听器。如果需要将其绑定到事务，请使用<code>@TransactionalEventListener</code> 。执行此操作时，默认情况下，侦听器将绑定到事务的提交阶段。</p>
</div>
<div class="paragraph">
<p>下一个例子展示了这个概念。假设一个组件发布一个订单创建的事件，并且我们想要定义一个只应该在发布它的事务成功提交后才应该处理该事件的监听器。以下示例设置此类事件侦听器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyComponent</span> { <span class="annotation">@TransactionalEventListener</span> <span class="directive">public</span> <span class="type">void</span> handleOrderCreatedEvent（CreationEvent &lt;Order&gt; creationEvent）{...}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@TransactionalEventListener</code>注释公开了一个<code>phase</code>属性，该属性允许您自定义侦听器应绑定到的事务的阶段。有效阶段是<code>BEFORE_COMMIT</code> ， <code>AFTER_COMMIT</code> （默认值）， <code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code> ，它们聚合事务完成（无论是提交还是回滚）。</p>
</div>
<div class="paragraph">
<p>如果没有正在运行的事务，则根本不会调用侦听器，因为我们无法遵守所需的语义。但是，您可以通过将注释的<code>fallbackExecution</code>属性设置为<code>true</code>来覆盖该行为。</p>
</div>
</div>
<div class="sect2">
<h3 id="transaction-application-server-integration"><a class="anchor" href="#transaction-application-server-integration"></a> 1.8。应用程序服务器特定的集成</h3>
<div class="paragraph">
<p>Spring的事务抽象通常与应用程序服务器无关。此外，Spring的<code>JtaTransactionManager</code>类（可以选择对JTA <code>UserTransaction</code>和<code>TransactionManager</code>对象执行JNDI查找）自动检测后一个对象的位置，该位置因应用程序服务器而异。有权访问JTA <code>TransactionManager</code>允许增强的事务语义 - 特别是支持事务暂停。有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/transaction/jta/JtaTransactionManager.html"><code>JtaTransactionManager</code> Javadoc</a> 。</p>
</div>
<div class="paragraph">
<p>Spring的<code>JtaTransactionManager</code>是在Java EE应用程序服务器上运行的标准选择，并且已知可在所有常见服务器上运行。高级功能（例如事务暂停）也适用于许多服务器（包括GlassFish，JBoss和Geronimo），无需任何特殊配置。但是，对于完全支持的事务挂起和进一步的高级集成，Spring包含用于WebLogic Server和WebSphere的特殊适配器。以下各节将讨论这些适配器。</p>
</div>
<div class="paragraph">
<p>对于标准方案（包括WebLogic Server和WebSphere），请考虑使用方便的<code>&lt;tx:jta-transaction-manager/&gt;</code>配置元素。配置后，此元素会自动检测基础服务器并选择可用于平台的最佳事务管理器。这意味着您无需显式配置特定于服务器的适配器类（如以下部分所述）。相反，它们是自动选择的，标准的<code>JtaTransactionManager</code>作为默认的后备。</p>
</div>
<div class="sect3">
<h4 id="transaction-application-server-integration-websphere"><a class="anchor" href="#transaction-application-server-integration-websphere"></a> 1.8.1。IBM WebSphere</h4>
<div class="paragraph">
<p>在WebSphere 6.1.0.9及更高版本中，要使用的推荐Spring JTA事务管理器是<code>WebSphereUowTransactionManager</code> 。此特殊适配器使用IBM的<code>UOWManager</code> API，该API在WebSphere Application Server 6.1.0.9及更高版本中可用。使用此适配器，IBM正式支持Spring驱动的事务暂停（由<code>PROPAGATION_REQUIRES_NEW</code>启动的暂停和恢复）。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-application-server-integration-weblogic"><a class="anchor" href="#transaction-application-server-integration-weblogic"></a> 1.8.2。Oracle WebLogic Server</h4>
<div class="paragraph">
<p>在WebLogic Server 9.0或更高版本上，通常使用<code>WebLogicJtaTransactionManager</code>而不是库存<code>JtaTransactionManager</code>类。普通<code>JtaTransactionManager</code>这个特殊的WebLogic特定子类在WebLogic管理的事务环境中支持Spring的事务定义的全部功能，超出了标准的JTA语义。功能包括事务名称，每事务隔离级别以及在所有情况下正确恢复事务。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-solutions-to-common-problems"><a class="anchor" href="#transaction-solutions-to-common-problems"></a> 1.9。解决常见问题</h3>
<div class="paragraph">
<p>本节介绍了一些常见问题的解决方案。</p>
</div>
<div class="sect3">
<h4 id="transaction-solutions-to-common-problems-wrong-ptm"><a class="anchor" href="#transaction-solutions-to-common-problems-wrong-ptm"></a> 1.9.1。使用错误的事务管理器来获取特定的<code>DataSource</code></h4>
<div class="paragraph">
<p>根据您选择的事务技术和要求，使用正确的<code>PlatformTransactionManager</code>实现。如果使用得当，Spring Framework只提供了简单易用的抽象。如果使用全局事务，则必须使用<code>org.springframework.transaction.jta.用于所有事务操作的JtaTransactionManager</code>类（或其<a href="#transaction-application-server-integration">特定</a>于<a href="#transaction-application-server-integration">应用程序服务器的子类</a> ）。否则，事务基础结构尝试在诸如容器<code>DataSource</code>实例之类的资源上执行本地事务。这样的本地事务没有意义，好的应用程序服务器将它们视为错误。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-resources"><a class="anchor" href="#transaction-resources"></a> 1.10。更多资源</h3>
<div class="paragraph">
<p>有关Spring Framework的事务支持的更多信息，请参阅：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html">Spring中的分布式事务，有或没有XA</a>是一个JavaWorld演示文稿，其中Spring的David Syer将引导您完成Spring应用程序中分布式事务的七种模式，其中三种使用XA，四种不使用。</p>
</li>
<li>
<p><a href="http://www.infoq.com/minibooks/JTDS"><em>Java Transaction Design Strategies</em></a>是<a href="http://www.infoq.com/">InfoQ</a>提供的一本书，它提供了对Java中事务的快速介绍。它还包括如何使用Spring Framework和EJB3配置和使用事务的并排示例。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dao"><a class="anchor" href="#dao"></a> 2。DAO支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring中的数据访问对象（DAO）支持旨在使您能够以一致的方式轻松使用数据访问技术（如JDBC，Hibernate或JPA）。这使您可以非常轻松地在上述持久性技术之间切换，并且还可以让您编写代码而无需担心捕获特定于每种技术的异常。</p>
</div>
<div class="sect2">
<h3 id="dao-exceptions"><a class="anchor" href="#dao-exceptions"></a> 2.1。一致的异常层次结构</h3>
<div class="paragraph">
<p>Spring提供了一种方便的转换，从特定于技术的异常，例如<code>SQLException</code>到它自己的异常类层次结构，它将<code>DataAccessException</code>作为根异常。这些异常包装了原始异常，因此您可能永远不会丢失任何可能出错的信息。</p>
</div>
<div class="paragraph">
<p>除了JDBC异常之外，Spring还可以包装特定于JPA和Hibernate的异常，将它们转换为一组集中的运行时异常。这使您可以仅在适当的层中处理大多数不可恢复的持久性异常，而无需在DAO中使用恼人的样板catch-and-throw块和异常声明。（您仍然可以在任何需要的地方捕获和处理异常。）如上所述，JDBC异常（包括特定于数据库的方言）也会转换为相同的层次结构，这意味着您可以在一致的编程模型中使用JDBC执行某些操作。</p>
</div>
<div class="paragraph">
<p>前面的讨论适用于Spring对各种ORM框架的支持中的各种模板类。如果使用基于拦截器的类，则应用程序必须关心处理<code>HibernateExceptions</code>和<code>PersistenceExceptions</code>本身，最好分别委托<code>SessionFactoryUtils</code>的<code>convertHibernateAccessException(..)</code>或<code>convertJpaAccessException()</code>方法。这些方法将异常转换为与<code>org.springframework.dao</code>异常层次结构中的异常兼容的异常。由于<code>PersistenceExceptions</code>未被选中，它们也可能被抛出（尽管在例外方面牺牲了通用DAO抽象）。</p>
</div>
<div class="paragraph">
<p>下图显示了Spring提供的异常层次结构。（请注意，图像中详细说明的类层次结构仅显示整个<code>DataAccessException</code>层次结构的子集。）</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/DataAccessException.png" alt="DataAccessException的">
</div>
</div>
</div>
<div class="sect2">
<h3 id="dao-annotations"><a class="anchor" href="#dao-annotations"></a> 2.2。用于配置DAO或存储库类的注释</h3>
<div class="paragraph">
<p>保证数据访问对象（DAO）或存储库提供异常转换的最佳方法是使用<code>@Repository</code>批注。此批注还允许组件扫描支持查找和配置DAO和存储库，而无需为它们提供XML配置条目。以下示例显示了如何使用<code>@Repository</code>批注：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">SomeMovieFinder</span> <span class="directive">实现</span> MovieFinder { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>@Repository</code>注释。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>任何DAO或存储库实现都需要访问持久性资源，具体取决于所使用的持久性技术。例如，基于JDBC的存储库需要访问JDBC <code>DataSource</code> ，而基于JPA的存储库需要访问<code>EntityManager</code> 。完成此操作的最简单方法是使用@ <code>@Autowired,</code> ，@ <code>@Inject</code> ， <code>@Resource</code>或<code>@PersistenceContext</code>注释之一注入此资源依赖项。以下示例适用于JPA存储库：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">JpaMovieFinder</span> <span class="directive">实现</span>的MovieFinder <span class="annotation">{@PersistenceContext</span> EntityManager的<span class="directive">私人</span> EntityManager的; <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用经典的Hibernate API，则可以注入<code>SessionFactory</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">HibernateMovieFinder</span> <span class="directive">实现</span>的MovieFinder { <span class="directive">私人</span> SessionFactory的SessionFactory的; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setSessionFactory（SessionFactory sessionFactory）{ <span class="local-variable">this</span> .sessionFactory = sessionFactory; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们在这里展示的最后一个例子是典型的JDBC支持。您可以将<code>DataSource</code>注入到初始化方法中，您可以使用此<code>DataSource</code>创建<code>JdbcTemplate</code>和其他数据访问支持类（如<code>SimpleJdbcCall</code>等）。以下示例自动装配<code>DataSource</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcMovieFinder</span> <span class="directive">实现</span>的MovieFinder { <span class="directive">私人</span>的JdbcTemplate JdbcTemplate的; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> init（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; } <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关如何配置应用程序上下文以利用这些注释的详细信息，请参阅每种持久性技术的具体内容。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jdbc"><a class="anchor" href="#jdbc"></a> 3。使用JDBC进行数据访问</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework JDBC抽象提供的值可能最好通过下表中列出的操作序列显示。该表显示了Spring负责的操作以及您负责的操作。</p>
</div>
<table id="jdbc-who-does-what" class="tableblock frame-all grid-all spread">
<caption class="title">表4。Spring JDBC  - 谁做了什么？</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">行动</th>
<th class="tableblock halign-left valign-top">弹簧</th>
<th class="tableblock halign-left valign-top">您</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义连接参数。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">打开连接。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定SQL语句。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明参数并提供参数值</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">准备并执行声明。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置循环以迭代结果（如果有的话）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">为每次迭代做好工作。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理任何异常。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理交易。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">关闭连接，语句和结果集。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring Framework负责处理所有可能使JDBC成为繁琐API的低级细节。</p>
</div>
<div class="sect3">
<h4 id="jdbc-choose-style"><a class="anchor" href="#jdbc-choose-style"></a> 3.1。选择JDBC数据库访问方法</h4>
<div class="paragraph">
<p>您可以选择多种方法来构成JDBC数据库访问的基础。除了三种<code>JdbcTemplate</code> ，新的<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>方法优化了数据库元数据，而RDBMS Object样式采用了类似于JDO Query设计的面向对象方法。一旦开始使用这些方法之一，您仍然可以混合和匹配以包含来自不同方法的功能。所有方法都需要JDBC 2.0兼容的驱动程序，而某些高级功能需要JDBC 3.0驱动程序。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JdbcTemplate</code>是经典且最流行的Spring JDBC方法。这种“最低级别”的方法和所有其他方法都使用了JdbcTemplate。</p>
</li>
<li>
<p><code>NamedParameterJdbcTemplate</code>包装<code>JdbcTemplate</code>以提供命名参数而不是传统的JDBC <code>?</code> 占位符。当您有多个SQL语句参数时，此方法可提供更好的文档和易用性。</p>
</li>
<li>
<p><code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>优化数据库元数据以限制必要的配置量。此方法简化了编码，因此您只需提供表或过程的名称，并提供与列名匹配的参数映射。仅当数据库提供足够的元数据时，这才有效。如果数据库未提供此元数据，则必须提供参数的显式配置。</p>
</li>
<li>
<p>RDBMS对象（包括<code>MappingSqlQuery</code> ， <code>SqlUpdate</code>和<code>StoredProcedure</code> ）要求您在数据访问层初始化期间创建可重用且线程安全的对象。此方法在JDO Query之后建模，其中您定义查询字符串，声明参数和编译查询。执行此操作后，可以使用各种参数值多次调用execute方法。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-packages"><a class="anchor" href="#jdbc-packages"></a> 3.2。包层次结构</h4>
<div class="paragraph">
<p>Spring Framework的JDBC抽象框架由四个不同的包组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code> ： <code>org.springframework.jdbc.core</code>包中包含<code>JdbcTemplate</code>类及其各种回调接口，以及各种相关类。名为<code>org.springframework.jdbc.core.simple</code>的子包包含<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>类。另一个名为<code>org.springframework.jdbc.core.namedparam</code>子包包含<code>NamedParameterJdbcTemplate</code>类和相关的支持类。请参阅<a href="#jdbc-core">使用JDBC核心类控制基本JDBC处理和错误处理</a> ， <a href="#jdbc-advanced-jdbc">JDBC批处理操作</a>和<a href="#jdbc-simple-jdbc">[jdbc-simple-jdbc]</a> 。</p>
</li>
<li>
<p><code>datasource</code> ： <code>org.springframework.jdbc.datasource</code>包中包含一个用于轻松访问<code>DataSource</code>的实用程序类和各种简单的<code>DataSource</code>实现，可用于在Java EE容器外测试和运行未修改的JDBC代码。名为<code>org.springfamework.jdbc.datasource.embedded</code>的子包提供了使用Java数据库引擎（如HSQL，H2和Derby）创建嵌入式数据库的支持。请参阅<a href="#jdbc-connections">控制数据库连接</a>和<a href="#jdbc-embedded-database-support">[jdbc-embedded-database-support]</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>object</code> ： <code>org.springframework.jdbc.object</code>包中包含将RDBMS查询，更新和存储过程表示为线程安全，可重用对象的类。见<a href="#jdbc-object">[jdbc-object]</a> 。这种方法由JDO建模，尽管查询返回的对象自然与数据库断开连接。这种更高级别的JDBC抽象取决于<code>org.springframework.jdbc.core</code>包中的低级抽象。</p>
</div>
<div class="paragraph">
<p><code>support</code> ： <code>org.springframework.jdbc.support</code>包提供<code>SQLException</code>转换功能和一些实用程序类。JDBC处理期间抛出的异常将转换为<code>org.springframework.dao</code>包中定义的异常。这意味着使用Spring JDBC抽象层的代码不需要实现JDBC或RDBMS特定的错误处理。所有已翻译的异常都是未选中的，这使您可以选择捕获可以恢复的异常，同时将其他异常传播给调用方。请参阅<a href="#jdbc-SQLExceptionTranslator">使用<code>SQLExceptionTranslator</code></a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-core"><a class="anchor" href="#jdbc-core"></a> 3.3。使用JDBC核心类控制基本JDBC处理和错误处理</h3>
<div class="paragraph">
<p>本节介绍如何使用JDBC核心类来控制基本的JDBC处理，包括错误处理。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-JdbcTemplate">使用<code>JdbcTemplate</code></a></p>
</li>
<li>
<p><a href="#jdbc-NamedParameterJdbcTemplate">使用<code>NamedParameterJdbcTemplate</code></a></p>
</li>
<li>
<p><a href="#jdbc-SQLExceptionTranslator">使用<code>SQLExceptionTranslator</code></a></p>
</li>
<li>
<p><a href="#jdbc-statements-executing">运行语句</a></p>
</li>
<li>
<p><a href="#jdbc-statements-querying">运行查询</a></p>
</li>
<li>
<p><a href="#jdbc-updates">更新数据库</a></p>
</li>
<li>
<p><a href="#jdbc-auto-genereted-keys">检索自动生成的密钥</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jdbc-JdbcTemplate"><a class="anchor" href="#jdbc-JdbcTemplate"></a> 3.3.1。使用<code>JdbcTemplate</code></h4>
<div class="paragraph">
<p><code>JdbcTemplate</code>是JDBC核心包中的中心类。它处理资源的创建和释放，帮助您避免常见错误，例如忘记关闭连接。它执行核心JDBC工作流的基本任务（例如语句创建和执行），留下应用程序代码以提供SQL并提取结果。<code>JdbcTemplate</code>类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>运行SQL查询</p>
</li>
<li>
<p>更新语句和存储过程调用</p>
</li>
<li>
<p>对<code>ResultSet</code>实例执行迭代并提取返回的参数值。</p>
</li>
<li>
<p>捕获JDBC异常并将它们转换为<code>org.springframework.dao</code>包中定义的通用的，信息量更大的异常层次结构。（请参阅<a href="#dao-exceptions">一致的异常层次结构</a> 。）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您为代码使用<code>JdbcTemplate</code> ，您只需要实现回调接口，为它们提供明确定义的合同。给定<code>JdbcTemplate</code>类提供的<code>Connection</code> ， <code>PreparedStatementCreator</code>回调接口创建一个<code>JdbcTemplate</code>准备语句，提供SQL和任何必要的参数。<code>CallableStatementCreator</code>接口也是如此，它创建了可调用语句。<code>RowCallbackHandler</code>接口从<code>ResultSet</code>每一行中提取值。</p>
</div>
<div class="paragraph">
<p>您可以通过使用<code>DataSource</code>引用直接实例化在DAO实现中使用<code>JdbcTemplate</code> ，也可以在Spring IoC容器中对其进行配置，并将其作为bean引用提供给DAO。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">应始终将<code>DataSource</code>配置为Spring IoC容器中的bean。在第一种情况下，bean直接提供给服务;在第二种情况下，它被给予准备好的模板。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此类发出的所有SQL都记录在与模板实例的完全限定类名对应的类别下的<code>DEBUG</code>级别（通常为<code>JdbcTemplate</code> ，但如果使用<code>JdbcTemplate</code>类的自定义子类，则可能会有所不同）。</p>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples"><a class="anchor" href="#jdbc-JdbcTemplate-examples"></a> JdbcTemplate类用法的示例</h5>
<div class="paragraph">
<p>本节提供了一些<code>JdbcTemplate</code>类用法的示例。这些示例并不是<code>JdbcTemplate</code>公开的所有功能的详尽列表。请参阅服务员<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html">Javadoc</a> 。</p>
</div>
<div class="sect5">
<h6 id="jdbc-JdbcTemplate-examples-query"><a class="anchor" href="#jdbc-JdbcTemplate-examples-query"></a>查询（ <code>SELECT</code> ）</h6>
<div class="paragraph">
<p>以下查询获取关系中的行数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> rowCount = <span class="local-variable">this</span> .jdbcTemplate.queryForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">select count（*）from t_actor</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Integer</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询使用绑定变量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> countOfActorsNamedJoe = <span class="local-variable">this</span> .jdbcTemplate.queryForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">select count（*）from t_actor where first_name =？</span><span class="delimiter">“</span></span> ， <span class="predefined-type">整数</span> .class， <span class="string"><span class="delimiter">”</span> <span class="content">乔</span> <span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询查找<code>String</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> lastName = <span class="local-variable">this</span> .jdbcTemplate.queryForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">从t_actor中选择last_name，其中id =？</span><span class="delimiter">“</span></span> ， <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> { <span class="integer">1212L</span> }， <span class="predefined-type">String</span> .class）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询查找并填充单个域对象：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Actor actor = <span class="local-variable">this</span> .jdbcTemplate.queryForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">select select_name，last_name from t_actor where id =？</span><span class="delimiter">“</span></span> ， <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> { <span class="integer">1212L</span> }， <span class="keyword">new</span> <span class="predefined-type">RowMapper</span> &lt;Actor&gt;（）{ <span class="directive">public</span> Actor mapRow（ <span class="predefined-type">ResultSet</span> rs， <span class="type">int</span> rowNum） <span class="directive">抛出</span> <span class="exception">SQLException</span> {Actor actor = <span class="keyword">new</span> Actor（）; actor.setFirstName（rs.getString（ <span class="string"><span class="delimiter">”</span> <span class="content">first_name</span> <span class="delimiter">“）</span></span> ））; actor.setLastName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">return</span> actor;}}）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询查找并填充许多域对象：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span> &lt;Actor&gt; actors = <span class="local-variable">this</span> .jdbcTemplate.query（ <span class="string"><span class="delimiter">“</span> <span class="content">select first_name，last_name from t_actor</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> <span class="predefined-type">RowMapper</span> &lt;Actor&gt;（）{ <span class="directive">public</span> Actor mapRow（ <span class="predefined-type">ResultSet</span> rs， <span class="type">int</span> rowNum） <span class="directive">throws</span> <span class="exception">SQLException</span> {Actor actor = <span class="keyword">new</span> Actor（）; actor.setFirstName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ））; actor.setLastName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">return</span> actor;}}）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果最后两个代码片段实际存在于同一个应用程序中，那么删除两个<code>RowMapper</code>匿名内部类中存在的重复并将它们提取到一个可以引用的单个类（通常是<code>static</code>嵌套类）中是有意义的。根据需要通过DAO方法。例如，最好编写前面的代码片段，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">List</span> &lt;Actor&gt; findAllActors（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .jdbcTemplate.query（ <span class="string"><span class="delimiter">“</span> <span class="content">select first_name，last_name from t_actor</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> ActorMapper（））; <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">ActorMapper</span> <span class="directive">实现</span> <span class="predefined-type">RowMapper</span> &lt;Actor&gt; { <span class="directive">public</span> Actor mapRow（ <span class="predefined-type">ResultSet</span> rs， <span class="type">int</span> rowNum） <span class="directive">throws</span> <span class="exception">SQLException</span> {Actor actor = <span class="keyword">new</span> Actor（）; actor.setFirstName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ））; actor.setLastName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">回归</span>演员; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="jdbc-JdbcTemplate-examples-update"><a class="anchor" href="#jdbc-JdbcTemplate-examples-update"></a>使用<code>JdbcTemplate</code>更新（ <code>INSERT</code> ， <code>UPDATE</code>和<code>DELETE</code> ）</h6>
<div class="paragraph">
<p>您可以使用<code>update(..)</code>方法执行插入，更新和删除操作。参数值通常作为变量参数提供，或者作为对象数组提供。</p>
</div>
<div class="paragraph">
<p>以下示例插入一个新条目：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">这个</span> .jdbcTemplate.update（ <span class="string"><span class="delimiter">“</span> <span class="content">插入t_actor（first_name，last_name）值（？，？）</span><span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">Leonor</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">Watling</span> <span class="delimiter">“</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例更新现有条目：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">这个</span> .jdbcTemplate.update（ <span class="string"><span class="delimiter">“</span> <span class="content">update t_actor set last_name =？其中id =？</span><span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">Banjo</span> <span class="delimiter">“</span></span> ， <span class="integer">5276L</span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例删除条目：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">这个</span> .jdbcTemplate.update（ <span class="string"><span class="delimiter">“</span> <span class="content">从actor中删除id =？</span><span class="delimiter">“</span></span> ， <span class="predefined-type">Long</span> .valueOf（actorId））;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="jdbc-JdbcTemplate-examples-other"><a class="anchor" href="#jdbc-JdbcTemplate-examples-other"></a>其他<code>JdbcTemplate</code>操作</h6>
<div class="paragraph">
<p>您可以使用<code>execute(..)</code>方法运行任意SQL。因此，该方法通常用于DDL语句。它重载了带有回调接口，绑定变量数组等的变体。以下示例创建一个表：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">这个</span> .jdbcTemplate.execute（ <span class="string"><span class="delimiter">“</span> <span class="content">create table mytable（id integer，name varchar（100））</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例调用存储过程：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">这个</span> .jdbcTemplate.update（ <span class="string"><span class="delimiter">“</span> <span class="content">调用SUPPORT.REFRESH_ACTORS_SUMMARY（？）</span><span class="delimiter">“</span></span> ， <span class="predefined-type">Long</span> .valueOf（unionId））;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#jdbc-StoredProcedure">稍后</a>将<a href="#jdbc-StoredProcedure">介绍</a>更复杂的存储过程支持。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-idioms"><a class="anchor" href="#jdbc-JdbcTemplate-idioms"></a> <code>JdbcTemplate</code>最佳实践</h5>
<div class="paragraph">
<p>一旦配置， <code>JdbcTemplate</code>类的实例就是线程安全的。这很重要，因为这意味着您可以配置<code>JdbcTemplate</code>的单个实例，然后将此共享引用安全地注入多个DAO（或存储库）。<code>JdbcTemplate</code>是有状态的，因为它维护对<code>DataSource</code>的引用，但此状态不是会话状态。</p>
</div>
<div class="paragraph">
<p>使用<code>JdbcTemplate</code>类（以及关联的<a href="#jdbc-NamedParameterJdbcTemplate"><code>NamedParameterJdbcTemplate</code></a>类）时的常见做法是在Spring配置文件中配置<code>DataSource</code> ，然后将共享<code>DataSource</code> bean依赖注入到DAO类中。<code>JdbcTemplate</code>是在<code>DataSource</code>的setter中创建的。这导致DAO类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcCorporateEventDao</span> <span class="directive">实现了</span> CorporateEventDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <strong><span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）;</strong> } <span class="comment">//在CorporateEventDao上的JDBC支持的方法实现遵循...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">corporateEventDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">com.example。JdbcCorporateEventDao</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">username</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;context：property-placeholder</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc .properties</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>显式配置的替代方法是使用组件扫描和注释支持依赖注入。在这种情况下，您可以使用<code>@Repository</code>注释该类（这使其成为组件扫描的候选者）并使用<code>@Autowired</code>注释<code>DataSource</code> setter方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcCorporateEventDao</span> <span class="directive">实现了</span> CorporateEventDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="annotation">@Autowired</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <i class="conum" data-value="3"></i> <b>（3）</b> } <span class="comment">//在CorporateEventDao上的JDBC支持的方法实现遵循...</span>}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>@Repository</code>注释类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>@Autowired</code>注释<code>DataSource</code> setter方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用<code>DataSource</code>创建一个新的<code>JdbcTemplate</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的XML配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：context</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/context</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content"><span class="content">http://www.springframework.org/schema/beans</span> http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">HTTP：/ /www.springframework.org/schema/context</span> <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 在@Component类的应用程序的基础包内扫描以配置为beans  - &gt;</span> <span class="tag">&lt;context：component-scan</span> <span class="attribute-name">base-package</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.docs.test</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">username</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;context：property-placeholder</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc .properties</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用Spring的<code>JdbcDaoSupport</code>类，并且各种JDBC支持的DAO类从它扩展，则子类从<code>JdbcDaoSupport</code>类继承<code>setDataSource(..)</code>方法。您可以选择是否继承此类。<code>JdbcDaoSupport</code>类仅为方便起见而提供。</p>
</div>
<div class="paragraph">
<p>无论您选择使用（或不使用）上述哪种模板初始化样式，每次要运行SQL时，很少需要创建<code>JdbcTemplate</code>类的新实例。配置完成后， <code>JdbcTemplate</code>实例是线程安全的。如果您的应用程序访问多个数据库，您可能需要多个<code>JdbcTemplate</code>实例，这需要多个<code>DataSources</code> ，随后需要多个不同配置的<code>JdbcTemplate</code>实例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-NamedParameterJdbcTemplate"><a class="anchor" href="#jdbc-NamedParameterJdbcTemplate"></a> 3.3.2。使用<code>NamedParameterJdbcTemplate</code></h4>
<div class="paragraph">
<p><code>NamedParameterJdbcTemplate</code>类通过使用命名参数添加了对JDBC语句编程的支持，而不是仅使用经典占位符编写JDBC语句（ <code>'?'</code> ）论点。<code>NamedParameterJdbcTemplate</code>类包装<code>JdbcTemplate</code>并委托包装的<code>JdbcTemplate</code>来完成其大部分工作。本节仅描述<code>NamedParameterJdbcTemplate</code>类与<code>JdbcTemplate</code>本身不同的区域 - 即使用命名参数编写JDBC语句。以下示例显示了如何使用<code>NamedParameterJdbcTemplate</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//一些JDBC支持的DAO类......</span>
<span class="directive">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .namedParameterJdbcTemplate = <span class="keyword">new</span> NamedParameterJdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> countOfActorsByFirstName（ <span class="predefined-type">String</span> firstName）{ <span class="predefined-type">String</span> sql = <span class="string"><span class="delimiter">“</span> <span class="content">select count（*）from T_ACTOR where first_name =：first_name</span> <span class="delimiter">”</span></span> ; SqlParameterSource namedParameters = <span class="keyword">new</span> MapSqlParameterSource（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ，firstName）; <span class="keyword">返回</span> <span class="local-variable">此</span> .namedParameterJdbcTemplate.queryForObject（sql，namedParameters， <span class="predefined-type">Integer</span> .class）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意在分配给<code>sql</code>变量的值中使用命名参数表示法以及插入<code>namedParameters</code>变量（ <code>MapSqlParameterSource</code>类型）的相应值。</p>
</div>
<div class="paragraph">
<p>或者，您可以使用基于<code>Map</code>的样式将命名参数及其对应值传递给<code>NamedParameterJdbcTemplate</code>实例。<code>NamedParameterJdbcOperations</code>公开并由<code>NamedParameterJdbcTemplate</code>类实现的其余方法遵循类似的模式，此处不再介绍。</p>
</div>
<div class="paragraph">
<p>以下示例显示了基于<code>Map</code>的样式的使用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//一些JDBC支持的DAO类......</span>
<span class="directive">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .namedParameterJdbcTemplate = <span class="keyword">new</span> NamedParameterJdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> countOfActorsByFirstName（ <span class="predefined-type">String</span> firstName）{ <span class="predefined-type">String</span> sql = <span class="string"><span class="delimiter">“</span> <span class="content">select count（*）from T_ACTOR where first_name =：first_name</span> <span class="delimiter">”</span></span> ; <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; namedParameters = <span class="predefined-type">Collections</span> .singletonMap（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ，firstName）; <span class="keyword">返回</span> <span class="local-variable">此</span> .namedParameterJdbcTemplate.queryForObject（sql，namedParameters， <span class="predefined-type">Integer</span> .class）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与<code>NamedParameterJdbcTemplate</code>相关的一个很好的功能（并且存在于同一个Java包中）是<code>SqlParameterSource</code>接口。您已经在之前的一个代码片段（ <code>MapSqlParameterSource</code>类）中看到了此接口的实现示例。<code>SqlParameterSource</code>是<code>NamedParameterJdbcTemplate</code>的命名参数值的<code>NamedParameterJdbcTemplate</code> 。<code>MapSqlParameterSource</code>类是一个简单的实现，它是<code>java.util.的适配器<code>java.util.Map</code> ，其中键是参数名称，值是参数值。</p>
</div>
<div class="paragraph">
<p>另一个<code>SqlParameterSource</code>实现是<code>BeanPropertySqlParameterSource</code>类。此类包装任意JavaBean（即，遵循<a href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">JavaBean约定</a>的类的实例），并使用包装的JavaBean的属性作为命名参数值的来源。</p>
</div>
<div class="paragraph">
<p>以下示例显示了典型的JavaBean：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">演员</span> { <span class="directive">private</span> <span class="predefined-type">Long</span> id; <span class="directive">private</span> <span class="predefined-type">String</span> firstName; <span class="directive">private</span> <span class="predefined-type">String</span> lastName; <span class="directive">public</span> <span class="predefined-type">String</span> getFirstName（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .firstName; <span class="directive">public</span> <span class="predefined-type">String</span> getLastName（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .lastName; <span class="directive">public</span> <span class="predefined-type">Long</span> getId（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .id; } <span class="comment">// setters省略了...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例使用<code>NamedParameterJdbcTemplate</code>返回上一示例中显示的类成员的计数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//一些JDBC支持的DAO类......</span>
<span class="directive">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .namedParameterJdbcTemplate = <span class="keyword">new</span> NamedParameterJdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> countOfActors（Actor exampleActor）{ <span class="comment">//注意命名参数如何匹配上面'Actor'类的属性</span> <span class="predefined-type">String</span> sql = <span class="string"><span class="delimiter">“</span> <span class="content">select count（*）from T_ACTOR where first_name =：firstName and last_name =：lastName</span> <span class="delimiter">”</span></span> ; SqlParameterSource namedParameters = <span class="keyword">new</span> BeanPropertySqlParameterSource（exampleActor）; <span class="keyword">返回</span> <span class="local-variable">此</span> .namedParameterJdbcTemplate.queryForObject（sql，namedParameters， <span class="predefined-type">Integer</span> .class）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请记住， <code>NamedParameterJdbcTemplate</code>类包装了一个经典的<code>JdbcTemplate</code>模板。如果需要访问包装的<code>JdbcTemplate</code>实例以访问仅存在于<code>JdbcTemplate</code>类中的功能，则可以使用<code>getJdbcOperations()</code>方法通过<code>JdbcOperations</code>接口访问包装的<code>JdbcTemplate</code> 。</p>
</div>
<div class="paragraph">
<p>有关在应用程序上下文中使用<code>NamedParameterJdbcTemplate</code>类的指导，另请参阅<a href="#jdbc-JdbcTemplate-idioms"><code>JdbcTemplate</code>最佳实践</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SQLExceptionTranslator"><a class="anchor" href="#jdbc-SQLExceptionTranslator"></a> 3.3.3。使用<code>SQLExceptionTranslator</code></h4>
<div class="paragraph">
<p><code>SQLExceptionTranslator</code>是一个由类实现的接口，可以在<code>SQLExceptions</code>和Spring自己的<code>org.springframework.dao.之间进行转换<code>org.springframework.dao.DataAccessException</code> ，与数据访问策略无关。实现可以是通用的（例如，使用JDBC的SQLState代码）或专有的（例如，使用Oracle错误代码）以获得更高的精度。</p>
</div>
<div class="paragraph">
<p><code>SQLErrorCodeSQLExceptionTranslator</code>是默认使用的<code>SQLExceptionTranslator</code>的实现。此实现使用特定供应商代码。它比<code>SQLState</code>实现更精确。错误代码转换基于名为<code>SQLErrorCodes</code>的JavaBean类型类中保存的代码。此类由<code>SQLErrorCodesFactory</code>创建和填充， <code>SQLErrorCodesFactory</code> （顾名思义）是一个工厂，用于根据名为<code>sql-error-codes.xml</code>的配置文件的内容创建<code>SQLErrorCodes</code> 。此文件使用供应商代码填充，并基于从<code>DatabaseProductName</code>获取的<code>DatabaseMetaData</code> 。使用您正在使用的实际数据库的代码。</p>
</div>
<div class="paragraph">
<p><code>SQLErrorCodeSQLExceptionTranslator</code>按以下顺序应用匹配规则：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>由子类实现的任何自定义转换。通常，使用提供的具体<code>SQLErrorCodeSQLExceptionTranslator</code> ，因此该规则不适用。仅当您实际提供了子类实现时才适用。</p>
</li>
<li>
<p><code>SQLExceptionTranslator</code>接口的任何自定义实现，作为<code>SQLErrorCodes</code>类的<code>customSqlExceptionTranslator</code>属性提供。</p>
</li>
<li>
<p>将搜索<code>CustomSQLErrorCodesTranslation</code>类的实例列表（为<code>SQLErrorCodes</code>类的<code>customTranslations</code>属性提供）以查找匹配项。</p>
</li>
<li>
<p>应用错误代码匹配。</p>
</li>
<li>
<p>使用后备翻译器。<code>SQLExceptionSubclassTranslator</code>是默认的回退转换器。如果此转换不可用，则下一个回退转换器是<code>SQLStateSQLExceptionTranslator</code> 。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下， <code>SQLErrorCodesFactory</code>用于定义<code>Error</code>代码和自定义异常转换。从类路径中查找名为<code>sql-error-codes.xml</code>的文件，并根据正在使用的数据库的数据库元数据中的数据库名称查找匹配的<code>SQLErrorCodes</code>实例。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以扩展<code>SQLErrorCodeSQLExceptionTranslator</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">CustomSQLErrorCodesTranslator</span> <span class="directive">扩展</span> SQLErrorCodeSQLExceptionTranslator { <span class="directive">protected</span> DataAccessException customTranslate（ <span class="predefined-type">String</span> task， <span class="predefined-type">String</span> sql， <span class="exception">SQLException</span> sqlex）{ <span class="keyword">if</span> （sqlex.getErrorCode（）==  - <span class="integer">12345</span> ）{ <span class="keyword">return</span> <span class="keyword">new</span> DeadlockLoserDataAccessException（task，sqlex）; } <span class="keyword">return</span> <span class="predefined-constant">null</span> ; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，特定错误代码（ <code>-12345</code> ）被翻译，而其他错误由默认翻译器实现保留。要使用此自定义转换程序，必须通过方法<code>setExceptionTranslator</code>将其传递给<code>JdbcTemplate</code> ，并且必须将此<code>JdbcTemplate</code>用于需要此转换程序的所有数据访问处理。以下示例显示了如何使用此自定义转换器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">公共</span> <span class="type">无效</span>的<span class="predefined-type">setDataSource（DataSource的</span>数据源<span class="comment">）{//创建一个JdbcTemplate并设置数据源</span> <span class="local-variable">此</span> .jdbcTemplate = <span class="keyword">新</span>的JdbcTemplate（）; <span class="local-variable">这个</span> .jdbcTemplate.setDataSource（dataSource）; <span class="comment">//创建自定义转换器并为默认转换查找设置DataSource</span> CustomSQLErrorCodesTranslator tr = <span class="keyword">new</span> CustomSQLErrorCodesTranslator（）; tr.setDataSource（数据源）; <span class="local-variable">这个</span> .jdbcTemplate.setExceptionTranslator（tr）; } <span class="directive">公共</span> <span class="type">无效</span> updateShippingCharge（ <span class="type">长</span>订单ID， <span class="type">长</span> <span class="comment">PCT）{//使用制备的JdbcTemplate此更新</span> <span class="local-variable">此</span> .jdbcTemplate.update（ <span class="string"><span class="delimiter">“</span> <span class="content">更新订单</span> <span class="delimiter">”</span></span> <span class="string"><span class="delimiter">+“</span> <span class="content">设定shipping_charge = shipping_charge *？/ 100</span> <span class="delimiter">“</span></span> + <span class="string"><span class="delimiter">”</span> <span class="content">其中id =？</span><span class="delimiter">“</span></span> ，pct，orderId）;}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>自定义转换器传递一个数据源，以便在<code>sql-error-codes.xml</code>查找错误代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-statements-executing"><a class="anchor" href="#jdbc-statements-executing"></a> 3.3.4。运行语句</h4>
<div class="paragraph">
<p>运行SQL语句只需要很少的代码。您需要一个<code>DataSource</code>和一个<code>JdbcTemplate</code> ，包括设置有方便的方法<code>JdbcTemplate</code> 。以下示例显示了为创建新表的最小但功能齐全的类所需要包含的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。JdbcTemplate</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ExecuteAStatement</span> { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">void</span> doExecute（）{ <span class="local-variable">this</span> .jdbcTemplate.execute（ <span class="string"><span class="delimiter">“</span> <span class="content">create table mytable（id integer，name varchar（100））</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-statements-querying"><a class="anchor" href="#jdbc-statements-querying"></a> 3.3.5。运行查询</h4>
<div class="paragraph">
<p>某些查询方法返回单个值。要从一行检索计数或特定值，请使用<code>queryForObject(..)</code> 。后者将返回的JDBC <code>Type</code>转换为作为参数传入的Java类。如果类型转换无效，则<code>InvalidDataAccessApiUsageException</code> 。以下示例包含两个查询方法，一个用于<code>int</code> ，另一个用于查询<code>String</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。JdbcTemplate</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">RunAQuery</span> { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> getCount（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .jdbcTemplate.queryForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">select count（*）from mytable</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Integer</span> .class）; <span class="directive">public</span> <span class="predefined-type">String</span> getName（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .jdbcTemplate.queryForObject（ <span class="string"><span class="delimiter">“</span> <span class="content">select mytable from mytable</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">String</span> .class）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了单个结果查询方法之外，还有几个方法返回一个列表，其中包含查询返回的每一行的条目。最通用的方法是<code>queryForList(..)</code> ，它返回一个<code>List</code> ，其中每个元素都是一个包含每列的一个条目的<code>Map</code> ，使用列名作为键。如果向前面的示例添加方法以检索所有行的列表，则可能如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;&gt; getList（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .jdbcTemplate.queryForList（ <span class="string"><span class="delimiter">“</span> <span class="content">select * from mytable</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>返回的列表将类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>[{name = Bob，id = 1}，{name = Mary，id = 2}]</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-updates"><a class="anchor" href="#jdbc-updates"></a> 3.3.6。更新数据库</h4>
<div class="paragraph">
<p>以下示例更新某个主键的列：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。JdbcTemplate</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">ExecuteAnUpdate</span> { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">void</span> setName（ <span class="type">int</span> id， <span class="predefined-type">String</span> name）{ <span class="local-variable">this</span> .jdbcTemplate.update（ <span class="string"><span class="delimiter">“</span> <span class="content">update mytable set name =？其中id =？</span><span class="delimiter">“</span></span> ，name，id）;}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，SQL语句具有行参数的占位符。您可以将参数值作为varargs传递，或者作为对象数组传递。因此，您应该在原始包装类中明确地包装原语，或者您应该使用自动装箱。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-auto-genereted-keys"><a class="anchor" href="#jdbc-auto-genereted-keys"></a> 3.3.7。检索自动生成的密钥</h4>
<div class="paragraph">
<p><code>update()</code>方便方法支持检索数据库生成的主键。此支持是JDBC 3.0标准的一部分。有关详细信息，请参阅规范的第13.6章。该方法将<code>PreparedStatementCreator</code>作为其第一个参数，这是指定所需insert语句的方式。另一个参数是<code>KeyHolder</code> ，它包含从更新成功返回时生成的密钥。没有标准的单一方法来创建适当的<code>PreparedStatement</code> （这解释了为什么方法签名就是这样）。以下示例适用于Oracle，但可能无法在其他平台上运行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">final</span> <span class="predefined-type">String</span> INSERT_SQL = <span class="string"><span class="delimiter">“</span> <span class="content">insert into my_test（name）values（？）</span><span class="delimiter">“</span></span> ; <span class="directive">final</span> <span class="predefined-type">String</span> name = <span class="string"><span class="delimiter">”</span> <span class="content">Rob</span> <span class="delimiter">“</span></span> ; KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder（）; jdbcTemplate.update（ <span class="keyword">new</span> PreparedStatementCreator（）{ <span class="directive">public</span> <span class="predefined-type">PreparedStatement</span> createPreparedStatement（ <span class="predefined-type">Connection</span> connection） <span class="directive">抛出</span> <span class="exception">SQLException</span> { <span class="predefined-type">PreparedStatement</span> ps = connection.prepareStatement（INSERT_SQL， <span class="keyword">new</span> <span class="predefined-type">String</span> <span class="type">[]</span> { <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> }）; ps.setString（ <span class="integer">1</span> ，name）; <span class="keyword">return</span> ps;}}，keyHolder）; <span class="comment">// keyHolder.getKey（）现在包含生成的密钥</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-connections"><a class="anchor" href="#jdbc-connections"></a> 3.4。控制数据库连接</h3>
<div class="paragraph">
<p>本节包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-datasource">使用<code>DataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-DataSourceUtils">使用<code>DataSourceUtils</code></a></p>
</li>
<li>
<p><a href="#jdbc-SmartDataSource">实现<code>SmartDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-AbstractDataSource">扩展<code>AbstractDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-SingleConnectionDataSource">使用<code>SingleConnectionDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-DriverManagerDataSource">使用<code>DriverManagerDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-TransactionAwareDataSourceProxy">使用<code>TransactionAwareDataSourceProxy</code></a></p>
</li>
<li>
<p><a href="#jdbc-DataSourceTransactionManager">使用<code>DataSourceTransactionManager</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jdbc-datasource"><a class="anchor" href="#jdbc-datasource"></a> 3.4.1。使用<code>DataSource</code></h4>
<div class="paragraph">
<p>Spring通过<code>DataSource</code>获取与数据库的连接。<code>DataSource</code>是JDBC规范的一部分，是一个通用的连接工厂。它允许容器或框架从应用程序代码中隐藏连接池和事务管理问题。作为开发人员，您无需了解有关如何连接到数据库的详细信息。这是设置数据源的管理员的责任。您最有可能在开发和测试代码时填充这两个角色，但您不必知道如何配置生产数据源。</p>
</div>
<div class="paragraph">
<p>使用Spring的JDBC层时，可以从JNDI获取数据源，也可以使用第三方提供的连接池实现配置自己的数据源。流行的实现是Apache Jakarta Commons DBCP和C3P0。Spring发行版中的实现仅用于测试目的，不提供池。</p>
</div>
<div class="paragraph">
<p>本节使用Spring的<code>DriverManagerDataSource</code>实现，稍后将介绍其他几个实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您应该仅将<code>DriverManagerDataSource</code>类用于测试目的，因为它不提供池，并且在发出多个连接请求时性能很差。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要配置<code>DriverManagerDataSource</code> ：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通常获取JDBC连接时，获取与<code>DriverManagerDataSource</code>连接。</p>
</li>
<li>
<p>指定JDBC驱动程序的完全限定类名，以便<code>DriverManager</code>可以加载驱动程序类。</p>
</li>
<li>
<p>提供不同JDBC驱动程序之间的URL。（有关正确的值，请参阅驱动程序的文档。）</p>
</li>
<li>
<p>提供用户名和密码以连接到数据库。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java中配置<code>DriverManagerDataSource</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource（）; dataSource.setDriverClassName（ <span class="string"><span class="delimiter">“</span> <span class="content">org.hsqldb.jdbcDriver</span> <span class="delimiter">”</span></span> ）; dataSource.setUrl（ <span class="string"><span class="delimiter">“</span> <span class="content">jdbc：hsqldb：hsql：// localhost：</span> <span class="delimiter">”</span></span> ）; dataSource.setUsername（ <span class="string"><span class="delimiter">“</span> <span class="content">sa</span> <span class="delimiter">”</span></span> ）; dataSource.setPassword（ <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ）;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;bean id = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="type">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.jdbc.datasource。DriverManagerDataSource</span> <span class="delimiter">“</span></span> &gt; &lt; <span class="class">property</span> name = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">”</span> <span class="content">username</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> value = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> /&gt; &lt;/ bean&gt; &lt;context：property-placeholder location = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc.properties</span> <span class="delimiter">”</span></span> /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来的两个示例显示了DBCP和C3P0的基本连接和配置。要了解有助于控制池功能的更多选项，请参阅相应连接池实现的产品文档。</p>
</div>
<div class="paragraph">
<p>以下示例显示了DBCP配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;bean id = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="type">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="class">destroy</span> -method = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> &gt; &lt;property name = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">“</span> <span class="content">username</span> <span class="delimiter">”</span></span> value = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> value = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> /&gt; &lt;/ bean&gt; &lt;context：property-placeholder location = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc .properties</span> <span class="delimiter">“</span></span> /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了C3P0配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;bean id = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="type">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">com.mchange.v2.c3p0。ComboPooledDataSource</span> <span class="delimiter">“</span></span> <span class="class">destroy</span> -method = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> &gt; &lt;property name = <span class="string"><span class="delimiter">”</span> <span class="content">driverClass</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.driverClassName}</span> <span class="delimiter">“</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">”</span> <span class="content">jdbcUrl</span> <span class="delimiter">“</span></span> value = <span class="string"><span class="delimiter">”</span> <span class="content">$ {jdbc.url}</span> <span class="delimiter">“</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">“</span> <span class="content">user</span> <span class="delimiter">”</span></span> value = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.username}</span> <span class="delimiter">”</span></span> /&gt; &lt;property name = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> value = <span class="string"><span class="delimiter">“</span> <span class="content">$ {jdbc.password}</span> <span class="delimiter">”</span></span> /&gt; &lt;/ bean&gt; &lt;context：property-placeholder location = <span class="string"><span class="delimiter">“</span> <span class="content">jdbc .properties</span> <span class="delimiter">“</span></span> /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DataSourceUtils"><a class="anchor" href="#jdbc-DataSourceUtils"></a> 3.4.2。使用<code>DataSourceUtils</code></h4>
<div class="paragraph">
<p><code>DataSourceUtils</code>类是一个方便且功能强大的辅助类，它提供<code>static</code>方法以在必要时从JNDI获取连接并关闭连接。它支持线程绑定连接，例如， <code>DataSourceTransactionManager</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SmartDataSource"><a class="anchor" href="#jdbc-SmartDataSource"></a> 3.4.3。实现<code>SmartDataSource</code></h4>
<div class="paragraph">
<p><code>SmartDataSource</code>接口应该由可以提供与关系数据库的连接的类实现。它扩展了<code>DataSource</code>接口，让使用它的类查询是否应该在给定操作后关闭连接。当您知道需要重用连接时，此用法很有效。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-AbstractDataSource"><a class="anchor" href="#jdbc-AbstractDataSource"></a> 3.4.4。扩展<code>AbstractDataSource</code></h4>
<div class="paragraph">
<p><code>AbstractDataSource</code>是Spring的<code>DataSource</code>实现的<code>abstract</code>基类。它实现了所有<code>DataSource</code>实现共有的代码。如果编写自己的<code>DataSource</code>实现，则应扩展<code>AbstractDataSource</code>类。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SingleConnectionDataSource"><a class="anchor" href="#jdbc-SingleConnectionDataSource"></a> 3.4.5。使用<code>SingleConnectionDataSource</code></h4>
<div class="paragraph">
<p><code>SingleConnectionDataSource</code>类是<code>SmartDataSource</code>接口的一个实现，它包装了每次使用后未关闭的单个<code>Connection</code> 。这不是多线程的。</p>
</div>
<div class="paragraph">
<p>如果任何客户端代码在假设池化连接时调用<code>close</code> （如使用持久性工具时），则应将<code>suppressClose</code>属性设置为<code>true</code> 。此设置返回一个封闭物理连接的封闭抑制代理。请注意，您不能再将其强制转换为本机Oracle <code>Connection</code>或类似对象。</p>
</div>
<div class="paragraph">
<p><code>SingleConnectionDataSource</code>主要是一个测试类。例如，它可以在简单的JNDI环境中轻松测试应用程序服务器外部的代码。与<code>DriverManagerDataSource</code> ，它始终重用相同的连接，避免过多创建物理连接。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DriverManagerDataSource"><a class="anchor" href="#jdbc-DriverManagerDataSource"></a> 3.4.6。使用<code>DriverManagerDataSource</code></h4>
<div class="paragraph">
<p><code>DriverManagerDataSource</code>类是标准<code>DataSource</code>接口的实现，它通过bean属性配置普通JDBC驱动程序，并且每次都返回一个新的<code>Connection</code> 。</p>
</div>
<div class="paragraph">
<p>此实现对于Java EE容器外部的测试和独立环境非常有用，可以作为Spring IoC容器中的<code>DataSource</code> bean，也可以与简单的JNDI环境结合使用。池假设<code>Connection.close()</code>调用关闭连接，因此任何<code>DataSource</code> -aware持久性代码都应该工作。但是，即使在测试环境中，使用JavaBean样式的连接池（例如<code>commons-dbcp</code> ）也非常容易，因此使用这样的连接池几乎总是优先于<code>DriverManagerDataSource</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-TransactionAwareDataSourceProxy"><a class="anchor" href="#jdbc-TransactionAwareDataSourceProxy"></a> 3.4.7。使用<code>TransactionAwareDataSourceProxy</code></h4>
<div class="paragraph">
<p><code>TransactionAwareDataSourceProxy</code>是目标<code>DataSource</code>的代理。代理包装目标<code>DataSource</code>以添加对Spring管理的事务的感知。在这方面，它类似于Java EE服务器提供的事务性JNDI <code>DataSource</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">除非必须调用已经存在的代码并传递标准JDBC <code>DataSource</code>接口实现，否则很少需要使用此类。在这种情况下，您仍然可以使用此代码，同时让此代码参与Spring托管事务。通常最好使用更高级别的资源管理抽象编写自己的新代码，例如<code>JdbcTemplate</code>或<code>DataSourceUtils</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.html"><code>TransactionAwareDataSourceProxy</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DataSourceTransactionManager"><a class="anchor" href="#jdbc-DataSourceTransactionManager"></a> 3.4.8。使用<code>DataSourceTransactionManager</code></h4>
<div class="paragraph">
<p><code>DataSourceTransactionManager</code>类是单个JDBC数据源的<code>PlatformTransactionManager</code>实现。它将JDBC连接从指定的数据源绑定到当前正在执行的线程，可能允许每个数据源一个线程连接。</p>
</div>
<div class="paragraph">
<p>需要应用程序代码来通过<code>DataSourceUtils.getConnection(DataSource)</code>而不是Java EE的标准<code>DataSource.getConnection</code>来检索JDBC连接。它会抛出未经检查的<code>org.springframework.dao</code>异常，而不是检查<code>SQLExceptions</code> 。所有框架类（例如<code>JdbcTemplate</code> ）都隐式使用此策略。如果未与此事务管理器一起使用，则查找策略的行为与常见策略完全相同。因此，它可以在任何情况下使用。</p>
</div>
<div class="paragraph">
<p><code>DataSourceTransactionManager</code>类支持自定义隔离级别和超时，这些级别和超时将作为适当的JDBC语句查询超时应用。要支持后者，应用程序代码必须使用<code>JdbcTemplate</code>或为每个创建的语句调用<code>DataSourceUtils.applyTransactionTimeout(..)</code>方法。</p>
</div>
<div class="paragraph">
<p>您可以在单资源情况下使用此实现而不是<code>JtaTransactionManager</code> ，因为它不需要容器支持JTA。如果您坚持所需的连接查找模式，则在两者之间切换只是配置问题。JTA不支持自定义隔离级别。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-advanced-jdbc"><a class="anchor" href="#jdbc-advanced-jdbc"></a> 3.5。JDBC批处理操作</h3>
<div class="paragraph">
<p>如果批量多次调用同一个预准备语句，则大多数JDBC驱动程序都可以提高性能。通过将更新分组到批次中，可以限制到数据库的往返次数。</p>
</div>
<div class="sect3">
<h4 id="jdbc-batch-classic"><a class="anchor" href="#jdbc-batch-classic"></a> 3.5.1。使用<code>JdbcTemplate</code>基本批处理操作</h4>
<div class="paragraph">
<p>您可以通过实现特殊接口<code>BatchPreparedStatementSetter</code>两个方法来完成<code>JdbcTemplate</code>批处理，并将该实现作为<code>batchUpdate</code>方法调用中的第二个参数传递。您可以使用<code>getBatchSize</code>方法提供当前批次的大小。您可以使用<code>setValues</code>方法设置<code>setValues</code>准备语句的参数值。此方法称为您在<code>getBatchSize</code>调用中指定的<code>getBatchSize</code> 。以下示例根据列表中的条目更新<code>actor</code>表，并将整个列表用作批处理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> <span class="type">[]</span> batchUpdate（ <span class="directive">final</span> <span class="predefined-type">List</span> &lt;Actor&gt; actors）{ <span class="keyword">return</span> <span class="local-variable">this</span> .jdbcTemplate.batchUpdate（ <span class="string"><span class="delimiter">“</span> <span class="content">update t_actor set first_name = ?, last_name =？其中id =？</span><span class="delimiter">“</span></span> ， <span class="keyword">new</span> BatchPreparedStatementSetter（）{ <span class="directive">public</span> <span class="type">void</span> setValues（ <span class="predefined-type">PreparedStatement</span> ps， <span class="type">int</span> i） <span class="directive">抛出</span> <span class="exception">SQLException</span> {ps.setString（ <span class="integer">1</span> ，actors.get（i）.getFirstName（））; ps.setString（ <span class="integer">2</span> ，actors.get（i） .getLastName（））; ps.setLong（ <span class="integer">3</span> ，actors.get（i）.getId（）。longValue（））;} <span class="directive">public</span> <span class="type">int</span> getBatchSize（）{ <span class="keyword">return</span> actors.size（）;}}）;} <span class="comment">//。 ..附加方法</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果处理更新流或从文件读取，则可能具有首选批处理大小，但最后一批可能没有该条目数。在这种情况下，您可以使用<code>InterruptibleBatchPreparedStatementSetter</code>接口，该接口允许您在输入源耗尽时中断批处理。<code>isBatchExhausted</code>方法允许您发出批处理结束的信号。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-batch-list"><a class="anchor" href="#jdbc-batch-list"></a> 3.5.2。使用对象列表进行批处理操作</h4>
<div class="paragraph">
<p><code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>提供了另一种提供批量更新的方法。您可以将调用中的所有参数值作为列表提供，而不是实现特殊的批处理接口。框架循环遍历这些值并使用内部预处理语句setter。API会有所不同，具体取决于您是否使用命名参数。对于命名参数，您提供了一个<code>SqlParameterSource</code>数组，该批处理的每个成员都有一个条目。您可以使用<code>SqlParameterSourceUtils.createBatch</code>方便方法来创建此数组，传入一个bean样式对象数组（使用与参数对应的getter方法）， <code>String</code> -keyed <code>Map</code>实例（包含相应参数作为值），或者混合使用都。</p>
</div>
<div class="paragraph">
<p>以下示例显示使用命名参数的批量更新：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> NamedParameterTemplate namedParameterJdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .namedParameterJdbcTemplate = <span class="keyword">new</span> NamedParameterJdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> <span class="type">[]</span> batchUpdate（ <span class="predefined-type">List</span> &lt;Actor&gt; actors）{ <span class="keyword">return</span> <span class="local-variable">this</span> .namedParameterJdbcTemplate.batchUpdate（ <span class="string"><span class="delimiter">“</span> <span class="content">update t_actor set first_name =：firstName，last_name =：lastName where id =：id</span> <span class="delimiter">”</span></span> ，SqlParameterSourceUtils.createBatch（actors））; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于使用经典的SQL语句<code>?</code> 在占位符中，传入包含具有更新值的对象数组的列表。此对象数组必须在SQL语句中为每个占位符分配一个条目，并且它们的顺序必须与SQL语句中定义的顺序相同。</p>
</div>
<div class="paragraph">
<p>以下示例与前面的示例相同，只是它使用经典JDBC“？“占位符：</p>
</div>
<div class="paragraph">
<p>===</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> <span class="type">[]</span> batchUpdate（ <span class="directive">final</span> <span class="predefined-type">List</span> &lt;Actor&gt; actors）{ <span class="predefined-type">List</span> &lt; <span class="predefined-type">Object</span> <span class="type">[]</span> &gt; batch = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span> &lt; <span class="predefined-type">Object</span> <span class="type">[]</span> &gt;（）; <span class="keyword">for</span> （Actor actor：actors）{ <span class="predefined-type">Object</span> <span class="type">[]</span> values = <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {actor.getFirstName（），actor.getLastName（），actor.getId（）}; batch.add（值）; <span class="keyword">返回</span> <span class="local-variable">此</span> .jdbcTemplate.batchUpdate（ <span class="string"><span class="delimiter">“</span> <span class="content">update t_actor set first_name = ?, last_name =？其中id =？</span><span class="delimiter">“</span></span> ，批处理;;} <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>我们之前描述的所有批处理更新方法都返回一个<code>int</code>数组，其中包含每个批处理条目的受影响行数。JDBC驱动程序报告此计数。如果计数不可用，则JDBC驱动程序返回值<code>-2</code> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，通过在底层<code>PreparedStatement</code>上自动设置值，需要从给定的Java类型派生每个值的相应JDBC类型。虽然这通常很有效，但是存在潜在的问题（例如，使用包含Map的<code>null</code>值）。默认情况下，Spring会在这种情况下调用<code>ParameterMetaData.getParameterType</code> ，这对于JDBC驱动程序来说可能很昂贵。您应该使用最新的驱动程序版本并考虑将<code>spring.jdbc.getParameterType.ignore</code>属性设置为<code>true</code> （作为JVM系统属性或类路径根目录中的<code>spring.properties</code>文件），如果遇到性能问题 - 例如，如Oracle 12c（SPR-16139）所述。</p>
</div>
<div class="paragraph">
<p>或者，您可以考虑通过'BatchPreparedStatementSetter'（如前所示），通过给予基于'List &lt;Object []&gt;'的调用的显式类型数组，通过'registerSqlType'调用来显式指定相应的JDBC类型。自定义'MapSqlParameterSource'实例，或通过'BeanPropertySqlParameterSource'，即使对于空值，也从Java声明的属性类型派生SQL类型。</p>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-batch-multi" class="paragraph">
<p>====多批次批处理操作</p>
</div>
<div class="paragraph">
<p>前面的批量更新示例处理的批量非常大，您希望将它们分成几个较小的批次。您可以通过多次调用<code>batchUpdate</code>方法，使用前面提到的方法执行此操作，但现在有一种更方便的方法。除了SQL语句之外，此方法还包含一个包含参数的对象<code>Collection</code> ，为每个批处理生成的更新数，以及一个<code>ParameterizedPreparedStatementSetter</code>用于设置预准备语句的参数值。框架循环提供的值，并将更新调用分解为指定大小的批处理。</p>
</div>
<div class="paragraph">
<p>以下示例显示批处理更新，批处理大小为100：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="directive">public</span> <span class="type">int</span> <span class="type">[]</span> <span class="type">[]</span> batchUpdate（ <span class="directive">final</span> <span class="predefined-type">Collection</span> &lt;Actor&gt; actors）{ <span class="type">int</span> <span class="type">[]</span> <span class="type">[]</span> updateCounts = jdbcTemplate.batchUpdate（ <span class="string"><span class="delimiter">“</span> <span class="content">update t_actor set first_name = ?, last_name =？其中id =？</span><span class="delimiter">“</span></span> ，actors， <span class="integer">100</span> ， <span class="keyword">new</span> ParameterizedPreparedStatementSetter &lt;Actor&gt;（）{ <span class="directive">public</span> <span class="type">void</span> setValues（ <span class="predefined-type">PreparedStatement</span> ps，Actor argument） <span class="directive">抛出</span> <span class="exception">SQLException</span> {ps.setString（ <span class="integer">1</span> ，argument.getFirstName（））; ps.setString（ <span class="integer">2</span> ，argument.getLastName（ ））; ps.setLong（ <span class="integer">3</span> ，argument.getId（）。longValue（））;}}）; <span class="keyword">返回</span> updateCounts;} <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>此调用的批处理更新方法返回一个<code>int</code>数组数组，其中包含每个批处理的数组条目，其中包含每个更新的受影响行数的数组。顶级数组的长度表示执行的批次数，第二级数组的长度表示该批次中的更新数。每个批次中的更新数量应该是为所有批次提供的批量大小（最后一个批次可能更少），具体取决于提供的更新对象总数。每个更新语句的更新计数是JDBC驱动程序报告的更新计数。如果计数不可用，则JDBC驱动程序返回值<code>-2</code> 。</p>
</div>
<div id="jdbc-simple-jdbc" class="paragraph">
<p>===使用<code>SimpleJdbc</code>类简化JDBC操作</p>
</div>
<div class="paragraph">
<p><code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>类通过利用可通过JDBC驱动程序检索的数据库元数据来提供简化的配置。这意味着您可以更少地预先配置，但如果您希望提供代码中的所有详细信息，则可以覆盖或关闭元数据处理。</p>
</div>
<div id="jdbc-simple-jdbc-insert-1" class="paragraph">
<p>====使用<code>SimpleJdbcInsert</code>插入数据</p>
</div>
<div class="paragraph">
<p>我们首先使用最少量的配置选项查看<code>SimpleJdbcInsert</code>类。您应该在数据访问层的初始化方法中实例化<code>SimpleJdbcInsert</code> 。对于此示例，初始化方法是<code>setDataSource</code>方法。您不需要<code>SimpleJdbcInsert</code>类的子类。相反，您可以使用<code>withTableName</code>方法创建新实例并设置表名。此类的配置方法遵循返回<code>SimpleJdbcInsert</code>实例的<code>fluid</code>样式，该样式允许您链接所有配置方法。以下示例仅使用一种配置方法（稍后我们将显示多个方法的示例）：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcInsert insertActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="local-variable">this</span> .insertActor = <span class="keyword">new</span> SimpleJdbcInsert（dataSource）.withTableName（ <span class="string"><span class="delimiter">“</span> <span class="content">t_actor</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> <span class="type">void</span> add（Actor actor）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; parameters = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（ <span class="integer">3</span> ）; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ，actor.getId（））; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ，actor.getFirstName（））; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ，actor.getLastName（））; insertActor.execute（参数）; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>这里使用的<code>execute</code>方法采用普通的<code>java.utils.Map</code>作为唯一参数。这里要注意的重要事项是，用于<code>Map</code>的键必须与表的列名匹配，如数据库中所定义。这是因为我们读取了元数据来构造实际的insert语句。</p>
</div>
<div id="jdbc-simple-jdbc-insert-2" class="paragraph">
<p>====使用<code>SimpleJdbcInsert</code>检索自动生成的密钥</p>
</div>
<div class="paragraph">
<p>下一个示例使用与前面示例相同的插入，但是，它不是传入<code>id</code> ，而是检索自动生成的键并将其设置在新的<code>Actor</code>对象上。在创建<code>SimpleJdbcInsert</code> ，除了指定表名外，它还使用<code>usingGeneratedKeyColumns</code>方法指定生成的键列的<code>usingGeneratedKeyColumns</code> 。以下清单显示了它的工作原理：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcInsert insertActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="local-variable">this</span> .insertActor = <span class="keyword">new</span> SimpleJdbcInsert（dataSource）.withTableName（ <span class="string"><span class="delimiter">“</span> <span class="content">t_actor</span> <span class="delimiter">”</span></span> ）。usingGeneratedKeyColumns（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> <span class="type">void</span> add（Actor actor）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; parameters = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（ <span class="integer">2</span> ）; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ，actor.getFirstName（））; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ，actor.getLastName（））; <span class="predefined-type">Number</span> newId = insertActor.executeAndReturnKey（参数）; actor.setId（newId.longValue（））; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>使用第二种方法运行插入时的主要区别在于您不将<code>id</code>添加到<code>Map</code> ，并调用<code>executeAndReturnKey</code>方法。这将返回一个<code>java.lang.Number</code>对象与您可以创建在你的领域类使用的数值类型的实例。您不能依赖所有数据库来返回特定的Java类。 <code>java.lang.Number</code>是您可以信赖的基类。如果您有多个自动生成的列或生成的值是非数字的，则可以使用从<code>executeAndReturnKeyHolder</code>方法返回的<code>KeyHolder</code> 。</p>
</div>
<div id="jdbc-simple-jdbc-insert-3" class="paragraph">
<p>====为<code>SimpleJdbcInsert</code>指定列</p>
</div>
<div class="paragraph">
<p>您可以通过使用<code>usingColumns</code>方法指定列名列表来限制插入的列，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcInsert insertActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="local-variable">this</span> .insertActor = <span class="keyword">new</span> SimpleJdbcInsert（dataSource）.withTableName（ <span class="string"><span class="delimiter">“</span> <span class="content">t_actor</span> <span class="delimiter">”</span></span> ）.usingColumns（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ）。usingGeneratedKeyColumns（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> <span class="type">void</span> add（Actor actor）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; parameters = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（ <span class="integer">2</span> ）; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ，actor.getFirstName（））; parameters.put（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ，actor.getLastName（））; <span class="predefined-type">Number</span> newId = insertActor.executeAndReturnKey（参数）; actor.setId（newId.longValue（））; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>插入的执行与您依赖元数据确定要使用的列相同。</p>
</div>
<div id="jdbc-simple-jdbc-parameters" class="paragraph">
<p>====使用<code>SqlParameterSource</code>提供参数值</p>
</div>
<div class="paragraph">
<p>使用<code>Map</code>提供参数值工作正常，但它不是最方便使用的类。Spring提供了几个可以使用的<code>SqlParameterSource</code>接口实现。第一个是<code>BeanPropertySqlParameterSource</code> ，如果你有一个包含你的值的JavaBean兼容类，这是一个非常方便的类。它使用相应的getter方法来提取参数值。以下示例显示如何使用<code>BeanPropertySqlParameterSource</code> ：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcInsert insertActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="local-variable">this</span> .insertActor = <span class="keyword">new</span> SimpleJdbcInsert（dataSource）.withTableName（ <span class="string"><span class="delimiter">“</span> <span class="content">t_actor</span> <span class="delimiter">”</span></span> ）。usingGeneratedKeyColumns（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> <span class="type">void</span> add（Actor actor）{SqlParameterSource parameters = <span class="keyword">new</span> BeanPropertySqlParameterSource（actor）; <span class="predefined-type">Number</span> newId = insertActor.executeAndReturnKey（参数）; actor.setId（newId.longValue（））; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>另一个选项是类似于<code>Map</code>的<code>MapSqlParameterSource</code> ，但提供了一个可以链接的更方便的<code>addValue</code>方法。以下示例显示了如何使用它：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcInsert insertActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="local-variable">this</span> .insertActor = <span class="keyword">new</span> SimpleJdbcInsert（dataSource）.withTableName（ <span class="string"><span class="delimiter">“</span> <span class="content">t_actor</span> <span class="delimiter">”</span></span> ）。usingGeneratedKeyColumns（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> <span class="type">void</span> add（Actor actor）{SqlParameterSource parameters = <span class="keyword">new</span> MapSqlParameterSource（）。addValue（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ，actor.getFirstName（））。addValue（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ，actor.getLastName（））; <span class="predefined-type">Number</span> newId = insertActor.executeAndReturnKey（参数）; actor.setId（newId.longValue（））; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>如您所见，配置是相同的。只有执行代码必须更改才能使用这些替代输入类。</p>
</div>
<div id="jdbc-simple-jdbc-call-1" class="paragraph">
<p>====使用<code>SimpleJdbcCall</code>调用存储过程</p>
</div>
<div class="paragraph">
<p><code>SimpleJdbcCall</code>类使用数据库中的元数据来查找<code>in</code>和<code>out</code>参数的名称，这样您就不必显式声明它们。如果您愿意这样做，或者如果您有没有自动映射到Java类的参数（例如<code>ARRAY</code>或<code>STRUCT</code> ），则可以声明参数。第一个示例显示了一个简单的过程，该过程仅从MySQL数据库返回<code>VARCHAR</code>和<code>DATE</code>格式的标量值。示例过程读取指定的actor条目，并以<code>out</code>参数的形式返回<code>first_name</code> ， <code>last_name</code>和<code>birth_date</code>列。以下清单显示了第一个示例：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">CREATE</span> <span class="type">PROCEDURE</span> read_actor（ <span class="keyword">IN</span> in_id <span class="predefined-type">INTEGER</span> ，OUT out_last_name <span class="predefined-type">VARCHAR</span> （ <span class="integer">100</span> ），OUT out_last_name <span class="predefined-type">VARCHAR</span> （ <span class="integer">100</span> ），OUT out_birth_date <span class="predefined-type">DATE</span> ） <span class="class">BEGIN</span> <span class="class">SELECT</span> first_name，last_name，birth_date <span class="class">INTO</span> out_first_name，out_last_name，out_birth_date <span class="keyword">FROM</span> t_actor <span class="keyword">where</span> id = in_id; <span class="keyword">结束</span> ;</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>in_id</code>参数包含您正在查找的actor的<code>id</code> 。<code>out</code>参数返回从表中读取的数据。</p>
</div>
<div class="paragraph">
<p>您可以用类似于声明<code>SimpleJdbcCall</code>的方式声明<code>SimpleJdbcInsert</code> 。您应该在数据访问层的初始化方法中实例化和配置类。与<code>StoredProcedure</code>类相比，您无需创建子类，也无需声明可在数据库元数据中查找的参数。以下<code>SimpleJdbcCall</code>配置示例使用前面的存储过程（除了<code>DataSource</code>之外，唯一的配置选项是存储过程的名称）：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcCall procReadActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; <span class="local-variable">这个</span> .procReadActor = <span class="keyword">new</span> SimpleJdbcCall（dataSource）.withProcedureName（ <span class="string"><span class="delimiter">“</span> <span class="content">read_actor</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> Actor readActor（ <span class="predefined-type">Long</span> id）{SqlParameterSource in = <span class="keyword">new</span> MapSqlParameterSource（）。addValue（ <span class="string"><span class="delimiter">“</span> <span class="content">in_id</span> <span class="delimiter">”</span></span> ，id）; <span class="predefined-type">Map</span> out = procReadActor.execute（in）;演员演员= <span class="keyword">新</span>演员（）; actor.setId（ID）; actor.setFirstName（（ <span class="predefined-type">String</span> ）out.get（ <span class="string"><span class="delimiter">“</span> <span class="content">out_first_name</span> <span class="delimiter">”</span></span> ））; actor.setLastName（（ <span class="predefined-type">String</span> ）out.get（ <span class="string"><span class="delimiter">“</span> <span class="content">out_last_name</span> <span class="delimiter">”</span></span> ））; actor.setBirthDate（（ <span class="predefined-type">Date</span> ）out.get（ <span class="string"><span class="delimiter">“</span> <span class="content">out_birth_date</span> <span class="delimiter">”</span></span> ））; <span class="keyword">回归</span>演员; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>为执行调用而编写的代码涉及创建包含IN参数的<code>SqlParameterSource</code> 。您必须将为输入值提供的名称与存储过程中声明的参数名称的名称匹配。该案例不必匹配，因为您使用元数据来确定应如何在存储过程中引用数据库对象。存储过程的源中指定的内容不一定是它存储在数据库中的方式。某些数据库将名称转换为全部大写，而其他数据库使用小写或使用指定的大小写。</p>
</div>
<div class="paragraph">
<p><code>execute</code>方法接受IN参数并返回一个<code>Map</code> ，该<code>Map</code>包含由存储过程中指定的名称键入的任何<code>out</code>参数。在这种情况下，它们是<code>out_first_name</code> ， <code>out_last_name</code>和<code>out_birth_date</code> 。</p>
</div>
<div class="paragraph">
<p><code>execute</code>方法的最后一部分创建一个<code>Actor</code>实例，用于返回检索到的数据。同样，在存储过程中声明它们时，使用<code>out</code>参数的名称很重要。另外，在姓名的情况下<code>out</code>存储在结果地图参数相匹配，所述的<code>out</code>在数据库中的参数名称，这可能数据库之间变化。为了使代码更具可移植性，您应该进行不区分大小写的查找或指示Spring使用<code>LinkedCaseInsensitiveMap</code> 。要执行后者，您可以创建自己的<code>JdbcTemplate</code>并将<code>setResultsMapCaseInsensitive</code>属性设置为<code>true</code> 。然后，您可以将此自定义<code>JdbcTemplate</code>实例传递给<code>SimpleJdbcCall</code>的构造函数。以下示例显示了此配置：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> SimpleJdbcCall procReadActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; jdbcTemplate.setResultsMapCaseInsensitive（ <span class="predefined-constant">true</span> ）; <span class="local-variable">这个</span> .procReadActor = <span class="keyword">new</span> SimpleJdbcCall（jdbcTemplate）.withProcedureName（ <span class="string"><span class="delimiter">“</span> <span class="content">read_actor</span> <span class="delimiter">”</span></span> ）; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>通过采取这一措施，您避免使用您退回的名称冲突的情况下<code>out</code>参数。</p>
</div>
<div id="jdbc-simple-jdbc-call-2" class="paragraph">
<p>====显式声明用于<code>SimpleJdbcCall</code>参数</p>
</div>
<div class="paragraph">
<p>在本章的前面部分，我们描述了如何从元数据中推导出参数，但如果您愿意，可以明确声明它们。您可以通过使用<code>declareParameters</code>方法创建和配置<code>SimpleJdbcCall</code> ，该方法将可变数量的<code>SqlParameter</code>对象作为输入。有关如何定义<code>SqlParameter</code>详细信息，请参阅<a href="#jdbc-params">下一节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用的数据库不是Spring支持的数据库，则必须使用显式声明。目前，Spring支持以下数据库的存储过程调用的元数据查找：Apache Derby，DB2，MySQL，Microsoft SQL Server，Oracle和Sybase。我们还支持MySQL，Microsoft SQL Server和Oracle的存储函数的元数据查找。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以选择显式声明一个，部分或全部参数。在未明确声明参数的情况下，仍会使用参数元数据。要绕过对潜在参数的元数据查找的所有处理并仅使用声明的参数，可以将方法调用<code>withoutProcedureColumnMetaDataAccess</code>作为声明的一部分。假设您为数据库函数声明了两个或多个不同的调用签名。在这种情况下，您调用<code>useInParameterNames</code>来指定要包含给定签名的IN参数名称列表。</p>
</div>
<div class="paragraph">
<p>以下示例显示了完全声明的过程调用，并使用前面示例中的信息：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> SimpleJdbcCall procReadActor; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; jdbcTemplate.setResultsMapCaseInsensitive（ <span class="predefined-constant">true</span> ）; <span class="local-variable">这个</span> .procReadActor = <span class="keyword">new</span> SimpleJdbcCall（jdbcTemplate）.withProcedureName（ <span class="string"><span class="delimiter">“</span> <span class="content">read_actor</span> <span class="delimiter">”</span></span> ）。withoutProcedureColumnMetaDataAccess（）。useInParameterNames（ <span class="string"><span class="delimiter">“</span> <span class="content">in_id</span> <span class="delimiter">”</span></span> ）。declareParameters（ <span class="keyword">new</span> SqlParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">in_id</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Types</span> 。NUMERIC）， <span class="keyword">新的</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">out_first_name</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。VARCHAR）， <span class="keyword">新的</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">out_last_name</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。VARCHAR）， <span class="keyword">新的</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">out_birth_date</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。日期））; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>两个示例的执行和结束结果是相同的。第二个示例明确指定所有详细信息，而不是依赖于元数据。</p>
</div>
<div id="jdbc-params" class="paragraph">
<p>====如何定义<code>SqlParameters</code></p>
</div>
<div class="paragraph">
<p>要为<code>SimpleJdbc</code>类以及RDBMS操作类（在<a href="#jdbc-object">[jdbc-object]中介绍</a> ）定义参数，可以使用<code>SqlParameter</code>或其子类之一。为此，通常在构造函数中指定参数名称和SQL类型。SQL类型是使用<code>java.sql.指定的<code>java.sql.Types</code>常量。在本章前面，我们看到了类似于以下内容的声明：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">新的</span> SqlParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">in_id</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。NUMERIC）， <span class="keyword">新的</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">out_first_name</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。VARCHAR），</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>SqlParameter</code>的第一行声明了一个IN参数。您可以使用IN参数进行存储过程调用和查询，方法是使用<code>SqlQuery</code>及其子类（在<a href="#jdbc-SqlQuery">[jdbc-SqlQuery]中介绍</a> ）。</p>
</div>
<div class="paragraph">
<p>第二行（使用<code>SqlOutParameter</code> ）声明要在存储过程调用中使用的<code>out</code>参数。<code>InOut</code>参数还有一个<code>SqlInOutParameter</code> （为过程提供IN值并且还返回值的参数）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">只有声明为<code>SqlParameter</code>和<code>SqlInOutParameter</code>参数才用于提供输入值。这与<code>StoredProcedure</code>类不同，后者（为了向后兼容性）允许为声明为<code>SqlOutParameter</code>参数提供输入值。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于IN参数，除了名称和SQL类型之外，还可以为自定义数据库类型指定数字数据的比例或类型名称。对于<code>out</code>参数，您可以提供<code>RowMapper</code>来处理从<code>REF</code>游标返回的行的映射。另一个选项是指定一个<code>SqlReturnType</code> ，它提供了定义返回值的自定义处理的机会。</p>
</div>
<div id="jdbc-simple-jdbc-call-3" class="paragraph">
<p>====使用<code>SimpleJdbcCall</code>调用存储函数</p>
</div>
<div class="paragraph">
<p>除了提供函数名称而不是过程名称之外，您可以使用与调用存储过程几乎相同的方式调用存储函数。您可以使用<code>withFunctionName</code>方法作为配置的一部分，以指示您要对函数进行调用，并生成函数调用的相应字符串。专用的执行调用（ <code>executeFunction</code> ）用于执行函数，它将函数返回值作为指定类型的对象返回，这意味着您不必从结果映射中检索返回值。类似的便捷方法（名为<code>executeObject</code> ）也可用于只有一个<code>out</code>参数的存储过程。以下示例（对于MySQL）基于名为<code>get_actor_name</code>的存储函数，该函数返回actor的全名：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">CREATE</span> <span class="type">FUNCTION</span> get_actor_name（in_id <span class="predefined-type">INTEGER</span> ）RETURNS <span class="predefined-type">VARCHAR</span> （ <span class="integer">200</span> ）READS SQL DATA <span class="class">BEGIN</span> DECLARE out_name <span class="predefined-type">VARCHAR</span> （ <span class="integer">200</span> ）; <span class="class">SELECT</span> concat（first_name， <span class="string"><span class="delimiter">'</span> <span class="content"> </span> <span class="delimiter">'</span></span> ，last_name） <span class="class">INTO</span> out_name <span class="keyword">FROM</span> t_actor <span class="keyword">，其中</span> id = in_id; <span class="directive">RETURN</span> out_name; <span class="keyword">结束</span> ;</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>要调用此函数，我们再次在初始化方法中创建<code>SimpleJdbcCall</code> ，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> JdbcTemplate jdbcTemplate; <span class="directive">private</span> SimpleJdbcCall funcGetActorName; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; jdbcTemplate.setResultsMapCaseInsensitive（ <span class="predefined-constant">true</span> ）; <span class="local-variable">这个</span> .funcGetActorName = <span class="keyword">new</span> SimpleJdbcCall（jdbcTemplate）.withFunctionName（ <span class="string"><span class="delimiter">“</span> <span class="content">get_actor_name</span> <span class="delimiter">”</span></span> ）; <span class="directive">public</span> <span class="predefined-type">String</span> getActorName（ <span class="predefined-type">Long</span> id）{SqlParameterSource in = <span class="keyword">new</span> MapSqlParameterSource（）。addValue（ <span class="string"><span class="delimiter">“</span> <span class="content">in_id</span> <span class="delimiter">”</span></span> ，id）; <span class="predefined-type">String</span> name = funcGetActorName.executeFunction（ <span class="predefined-type">String</span> .class，in）; <span class="keyword">返回</span>名称; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>使用的<code>executeFunction</code>方法返回一个<code>String</code> ，该<code>String</code>包含函数调用的返回值。</p>
</div>
<div id="jdbc-simple-jdbc-call-4" class="paragraph">
<p>====从<code>SimpleJdbcCall</code>返回<code>ResultSet</code>或REF游标</p>
</div>
<div class="paragraph">
<p>调用返回结果集的存储过程或函数有点棘手。一些数据库的JDBC结果处理过程中返回结果集，而另一些需要明确注册<code>out</code>参数的特定类型。这两种方法都需要额外的处理来循环结果集并处理返回的行。使用<code>SimpleJdbcCall</code> ，您可以使用<code>returningResultSet</code>方法并声明<code>RowMapper</code>实现用于特定参数。如果在结果处理期间返回结果集，则不会定义任何名称，因此返回的结果必须与声明<code>RowMapper</code>实现的顺序相匹配。指定的名称仍用于将处理的结果列表存储在从<code>execute</code>语句返回的结果映射中。</p>
</div>
<div class="paragraph">
<p>下一个示例（对于MySQL）使用不带IN参数的存储过程，并返回<code>t_actor</code>表中的所有行：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">CREATE</span> <span class="type">PROCEDURE</span> read_all_actors（） <span class="class">BEGIN</span> <span class="class">SELECT</span> a.id，a.first_name，a.last_name，a.birth_date <span class="keyword">FROM</span> t_actor a; <span class="keyword">结束</span> ;</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>要调用此过程，可以声明<code>RowMapper</code> 。因为要映射到的类遵循JavaBean规则，所以可以使用通过传入必需的类来映射到<code>newInstance</code>方法而创建的<code>BeanPropertyRowMapper</code> 。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">JdbcActorDao</span> <span class="directive">实现了</span> ActorDao { <span class="directive">private</span> SimpleJdbcCall procReadAllActors; <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate（dataSource）; jdbcTemplate.setResultsMapCaseInsensitive（ <span class="predefined-constant">true</span> ）; <span class="local-variable">这个</span> .procReadAllActors = <span class="keyword">new</span> SimpleJdbcCall（jdbcTemplate）.withProcedureName（ <span class="string"><span class="delimiter">“</span> <span class="content">read_all_actors</span> <span class="delimiter">”</span></span> ）.returningResultSet（ <span class="string"><span class="delimiter">“</span> <span class="content">actors</span> <span class="delimiter">”</span></span> ，BeanPropertyRowMapper.newInstance（Actor.class））; <span class="directive">public</span> <span class="predefined-type">List</span> getActorsList（）{ <span class="predefined-type">Map</span> m = procReadAllActors.execute（ <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（ <span class="integer">0</span> ））; <span class="keyword">return</span> （ <span class="predefined-type">List</span> ）m.get（ <span class="string"><span class="delimiter">“</span> <span class="content">actors</span> <span class="delimiter">”</span></span> ）; } <span class="comment">// ...其他方法</span> }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>execute</code>调用传入一个空<code>Map</code> ，因为此调用不接受任何参数。然后从结果映射中检索actor列表并返回给调用者。</p>
</div>
<div id="jdbc-object" class="paragraph">
<p>===将JDBC操作建模为Java对象</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jdbc.object</code>包中包含的类允许您以面向对象的方式访问数据库。例如，您可以执行查询并将结果作为包含业务对象的列表返回，其中关系列数据映射到业务对象的属性。您还可以运行存储过程并运行update，delete和insert语句。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>许多Spring开发人员认为下面描述的各种RDBMS操作类（ <a href="#jdbc-StoredProcedure"><code>StoredProcedure</code></a>类除外）通常可以用直接的<code>JdbcTemplate</code>调用替换。通常，编写直接在<code>JdbcTemplate</code>上调用方法的DAO方法（而不是将查询封装为完整的类）更简单。</p>
</div>
<div class="paragraph">
<p>但是，如果您从使用RDBMS操作类获得可测量的值，则应继续使用这些类。</p>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-SqlQuery" class="paragraph">
<p>====了解<code>SqlQuery</code></p>
</div>
<div class="paragraph">
<p><code>SqlQuery</code>是一个可重用的，线程安全的类，它封装了一个SQL查询。子类必须实现<code>newRowMapper(..)</code>方法以提供<code>RowMapper</code>实例，该实例可以通过迭代在查询执行期间创建的<code>ResultSet</code>获得每行创建一个对象。<code>SqlQuery</code>类很少直接使用，因为<code>MappingSqlQuery</code>子类为将行映射到Java类提供了更方便的实现。扩展<code>SqlQuery</code>其他实现是<code>MappingSqlQueryWithParameters</code>和<code>UpdatableSqlQuery</code> 。</p>
</div>
<div id="jdbc-MappingSqlQuery" class="paragraph">
<p>====使用<code>MappingSqlQuery</code></p>
</div>
<div class="paragraph">
<p><code>MappingSqlQuery</code>是一个可重用的查询，其中具体的子类必须实现抽象的<code>mapRow(..)</code>方法，以将提供的<code>ResultSet</code>每一行转换为指定类型的对象。以下示例显示了一个自定义查询，该查询将<code>t_actor</code>关系中的数据映射到<code>Actor</code>类的实例：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ActorMappingQuery</span> <span class="directive">扩展</span> MappingSqlQuery &lt;Actor&gt; { <span class="directive">public</span> ActorMappingQuery（ <span class="predefined-type">DataSource</span> ds）{ <span class="local-variable">super</span> （ds， <span class="string"><span class="delimiter">“</span> <span class="content">select id，first_name，last_name from t_actor where id =？</span><span class="delimiter">“</span></span> ）; declareParameter（ <span class="keyword">new</span> SqlParameter（ <span class="string"><span class="delimiter">”</span> <span class="content">id</span> <span class="delimiter">“</span></span> ， <span class="predefined-type">Types</span> 。整数））;编译（）; } <span class="annotation">@覆盖</span> <span class="directive">保护</span>演员mapRow（ <span class="predefined-type">结果集</span> <span class="type">RS，INT</span> ROWNUMBER） <span class="directive">抛出</span> <span class="exception">的SQLException</span> {演员演员= <span class="keyword">新</span>演员（）; actor.setId（rs.getLong（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ））; actor.setFirstName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">first_name</span> <span class="delimiter">”</span></span> ））; actor.setLastName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">last_name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">回归</span>演员; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>该类扩展了使用<code>Actor</code>类型参数化的<code>MappingSqlQuery</code> 。此客户查询的构造函数将<code>DataSource</code>作为唯一参数。在此构造函数中，您可以使用<code>DataSource</code>和应执行的SQL调用超类上的构造函数来检索此查询的行。此SQL用于创建<code>PreparedStatement</code> ，因此它可能包含在执行期间传递的任何参数的占位符。您必须使用传入<code>SqlParameter</code>的<code>declareParameter</code>方法声明每个参数。<code>SqlParameter</code>采用名称，以及<code>java.sql.定义的JDBC类型<code>java.sql.Types</code> 。定义所有参数后，可以调用<code>compile()</code>方法，以便可以准备并稍后运行该语句。这个类在编译后是线程安全的，因此，只要在初始化DAO时创建这些实例，它们就可以作为实例变量保存并重用。以下示例显示如何定义此类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">私人</span> ActorMappingQuery actorMappingQuery; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> setDataSource（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .actorMappingQuery = <span class="keyword">new</span> ActorMappingQuery（dataSource）; <span class="directive">public</span> Customer getCustomer（ <span class="predefined-type">Long</span> id）{ <span class="keyword">return</span> actorMappingQuery.findObject（id）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的方法使用作为唯一参数传入的<code>id</code>检索客户。由于我们只想返回一个对象，因此我们使用<code>id</code>作为参数调用<code>findObject</code>方法。如果我们改为返回一个对象列表并采用其他参数的查询，我们将使用一个<code>execute</code>方法，该方法将传入的参数值数组作为varargs。以下示例显示了这样一种方法：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">List</span> &lt;Actor&gt; searchForActors（ <span class="type">int</span> age， <span class="predefined-type">String</span> namePattern）{ <span class="predefined-type">List</span> &lt;Actor&gt; actors = actorSearchMappingQuery.execute（age，namePattern）; <span class="keyword">回归</span>演员; }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-SqlUpdate" class="paragraph">
<p>====使用<code>SqlUpdate</code></p>
</div>
<div class="paragraph">
<p><code>SqlUpdate</code>类封装了SQL更新。与查询一样，更新对象是可重用的，并且与所有<code>RdbmsOperation</code>类一样，更新可以具有参数并在SQL中定义。此类提供了许多类似于查询对象的<code>execute(..)</code>方法的<code>update(..)</code>方法。<code>SQLUpdate</code>类是具体的。它可以是子类 - 例如，添加自定义更新方法。但是，您不必为<code>SqlUpdate</code>类创建子类，因为可以通过设置SQL和声明参数来轻松地对其进行参数化。以下示例创建名为<code>execute</code>的自定义更新方法：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.sql。类型</span> ; <span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。SqlParameter</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.object。SqlUpdate</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">UpdateCreditRating</span> <span class="directive">扩展了</span> SqlUpdate { <span class="directive">public</span> UpdateCreditRating（ <span class="predefined-type">DataSource</span> ds）{setDataSource（ds）; setSql（ <span class="string"><span class="delimiter">“</span> <span class="content">更新客户设置credit_rating =？其中id =？</span><span class="delimiter">“</span></span> ）; declareParameter（ <span class="keyword">new</span> SqlParameter（ <span class="string"><span class="delimiter">”</span> <span class="content">creditRating</span> <span class="delimiter">“</span></span> ， <span class="predefined-type">Types</span> 。数字））; declareParameter（ <span class="keyword">new</span> SqlParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Types</span> 。数字））;编译（）; } <span class="comment">/ ** * @param id用于更新客户* @param评级信用评级的新值* @return更新的行数* /</span> <span class="directive">public</span> <span class="type">int</span> execute（ <span class="type">int</span> id， <span class="type">int</span> rating）{ <span class="keyword">return</span> update（rating，id ）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-StoredProcedure" class="paragraph">
<p>====使用<code>StoredProcedure</code></p>
</div>
<div class="paragraph">
<p><code>StoredProcedure</code>类是RDBMS存储过程的对象抽象的超类。这个类是<code>abstract</code> ，它的各种<code>execute(..)</code>方法具有<code>protected</code>访问权限，防止除了通过提供更严格类型的子类之外的其他用途。</p>
</div>
<div class="paragraph">
<p>继承的<code>sql</code>属性是RDBMS中存储过程的名称。</p>
</div>
<div class="paragraph">
<p>要为<code>StoredProcedure</code>类定义参数，可以使用<code>SqlParameter</code>或其子类之一。您必须在构造函数中指定参数名称和SQL类型，如以下代码段所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">新的</span> SqlParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">in_id</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。NUMERIC）， <span class="keyword">新的</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">out_first_name</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">类型</span> 。VARCHAR），</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>使用<code>java.sql.指定SQL类型<code>java.sql.Types</code>常量。</p>
</div>
<div class="paragraph">
<p>第一行（使用<code>SqlParameter</code> ）声明一个IN参数。您可以将IN参数用于存储过程调用和使用<code>SqlQuery</code>及其子类的查询（在<a href="#jdbc-SqlQuery">[jdbc-SqlQuery]中介绍</a> ）。</p>
</div>
<div class="paragraph">
<p>第二行（使用<code>SqlOutParameter</code> ）声明要在存储过程调用中使用的<code>out</code>参数。此外，还有一个<code>SqlInOutParameter</code>为<code>InOut</code>参数（即提供一个参数<code>in</code>的程序值并且还返回一个值）。</p>
</div>
<div class="paragraph">
<p>对于<code>in</code>参数，除了名称和SQL类型之外，还可以为自定义数据库类型指定数字数据的比例或类型名称。对于<code>out</code>参数，您可以提供<code>RowMapper</code>来处理从<code>REF</code>游标返回的行的映射。另一个选项是指定一个<code>SqlReturnType</code> ，它允许您定义返回值的自定义处理。</p>
</div>
<div class="paragraph">
<p>简单DAO的下一个示例使用<code>StoredProcedure</code>来调用函数（ <code>sysdate()</code> ），该函数随任何Oracle数据库一起提供。要使用存储过程功能，您必须创建一个扩展<code>StoredProcedure</code>的类。在此示例中， <code>StoredProcedure</code>类是内部类。但是，如果需要重用<code>StoredProcedure</code> ，可以将其声明为顶级类。此示例没有输入参数，但通过使用<code>SqlOutParameter</code>类将输出参数声明为日期类型。<code>execute()</code>方法运行该过程并从结果<code>Map</code>提取返回的日期。结果<code>Map</code>通过使用参数名称作为键，为每个声明的输出参数（在本例中只有一个）提供了一个条目。以下清单显示了我们的自定义StoredProcedure类：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.sql。类型</span> ; <span class="keyword">import</span> <span class="include">java.util。日期</span> ; <span class="keyword">import</span> <span class="include">java.util。HashMap</span> ; <span class="keyword">import</span> <span class="include">java.util。地图</span> ; <span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation。自动装配</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。SqlOutParameter</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.object。存储过程</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">StoredProcedureDao</span> { <span class="directive">private</span> GetSysdateProcedure getSysdate; <span class="annotation">@Autowired</span> <span class="directive">public</span> <span class="type">void</span> init（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">this</span> .getSysdate = <span class="keyword">new</span> GetSysdateProcedure（dataSource）; <span class="directive">public</span> <span class="predefined-type">Date</span> getSysdate（）{ <span class="keyword">return</span> getSysdate.execute（）; <span class="directive">私有</span> <span class="type">类</span> <span class="class">GetSysdateProcedure</span> <span class="directive">扩展</span> StoredProcedure { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SQL = <span class="string"><span class="delimiter">“</span> <span class="content">sysdate</span> <span class="delimiter">”</span></span> ; <span class="directive">public</span> GetSysdateProcedure（ <span class="predefined-type">DataSource</span> dataSource）{setDataSource（dataSource）; setFunction（ <span class="predefined-constant">true</span> ）; setSql（SQL）; declareParameter（ <span class="keyword">new</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">date</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">Types</span> 。日期））;编译（）; <span class="directive">public</span> <span class="predefined-type">Date</span> execute（）{ <span class="comment">//'sysdate'sproc没有输入参数，因此提供了一个空Map ...</span>
            <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; results = execute（ <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（））; <span class="predefined-type">日期</span> sysdate =（ <span class="predefined-type">日期</span> ）results.get（ <span class="string"><span class="delimiter">“</span> <span class="content">date</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> sysdate; }}}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>以下<code>StoredProcedure</code>示例有两个输出参数（在本例中为Oracle REF游标）：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util。HashMap</span> ; <span class="keyword">import</span> <span class="include">java.util。地图</span> ; <span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">oracle.jdbc。OracleTypes</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。SqlOutParameter</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.object。存储过程</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">TitlesAndGenresStoredProcedure</span> <span class="directive">扩展了</span> StoredProcedure { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SPROC_NAME = <span class="string"><span class="delimiter">“</span> <span class="content">AllTitlesAndGenres</span> <span class="delimiter">”</span></span> ; <span class="directive">public</span> TitlesAndGenresStoredProcedure（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">super</span> （dataSource，SPROC_NAME）; declareParameter（ <span class="keyword">new</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">titles</span> <span class="delimiter">”</span></span> ，OracleTypes。CURSOR， <span class="keyword">新的</span> TitleMapper（）））; declareParameter（ <span class="keyword">new</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">genres</span> <span class="delimiter">”</span></span> ，OracleTypes。CURSOR， <span class="keyword">新的</span> GenreMapper（）））;编译（）; <span class="directive">public</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; execute（）{ <span class="comment">//再次，这个sproc没有输入参数，所以提供一个空的Map</span> <span class="keyword">返回</span> <span class="local-variable">super</span> .execute（ <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（））; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>请注意在<code>TitlesAndGenresStoredProcedure</code>构造函数中使用的<code>declareParameter(..)</code>方法的重载变体是如何传递<code>RowMapper</code>实现实例的。这是重用现有功能的一种非常方便和强大的方法。接下来的两个示例提供了两个<code>RowMapper</code>实现的代码。</p>
</div>
<div class="paragraph">
<p><code>TitleMapper</code>类将<code>ResultSet</code>映射到提供的<code>ResultSet</code>每一行的<code>Title</code>域对象，如下所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.sql。ResultSet</span> ; <span class="keyword">import</span> <span class="include">java.sql。SQLException</span> ; <span class="keyword">import</span> <span class="include">com.foo.domain。标题</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。RowMapper</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">TitleMapper</span> <span class="directive">实现</span> <span class="predefined-type">RowMapper</span> &lt;Title&gt; { <span class="directive">public</span> Title mapRow（ <span class="predefined-type">ResultSet</span> rs， <span class="type">int</span> rowNum） <span class="directive">throws</span> <span class="exception">SQLException</span> {Title title = <span class="keyword">new</span> Title（）; title.setId（rs.getLong（ <span class="string"><span class="delimiter">“</span> <span class="content">id</span> <span class="delimiter">”</span></span> ））; title.setName（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ））; <span class="keyword">回报</span>标题; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>GenreMapper</code>类将<code>ResultSet</code>映射到提供的<code>ResultSet</code>每一行的<code>Genre</code>域对象，如下所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.sql。ResultSet</span> ; <span class="keyword">import</span> <span class="include">java.sql。SQLException</span> ; <span class="keyword">import</span> <span class="include">com.foo.domain。类型</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。RowMapper</span> ; <span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">GenreMapper</span> <span class="directive">实现</span> <span class="predefined-type">RowMapper</span> &lt;Genre&gt; { <span class="directive">public</span> Genre mapRow（ <span class="predefined-type">ResultSet</span> rs， <span class="type">int</span> rowNum） <span class="directive">抛出</span> <span class="exception">SQLException</span> { <span class="keyword">return</span> <span class="keyword">new</span> Genre（rs.getString（ <span class="string"><span class="delimiter">“</span> <span class="content">name</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>要将参数传递给在RDBMS的定义中具有一个或多个输入参数的存储过程，您可以编写一个强类型的<code>execute(..)</code>方法，该方法将委托给超类中的无类型<code>execute(Map)</code>方法，如以下示例显示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.sql。类型</span> ; <span class="keyword">import</span> <span class="include">java.util。日期</span> ; <span class="keyword">import</span> <span class="include">java.util。HashMap</span> ; <span class="keyword">import</span> <span class="include">java.util。地图</span> ; <span class="keyword">import</span> <span class="include">javax.sql。DataSource</span> ; <span class="keyword">import</span> <span class="include">oracle.jdbc。OracleTypes</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。SqlOutParameter</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.core。SqlParameter</span> ; <span class="keyword">import</span> <span class="include">org.springframework.jdbc.object。存储过程</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">TitlesAfterDateStoredProcedure</span> <span class="directive">扩展了</span> StoredProcedure { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SPROC_NAME = <span class="string"><span class="delimiter">“</span> <span class="content">TitlesAfterDate</span> <span class="delimiter">”</span></span> ; <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> CUTOFF_DATE_PARAM = <span class="string"><span class="delimiter">“</span> <span class="content">cutoffDate</span> <span class="delimiter">”</span></span> ; <span class="directive">public</span> TitlesAfterDateStoredProcedure（ <span class="predefined-type">DataSource</span> dataSource）{ <span class="local-variable">super</span> （dataSource，SPROC_NAME）; declareParameter（ <span class="keyword">new</span> SqlParameter（CUTOFF_DATE_PARAM， <span class="predefined-type">Types</span> 。日期）; declareParameter（ <span class="keyword">new</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">titles</span> <span class="delimiter">”</span></span> ，OracleTypes。CURSOR， <span class="keyword">新的</span> TitleMapper（）））;编译（）; <span class="directive">public</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; execute（ <span class="predefined-type">Date</span> cutoffDate）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; inputs = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（）; inputs.put（CUTOFF_DATE_PARAM，cutoffDate）; <span class="keyword">return</span> <span class="local-variable">super</span> .execute（inputs）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-parameter-handling" class="paragraph">
<p>===参数和数据值处理的常见问题</p>
</div>
<div class="paragraph">
<p>Spring Framework的JDBC支持提供的不同方法中存在参数和数据值的常见问题。本节介绍如何解决这些问题。</p>
</div>
<div id="jdbc-type-information" class="paragraph">
<p>====为参数提供SQL类型信息</p>
</div>
<div class="paragraph">
<p>通常，Spring根据传入的参数类型确定参数的SQL类型。可以显式提供设置参数值时要使用的SQL类型。有时需要正确设置<code>NULL</code>值。</p>
</div>
<div class="paragraph">
<p>您可以通过多种方式提供SQL类型信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JdbcTemplate</code>许多更新和查询方法都采用<code>int</code>数组形式的附加参数。此数组用于通过使用<code>java.sql.常量值来指示相应参数的SQL类型<code>java.sql.Types</code>类。为每个参数提供一个条目。</p>
</li>
<li>
<p>您可以使用<code>SqlParameterValue</code>类来包装需要此附加信息的参数值。为此，请为每个值创建一个新实例，并在构造函数中传入SQL类型和参数值。您还可以为数值提供可选的缩放参数。</p>
</li>
<li>
<p>对于使用命名参数的方法，可以使用<code>SqlParameterSource</code>类， <code>BeanPropertySqlParameterSource</code>或<code>MapSqlParameterSource</code> 。它们都具有为任何命名参数值注册SQL类型的方法。</p>
</li>
</ul>
</div>
<div id="jdbc-lob" class="paragraph">
<p>====处理BLOB和CLOB对象</p>
</div>
<div class="paragraph">
<p>您可以在数据库中存储图像，其他二进制数据和大块文本。这些大对象称为二进制数据的BLOB（二进制大对象）和字符数据的CLOB（字符大对象）。在Spring中，您可以直接使用<code>JdbcTemplate</code>处理这些大对象，也可以使用RDBMS Objects和<code>SimpleJdbc</code>类提供的更高抽象。所有这些方法都使用<code>LobHandler</code>接口的实现来实际管理LOB（大对象）数据。
<code>LobHandler</code>通过<code>getLobCreator</code>方法提供对<code>LobCreator</code>类的访问，该方法用于创建要插入的新LOB对象。</p>
</div>
<div class="paragraph">
<p><code>LobCreator</code>和<code>LobHandler</code>为LOB输入和输出提供以下支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BLOB</p>
<div class="ulist">
<ul>
<li>
<p><code>byte[]</code> ： <code>getBlobAsBytes</code>和<code>setBlobAsBytes</code></p>
</li>
<li>
<p><code>InputStream</code> ： <code>getBlobAsBinaryStream</code>和<code>setBlobAsBinaryStream</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>CLOB</p>
<div class="ulist">
<ul>
<li>
<p><code>String</code> ： <code>getClobAsString</code>和<code>setClobAsString</code></p>
</li>
<li>
<p><code>InputStream</code> ： <code>getClobAsAsciiStream</code>和<code>setClobAsAsciiStream</code></p>
</li>
<li>
<p><code>Reader</code> ： <code>getClobAsCharacterStream</code>和<code>setClobAsCharacterStream</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一个示例显示如何创建和插入BLOB。稍后我们将展示如何从数据库中读取它。</p>
</div>
<div class="paragraph">
<p>此示例使用<code>JdbcTemplate</code>和<code>AbstractLobCreatingPreparedStatementCallback</code>的实现。它实现了一个方法<code>setValues</code> 。此方法提供了一个<code>LobCreator</code> ，我们用它来设置SQL insert语句中LOB列的值。</p>
</div>
<div class="paragraph">
<p>对于此示例，我们假设有一个变量<code>lobHandler</code>已经设置为<code>DefaultLobHandler</code>一个实例。您通常通过依赖注入设置此值。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何创建和插入BLOB：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">final</span> <span class="predefined-type">file</span> blobIn = <span class="keyword">new</span> <span class="predefined-type">File</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">spring2004.jpg</span> <span class="delimiter">”</span></span> ）; <span class="directive">final</span> <span class="predefined-type">InputStream</span> blobIs = <span class="keyword">new</span> <span class="predefined-type">FileInputStream</span> （blobIn）; <span class="directive">final</span> <span class="predefined-type">file</span> clobIn = <span class="keyword">new</span> <span class="predefined-type">File</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">large.txt</span> <span class="delimiter">”</span></span> ）; <span class="directive">final</span> <span class="predefined-type">InputStream</span> clobIs = <span class="keyword">new</span> <span class="predefined-type">FileInputStream</span> （clobIn）; <span class="directive">final</span> <span class="predefined-type">InputStreamReader</span> clobReader = <span class="keyword">new</span> <span class="predefined-type">InputStreamReader</span> （clobIs）; jdbcTemplate.execute（ <span class="string"><span class="delimiter">“</span> <span class="content">INSERT INTO lob_table（id，a_clob，a_blob）VALUES（？，？，？）</span><span class="delimiter">“</span></span> ， <span class="keyword">new</span> AbstractLobCreatingPreparedStatementCallback（lobHandler）{ <i class="conum" data-value="1"></i> <b>（1）</b> <span class="directive">保护</span> <span class="type">无效</span> setValues方法<span class="predefined-type">（PreparedStatement的</span> PS，LobCreator的LobCreator的） <span class="directive">抛出</span> <span class="exception">的SQLException</span> <span class="integer"><span class="integer">{ps.setLong（1，1</span>升</span> ）; lobCreator.setClobAsCharacterStream（ps， <span class="integer">2</span> ，clobReader，（ <span class="type">int</span> ）clobIn.length（））; <i class="conum" data-value="2"></i> <b>（2）</b> lobCreator.setBlobAsBinaryStream（ps， <span class="integer">3</span> ，blobIs，（ <span class="type">int</span> ）blobIn.length（））; <i class="conum" data-value="3"></i> <b>（3）</b> }}）; blobIs.close（）; clobReader.close（）;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td><code>lobHandler</code> （在本例中）是一个普通的<code>DefaultLobHandler</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用方法<code>setClobAsCharacterStream</code>传入CLOB的内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用方法<code>setBlobAsBinaryStream</code>传入BLOB的内容。</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">

</div>
</div>
<div class="paragraph">
<p>如果你调用<code>setBlobAsBinaryStream</code> ， <code>setClobAsAsciiStream</code> ，或<code>setClobAsCharacterStream</code>方法上<code>LobCreator</code>从返回<code>DefaultLobHandler.getLobCreator()</code>您可以选择指定为负值<code>contentLength</code>说法。如果指定的内容长度为负，则<code>DefaultLobHandler</code>使用set-stream方法的JDBC 4.0变体而不使用length参数。否则，它将指定的长度传递给驱动程序。</p>
</div>
<div class="paragraph">
<p>请参阅JDBC驱动程序的文档，该驱动程序用于验证它是否支持在不提供内容长度的情况下流式传输LOB。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>现在是时候从数据库中读取LOB数据了。同样，你使用<code>JdbcTemplate</code>使用相同的实例变量<code>lobHandler</code>和一个参考<code>DefaultLobHandler</code> 。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span> &lt; <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;&gt; l = jdbcTemplate.query（ <span class="string"><span class="delimiter">“</span> <span class="content">select id，a_clob，a_blob from lob_table</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> <span class="predefined-type">RowMapper</span> &lt; <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;&gt;（）{ <span class="directive">public</span> <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; mapRow（ <span class="predefined-type">ResultSet</span> rs ， <span class="type">int</span> i） <span class="directive">抛出</span> <span class="exception">SQLException</span> { <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt; results = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">Object</span> &gt;（）; <span class="predefined-type">String</span> clobText = lobHandler.getClobAsString（rs， <span class="string"><span class="delimiter">“</span> <span class="content">a_clob</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="1"></i> <b>（1）</b> results.put（ <span class="string"><span class="delimiter">“</span> <span class="content">CLOB</span> <span class="delimiter">”</span></span> ，clobText）; <span class="type">byte</span> <span class="type">[]</span> blobBytes = lobHandler.getBlobAsBytes（rs， <span class="string"><span class="delimiter">“</span> <span class="content">a_blob</span> <span class="delimiter">”</span></span> ）; <i class="conum" data-value="2"></i> <b>（2）</b> results.put（ <span class="string"><span class="delimiter">“</span> <span class="content">BLOB</span> <span class="delimiter">”</span></span> ，blobBytes）; <span class="keyword">返回</span>结果; }};</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>使用<code>getClobAsString</code>方法检索CLOB的内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用方法<code>getBlobAsBytes</code>来检索BLOB的内容。</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-in-clause" class="paragraph">
<p>====传入IN子句的值列表</p>
</div>
<div class="paragraph">
<p>SQL标准允许基于包含变量值列表的表达式来选择行。一个典型的例子是<code>select * from T_ACTOR where id in (1, 2, 3)</code> 。JDBC标准对预准备语句不直接支持此变量列表。您不能声明可变数量的占位符。您需要准备好所需占位符数量的多种变体，或者一旦知道需要多少占位符，就需要动态生成SQL字符串。<code>NamedParameterJdbcTemplate</code>和<code>JdbcTemplate</code>提供的命名参数支持采用后一种方法。您可以将值作为<code>java.util.传递<code>java.util.原始对象List</code> 。此列表用于插入所需的占位符，并在语句执行期间传入值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">传递许多值时要小心。JDBC标准不保证您可以<code>in</code>表达式列表中使用100个以上的值。各种数据库超过此数量，但它们通常对允许的值有多少硬性限制。例如，Oracle的限制为1000。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除了值列表中的原始值之外，您还可以创建<code>java.util.对象数组List</code> 。此列表可以支持为<code>in</code>子句定义的多个表达式，例如<code>select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2, 'Harrop'\))</code> 。当然，这要求您的数据库支持此语法。</p>
</div>
<div id="jdbc-complex-types" class="paragraph">
<p>====处理存储过程调用的复杂类型</p>
</div>
<div class="paragraph">
<p>调用存储过程时，有时可以使用特定于数据库的复杂类型。为了适应这些类型，Spring提供了一个<code>SqlReturnType</code>用于在它们作为参数传递给存储过程时从存储过程调用和<code>SqlTypeValue</code>返回时处理它们。</p>
</div>
<div class="paragraph">
<p><code>SqlReturnType</code>接口有一个必须实现的方法（名为<code>getTypeValue</code> ）。此接口用作<code>SqlOutParameter</code>声明的<code>SqlOutParameter</code> 。以下示例显示返回声明类型为<code>ITEM_TYPE</code>的用户的Oracle <code>STRUCT</code>对象的值：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">TestItemStoredProcedure</span> <span class="directive">扩展了</span> StoredProcedure { <span class="directive">public</span> TestItemStoredProcedure（ <span class="predefined-type">DataSource</span> dataSource）{...declareParameter（ <span class="keyword">new</span> SqlOutParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">item</span> <span class="delimiter">”</span></span> ，OracleTypes。STRUCT， <span class="string"><span class="delimiter">“</span> <span class="content">ITEM_TYPE</span> <span class="delimiter">”</span></span> ， <span class="keyword">新的</span> SqlReturnType（）{ <span class="directive">public</span> <span class="predefined-type">Object</span> getTypeValue（ <span class="predefined-type">CallableStatement</span> cs， <span class="type">int</span> colIndx， <span class="type">int</span> sqlType， <span class="predefined-type">String</span> typeName） <span class="directive">抛出</span> <span class="exception">SQLException</span> {STRUCT struct =（STRUCT）cs.getObject（colIndx）; <span class="predefined-type">Object</span> <span class="type">[]</span> attr = struct.getAttributes（）; TestItem item = <span class="keyword">new</span> TestItem（）; item.setId（（（ <span class="predefined-type">Number</span> ）attr [ <span class="integer">0</span> ]）。longValue（））; item.setDescription（（ <span class="predefined-type">String</span> ）attr [ <span class="integer">1</span> ]）; item.setExpirationDate（（java.util中。日期）attr [ <span class="integer">2</span> ]）; <span class="keyword">退货</span> ; }））; ...}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>您可以使用<code>SqlTypeValue</code>将Java对象（例如<code>TestItem</code> ）的值传递给存储过程。<code>SqlTypeValue</code>接口有一个必须实现的方法（名为<code>createTypeValue</code> ）。传入活动连接，您可以使用它来创建特定于数据库的对象，例如<code>StructDescriptor</code>实例或<code>ArrayDescriptor</code>实例。以下示例创建<code>StructDescriptor</code>实例：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">final</span> TestItem testItem = <span class="keyword">new</span> TestItem（ <span class="integer">123L</span> ， <span class="string"><span class="delimiter">“</span> <span class="content">A test item</span> <span class="delimiter">”</span></span> ， <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">yyyy-Md</span> <span class="delimiter">”</span></span> ）。parse（ <span class="string"><span class="delimiter">“</span> <span class="content">2010-12-31</span> <span class="delimiter">”</span></span> ））; SqlTypeValue value = <span class="keyword">new</span> AbstractSqlTypeValue（）{ <span class="directive">protected</span> <span class="predefined-type">Object</span> createTypeValue（ <span class="predefined-type">Connection</span> conn， <span class="type">int</span> sqlType， <span class="predefined-type">String</span> typeName） <span class="directive">throws</span> <span class="exception">SQLException</span> {StructDescriptor itemDescriptor = <span class="keyword">new</span> StructDescriptor（typeName，conn）; <span class="predefined-type">Struct</span> item = <span class="keyword">new</span> STRUCT（itemDescriptor，conn， <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {testItem.getId（），testItem.getDescription（）， <span class="keyword">new</span> java.sql。日期（testItem.getExpirationDate（）。getTime（））}）; <span class="keyword">退货</span> ; }};</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>您现在可以将此<code>SqlTypeValue</code>添加到包含存储过程的<code>execute</code>调用的输入参数的<code>Map</code> 。</p>
</div>
<div class="paragraph">
<p><code>SqlTypeValue</code>另一个用途是将值数组传递给Oracle存储过程。Oracle有自己的内部<code>ARRAY</code>类，在这种情况下必须使用它，您可以使用<code>SqlTypeValue</code>创建Oracle <code>ARRAY</code>的实例并使用Java <code>ARRAY</code>值填充它，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">final</span> <span class="predefined-type">Long</span> <span class="type">[]</span> ids = <span class="keyword">new</span> <span class="predefined-type">Long</span> <span class="type">[]</span> { <span class="integer">1L</span> ， <span class="integer">2L</span> }; SqlTypeValue value = <span class="keyword">new</span> AbstractSqlTypeValue（）{ <span class="directive">protected</span> <span class="predefined-type">Object</span> createTypeValue（ <span class="predefined-type">Connection</span> conn， <span class="type">int</span> sqlType， <span class="predefined-type">String</span> typeName） <span class="directive">抛出</span> <span class="exception">SQLException</span> {ArrayDescriptor arrayDescriptor = <span class="keyword">new</span> ArrayDescriptor（typeName，conn）; ARRAY idArray = <span class="keyword">new</span> ARRAY（arrayDescriptor，conn，ids）; <span class="keyword">return</span> idArray; }};</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-embedded-database-support" class="paragraph">
<p>===嵌入式数据库支持</p>
</div>
<div class="paragraph">
<p><code>org.springframework.jdbc.datasource.embedded</code>包提供对嵌入式Java数据库引擎的支持。本机提供对<a href="http://www.hsqldb.org">HSQL</a> ， <a href="http://www.h2database.com">H2</a>和<a href="http://db.apache.org/derby">Derby的</a>支持。您还可以使用可扩展API来插入新的嵌入式数据库类型和<code>DataSource</code>实现。</p>
</div>
<div id="jdbc-why-embedded-database" class="paragraph">
<p>====为什么要使用嵌入式数据库？</p>
</div>
<div class="paragraph">
<p>嵌入式数据库在项目的开发阶段非常有用，因为它具有轻量级特性。优点包括易于配置，快速启动时间，可测试性以及在开发过程中快速发展SQL的能力。</p>
</div>
<div id="jdbc-embedded-database-xml" class="paragraph">
<p>====使用Spring XML创建嵌入式数据库</p>
</div>
<div class="paragraph">
<p>如果要在Spring <code>ApplicationContext</code>中将嵌入式数据库实例公开为bean，可以在<code>spring-jdbc</code>命名空间中使用<code>embedded-database</code>标记：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jdbc：embedded-database</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">generate-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：schema.sql</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：test-data.sql</span> <span class="delimiter">”</span></span> <span class="tag">/ &gt;</span> <span class="tag">&lt;/ jdbc：embedded-database&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>上述配置创建一个填充了来自SQL嵌入式HSQL数据库<code>schema.sql</code>和<code>test-data.sql</code>在类路径的根资源。此外，作为最佳实践，将为嵌入式数据库分配唯一生成的名称。嵌入式数据库作为<code>javax.sql.类型的bean可用于Spring容器<code>javax.sql.然后可以根据需要将DataSource</code>注入数据访问对象。</p>
</div>
<div id="jdbc-embedded-database-java" class="paragraph">
<p>====以编程方式创建嵌入式数据库</p>
</div>
<div class="paragraph">
<p><code>EmbeddedDatabaseBuilder</code>类提供了一个流畅的API，用于以编程方式构建嵌入式数据库。当您需要在独立环境或独立集成测试中创建嵌入式数据库时，可以使用此方法，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">EmbeddedDatabase分贝= <span class="keyword">新</span> EmbeddedDatabaseBuilder（）.generateUniqueName（ <span class="predefined-constant">真</span> ）.setType（H2）.setScriptEncoding（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“UTF-8”）.ignoreFailedDrops（</span></span></span></span> <span class="predefined-constant">真</span> ）.addScript（ <span class="string"><span class="content"><span class="delimiter">“schema.sql</span>文件</span> <span class="delimiter">”）.addScripts（</span></span> <span class="string"><span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="delimiter">“user_data.sql”，“</span></span></span></span></span> <span class="content">country_data.sql</span> <span class="delimiter">“</span></span> ）。build（）; <span class="comment">//对db执行操作（EmbeddedDatabase扩展javax.sql。数据源）</span> db.shutdown（）</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>有关所有支持选项的更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html">Javadoc for <code>EmbeddedDatabaseBuilder</code></a> 。</p>
</div>
<div class="paragraph">
<p>您还可以使用<code>EmbeddedDatabaseBuilder</code>通过Java配置创建嵌入式数据库，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">DataSourceConfig</span> <span class="annotation">{@Bean</span> <span class="directive">公共</span> <span class="predefined-type">数据源</span>数据源（）{ <span class="keyword">返回</span> <span class="keyword">新</span> EmbeddedDatabaseBuilder（）.generateUniqueName（ <span class="predefined-constant">真</span> ）.setType（H2）.setScriptEncoding（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“UTF-8”）.ignoreFailedDrops（</span></span></span></span> <span class="predefined-constant">真</span> <span class="string"><span class="content"><span class="delimiter">）.addScript（“schema.sql</span>文件</span> <span class="delimiter">“</span></span> ）。addScripts（ <span class="string"><span class="delimiter">”</span> <span class="content">user_data.sql</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">country_data.sql</span> <span class="delimiter">“</span></span> ）。build（）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-embedded-database-types" class="paragraph">
<p>====选择嵌入式数据库类型</p>
</div>
<div class="paragraph">
<p>本节介绍如何选择Spring支持的三个嵌入式数据库之一。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-embedded-database-using-HSQL">[JDBC的嵌入式数据库使用-HSQL]</a></p>
</li>
<li>
<p><a href="#jdbc-embedded-database-using-H2">[JDBC的嵌入式数据库使用-H2]</a></p>
</li>
<li>
<p><a href="#jdbc-embedded-database-using-Derby">[JDBC的嵌入式数据库使用-德比]</a></p>
</li>
</ul>
</div>
<div id="jdbc-embedded-database-using-HSQL" class="paragraph">
<p>=====使用HSQL</p>
</div>
<div class="paragraph">
<p>Spring支持HSQL 1.8.0及更高版本。如果未明确指定类型，HSQL是默认的嵌入式数据库。要显式指定HSQL，请将<code>embedded-database</code>标记的<code>type</code>属性设置为<code>HSQL</code> 。如果使用构建器API，请使用<code>setType(EmbeddedDatabaseType)</code>调用<code>setType(EmbeddedDatabaseType)</code>方法<code>EmbeddedDatabaseType.HSQL</code> 。</p>
</div>
<div id="jdbc-embedded-database-using-H2" class="paragraph">
<p>=====使用H2</p>
</div>
<div class="paragraph">
<p>Spring支持H2数据库。要启用H2，请将<code>embedded-database</code>标记的<code>type</code>属性设置为<code>H2</code> 。如果使用构建器API，请使用<code>setType(EmbeddedDatabaseType)</code>调用<code>setType(EmbeddedDatabaseType)</code>方法<code>EmbeddedDatabaseType.H2</code> 。</p>
</div>
<div id="jdbc-embedded-database-using-Derby" class="paragraph">
<p>=====使用Derby</p>
</div>
<div class="paragraph">
<p>Spring支持Apache Derby 10.5及更高版本。要启用Derby，请将<code>embedded-database</code>标记的<code>type</code>属性设置为<code>DERBY</code> 。如果使用构建器API，请使用<code>setType(EmbeddedDatabaseType)</code>调用<code>setType(EmbeddedDatabaseType)</code>方法<code>EmbeddedDatabaseType.DERBY</code> 。</p>
</div>
<div id="jdbc-embedded-database-dao-testing" class="paragraph">
<p>====使用嵌入式数据库测试数据访问逻辑</p>
</div>
<div class="paragraph">
<p>嵌入式数据库提供了一种轻量级的方法来测试数据访下一个示例是使用嵌入式数据库的数据访问集成测试模板。当嵌入式数据库不需要跨测试类重用时，使用这样的模板可以用于一次性。但是，如果您希望创建在测试套件中共享的嵌入式数据库，请考虑使用<a href="testing.html#testcontext-framework">Spring TestContext Framework</a>并将嵌入式数据库配置为Spring <code>ApplicationContext</code>的bean，如<a href="#jdbc-embedded-database-xml">[jdbc-embedded-database-xml]</a>和<a href="#jdbc-embedded-database-java">[</a> <a href="#jdbc-embedded-database-xml">jdbc-embedded-database-xml]中所述。</a> <a href="#jdbc-embedded-database-java">jdbc-embedded-database-java]</a> 。以下清单显示了测试模板：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DataAccessIntegrationTestTemplate</span> { <span class="directive">private</span> EmbeddedDatabase db; <span class="annotation">@Before</span> <span class="directive">public</span> <span class="type">void</span> setUp（）{ <span class="comment">//创建一个从默认脚本填充的HSQL内存数据库</span> <span class="comment">// classpath：schema.sql和classpath：data.sql</span> db = <span class="keyword">new</span> EmbeddedDatabaseBuilder（）。GenerateUniqueName（ <span class="predefined-constant">true</span> ）.addDefaultScripts（）。建立（）; } <span class="annotation">@Test</span> <span class="directive">public</span> <span class="type">void</span> testDataAccess（）{JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate（db）; template.query（ <span class="comment">/ * ...* /</span> ）; <span class="annotation">@After</span> <span class="directive">public</span> <span class="type">void</span> tearDown（）{db.shutdown（）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="jdbc-embedded-database-unique-names" class="paragraph">
<p>====为嵌入式数据库生成唯一名称</p>
</div>
<div class="paragraph">
<p>如果测试套件无意中尝试重新创建同一数据库的其他实例，则开发团队经常会遇到嵌入式数据库的错误。如果XML配置文件或<code>@Configuration</code>类负责创建嵌入式数据库，并且相应的配置随后在同一测试套件中的多个测试场景中重复使用（即，在同一JVM进程中），则可以非常轻松地执行此操作 - 对于例如，针对嵌入式数据库的集成测试，其<code>ApplicationContext</code>配置仅与哪些bean定义配置文件处于活动状态有所不同。</p>
</div>
<div class="paragraph">
<p>导致此类错误的根本原因是，如果没有另外指定，Spring的<code>EmbeddedDatabaseFactory</code> （由<code>&lt;jdbc:embedded-database&gt;</code> XML名称空间元素和<code>EmbeddedDatabaseBuilder</code> for Java配置在内部使用）将嵌入数据库的名称设置为<code>testdb</code> 。对于<code>&lt;jdbc:embedded-database&gt;</code> ，通常会为嵌入式数据库分配一个等于bean的<code>id</code>的名称（通常类似于<code>dataSource</code> ）。因此，后续创建嵌入式数据库的尝试不会产生新的数据库。相反，重用相同的JDBC连接URL，并且尝试创建新的嵌入式数据库实际上指向从相同配置创建的现有嵌入式数据库。</p>
</div>
<div class="paragraph">
<p>为了解决这个常见问题，Spring Framework 4.2支持为嵌入式数据库生成唯一名称。要启用生成的名称，请使用以下选项之一。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName（）</code></p>
</li>
<li>
<p><code>EmbeddedDatabaseBuilder.generateUniqueName（）</code></p>
</li>
<li>
<p><code>&lt;jdbc：embedded-database generate-name =“true”...&gt;</code></p>
</li>
</ul>
</div>
<div id="jdbc-embedded-database-extension" class="paragraph">
<p>====扩展嵌入式数据库支持</p>
</div>
<div class="paragraph">
<p>您可以通过两种方式扩展Spring JDBC嵌入式数据库支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实现<code>EmbeddedDatabaseConfigurer</code>以支持新的嵌入式数据库类型。</p>
</li>
<li>
<p>实现<code>DataSourceFactory</code>以支持新的<code>DataSource</code>实现，例如用于管理嵌入式数据库连接的连接池。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们鼓励您在<a href="https://jira.spring.io/browse/SPR">jira.spring.io</a>上为Spring社区贡献扩展。</p>
</div>
<div id="jdbc-initializing-datasource" class="paragraph">
<p>===初始化<code>DataSource</code></p>
</div>
<div class="paragraph">
<p><code>org.springframework.jdbc.datasource.init</code>包提供对初始化现有<code>DataSource</code>支持。嵌入式数据库支持提供了一个用于为应用程序创建和初始化<code>DataSource</code>选项。但是，您有时可能需要初始化在某个服务器上运行的实例。</p>
</div>
<div id="jdbc-initializing-datasource-xml" class="paragraph">
<p>====使用Spring XML初始化数据库</p>
</div>
<div class="paragraph">
<p>如果要初始化数据库并且可以提供对<code>DataSource</code> bean的引用，可以在<code>spring-jdbc</code>命名空间中使用<code>initialize-database</code>标记：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jdbc：initialize-database</span> <span class="attribute-name">data-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / foo / sql / db-schema.sql</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / foo / sql / db-test-data.sql</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：initialize-database&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>上面的示例针对数据库运行两个指定的脚本。第一个脚本创建一个模式，第二个脚本使用测试数据集填充表。脚本位置也可以是带有通配符的模式，这些通配符用于Spring中的资源（例如， <code>classpath*:/com/foo/**/sql/*-data.sql</code> ）。如果使用模式，脚本将按其URL或文件名的词法顺序运行。</p>
</div>
<div class="paragraph">
<p>数据库初始化程序的默认行为是无条件运行提供的脚本。这可能并不总是您想要的 - 例如，如果您针对已经包含测试数据的数据库运行脚本。通过首先创建表然后插入数据的公共模式（如前所示），减少了意外删除数据的可能性。如果表已经存在，则第一步失败。</p>
</div>
<div class="paragraph">
<p>但是，为了更好地控制现有数据的创建和删除，XML命名空间提供了一些其他选项。第一个是打开和关闭初始化的标志。您可以根据环境设置它（例如从系统属性或环境bean中提取布尔值）。以下示例从系统属性获取值：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jdbc：initialize-database</span> <span class="attribute-name">data-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">enabled</span> = <span class="string"><span class="delimiter">“</span> <span class="content">＃{systemProperties。INITIALIZE_DATABASE}</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：initialize-database&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>从名为<code>INITIALIZE_DATABASE</code>的系统属性获取<code>enabled</code>的值。</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>控制现有数据发生情况的第二个选择是更容忍失败。为此，您可以控制初始化程序忽略它从脚本执行的SQL中的某些错误的能力，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jdbc：initialize-database</span> <span class="attribute-name">data-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="error"><strong></strong></span> <span class="error"></span> <span class="attribute-name">ignore-failures</span> = <span class="string"><span class="delimiter">“</span> <span class="content">DROPS</span> <span class="delimiter">”</span></span> <span class="error"><strong></strong></span> <span class="error"></span> <span class="tag">&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：initialize-database&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>在前面的示例中，我们说我们希望脚本有时会针对空数据库运行，并且脚本中有一些<code>DROP</code>语句因此会失败。因此，失败的SQL <code>DROP</code>语句将被忽略，但其他失败将导致异常。如果您的SQL方言不支持<code>DROP …​ IF EXISTS</code> （或类似），但您希望在重新创建之前无条件地删除所有测试数据，这将非常有用。在这种情况下，第一个脚本通常是一组<code>DROP</code>语句，后跟一组<code>CREATE</code>语句。</p>
</div>
<div class="paragraph">
<p><code>ignore-failures</code>选项可以设置为<code>NONE</code> （默认值）， <code>DROPS</code> （忽略失败的丢弃）或<code>ALL</code> （忽略所有失败）。</p>
</div>
<div class="paragraph">
<p>每个陈述应分开<code>;</code>或者如果是新线<code>;</code>脚本中根本不存在字符。您可以通过脚本控制全局或脚本，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jdbc：initialize-database</span> <span class="attribute-name">data-source</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">separator</span> = <span class="string"><span class="delimiter">“</span> <span class="content">@@</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / myapp / sql / db-schema.sql</span> <span class="delimiter">”</span></span> <span class="attribute-name">separator</span> = <span class="string"><span class="delimiter">“</span> <span class="content">;</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / myapp / sql / db-test-data-1.sql</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;jdbc：script</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：com / myapp / sql / db-test-data -2.sql</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ jdbc：initialize-database&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>将分隔符脚本设置为<code>@@</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将<code>db-schema.sql</code>的分隔符设置为<code>;</code> 。</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>在此示例中，两个<code>test-data</code>脚本使用<code>@@</code>作为语句分隔符，并且只使用<code>db-schema.sql</code> <code>;</code> 。此配置指定缺省分隔符为<code>@@</code>并覆盖<code>db-schema</code>脚本的缺省分隔符。</p>
</div>
<div class="paragraph">
<p>如果您需要比从XML命名空间获得的更多控制，则可以直接使用<code>DataSourceInitializer</code>并将其定义为应用程序中的组件。</p>
</div>
<div id="jdbc-client-component-initialization" class="paragraph">
<p>=====初始化依赖于数据库的其他组件</p>
</div>
<div class="paragraph">
<p>一大类应用程序（那些在Spring上下文启动之后才使用数据库的应用程序）可以使用数据库初始化程序而没有进一步的复杂化。如果您的应用程序不是其中之一，则可能需要阅读本节的其余部分。</p>
</div>
<div class="paragraph">
<p>数据库初始化程序依赖于<code>DataSource</code>实例并运行其初始化回调中提供的脚本（类似于XML bean定义中的<code>init-method</code>方法，组件中的<code>@PostConstruct</code>方法或实现<code>InitializingBean</code>的组件中的<code>afterPropertiesSet()</code>方法<code>afterPropertiesSet()</code> ）。如果其他bean依赖于相同的数据源并在初始化回调中使用数据源，则可能存在问题，因为数据尚未初始化。一个常见的例子是一个缓存，它在应用程序启动时急切地初始化并从数据库加载数据。</p>
</div>
<div class="paragraph">
<p>要解决此问题，您有两种选择：将缓存初始化策略更改为稍后阶段或确保首先初始化数据库初始化程序。</p>
</div>
<div class="paragraph">
<p>如果应用程序在您的控制范围内而不是其他方式，则更改缓存初始化策略可能很容易。关于如何实现这一点的一些建议包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在首次使用时使缓存初始化，这可以缩短应用程序启动时间。</p>
</li>
<li>
<p>使用缓存或初始化缓存的单独组件实现<code>Lifecycle</code>或<code>SmartLifecycle</code> 。当应用程序上下文启动后，可以自动启动<code>SmartLifecycle</code>通过设置它<code>autoStartup</code>标志，你可以手动启动<code>Lifecycle`by calling `ConfigurableApplicationContext.start()</code>在封闭的环境。</p>
</li>
<li>
<p>使用Spring <code>ApplicationEvent</code>或类似的自定义观察器机制来触发缓存初始化。<code>ContextRefreshedEvent</code>总是在上下文准备好使用时发布（在所有bean初始化之后），因此这通常是一个有用的钩子（这就是默认情况下<code>SmartLifecycle</code>工作方式）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保首先初始化数据库初始化程序也很容易。关于如何实现这一点的一些建议包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依赖于Spring <code>BeanFactory</code>的默认行为，即bean按注册顺序初始化。您可以通过采用XML配置中的一组<code>&lt;import/&gt;</code>元素的通用实践来轻松安排，这些元素可以对您的应用程序模块进行排序，并确保首先列出数据库和数据库初始化。</p>
</li>
<li>
<p>将<code>DataSource</code>和使用它的业务组件分开并通过将它们放在单独的<code>ApplicationContext</code>实例中来控制它们的启动顺序（例如，父上下文包含<code>DataSource</code> ，子上下文包含业务组件）。这种结构在Spring Web应用程序中很常见，但可以更普遍地应用。</p>
</li>
</ul>
</div>
<div id="orm" class="paragraph">
<p>==对象关系映射（ORM）数据访问</p>
</div>
<div class="paragraph">
<p>本节介绍使用对象关系映射（ORM）时的数据访问。</p>
</div>
<div id="orm-introduction" class="paragraph">
<p>=== ORM与Spring简介</p>
</div>
<div class="paragraph">
<p>Spring Framework支持与Java Persistence API（JPA）集成，并支持本机Hibernate用于资源管理，数据访问对象（DAO）实现和事务策略。例如，对于Hibernate，有一些一流的支持，具有几个方便的IoC功能，可以解决许多典型的Hibernate集成问题。您可以通过依赖注入为OR（对象关系）映射工具配置所有支持的功能。他们可以参与Spring的资源和事务管理，并且符合Spring的通用事务和DAO异常层次结构。推荐的集成方式是针对普通的Hibernate或JPA API编写DAO代码。</p>
</div>
<div class="paragraph">
<p>在创建数据访问应用程序时，Spring会为您选择的ORM层添加重要的增强功能。您可以根据需要利用尽可能多的集成支持，并且应该将此集成工作与内部构建类似基础架构的成本和风险进行比较。您可以像使用库一样使用大部分ORM支持，无论技术如何，因为所有内容都设计为一组可重用的JavaBean。Spring IoC容器中的ORM有助于配置和部署。因此，本节中的大多数示例都显示了Spring容器内的配置。</p>
</div>
<div class="paragraph">
<p>使用Spring Framework创建ORM DAO的好处包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>更容易测试。</strong> Spring的IoC方法可以轻松交换Hibernate <code>SessionFactory</code>实例，JDBC <code>DataSource</code>实例，事务管理器和映射对象实现（如果需要）的实现和配置位置。这反过来使得单独测试每个与持久性相关的代码变得更加容易。</p>
</li>
<li>
<p><strong>常见数据访问异常。</strong> Spring可以从ORM工具中包装异常，将它们从专有（可能已检查）的异常转换为公共运行时<code>DataAccessException</code>层次结构。此功能允许您处理大多数不可恢复的持久性异常，仅在适当的层中处理，而不会产生令人讨厌的样板捕获，抛出和异常声明。您仍然可以根据需要捕获和处理异常。请记住，JDBC异常（包括特定于DB的方言）也会转换为相同的层次结构，这意味着您可以在一致的编程模型中使用JDBC执行某些操作。</p>
</li>
<li>
<p><strong>一般资源管理。</strong> Spring应用程序上下文可以处理Hibernate <code>SessionFactory</code>实例，JPA <code>EntityManagerFactory</code>实例，JDBC <code>DataSource</code>实例和其他相关资源的位置和配置。这使得这些值易于管理和更改。Spring提供高效，简单和安全的持久性资源处理。例如，使用Hibernate的相关代码通常需要使用相同的Hibernate <code>Session</code>来确保效率和正确的事务处理。Spring通过Hibernate <code>SessionFactory</code>公开当前<code>Session</code> ，可以轻松地透明地创建<code>Session</code>并将其绑定到当前线程。因此，Spring解决了许多典型Hibernate使用的慢性问题，适用于任何本地或JTA事务环境。</p>
</li>
<li>
<p><strong>综合交易管理。</strong> 您可以通过<code>@Transactional</code>注释或通过在XML配置文件中显式配置事务AOP建议，使用声明性，面向方面编程（AOP）样式方法拦截器包装ORM代码。在这两种情况下，都会为您处理事务语义和异常处理（回滚等）。如<a href="#orm-resource-mngmnt">[orm-resource-mngmnt]中所述</a> ，您还可以交换各种事务管理器，而不会影响与ORM相关的代码。例如，您可以使用两种方案中可用的相同完整服务（例如声明性事务）在本地事务和JTA之间进行交换。此外，与JDBC相关的代码可以与您用于执行ORM的代码进行事务性完全集成。这对于不适合ORM的数据访问（例如批处理和BLOB流）很有用，但仍需要与ORM操作共享公共事务。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关更全面的ORM支持，包括对MongoDB等替代数据库技术的支持，您可能需要查看<a href="http://projects.spring.io/spring-data/">Spring Data</a>项目套件。如果您是JPA用户，则<a href="https://spring.io" class="bare">https://spring.io上</a>的“ <a href="https://spring.io/guides/gs/accessing-data-jpa/">入门使用JPA访问数据”</a>指南提供了很好的介绍。
</td>
</tr>
</table>
</div>
<div id="orm-general" class="paragraph">
<p>===一般ORM集成注意事项</p>
</div>
<div class="paragraph">
<p>本节重点介绍适用于所有ORM技术的注意事项。<a href="#orm-hibernate">[orm-hibernate]</a>部分提供了更多详细信息，并在具体上下文中显示了这些功能和配置。</p>
</div>
<div class="paragraph">
<p>Spring的ORM集成的主要目标是清晰的应用程序分层（使用任何数据访问和事务技术）以及应用程序对象的松散耦合 - 不再需要对数据访问或事务策略的业务服务依赖性，不再需要硬编码的资源查找，更难以替换的单身人士，没有更多的定制服务注册表。目标是使用一种简单而一致的方法来连接应用程序对象，使它们保持可重用性并尽可能避免容器依赖。所有单独的数据访问功能都可以单独使用，但与Spring的应用程序上下文概念很好地集成，提供基于XML的配置和不需要Spring感知的普通JavaBean实例的交叉引用。在典型的Spring应用程序中，许多重要的对象是JavaBeans：数据访问模板，数据访问对象，事务管理器，使用数据访问对象和事务管理器的业务服务，Web视图解析器，使用业务服务的Web控制器等等。</p>
</div>
<div id="orm-resource-mngmnt" class="paragraph">
<p>====资源和交易管理</p>
</div>
<div class="paragraph">
<p>典型的业务应用程序混杂着重复的资源管理代码。许多项目试图发明自己的解决方案，有时为了方便编程而牺牲正确的故障处理。Spring提出了适当资源处理的简单解决方案，即在JDBC的情况下通过模板化IoC并为ORM技术应用AOP拦截器。</p>
</div>
<div class="paragraph">
<p>基础结构提供适当的资源处理以及将特定API异常适当转换为未经检查的基础结构异常层次结构。Spring引入了DAO异常层次结构，适用于任何数据访问策略。对于直接JDBC， <a href="#jdbc-JdbcTemplate">上一节中</a>提到的<code>JdbcTemplate</code>类提供了连接处理和<code>SQLException</code>到<code>DataAccessException</code>层次结构的正确转换，包括将特定于数据库的SQL错误代码转换为有意义的异常类。对于ORM技术，请参阅<a href="#orm-exception-translation">下一节</a> ，了解如何获得相同的异常转换优势。</p>
</div>
<div class="paragraph">
<p>在事务管理方面， <code>JdbcTemplate</code>类通过各自的Spring事务管理器挂钩Spring事务支持并支持JTA和JDBC事务。对于支持的ORM技术，Spring通过Hibernate和JPA事务管理器以及JTA支持提供Hibernate和JPA支持。有关事务支持的详细信息，请参阅“ <a href="#transaction">事务管理”</a>一章。</p>
</div>
<div id="orm-exception-translation" class="paragraph">
<p>====异常翻译</p>
</div>
<div class="paragraph">
<p>在DAO中使用Hibernate或JPA时，必须决定如何处理持久性技术的本机异常类。DAO抛出<code>HibernateException</code>或<code>PersistenceException</code>的子类，具体取决于技术。这些异常都是运行时异常，不必声明或捕获。您可能还必须处理<code>IllegalArgumentException</code>和<code>IllegalStateException</code> 。这意味着调用者只能将异常视为通常致命的，除非他们想要依赖持久性技术自己的异常结构。如果不将调用者与实现策略联系起来，则无法捕获特定原因（例如乐观锁定失败）。对于强烈基于ORM或不需要任何特殊异常处理（或两者）的应用程序，这种权衡可能是可接受的。但是，Spring允许通过<code>@Repository</code>注释透明地应用异常转换。以下示例（一个用于Java配置，一个用于XML配置）显示如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span> <span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductDaoImpl</span> <span class="comment">在这里</span> <span class="directive">实现</span> ProductDao { <span class="comment">//类体...</span>}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 异常翻译bean后处理器 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.dao.annotation。PersistenceExceptionTranslationPostProcessor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myProductDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">product。ProductDaoImpl</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>后处理器自动查找所有异常转换器（ <code>PersistenceExceptionTranslator</code>接口的实现），并建议所有标记有<code>@Repository</code>注释的bean，以便发现的转换器可以拦截并对引发的异常应用适当的转换。</p>
</div>
<div class="paragraph">
<p>总之，您可以基于普通持久性技术的API和注释实现DAO，同时仍然可以从Spring管理的事务，依赖项注入和Spring的自定义异常层次结构的透明异常转换（如果需要）中受益。</p>
</div>
<div id="orm-hibernate" class="paragraph">
<p>===休眠</p>
</div>
<div class="paragraph">
<p>我们首先在Spring环境中介绍<a href="http://www.hibernate.org/">Hibernate 5</a> ，然后使用它来演示Spring对集成OR映射器的方法。本节详细介绍了许多问题，并展示了DAO实现和事务划分的不同变体。大多数这些模式可以直接转换为所有其他支持的ORM工具。然后，本章后面的部分将介绍其他ORM技术并展示简要示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring Framework 5.0开始，Spring需要Hibernate ORM 4.3或更高版本来支持JPA，甚至需要Hibernate ORM 5.0+来针对本机Hibernate Session API进行编程。请注意，Hibernate团队不再维护5.1之前的任何版本，很可能很快就会专注于5.3+。
</td>
</tr>
</table>
</div>
<div id="orm-session-factory-setup" class="paragraph">
<p>==== Spring容器中的<code>SessionFactory</code>设置</p>
</div>
<div class="paragraph">
<p>为避免将应用程序对象绑定到硬编码资源查找，您可以将资源（例如JDBC <code>DataSource</code>或Hibernate <code>SessionFactory</code> ）定义为Spring容器中的bean。需要访问资源的应用程序对象通过bean引用接收对此类预定义实例的引用，如<a href="#orm-hibernate-straight">下一节</a>中的DAO定义所示。</p>
</div>
<div class="paragraph">
<p>以下摘自XML应用程序上下文定义显示了如何在其上设置JDBC <code>DataSource</code>和Hibernate <code>SessionFactory</code> ：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.apache.commons.dbcp。BasicDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">destroy-method</span> = <span class="string"><span class="delimiter">”</span> <span class="content">close</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">driverClassName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.hsqldb.jdbcDriver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">url</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">jdbc：hsqldb：hsql：// localhost：9001</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">username</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">sa</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">password</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">mySessionFactory</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.hibernate5 。LocalSessionFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myDataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappingResources</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> product.hbm.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">hibernateProperties</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;value&gt;</span> hibernate.dialect = org.hibernate.dialect。HSQLDialect <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>从本地Jakarta Commons DBCP <code>BasicDataSource</code>切换到位于JNDI的<code>DataSource</code> （通常由应用程序服务器管理）只是配置问题，如下例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myDataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">java：comp / env / jdbc / myds</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>您还可以使用Spring的<code>JndiObjectFactoryBean</code> / <code>&lt;jee:jndi-lookup&gt;</code>来访问位于JNDI的<code>SessionFactory</code> ，以检索并公开它。但是，这通常在EJB上下文之外并不常见。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring还提供了<code>LocalSessionFactoryBuilder</code>变体，与<code>@Bean</code>样式配置和程序设置无缝集成（不涉及<code>FactoryBean</code> ）。</p>
</div>
<div class="paragraph">
<p><code>LocalSessionFactoryBean</code>和<code>LocalSessionFactoryBuilder</code>支持后台引导，Hibernate初始化与给定引导执行程序（例如<code>SimpleAsyncTaskExecutor</code> ）上的应用程序引导线程并行运行。在<code>LocalSessionFactoryBean</code> ，这可以通过<code>bootstrapExecutor</code>属性获得。在程序化的<code>LocalSessionFactoryBuilder</code> ，有一个重载的<code>buildSessionFactory</code>方法，它接受一个bootstrap executor参数。</p>
</div>
<div class="paragraph">
<p>从Spring Framework 5.1开始，这样的本机Hibernate设置还可以在本机Hibernate访问旁边公开JPA <code>EntityManagerFactory</code>以进行标准JPA交互。有关详细信息，请参阅<a href="#orm-jpa-hibernate">JPA的Native Hibernate Setup</a> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div id="orm-hibernate-straight" class="paragraph">
<p>====基于Plain Hibernate API实现DAO</p>
</div>
<div class="paragraph">
<p>Hibernate有一个称为上下文会话的功能，其中Hibernate本身管理每个事务的一个当前<code>Session</code> 。这大致相当于Spring每次事务同步一个Hibernate <code>Session</code> 。相应的DAO实现类似于以下示例，基于普通的Hibernate API：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductDaoImpl</span> <span class="directive">实现</span> ProductDao { <span class="directive">private</span> SessionFactory sessionFactory; <span class="directive">public</span> <span class="type">void</span> setSessionFactory（SessionFactory sessionFactory）{ <span class="local-variable">this</span> .sessionFactory = sessionFactory; <span class="directive">public</span> <span class="predefined-type">Collection</span> loadProductsByCategory（ <span class="predefined-type">String</span> category）{ <span class="keyword">return</span> <span class="local-variable">this</span> .sessionFactory.getCurrentSession（）。createQuery（ <span class="string"><span class="delimiter">“</span> <span class="content">from test.Product product where product.category =？</span><span class="delimiter">“</span></span> ）。setParameter（ <span class="integer">0</span> ，category）.list（）;}}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>除了将<code>SessionFactory</code>在实例变量中之外，此样式类似于Hibernate参考文档和示例的样式。我们强烈建议在Hibernate的CaveatEmptor示例应用程序中使用老式<code>static</code> <code>HibernateUtil</code>类进行基于实例的设置。（一般情况下，除非绝对必要，否则不要将任何资源保留在<code>static</code>变量中。）</p>
</div>
<div class="paragraph">
<p>前面的DAO示例遵循依赖注入模式。它非常适合Spring IoC容器，就像在Spring的<code>HibernateTemplate</code>编码一样。您还可以在普通Java中设置这样的DAO（例如，在单元测试中）。为此，请实例化它并使用所需的工厂引用调用<code>setSessionFactory(..)</code> 。作为Spring bean定义，DAO将类似于以下内容：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myProductDao</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">product。ProductDaoImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mySessionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>这种DAO风格的主要优点是它仅依赖于Hibernate API。不需要导入任何Spring类。从非侵入性的角度来看，这很有吸引力，对Hibernate开发人员来说可能更自然。</p>
</div>
<div class="paragraph">
<p>但是，DAO抛出普通的<code>HibernateException</code> （未经检查，因此不必声明或捕获），这意味着调用者只能将异常视为致命 - 除非他们想要依赖Hibernate自己的异常层次结构。如果不将调用者与实现策略联系起来，则无法捕获特定原因（例如乐观锁定失败）。对于基于Hibernate的强大，不需要任何特殊异常处理或两者兼而有之的应用程序，这种权衡可能是可以接受的。</p>
</div>
<div class="paragraph">
<p>幸运的是，Spring的<code>LocalSessionFactoryBean</code>支持任何Spring事务策略的Hibernate的<code>SessionFactory.getCurrentSession()</code>方法，返回当前Spring管理的事务<code>Session</code> ，即使使用<code>HibernateTransactionManager</code> 。该方法的标准行为仍然是返回与正在进行的JTA事务关联的当前<code>Session</code> （如果有）。无论您使用的是Spring的<code>JtaTransactionManager</code> ，EJB容器管理事务（CMT）还是JTA，此行为都适用。</p>
</div>
<div class="paragraph">
<p>总之，您可以基于普通的Hibernate API实现DAO，同时仍然可以参与Spring管理的事务。</p>
</div>
<div id="orm-hibernate-tx-declarative" class="paragraph">
<p>====声明性交易划分</p>
</div>
<div class="paragraph">
<p>我们建议您使用Spring的声明式事务支持，它允许您使用AOP事务拦截器替换Java代码中的显式事务划分API调用。您可以使用Java注释或XML在Spring容器中配置此事务拦截器。这种声明式事务功能使您可以保持业务服务不受重复的事务划分代码的影响，并专注于添加业务逻辑，这是您的应用程序的真正价值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在您继续之前，我们强烈建议您阅读<a href="#transaction-declarative">声明式事务管理（</a>如果您尚未这样做）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以使用<code>@Transactional</code>注释来注释服务层，并指示Spring容器查找这些注释并为这些带注释的方法提供事务语义。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductServiceImpl</span> <span class="directive">实现</span> ProductService { <span class="directive">private</span> ProductDao productDao; <span class="directive">public</span> <span class="type">void</span> setProductDao（ProductDao productDao）{ <span class="local-variable">this</span> .productDao = productDao; } <span class="annotation">@Transactional</span> <span class="directive">public</span> <span class="type">void</span> increasePriceOfAllProductsInCategory（ <span class="directive">final</span> <span class="predefined-type">String</span> category）{ <span class="predefined-type">List</span> productsToChange = <span class="local-variable">this</span> .productDao.loadProductsByCategory（category）; <span class="comment">// ...</span>} <span class="annotation">@Transactional</span> （readOnly = <span class="predefined-constant">true</span> ） <span class="directive">public</span> <span class="predefined-type">List</span> &lt;Product&gt; findAllProducts（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .productDao.findAllProducts（）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>在容器中，您需要设置<code>PlatformTransactionManager</code>实现（作为bean）和<code>&lt;tx:annotation-driven/&gt;</code>条目，在运行时选择<code>@Transactional</code>处理。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="content">HTTP：/ /www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="content">http://www.springframework.org/schema/tx/spring-tx.xsd</span> <span class="content">http： //www.springframework.org/schema/aop</span> <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  SessionFactory，DataSource等省略 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">transactionManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.hibernate5。HibernateTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;tx：annotation-driven</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myProductService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">product。SimpleProductService</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">productDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myProductDao</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="orm-hibernate-tx-programmatic" class="paragraph">
<p>====程序化事务划分</p>
</div>
<div class="paragraph">
<p>除了跨越任意数量操作的低级数据访问服务之外，您还可以在更高级别的应用程序中划分事务。对周围业务服务的实施也没有限制。它只需要一个Spring <code>PlatformTransactionManager</code> 。同样，后者可以来自任何地方，但最好通过<code>setTransactionManager(..)</code>方法作为bean引用。此外， <code>productDAO</code>应该由<code>setProductDao(..)</code>方法设置。以下一对片段在Spring应用程序上下文中显示事务管理器和业务服务定义，以及业务方法实现的示例：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myTxManager</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.hibernate5。HibernateTransactionManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">sessionFactory</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mySessionFactory</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myProductService</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">product。ProductServiceImpl</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">transactionManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myTxManager</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">productDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myProductDao</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductServiceImpl</span> <span class="directive">实现</span> ProductService { <span class="directive">private</span> TransactionTemplate transactionTemplate; <span class="directive">私人</span>产品道产品道; <span class="directive">public</span> <span class="type">void</span> setTransactionManager（PlatformTransactionManager transactionManager）{ <span class="local-variable">this</span> .transactionTemplate = <span class="keyword">new</span> TransactionTemplate（transactionManager）; <span class="directive">public</span> <span class="type">void</span> setProductDao（ProductDao productDao）{ <span class="local-variable">this</span> .productDao = productDao; <span class="directive">public</span> <span class="type">void</span> increasePriceOfAllProductsInCategory（ <span class="directive">final</span> <span class="predefined-type">String</span> category）{ <span class="local-variable">this</span> .transactionTemplate.execute（ <span class="keyword">new</span> TransactionCallbackWithoutResult（）{ <span class="directive">public</span> <span class="type">void</span> doInTransactionWithoutResult（TransactionStatus status）{ <span class="predefined-type">List</span> productsToChange = <span class="local-variable">this</span> .productDao.loadProductsByCategory（category）; <span class="comment">//做价格上涨......</span>}}; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Spring的<code>TransactionInterceptor</code>允许使用回调代码抛出任何已检查的应用程序异常，而<code>TransactionTemplate</code>仅限于回调中未经检查的异常。如果未经检查的应用程序异常或者事务被应用程序标记为仅回滚（通过设置<code>TransactionStatus</code> ）， <code>TransactionTemplate</code>将触发回滚。默认情况下， <code>TransactionInterceptor</code>行为方式相同，但每个方法允许可配置的回滚策略。</p>
</div>
<div id="orm-hibernate-tx-strategies" class="paragraph">
<p>====交易管理策略</p>
</div>
<div class="paragraph">
<p><code>TransactionTemplate</code>和<code>TransactionInterceptor</code>将实际的事务处理委托给<code>PlatformTransactionManager</code>实例（可以是<code>HibernateTransactionManager</code> （对于单个Hibernate <code>SessionFactory</code> ），通过使用引擎下的<code>ThreadLocal</code> <code>Session</code> ）或<code>JtaTransactionManager</code> （委托给容器的JTA子系统）来进行Hibernate应用。您甚至可以使用自定义的<code>PlatformTransactionManager</code>实现。从本机Hibernate事务管理切换到JTA（例如，当面对应用程序的某些部署的分布式事务要求时）只是配置问题。您可以使用Spring的JTA事务实现替换Hibernate事务管理器。事务划分和数据访问代码都可以无变化地工作，因为它们使用通用事务管理API。</p>
</div>
<div class="paragraph">
<p>对于跨多个Hibernate会话工厂的分布式事务，您可以将<code>JtaTransactionManager</code>作为事务策略与多个<code>LocalSessionFactoryBean</code>定义相结合。然后，每个DAO都会将一个特定的<code>SessionFactory</code>引用传递到其相应的bean属性中。如果所有基础JDBC数据源都是事务性容器，则业务服务可以跨越任意数量的DAO和任意数量的会话工厂划分事务，而无需特别考虑，只要它使用<code>JtaTransactionManager</code>作为策略。</p>
</div>
<div class="paragraph">
<p><code>HibernateTransactionManager</code>和<code>JtaTransactionManager</code>允许使用<code>HibernateTransactionManager</code>进行正确的JVM级缓存处理，无需特定于容器的事务管理器查找或JCA连接器（如果不使用EJB来启动事务）。</p>
</div>
<div class="paragraph">
<p><code>HibernateTransactionManager</code>可以将Hibernate JDBC <code>Connection</code>导出为特定<code>DataSource</code>普通JDBC访问代码。如果您只访问一个数据库，则此功能允许在没有JTA的情况下完全混合Hibernate和JDBC数据访问的高级事务划分。如果您通过<code>LocalSessionFactoryBean</code>类的<code>dataSource</code>属性设置了传入的<code>SessionFactory</code>和<code>DataSource</code> <code>HibernateTransactionManager</code>自动将Hibernate事务公开为JDBC事务。或者，您可以通过<code>HibernateTransactionManager</code>类的<code>dataSource</code>属性显式指定应该为其公开事务的<code>DataSource</code> 。</p>
</div>
<div id="orm-hibernate-resources" class="paragraph">
<p>====比较容器管理和本地定义的资源</p>
</div>
<div class="paragraph">
<p>您可以在容器管理的JNDI <code>SessionFactory</code>和本地定义的JNDI <code>SessionFactory</code>之间切换，而无需更改单行应用程序代码。是将资源定义保留在容器中还是本地保存在应用程序中主要取决于您使用的事务策略。与Spring定义的本地<code>SessionFactory</code> ，手动注册的JNDI <code>SessionFactory</code>不提供任何好处。通过Hibernate的JCA连接器部署<code>SessionFactory</code>提供了参与Java EE服务器管理基础结构的附加价值，但不会增加实际价值。</p>
</div>
<div class="paragraph">
<p>Spring的事务支持不限于容器。使用除JTA之外的任何策略进行配置时，事务支持也可以在独立或测试环境中运行。特别是在单数据库事务的典型情况下，Spring的单资源本地事务支持是JTA的轻量级和强大的替代方案。当您使用本地EJB无状态会话bean来驱动事务时，您既依赖于EJB容器又依赖于JTA，即使您只访问单个数据库并仅使用无状态会话bean来通过容器管理的事务提供声明性事务。以编程方式直接使用JTA还需要Java EE环境。JTA不仅涉及JTA本身和JNDI <code>DataSource</code>实例的容器依赖性。对于非Spring，JTA驱动的Hibernate事务，您必须使用Hibernate JCA连接器或额外的Hibernate事务代码，并为正确的JVM级缓存配置<code>TransactionManagerLookup</code> 。</p>
</div>
<div class="paragraph">
<p>Spring驱动的事务也可以使用本地定义的Hibernate <code>SessionFactory</code>就像它们使用本地JDBC <code>DataSource</code> ，前提是它们访问单个数据库。因此，当您具有分布式事务要求时，只需使用Spring的JTA事务策略。JCA连接器需要特定于容器的部署步骤，并且（显然）首先需要JCA支持。与使用本地资源定义和Spring驱动的事务部署简单Web应用程序相比，此配置需要更多工作。此外，如果使用例如不提供JCA的WebLogic Express，则通常需要容器的Enterprise Edition。具有跨越单个数据库的本地资源和事务的Spring应用程序可在任何Java EE Web容器（无JTA，JCA或EJB）中工作，例如Tomcat，Resin甚至普通Jetty。此外，您可以轻松地在桌面应用程序或测试套件中重用这样的中间层。</p>
</div>
<div class="paragraph">
<p>考虑到所有事情，如果你不使用EJB，坚持使用本地<code>SessionFactory</code>设置和Spring的<code>HibernateTransactionManager</code>或<code>JtaTransactionManager</code> 。您可以获得所有好处，包括正确的事务性JVM级缓存和分布式事务，而不会给容器部署带来不便。通过JCA连接器对Hibernate <code>SessionFactory</code>进行JNDI注册只有在与EJB结合使用时才会增加值。</p>
</div>
<div id="orm-hibernate-invalid-jdbc-access-error" class="paragraph">
<p>==== Hibernate的Spurious Application Server警告</p>
</div>
<div class="paragraph">
<p>在一些具有非常严格的<code>XADataSource</code>实现的JTA环境中（当前只有一些WebLogic Server和WebSphere版本），当配置Hibernate而不考虑该环境的JTA <code>PlatformTransactionManager</code>对象时，虚假警告或异常可以显示在应用程序服务器日志中。这些警告或异常表明正在访问的连接不再有效或JDBC访问不再有效，可能是因为事务不再处于活动状态。例如，以下是WebLogic的实际异常：</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>java.sql中。SQLException：事务不再处于活动状态 - 状态：“已提交”。此事务中不允许进一步的JDBC访问。</pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>您可以通过让Hibernate知道它同步的JTA <code>PlatformTransactionManager</code>实例（以及Spring）来解决此警告。您有两种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果在您的应用程序上下文中，您已经直接获取JTA <code>PlatformTransactionManager</code>对象（可能是从JNDI到<code>JndiObjectFactoryBean</code>或<code>&lt;jee:jndi-lookup&gt;</code> ）并将其提供给Spring的<code>JtaTransactionManager</code> ，最简单的方法是指定对定义此JTA <code>PlatformTransactionManager</code>实例的bean，作为<code>jtaTransactionManager</code>属性的<code>LocalSessionFactoryBean.</code> Spring然后使该对象可用于Hibernate。</p>
</li>
<li>
<p>更有可能的是，您还没有JTA <code>PlatformTransactionManager</code>实例，因为Spring的<code>JtaTransactionManager</code>可以自己找到它。因此，您需要配置Hibernate以直接查找JTA <code>PlatformTransactionManager</code> 。您可以通过在Hibernate配置中配置特定于应用程序服务器的<code>TransactionManagerLookup</code>类来完成此操作，如Hibernate手册中所述。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节的其余部分描述了在Hibernate意识到JTA <code>PlatformTransactionManager</code>情况下发生的事件序列。</p>
</div>
<div class="paragraph">
<p>当Hibernate未配置任何JTA <code>PlatformTransactionManager</code>意识时，JTA事务提交时会发生以下事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JTA事务提交。</p>
</li>
<li>
<p>Spring的<code>JtaTransactionManager</code>与JTA事务同步，因此JTA事务管理器通过<code>afterCompletion</code>回调<code>afterCompletion</code>它。</p>
</li>
<li>
<p>在其他活动中，这种同步可以触发Spring对Hibernate的回调，通过Hibernate的<code>afterTransactionCompletion</code>回调（用于清除Hibernate缓存），然后在Hibernate会话上进行显式的<code>close()</code>调用，这会导致Hibernate尝试<code>close()</code> JDBC连接。</p>
</li>
<li>
<p>在某些环境中，此<code>Connection.close()</code>调用会触发警告或错误，因为应用程序服务器不再认为<code>Connection</code>可用，因为事务已经提交。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当Hibernate配置为了解JTA <code>PlatformTransactionManager</code> ，JTA事务提交时会发生以下事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JTA事务已准备好提交。</p>
</li>
<li>
<p>Spring的<code>JtaTransactionManager</code>与JTA事务同步，因此JTA事务管理器通过<code>beforeCompletion</code>回调调用该事务。</p>
</li>
<li>
<p>Spring意识到Hibernate本身与JTA事务同步，其行为与前一个场景不同。假设Hibernate <code>Session</code>需要完全关闭，Spring现在关闭它。</p>
</li>
<li>
<p>JTA事务提交。</p>
</li>
<li>
<p>Hibernate与JTA事务同步，因此事务由JTA事务管理器通过<code>afterCompletion</code>回调调用，并可以正确清除其缓存。</p>
</li>
</ul>
</div>
<div id="orm-jpa" class="paragraph">
<p>=== JPA</p>
</div>
<div class="paragraph">
<p>Spring JPA在<code>org.springframework.orm.jpa</code>包下提供，以类似于与Hibernate集成的方式提供对<a href="http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html">Java Persistence API的</a>全面支持，同时了解底层实现以提供其他功能。</p>
</div>
<div id="orm-jpa-setup" class="paragraph">
<p>==== Spring环境中JPA安装的三个选项</p>
</div>
<div class="paragraph">
<p>Spring JPA支持提供了三种方法来设置应用程序用来获取实体管理器的JPA <code>EntityManagerFactory</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#orm-jpa-setup-lemfb">[ORM-JPA-设置-lemfb]</a></p>
</li>
<li>
<p><a href="#orm-jpa-setup-jndi">[ORM-JPA-设置-JNDI]</a></p>
</li>
<li>
<p><a href="#orm-jpa-setup-lcemfb">[ORM-JPA-设置-lcemfb]</a></p>
</li>
</ul>
</div>
<div id="orm-jpa-setup-lemfb" class="paragraph">
<p>=====使用<code>LocalEntityManagerFactoryBean</code></p>
</div>
<div class="paragraph">
<p>您只能在简单的部署环境中使用此选项，例如独立应用程序和集成测试。</p>
</div>
<div class="paragraph">
<p><code>LocalEntityManagerFactoryBean</code>创建一个适用于简单部署环境的<code>EntityManagerFactory</code> ，其中应用程序仅使用JPA进行数据访问。工厂bean使用JPA <code>PersistenceProvider</code>自动检测机制（根据JPA的Java SE引导），并且在大多数情况下，要求您仅指定持久性单元名称。以下XML示例配置了这样一个bean：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myEmf</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa。LocalEntityManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">persistenceUnitName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myPersistenceUnit</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>这种形式的JPA部署是最简单和最有限的。您不能引用现有的JDBC <code>DataSource</code> bean定义，也不存在对全局事务的支持。此外，持久化类的编织（字节码转换）是特定于提供者的，通常需要在启动时指定特定的JVM代理。此选项仅适用于为其设计JPA规范的独立应用程序和测试环境。</p>
</div>
<div id="orm-jpa-setup-jndi" class="paragraph">
<p>=====从JNDI获取EntityManagerFactory</p>
</div>
<div class="paragraph">
<p>部署到Java EE服务器时，可以使用此选项。检查服务器的文档，了解如何将自定义JPA提供程序部署到服务器中，从而允许使用与服务器默认提供程序不同的提供程序。</p>
</div>
<div class="paragraph">
<p>从JNDI获取<code>EntityManagerFactory</code> （例如在Java EE环境中），需要更改XML配置，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;jee：jndi-lookup</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myEmf</span> <span class="delimiter">”</span></span> <span class="attribute-name">jndi-name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">persistence / myPersistenceUnit</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>此操作假定标准Java EE引导。Java EE服务器自动检测Java EE部署描述符中的持久性单元（实际上是应用程序jar中的<code>META-INF/persistence.xml</code>文件）和<code>persistence-unit-ref</code>条目（例如， <code>web.xml</code> ）并定义环境命名这些持久性单元的上下文位置。</p>
</div>
<div class="paragraph">
<p>在这种情况下，整个持久性单元部署（包括持久化类的编织（字节码转换））由Java EE服务器决定。JDBC <code>DataSource</code>是通过<code>META-INF/persistence.xml</code>文件中的JNDI位置定义的。
<code>EntityManager</code>事务与服务器的JTA子系统集成在一起。Spring只使用获得的<code>EntityManagerFactory</code> ，通过依赖注入和管理持久性单元的事务（通常通过<code>JtaTransactionManager</code> ）将其传递给应用程序对象。</p>
</div>
<div class="paragraph">
<p>如果在同一个应用程序中使用多个持久性单元，则此类JNDI检索的持久性单元的bean名称应与应用程序用于引用它们的持久性单元名称匹配（例如，在<code>@PersistenceUnit</code>和<code>@PersistenceContext</code>注释中）。</p>
</div>
<div id="orm-jpa-setup-lcemfb" class="paragraph">
<p>=====使用<code>LocalContainerEntityManagerFactoryBean</code></p>
</div>
<div class="paragraph">
<p>您可以在基于Spring的应用程序环境中将此选项用于完整的JPA功能。这包括Web容器（如Tomcat），独立应用程序以及具有复杂持久性要求的集成测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果你想专门配置一个Hibernate设置，一个直接的选择是使用Hibernate 5.2或5.3并设置本机Hibernate <code>LocalSessionFactoryBean</code>而不是普通的JPA <code>LocalContainerEntityManagerFactoryBean</code> ，让它与JPA访问代码以及本机Hibernate访问代码交互。有关详细信息，请参阅<a href="#orm-jpa-hibernate">JPA交互的Native Hibernate设置</a> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>LocalContainerEntityManagerFactoryBean</code>提供对<code>EntityManagerFactory</code>配置的完全控制，适用于需要细粒度自定义的环境。<code>LocalContainerEntityManagerFactoryBean</code>基于<code>persistence.xml</code>文件，提供的<code>dataSourceLookup</code>策略和指定的<code>loadTimeWeaver</code>创建<code>PersistenceUnitInfo</code>实例。因此，可以使用JNDI之外的自定义数据源并控制编织过程。以下示例显示了<code>LocalContainerEntityManagerFactoryBean</code>的典型bean定义：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myEmf</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa。LocalContainerEntityManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">dataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">someDataSource</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">loadTimeWeaver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.instrument.classloading。InstrumentationLoadTimeWeaver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>以下示例显示了典型的<code>persistence.xml</code>文件：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;persistence</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://java.sun.com/xml/ns/persistence</span> <span class="delimiter">”</span></span> <span class="attribute-name">version</span> = <span class="string"><span class="delimiter">“</span> <span class="content">1.0</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;persistence-unit</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myUnit</span> <span class="delimiter">”</span></span> <span class="attribute-name">transaction-type</span> = <span class="string"><span class="delimiter">“</span> <span class="content">RESOURCE_LOCAL</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;mapping-file&gt;</span> META -INF / orm.xml <span class="tag">&lt;/ mapping-file&gt;</span> <span class="tag">&lt;exclude-unlisted-classes</span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ persistence-unit&gt;</span> <span class="tag">&lt;/ persistence&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>&lt;exclude-unlisted-classes/&gt;</code>快捷方式表示不应扫描带注释的实体类。显式的'true'值（ <code>&lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes/&gt;</code> ）也意味着没有扫描。
<code>&lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes/&gt;</code>会触发扫描。但是，如果要进行实体类扫描，我们建议省略<code>exclude-unlisted-classes</code>元素。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用<code>LocalContainerEntityManagerFactoryBean</code>是最强大的JPA设置选项，允许在应用程序中进行灵活的本地配置。它支持指向现有JDBC <code>DataSource</code>链接，支持本地和全局事务等。但是，它还对运行时环境施加了要求，例如，如果持久性提供程序需要字节码转换，则可以使用具有编织功能的类加载器。</p>
</div>
<div class="paragraph">
<p>此选项可能与Java EE服务器的内置JPA功能冲突。在完整的Java EE环境中，请考虑从JNDI获取<code>EntityManagerFactory</code> 。或者，在<code>LocalContainerEntityManagerFactoryBean</code>定义上指定自定义<code>persistenceXmlLocation</code> （例如，META-INF / my-persistence.xml），并在应用程序jar文件中仅包含具有该名称的描述符。由于Java EE服务器仅查找默认的<code>META-INF/persistence.xml</code>文件，因此它会忽略此类自定义持久性单元，因此可以避免与Spring驱动的JPA设置发生冲突。（例如，这适用于Resin 3.1。）</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">何时需要加载时间编织？</div>
<div class="paragraph">
<p>并非所有JPA提供程序都需要JVM代理。Hibernate就是一个没有的例子。如果您的提供程序不需要代理或您有其他选择，例如通过自定义编译器或Ant任务在构建时应用增强功能，则不应使用加载时编织器。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><code>LoadTimeWeaver</code>接口是一个Spring提供的类，它允许以特定方式插入JPA <code>ClassTransformer</code>实例，具体取决于环境是Web容器还是应用程序服务器。通过<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理</a>挂钩<code>ClassTransformers</code>通常效率不高。代理对整个虚拟机起作用并检查加载的每个类，这在生产服务器环境中通常是不合需要的。</p>
</div>
<div class="paragraph">
<p>Spring为各种环境提供了许多<code>LoadTimeWeaver</code>实现，让<code>ClassTransformer</code>实例只应用于每个类加载器而不是每个VM。</p>
</div>
<div class="paragraph">
<p>有关<code>LoadTimeWeaver</code>实现及其设置的更多信息，请参阅AOP章节中的<a href="core.html#aop-aj-ltw-spring">Spring配置</a> ，这些实现可以是通用的，也可以是针对各种平台（例如Tomcat，WebLogic，GlassFish，Resin和JBoss）定制的。</p>
</div>
<div class="paragraph">
<p>如<a href="core.html#aop-aj-ltw-spring">Spring配置中所述</a> ，您可以使用上下文的<code>@EnableLoadTimeWeaving</code>批注配置上下文范围的<code>LoadTimeWeaver</code> <code>context:load-time-weaver</code> XML元素。所有JPA <code>LocalContainerEntityManagerFactoryBean</code>实例都会自动获取此类全局编织器。以下示例显示了设置加载时织入器的首选方法，即自动检测平台（WebLogic，GlassFish，Tomcat，Resin，JBoss或VM代理）以及将weaver自动传播到所有weaver-aware bean ：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context：load-time-weaver</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emf</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa。LocalContainerEntityManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> ...
<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>但是，如果需要，您可以通过<code>loadTimeWeaver</code>属性手动指定专用的weaver，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emf</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa。LocalContainerEntityManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">loadTimeWeaver</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.instrument.classloading。ReflectiveLoadTimeWeaver</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>无论如何配置LTW，通过使用此技术，依赖于检测的JPA应用程序可以在目标平台（例如，Tomcat）中运行，而无需代理。当托管应用程序依赖于不同的JPA实现时，这一点尤为重要，因为JPA转换器仅应用于类加载器级别，因此彼此隔离。</p>
</div>
<div id="orm-jpa-setup-multiple" class="paragraph">
<p>=====处理多个持久性单元</p>
</div>
<div class="paragraph">
<p>对于依赖于多个持久性单元位置的应用程序（例如，存储在类路径中的各种JARS中），Spring提供<code>PersistenceUnitManager</code>作为中央存储库并避免持久性单元发现过程，这可能很昂贵。默认实现允许指定多个位置。解析这些位置，然后通过持久性单元名称检索这些位置。（默认情况下，会在类路径中搜索<code>META-INF/persistence.xml</code>文件。）以下示例配置多个位置：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">pum</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa.persistenceunit。DefaultPersistenceUnitManager</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">persistenceXmlLocations</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> org / springframework / orm / jpa / domain / persistence-multi.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> classpath：/ my / package / ** / custom -persistence.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> classpath *：META-INF / persistence.xml <span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">dataSources</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;map&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">“</span> <span class="content">localDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">local-db</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">remoteDataSource</span> <span class="delimiter">“</span></span> <span class="attribute-name">value-ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">remote-db</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ map&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="comment">&lt;！ - 如果未指定数据源，请使用此方法one  - &gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">defaultDataSource</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">remoteDataSource</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emf</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa。LocalContainerEntityManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">persistenceUnitManager</span> <span class="delimiter">“</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">”</span> <span class="content">pum</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">persistenceUnitName</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myCustomUnit</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>默认实现允许自定义<code>PersistenceUnitInfo</code>实例（在它们被提供给JPA提供程序之前），以声明方式（通过其属性，影响所有托管单元）或以编程方式（通过<code>PersistenceUnitPostProcessor</code> ，允许持久性单元选择）。如果未指定<code>PersistenceUnitManager</code> ，则由<code>LocalContainerEntityManagerFactoryBean</code>在内部创建并使用一个。</p>
</div>
<div id="orm-jpa-setup-background" class="paragraph">
<p>=====背景引导</p>
</div>
<div class="paragraph">
<p><code>LocalContainerEntityManagerFactoryBean</code>通过<code>bootstrapExecutor</code>属性支持后台引导，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">emf</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa。LocalContainerEntityManagerFactoryBean</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">bootstrapExecutor</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.core.task。SimpleAsyncTaskExecutor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>实际的JPA提供程序引导传递给指定的执行程序，然后并行运行到应用程序引导程序线程。公开的<code>EntityManagerFactory</code>代理可以注入其他应用程序组件，甚至能够响应<code>EntityManagerFactoryInfo</code>配置检查。但是，一旦实际的JPA提供程序被其他组件访问（例如，调用<code>createEntityManager</code> ），这些调用将阻塞，直到后台引导完成。特别是，当您使用Spring Data JPA时，请确保为其存储库设置延迟引导。</p>
</div>
<div id="orm-jpa-dao" class="paragraph">
<p>====基于JPA实现DAO： <code>EntityManagerFactory</code>和<code>EntityManager</code></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">虽然<code>EntityManagerFactory</code>实例是线程安全的，但<code>EntityManager</code>实例不是。注入的JPA <code>EntityManager</code>行为类似于从应用程序服务器的JNDI环境获取的<code>EntityManager</code> ，如JPA规范所定义。它将所有调用委托给当前事务性<code>EntityManager</code> （如果有）。否则，它会回退到每个操作新创建的<code>EntityManager</code> ，实际上使其使用线程安全。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过使用注入的<code>EntityManagerFactory</code>或<code>EntityManager</code> ，可以在没有任何Spring依赖性的情况下针对普通JPA编写代码。如果启用了<code>PersistenceAnnotationBeanPostProcessor</code> Spring可以在字段和方法级别理解<code>@PersistenceUnit</code>和<code>@PersistenceContext</code>注释。以下示例显示了使用<code>@PersistenceUnit</code>批注的普通JPA DAO实现：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductDaoImpl</span> <span class="directive">实现</span> ProductDao { <span class="directive">private</span> EntityManagerFactory emf; <span class="annotation">@PersistenceUnit</span> <span class="directive">public</span> <span class="type">void</span> setEntityManagerFactory（EntityManagerFactory emf）{ <span class="local-variable">this</span> .emf = emf; <span class="directive">public</span> <span class="predefined-type">Collection</span> loadProductsByCategory（ <span class="predefined-type">String</span> category）{EntityManager em = <span class="local-variable">this</span> .emf.createEntityManager（）; <span class="keyword">尝试</span> { <span class="predefined-type">Query</span> query = em.createQuery（ <span class="string"><span class="delimiter">“</span> <span class="content">from Product as p where p.category =？1</span> <span class="delimiter">“</span></span> ）; query.setParameter（ <span class="integer">1</span> ，category）; <span class="keyword">return</span> query.getResultList（）;} <span class="keyword">finally</span> { <span class="keyword">if</span> （em！em！）= <span class="predefined-constant">null</span> ）{em.close（）; }}}}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>前面的DAO不依赖于Spring，仍然很适合Spring应用程序上下文。此外，DAO利用注释来要求注入默认的<code>EntityManagerFactory</code> ，如下面的示例bean定义所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 用于JPA注释的bean后处理程序 - &gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.orm.jpa.support。PersistenceAnnotationBeanPostProcessor</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">”</span> <span class="content">myProductDao</span> <span class="delimiter">“</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">”</span> <span class="content">product。ProductDaoImpl</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>作为显式定义<code>PersistenceAnnotationBeanPostProcessor</code>的替代方法，请考虑在应用程序上下文配置中使用Spring <code>context:annotation-config</code> XML元素。这样做会自动注册所有Spring标准后处理器以进行基于注释的配置，包括<code>CommonAnnotationBeanPostProcessor</code>等。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="comment">&lt;！ - 所有标准配置注释的后处理器 - &gt;</span> <span class="tag">&lt;context：annotation-config</span> <span class="tag">/&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">myProductDao</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">product。ProductDaoImpl</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>这种DAO的主要问题是它总是通过工厂创建一个新的<code>EntityManager</code> 。您可以通过请求事务性<code>EntityManager</code> （也称为“共享EntityManager”，因为它是实际事务性EntityManager的共享，线程安全代理）而不是工厂来避免这种情况。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ProductDaoImpl</span> <span class="directive">实现</span> ProductDao { <span class="annotation">@PersistenceContext</span> <span class="directive">private</span> EntityManager em; <span class="directive">public</span> <span class="predefined-type">Collection</span> loadProductsByCategory（ <span class="predefined-type">String</span> category）{ <span class="predefined-type">Query</span> query = em.createQuery（ <span class="string"><span class="delimiter">“</span> <span class="content">from Product as p where p.category =：category</span> <span class="delimiter">”</span></span> ）; query.setParameter（ <span class="string"><span class="delimiter">“</span> <span class="content">category</span> <span class="delimiter">”</span></span> ，category）; <span class="keyword">return</span> query.getResultList（）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>@PersistenceContext</code>注释具有一个名为<code>type</code>的可选属性，默认为<code>PersistenceContextType.TRANSACTION</code> 。您可以使用此默认值来接收共享的<code>EntityManager</code>代理。另一种方法是<code>PersistenceContextType.EXTENDED</code> ，是一个完全不同的事情。这导致了一个所谓的扩展<code>EntityManager</code> ，它不是线程安全的，因此不能在并发访问的组件中使用，例如Spring管理的单例bean。扩展的<code>EntityManager</code>实例仅应用于有状态组件，例如驻留在会话中， <code>EntityManager</code>的生命周期不依赖于当前事务，而是完全取决于应用程序。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">方法和字段级注入</div>
<div class="paragraph">
<p>您可以在类中的字段或方法上应用指示依赖注入的注释（例如<code>@PersistenceUnit</code>和<code>@PersistenceContext</code> ） - 因此表达式为“方法级注入”和“字段级注入”。字段级注释简洁且易于使用，而方法级注释允许进一步处理注入的依赖项。在这两种情况下，成员可见性（公共，受保护或私有）都无关紧要。</p>
</div>
<div class="paragraph">
<p>类级注释怎么样？</p>
</div>
<div class="paragraph">
<p>在Java EE平台上，它们用于依赖性声明，而不用于资源注入。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>注入的<code>EntityManager</code>是Spring管理的（了解正在进行的事务）。即使新的DAO实现使用<code>EntityManager</code>方法级注入而不是<code>EntityManagerFactory</code> ，但由于注释的使用，在应用程序上下文XML中不需要进行任何更改。</p>
</div>
<div class="paragraph">
<p>这种DAO风格的主要优点是它仅依赖于Java Persistence API。不需要导入任何Spring类。此外，当理解JPA注释时，注入由Spring容器自动应用。从非侵入性的角度来看，这很有吸引力，并且对于JPA开发人员来说感觉更自然。</p>
</div>
<div id="orm-jpa-tx" class="paragraph">
<p>==== Spring驱动的JPA事务</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们强烈鼓励您阅读<a href="#transaction-declarative">声明式事务管理</a> （如果您还没有这样做），以获得有关Spring声明式事务支持的更详细的介绍。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>JPA的推荐策略是通过JPA的本机事务支持进行本地事务。Spring的<code>JpaTransactionManager</code>针对任何常规JDBC连接池（无XA要求）提供了许多本地JDBC事务（例如特定于事务的隔离级别和资源级只读优化）的功能。</p>
</div>
<div class="paragraph">
<p>Spring JPA还允许配置的<code>JpaTransactionManager</code>将JPA事务公开给访问相同<code>DataSource</code> JDBC访问代码，前提是已注册的<code>JpaDialect</code>支持检索基础JDBC <code>Connection</code> 。Spring为EclipseLink和Hibernate JPA实现提供了方言。有关<code>JpaDialect</code>机制的详细信息，请参阅<a href="#orm-jpa-dialect">下一节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">作为一种直接替代方案，Spring的本机<code>HibernateTransactionManager</code>能够与Spring Framework 5.1和Hibernate 5.2 / 5.3中的JPA访问代码进行交互，适应多种Hibernate细节并提供JDBC交互。这与<code>LocalSessionFactoryBean</code>设置结合使用特别有意义。有关详细信息，请参阅<a href="#orm-jpa-hibernate">JPA Interaction的Native Hibernate Setup</a> 。
</td>
</tr>
</table>
</div>
<div id="orm-jpa-dialect" class="paragraph">
<p>====了解<code>JpaDialect</code>和<code>JpaVendorAdapter</code></p>
</div>
<div class="paragraph">
<p>作为一项高级功能， <code>JpaTransactionManager</code>和<code>AbstractEntityManagerFactoryBean</code>子类允许将自定义<code>JpaDialect</code>传递给<code>jpaDialect</code> bean属性。<code>JpaDialect</code>实现可以启用Spring支持的以下高级功能，通常以特定于供应商的方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>应用特定的事务语义（例如自定义隔离级别或事务超时）</p>
</li>
<li>
<p>检索事务JDBC <code>Connection</code> （用于暴露于基于JDBC的DAO）</p>
</li>
<li>
<p><code>PersistenceExceptions</code>到Spring <code>DataAccessExceptions</code>高级转换</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这对于特殊事务语义和异常的高级转换特别有用。默认实现（ <code>DefaultJpaDialect</code> ）不提供任何特殊功能，如果需要前面列出的功能，则必须指定适当的方言。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">作为一个更广泛的提供者适配工具，主要用于Spring的全功能<code>LocalContainerEntityManagerFactoryBean</code>设置， <code>JpaVendorAdapter</code>将<code>JpaDialect</code>的功能与其他特定于提供者的默认设置相结合。指定<code>HibernateJpaVendorAdapter</code>或<code>EclipseLinkJpaVendorAdapter</code>是分别为Hibernate或EclipseLink自动配置<code>EntityManagerFactory</code>设置的最便捷方式。请注意，这些提供程序适配器主要设计用于Spring驱动的事务管理（即，与<code>JpaTransactionManager</code>一起使用）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关其操作的更多详细信息以及如何在Spring的JPA支持中使用它们，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaDialect.html"><code>JpaDialect</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaVendorAdapter.html"><code>JpaVendorAdapter</code></a> Javadoc。</p>
</div>
<div id="orm-jpa-jta" class="paragraph">
<p>====使用JTA事务管理设置JPA</p>
</div>
<div class="paragraph">
<p>作为<code>JpaTransactionManager</code>的替代方案，Spring还允许通过JTA进行多资源事务协调，无论是在Java EE环境中还是在独立的事务协调器（如Atomikos）上。除了选择Spring的<code>JtaTransactionManager</code>而不是<code>JpaTransactionManager</code> ，您还需要采取以下几个步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>底层JDBC连接池需要具备XA功能，并与事务协调器集成。这在Java EE环境中通常很简单，通过JNDI公开不同类型的<code>DataSource</code> 。有关详细信息，请参阅应用程序服类似地，独立的事务协调器通常带有特殊的XA集成的<code>DataSource</code>实现。再次，检查其文档。</p>
</li>
<li>
<p>需要为JTA配置JPA <code>EntityManagerFactory</code>设置。这是特定于提供者的，通常通过在<code>LocalContainerEntityManagerFactoryBean</code>上指定为<code>jpaProperties</code>特殊属性。在Hibernate的情况下，这些属性甚至是特定于版本的。有关详细信息，请参阅Hibernate文档。</p>
</li>
<li>
<p>Spring的<code>HibernateJpaVendorAdapter</code>强制执行某些面向Spring的默认设置，例如连接释放模式<code>on-close</code> ，它与Hibernate在Hibernate 5.0中的默认设置相匹配，但在5.1 / 5.2中则不再。对于JTA设置，要么不声明<code>HibernateJpaVendorAdapter</code>开始或关闭其<code>prepareConnection</code>标志。或者，将Hibernate 5.2的<code>hibernate.connection.handling_mode</code>属性设置为<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT</code>以恢复Hibernate自己的默认值。有关WebLogic的相关说明，请参阅<a href="#orm-hibernate-invalid-jdbc-access-error">[orm-hibernate-invalid-jdbc-access-error]</a> 。</p>
</li>
<li>
<p>或者，考虑从应用程序服务器本身获取<code>EntityManagerFactory</code> （即，通过JNDI查找而不是本地声明的<code>LocalContainerEntityManagerFactoryBean</code> ）。服务器提供的<code>EntityManagerFactory</code>可能需要在服务器配置中使用特殊定义（使部署的可移植性降低），但是为服务器的JTA环境设置了这些定义。</p>
</li>
</ul>
</div>
<div id="orm-jpa-hibernate" class="paragraph">
<p>====用于JPA交互的本机Hibernate设置和本机Hibernate事务</p>
</div>
<div class="paragraph">
<p>从Spring Framework 5.1和Hibernate 5.2 / 5.3开始，本机<code>LocalSessionFactoryBean</code>设置与<code>HibernateTransactionManager</code>结合使用，可以与<code>@PersistenceContext</code>和其他JPA访问代码进行交互。Hibernate <code>SessionFactory</code>现在本地实现了JPA的<code>EntityManagerFactory</code>接口，而本地的Hibernate <code>Session</code>句柄是JPA <code>EntityManager</code> 。Spring的JPA支持工具自动检测本机Hibernate会话。</p>
</div>
<div class="paragraph">
<p>因此，在许多场景中，这种本机Hibernate设置可以替代标准JPA <code>LocalContainerEntityManagerFactoryBean</code>和<code>JpaTransactionManager</code>组合，允许在同一本地事务中与<code>@PersistenceContext EntityManager</code>旁边的<code>SessionFactory.getCurrentSession()</code> （以及<code>HibernateTemplate</code> ）进行交互。这样的设置还提供了更强大的Hibernate集成和更多的配置灵活性，因为它不受JPA引导程序契约的约束。</p>
</div>
<div class="paragraph">
<p>在这种情况下，您不需要<code>HibernateJpaVendorAdapter</code>配置，因为Spring的本机Hibernate设置提供了更多功能（例如，自定义Hibernate Integrator设置，Hibernate 5.3 bean容器集成以及对只读事务的更强优化）。最后但同样重要的是，您还可以通过<code>LocalSessionFactoryBuilder</code>表达本机Hibernate设置，与<code>@Bean</code>样式配置无缝集成（不涉及<code>FactoryBean</code> ）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><code>LocalSessionFactoryBean</code>和<code>LocalSessionFactoryBuilder</code>支持后台引导，就像JPA <code>LocalContainerEntityManagerFactoryBean</code>一样。有关简介，请参阅<a href="#orm-jpa-setup-background">后台引导</a> 。</p>
</div>
<div class="paragraph">
<p>在<code>LocalSessionFactoryBean</code> ，这可以通过<code>bootstrapExecutor</code>属性获得。在程序化的<code>LocalSessionFactoryBuilder</code> ，重载的<code>buildSessionFactory</code>方法采用bootstrap executor参数。</p>
</div>
<div class="exampleblock">
<div class="content">
<div id="oxm" class="paragraph">
<p>==使用Object-XML Mappers编组XML</p>
</div>
<div id="oxm-introduction" class="paragraph">
<p>===简介</p>
</div>
<div class="paragraph">
<p>本章介绍Spring的Object-XML Mapping支持。Object-XML Mapping（简称OX映射）是将XML文档转换为对象或从对象转换XML文档的行为。此转换过程也称为XML编组或XML序列化。本章可互换使用这些术语。</p>
</div>
<div class="paragraph">
<p>在OX映射领域，编组器负责将对象（图形）序列化为XML。以类似的方式，unmarshaller将XML反序列化为对象图。此XML可以采用DOM文档，输入或输出流或SAX处理程序的形式。</p>
</div>
<div class="paragraph">
<p>使用Spring满足O / X映射需求的一些好处是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oxm-ease-of-configuration">[OXM-易用性的构型]</a></p>
</li>
<li>
<p><a href="#oxm-consistent-interfaces">[OXM一致接口]</a></p>
</li>
<li>
<p><a href="#oxm-consistent-exception-hierarchy">[OXM一致的异常层次结构]</a></p>
</li>
</ul>
</div>
<div id="oxm-ease-of-configuration" class="paragraph">
<p>====易于配置</p>
</div>
<div class="paragraph">
<p>Spring的bean工厂可以轻松配置marshallers，而无需构建JAXB上下文，JiBX绑定工厂等。您可以像应用程序上下文中的任何其他bean一样配置marshallers。此外，基于XML命名空间的配置可用于许多marshallers，使配置更简单。</p>
</div>
<div id="oxm-consistent-interfaces" class="paragraph">
<p>====一致的界面</p>
</div>
<div class="paragraph">
<p>Spring的OX映射通过两个全局接口运行： <a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/oxm/Marshaller.html"><code>Marshaller</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/oxm/Unmarshaller.html"><code>Unmarshaller</code></a> 。这些抽象允许您相对轻松地切换OX映射框架，对执行编组的类几乎不需要更改。这种方法的另一个好处是可以使用混合和匹配方法进行XML编组（例如，使用JAXB执行某些编组，使用Castor执行某些编组），以非侵入方式执行，使您可以使用每种方法的强度。技术。</p>
</div>
<div id="oxm-consistent-exception-hierarchy" class="paragraph">
<p>====一致的异常层次结构</p>
</div>
<div class="paragraph">
<p>Spring提供从底层OX映射工具的异常到其自己的异常层次结构的转换，并将<code>XmlMappingException</code>作为根异常。这些运行时异常包装原始异常，因此不会丢失任何信息。</p>
</div>
<div id="oxm-marshaller-unmarshaller" class="paragraph">
<p>=== <code>Marshaller</code>和<code>Unmarshaller</code></p>
</div>
<div class="paragraph">
<p>如<a href="#oxm-introduction">介绍</a>中所述，marshaller将对象序列化为XML，而unmarshaller将XML流反序列化为对象。本节介绍用于此目的的两个Spring接口。</p>
</div>
<div id="oxm-marshaller" class="paragraph">
<p>====了解<code>Marshaller</code></p>
</div>
<div class="paragraph">
<p>Spring抽象了<code>org.springframework.oxm.背后的所有编组操作<code>org.springframework.oxm.Marshaller</code>接口，其主要方法如下：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">Marshaller</span> { <span class="comment">/ ** *将具有给定根的对象图 <span class="class">编组</span> <span class="comment">到提供的Result中。* /</span> <span class="type">void</span> marshal（ <span class="predefined-type">对象</span>图， <span class="predefined-type">结果</span>结果） <span class="directive">抛出</span> XmlMappingException， <span class="exception">IOException</span> ; }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>Marshaller</code>接口有一个main方法，它将给定对象<code>javax.xml.transform.送到给定的<code>javax.xml.transform.Result</code> 。结果是一个标记接口，它基本上代表XML输出抽象。具体实现包装各种XML表示，如下表所示：</p>
</div>
<table id="oxm-marshller-tbl" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">结果实施</th>
<th class="tableblock halign-left valign-top">包装XML表示</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOMResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.w3c.dom中。节点</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的SAXResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.xml.sax中。ContentHandler的</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.File</code> ， <code>java.io.OutputStream</code>或<code>java.io.作家</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管<code>marshal()</code>方法接受普通对象作为其第一个参数，但大多数<code>Marshaller</code>实现都无法处理任意对象。相反，对象类必须映射到映射文件中，使用注释标记，向编组器注册或具有公共基类。请参阅本章后面的部分，以确定OX技术如何管理它。
</td>
</tr>
</table>
</div>
<div id="oxm-unmarshaller" class="paragraph">
<p>====了解<code>Unmarshaller</code></p>
</div>
<div class="paragraph">
<p>与<code>Marshaller</code>类似，我们有<code>org.springframework.oxm.Unmarshaller</code>接口，如下所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">Unmarshaller</span> { <span class="comment">/ ** *将给定的Source解组到对象图中。* /</span> <span class="predefined-type">Object</span> unmarshal（ <span class="predefined-type">源</span>代码） <span class="directive">抛出</span> XmlMappingException， <span class="exception">IOException</span> ; }</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>该接口还有一个方法，它从给定的<code>javax.xml.transform.读取<code>javax.xml.transform.Source</code> （XML输入抽象）并返回读取的对象。与<code>Result</code> ， <code>Source</code>是一个标记接口，具有三个具体实现。每个包装一个不同的XML表示，如下表所示：</p>
</div>
<table id="oxm-unmarshller-tbl" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">来源实施</th>
<th class="tableblock halign-left valign-top">包装XML表示</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOMSource的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.w3c.dom中。节点</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的SAXSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.xml.sax中。InputSource</code>和<code>org.xml.sax.XMLReader的</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamSource的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.File</code> ， <code>java.io.InputStream</code>或<code>java.io.读者</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>即使有两个独立的编组接口（ <code>Marshaller</code>和<code>Unmarshaller</code> ），Spring-WS中的所有实现都在一个类中实现。这意味着您可以连接一个marshaller类，并将其作为marshaller和<code>applicationContext.xml</code>的unmarshaller引用。</p>
</div>
<div id="oxm-xmlmappingexception" class="paragraph">
<p>====了解<code>XmlMappingException</code></p>
</div>
<div class="paragraph">
<p>Spring将基础OX映射工具中的异常转换为其自己的异常层次结构，并将<code>XmlMappingException</code>作为根异常。这些运行时异常包装原始异常，因此不会丢失任何信息。</p>
</div>
<div class="paragraph">
<p>此外， <code>MarshallingFailureException</code>和<code>UnmarshallingFailureException</code>提供了编组和解组操作之间的区别，即使底层OX映射工具不这样做。</p>
</div>
<div class="paragraph">
<p>OX Mapping异常层次结构如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oxm-exceptions.png" alt="oxm例外">
</div>
</div>
<div id="oxm-usage" class="paragraph">
<p>===使用<code>Marshaller</code>和<code>Unmarshaller</code></p>
</div>
<div class="paragraph">
<p>您可以在各种情况下使用Spring的OXM。在下面的示例中，我们使用它将Spring托管应用程序的设置编组为XML文件。在以下示例中，我们使用简单的JavaBean来表示设置：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Settings</span> { <span class="directive">private</span> <span class="type">boolean</span> fooEnabled; <span class="directive">public</span> <span class="type">boolean</span> isFooEnabled（）{ <span class="keyword">return</span> fooEnabled; <span class="directive">public</span> <span class="type">void</span> setFooEnabled（ <span class="type">boolean</span> fooEnabled）{ <span class="local-variable">this</span> .fooEnabled = fooEnabled; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>应用程序类使用此bean来存储其设置。除了main方法之外，该类还有两个方法： <code>saveSettings()</code>将设置bean保存到名为<code>settings.xml</code>的文件<code>settings.xml</code> ， <code>loadSettings()</code>再次加载这些设置。以下<code>main()</code>方法构造Spring应用程序上下文并调用这两个方法：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.io.FileInputStream</span> ; <span class="keyword">import</span> <span class="include">java.io.FileOutputStream</span> ; <span class="keyword">import</span> <span class="include">java.io.IOException</span> ; <span class="keyword">import</span> <span class="include">javax.xml.transform.stream。StreamResult</span> ; <span class="keyword">import</span> <span class="include">javax.xml.transform.stream。StreamSource</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context。ApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.context.support。ClassPathXmlApplicationContext</span> ; <span class="keyword">import</span> <span class="include">org.springframework.oxm。Marshaller</span> ; <span class="keyword">import</span> <span class="include">org.springframework.oxm。Unmarshaller</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">Application</span> { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> FILE_NAME = <span class="string"><span class="delimiter">“</span> <span class="content">settings.xml</span> <span class="delimiter">”</span></span> ; <span class="directive">私人</span>设置设置= <span class="keyword">新</span>设置（）; <span class="directive">私人</span> Marshaller marshaller; <span class="directive">私人</span> Unmarshaller unmarshaller; <span class="directive">public</span> <span class="type">void</span> setMarshaller（Marshaller marshaller）{ <span class="local-variable">this</span> .marshaller = marshaller; <span class="directive">public</span> <span class="type">void</span> setUnmarshaller（Unmarshaller unmarshaller）{ <span class="local-variable">this</span> .unmarshaller = unmarshaller; <span class="directive">public</span> <span class="type">void</span> saveSettings（） <span class="directive">抛出</span> <span class="exception">IOException</span> { <span class="predefined-type">FileOutputStream</span> os = <span class="predefined-constant">null</span> ; <span class="keyword">尝试</span> {os = <span class="keyword">new</span> <span class="predefined-type">FileOutputStream</span> （FILE_NAME）; <span class="local-variable">这个</span> .marshaller.marshal（设置， <span class="keyword">新的</span> <span class="predefined-type">StreamResult</span> （os））; <span class="keyword">终于</span> { <span class="keyword">if</span> （os！）= <span class="predefined-constant">null</span> ）{os.close（）; <span class="directive">public</span> <span class="type">void</span> loadSettings（） <span class="directive">throws</span> <span class="exception">IOException</span> { <span class="predefined-type">FileInputStream</span> is = <span class="predefined-constant">null</span> ; <span class="keyword">try</span> {is = <span class="keyword">new</span> <span class="predefined-type">FileInputStream</span> （FILE_NAME）; <span class="local-variable">这个</span> .settings =（设置） <span class="local-variable">这个</span> .unmarshaller.unmarshal（ <span class="keyword">new</span> <span class="predefined-type">StreamSource</span> （is））; <span class="keyword">终于</span> { <span class="keyword">if</span> （是！）= <span class="predefined-constant">null</span> ）{is.close（）; <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main（ <span class="predefined-type">String</span> <span class="type">[]</span> args） <span class="directive">throws</span> <span class="exception">IOException</span> {ApplicationContext appContext = <span class="keyword">new</span> ClassPathXmlApplicationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">applicationContext.xml</span> <span class="delimiter">”</span></span> ）; Application application =（Application）appContext.getBean（ <span class="string"><span class="delimiter">“</span> <span class="content">application</span> <span class="delimiter">”</span></span> ）; application.saveSettings（）; application.loadSettings（）; }}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>Application</code>需要设置<code>marshaller</code>和<code>unmarshaller</code>属性。我们可以使用以下<code>applicationContext.xml</code> ：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">application</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">Application</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">marshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">castorMarshaller</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">unmarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">ref</span> = <span class="string"><span class="delimiter">“</span> <span class="content">castorMarshaller</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">castorMarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.castor。CastorMarshaller</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>此应用程序上下文使用Castor，但我们可以使用本章后面介绍的任何其他marshaller实例。请注意，默认情况下，Castor不需要任何进一步的配置，因此bean定义相当简单。另请注意， <code>CastorMarshaller</code>实现了<code>Marshaller</code>和<code>Unmarshaller</code> ，因此我们可以在应用程序的<code>marshaller</code>和<code>unmarshaller</code>属性中引用<code>castorMarshaller</code> bean。</p>
</div>
<div class="paragraph">
<p>此示例应用程序生成以下<code>settings.xml</code>文件：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;settings</span> <span class="attribute-name">foo-enabled</span> = <span class="string"><span class="delimiter">“</span> <span class="content">false</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="oxm-schema-based-config" class="paragraph">
<p>=== XML配置命名空间</p>
</div>
<div class="paragraph">
<p>您可以使用OXM命名空间中的标记更简洁地配置marshallers。要使这些标记可用，必须首先在XML配置文件的前导中引用相应的模式。以下示例显示了如何执行此操作：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：oxm</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/oxm</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/beans <span class="error">&lt;1&gt;</span></span></span> http://www.springframework.org/schema/beans/spring-beans.xsd <strong>http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd“</strong> <span class="error">&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>参考<code>oxm</code>架构。</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>目前，架构使以下元素可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oxm-jaxb2-xsd"><code>JAXB2-编组</code></a></p>
</li>
<li>
<p><a href="#oxm-jibx-xsd"><code>JiBX的-编组</code></a></p>
</li>
<li>
<p><a href="#oxm-castor-xsd"><code>蓖麻编组</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个标签都在其各自的编组部分中进行了解释。但是，作为示例，JAXB2 marshaller的配置可能类似于以下内容：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;oxm：jaxb2-marshaller</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">marshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">contextPath</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ws.samples.airline.schema</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="oxm-jaxb" class="paragraph">
<p>=== JAXB</p>
</div>
<div class="paragraph">
<p>JAXB绑定编译器将W3C XML Schema转换为一个或多个Java类， <code>jaxb.properties</code>文件以及可能的某些资源文件。JAXB还提供了一种从带注释的Java类生成模式的方法。</p>
</div>
<div class="paragraph">
<p>Spring遵循<a href="#oxm-marshaller-unmarshaller">[oxm-marshaller-unmarshaller]中</a>描述的<code>Marshaller</code>和<code>Unmarshaller</code>接口，支持JAXB 2.0 API作为XML编组策略。相应的集成类位于<code>org.springframework.oxm.jaxb</code>包中。</p>
</div>
<div id="oxm-jaxb2" class="paragraph">
<p>====使用<code>Jaxb2Marshaller</code></p>
</div>
<div class="paragraph">
<p><code>Jaxb2Marshaller</code>类实现了Spring的<code>Marshaller</code>和<code>Unmarshaller</code>接口。它需要一个上下文路径来运行。您可以通过设置<code>contextPath</code>属性来设置上下文路径。上下文路径是包含模式派生类的冒号分隔的Java包名称列表。它还提供了<code>classesToBeBound</code>属性，允许您设置marshaller支持的类数组。通过为bean指定一个或多个模式资源来执行模式验证，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jaxb2Marshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.jaxb。Jaxb2Marshaller</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classesToBeBound</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;list&gt;</span> <span class="tag">&lt;value&gt;</span> org.springframework.oxm.jaxb。航班<span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;value&gt;</span> org.springframework.oxm.jaxb。航班<span class="tag">&lt;/ value&gt;</span> <span class="tag">&lt;/ list&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">schema</span> <span class="delimiter">”</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：org / springframework / oxm / schema.xsd</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> ...

<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="oxm-jaxb2-xsd" class="paragraph">
<p>===== XML配置命名空间</p>
</div>
<div class="paragraph">
<p><code>jaxb2-marshaller</code>元素配置<code>org.springframework.oxm.jaxb.Jaxb2Marshaller</code> ，如下例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;oxm：jaxb2-marshaller</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">marshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">contextPath</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ws.samples.airline.schema</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>或者，您可以使用要绑定的<code>class-to-be-bound</code>子元素提供要绑定到编组器的<code>class-to-be-bound</code>列表：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;oxm：jaxb2-marshaller</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">marshaller</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;oxm：class-to-be bound</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ws.samples.airline.schema。Airport</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;oxm：class-to-bound-</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.ws.samples.airline.schema。航班</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> ......
<span class="tag">&lt;/ OXM：JAXB2-编组&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>下表描述了可用的属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">需要</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编组员的身份证</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>的contextPath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAXB上下文路径</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
<div id="oxm-castor" class="paragraph">
<p>===蓖麻</p>
</div>
<div class="paragraph">
<p>Castor XML映射是一种开源XML绑定框架。它允许您将Java对象模型中包含的数据转换为XML文档或从XML文档转换。默认情况下，它不需要任何进一步的配置，但您可以使用映射文件来更好地控制Castor的行为。</p>
</div>
<div class="paragraph">
<p>有关Castor的更多信息，请参阅<a href="http://castor-data-binding.github.io/castor">Castor网站</a> 。Spring集成类驻留在<code>org.springframework.oxm.castor</code>包中。</p>
</div>
<div id="oxm-castor-marshaller" class="paragraph">
<p>====使用<code>CastorMarshaller</code></p>
</div>
<div class="paragraph">
<p>与JAXB一样， <code>CastorMarshaller</code>实现了<code>Marshaller</code>和<code>Unmarshaller</code>接口。它可以按如下方式连接：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">castorMarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.castor。CastorMarshaller</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> ......
<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="oxm-castor-mapping" class="paragraph">
<p>====映射</p>
</div>
<div class="paragraph">
<p>虽然可以依赖Castor的默认编组行为，但可能需要对其进行更多控制。您可以使用Castor映射文件获得更多控制权。有关更多信息，请参阅<a href="http://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/index.html#xml.mapping">Castor XML Mapping</a> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>mappingLocation</code>资源属性设置映射，在以下示例中使用classpath资源指示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">castorMarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.castor。CastorMarshaller</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">mappingLocation</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">classpath：mapping.xml</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ bean&gt;</span> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="oxm-castor-xsd" class="paragraph">
<p>===== XML配置命名空间</p>
</div>
<div class="paragraph">
<p><code>castor-marshaller</code>标签配置<code>org.springframework.oxm.castor.CastorMarshaller</code> ，如下例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;oxm：castor-marshaller</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">marshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">mapping-location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">classpath：org / springframework / oxm / castor / mapping.xml</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>您可以通过两种方式配置marshaller实例：通过指定映射文件的位置（通过<code>mapping-location</code>属性）或通过标识存在相应XML的Java POJO（通过<code>target-class</code>或<code>target-package</code>属性）描述符类。后一种方式通常与XML模式中的XML代码生成结合使用。</p>
</div>
<div class="paragraph">
<p>下表描述了可用的属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">需要</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编组员的身份证</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>编码</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于从XML解组的编码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>目标级</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POJO的Java类名，XML类描述符可用（通过代码生成生成）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>目标包</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个Java包名称，用于标识包含POJO的包及其对应的Castor XML描述符类（通过从XML模式生成代码生成）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>映射-位置</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Castor XML映射文件的位置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
<div id="oxm-jibx" class="paragraph">
<p>=== JiBX</p>
</div>
<div class="paragraph">
<p>JiBX框架提供了类似于Hibernate为ORM提供的解决方案：绑定定义定义了如何将Java对象转换为XML或从XML转换的规则。在准备绑定和编译类之后，JiBX绑定编译器增强了类文件，并添加了代码来处理从XML转换类的实例。</p>
</div>
<div class="paragraph">
<p>有关JiBX的更多信息，请参阅<a href="http://jibx.sourceforge.net/">JiBX网站</a> 。Spring集成类驻留在<code>org.springframework.oxm.jibx</code>包中。</p>
</div>
<div id="oxm-jibx-marshaller" class="paragraph">
<p>====使用<code>JibxMarshaller</code></p>
</div>
<div class="paragraph">
<p><code>JibxMarshaller</code>类实现<code>Marshaller</code>和<code>Unmarshaller</code>接口。要进行操作，需要编组类的名称，您可以使用<code>targetClass</code>属性进行设置。（可选）您可以通过设置<code>bindingName</code>属性来设置绑定名称。在以下示例中，我们绑定<code>Flights</code>类：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">jibxFlightsMarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.jibx。JibxMarshaller</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">targetClass</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> org.springframework.oxm.jibx。航班<span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> ...
<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>JibxMarshaller</code>是为单个类配置的。如果要编组多个类，则必须使用不同的<code>targetClass</code>属性值配置多个<code>JibxMarshaller</code>实例。</p>
</div>
<div id="oxm-jibx-xsd" class="paragraph">
<p>===== XML配置命名空间</p>
</div>
<div class="paragraph">
<p><code>jibx-marshaller</code>标记配置<code>org.springframework.oxm.jibx.JibxMarshaller</code> ，如下例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;oxm：jibx-marshaller</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">marshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">target-class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.ws.samples.airline.schema。航班</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>下表描述了可用的属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">需要</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编组员的身份证</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>目标级</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个编组的目标类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bindingName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此编组使用的绑定名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
<div id="oxm-xstream" class="paragraph">
<p>=== XStream</p>
</div>
<div class="paragraph">
<p>XStream是一个简单的库，用于将对象序列化为XML并再次返回。它不需要任何映射并生成干净的XML。</p>
</div>
<div class="paragraph">
<p>有关XStream的更多信息，请参阅<a href="http://x-stream.github.io/">XStream Web站点</a> 。Spring集成类驻留在<code>org.springframework.oxm.xstream</code>包中。</p>
</div>
<div id="oxm-xstream-marshaller" class="paragraph">
<p>====使用<code>XStreamMarshaller</code></p>
</div>
<div class="paragraph">
<p><code>XStreamMarshaller</code>不需要任何配置，可以直接在应用程序上下文中配置。要进一步自定义XML，您可以设置别名映射，该映射由映射到类的字符串别名组成，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span> <span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xstreamMarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.xstream。XStreamMarshaller</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">aliases</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;props&gt;</span> <span class="tag">&lt;prop</span> <span class="attribute-name">key</span> = <span class="string"><span class="delimiter">”</span> <span class="content">Flight</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> org.springframework.oxm.xstream。航班<span class="tag">&lt;/ prop&gt;</span> <span class="tag">&lt;/ props&gt;</span> <span class="tag">&lt;/ property&gt;</span> <span class="tag">&lt;/ bean&gt;</span> ...
<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，XStream允许对任意类进行解组，这可能导致不安全的Java序列化效果。因此，我们不建议使用<code>XStreamMarshaller</code>从外部源（即Web）解组XML，因为这可能导致安全漏洞。</p>
</div>
<div class="paragraph">
<p>如果您选择使用<code>XStreamMarshaller</code>来解组XML从外部源，设置<code>supportedClasses</code>的财产<code>XStreamMarshaller</code> ，如下例所示：</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">xstreamMarshaller</span> <span class="delimiter">”</span></span> <span class="attribute-name">class</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.springframework.oxm.xstream。XStreamMarshaller</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;property</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">”</span> <span class="content">supportedClasses</span> <span class="delimiter">“</span></span> <span class="attribute-name">value</span> = <span class="string"><span class="delimiter">”</span> <span class="content">org.springframework.oxm.xstream。航班</span> <span class="delimiter">“</span></span> <span class="tag">/&gt;</span> ......
<span class="tag">&lt;/豆&gt;</span></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>这样做可确保只有已注册的类才有资格进行解组。</p>
</div>
<div class="paragraph">
<p>此外，您可以注册<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher%E2%80%A6%E2%80%8B)">自定义转换器</a> ，以确保只能对您支持的类进行解组。除了明确支持应支持的域类的转换器之外，您可能还希望将<code>CatchAllConverter</code>添加为<code>CatchAllConverter</code>中的最后一个转换器。因此，不会调用具有较低优先级和可能的安全漏洞的默认XStream转换器。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，XStream是XML序列化库，而不是数据绑定库。因此，它具有有限的命名空间支持。因此，它非常不适合在Web服务中使用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>=附录</p>
</div>
<div id="xsd-schemas" class="paragraph">
<p>== XML Schema</p>
</div>
<div class="paragraph">
<p>附录的这一部分列出了用于数据访问的XML模式，包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xsd-schemas-tx">[XSD的架构-TX]</a></p>
</li>
<li>
<p><a href="#xsd-schemas-jdbc"><code>jdbc</code>架构</a></p>
</li>
</ul>
</div>
<div id="xsd-schemas-tx" class="paragraph">
<p>=== <code>tx</code> Schema</p>
</div>
<div class="paragraph">
<p><code>tx</code>标签处理Spring对事务的全面支持中所有这些bean的配置。这些标签在标题为“ <a href="#transaction">事务管理”</a>的章节中介绍。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们强烈鼓励您查看Spring发行版附带的<code>'spring-tx.xsd'</code>文件。此文件包含Spring的事务配置的XML Schema，并涵盖<code>tx</code>命名空间中的所有各种元素，包括属性默认值和类似信息。该文件以内联方式记录，因此，为了遵守DRY（不要重复自己）原则，此处不再重复这些信息。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了完整性，要使用<code>tx</code>模式中的元素，您需要在Spring XML配置文件的顶部包含以下前导码。以下代码段中的文本引用了正确的架构，以便您可以使用<code>tx</code>命名空间中的标记：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：aop</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/aop</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xmlns：TX</span> <span class="string"><span class="delimiter">=”</span> <span class="content">http://www.springframework.org/schema/tx</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <i class="conum" data-value="1"></i> <b>（1）</b> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/tx http： //www.springframework.org/schema/tx/spring-tx.xsd</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="content">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <span class="tag">&lt;/ beans &gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定命名空间。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>指定位置（使用其他架构位置）。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通常，当您使用<code>tx</code>命名空间中的元素时，您还使用了<code>aop</code>命名空间中的元素（因为Spring中的声明性事务支持是通过使用AOP实现的）。前面的XML片段包含引用<code>aop</code>架构所需的相关行，以便您可以使用<code>aop</code>命名空间中的元素。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jdbc"><a class="anchor" href="#xsd-schemas-jdbc"></a> 3.5.3。<code>jdbc</code>架构</h4>
<div class="paragraph">
<p><code>jdbc</code>元素使您可以快速配置嵌入式数据库或初始化现有数据源。这些元素分别记录在<a href="#jdbc-embedded-database-support">嵌入式数据库支持</a>和<a href="#jdbc-initializing-datasource">初始化数据源中</a> 。</p>
</div>
<div class="paragraph">
<p>要使用<code>jdbc</code>架构中的元素，需要在Spring XML配置文件的顶部包含以下前导码。以下代码段中的文本引用了正确的架构，以便您可以使用<code>jdbc</code>命名空间中的元素：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</span> <span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.springframework.org/schema/beans</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：xsi</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http://www.w3.org/2001/XMLSchema-instance</span> <span class="delimiter">”</span></span> <span class="attribute-name">xmlns：jdbc</span> = <span class="string"><span class="delimiter">“</span> <span class="content">http：// www.springframework.org/schema/jdbc</span> <span class="delimiter">“</span></span> <span class="attribute-name">的xsi：的schemaLocation</span> <span class="string"><span class="delimiter">=”</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span> <span class="content">http://www.springframework.org/schema/jdbc http： //www.springframework.org/schema/jdbc/spring-jdbc.xsd</span> <span class="delimiter">“</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ -  bean定义在这里 - &gt;</span> <i class="conum" data-value="2"></i> <b>（2）</b> <span class="tag">&lt;/ beans&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>指定命名空间。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>指定位置（使用其他架构位置）。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.1.0。发布<br>上次更新时间2018-09-21 06:51:06 UTC</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>